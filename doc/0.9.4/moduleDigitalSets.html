<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Sets of points in digital spaces</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.9.4beta</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Sets of points in digital spaces </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#digital_sets_1">Overview</a></li>
<li class="level1"><a href="#digital_sets_2">The concept concepts::CDigitalSet and models of concepts::CDigitalSet</a></li>
<li class="level1"><a href="#digital_sets_3">Using digital sets</a></li>
<li class="level1"><a href="#digital_sets_4">Digital sets and point predicates</a></li>
<li class="level1"><a href="#digital_sets_5">A digital set may be transformed into a domain</a></li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: Jacques-Olivier Lachaud</dt><dd></dd></dl>
<h1><a class="anchor" id="digital_sets_1"></a>
Overview</h1>
<p><b>Digital</b> <b>sets</b> are sets of digital points within some domain of a digital space. They are thus subsets of a given domain (e.g. see <a class="el" href="moduleSpacePointVectorDomain.html#sectDomain">Domains and HyperRectDomains</a>). As such, their elements can be enumerated with iterators through the range [begin(),end()). Furthermore, digital sets can be complemented within their domain. Last, a digital set is also a predicate on point, returning true whenever the points lies inside the set.</p>
<h1><a class="anchor" id="digital_sets_2"></a>
The concept concepts::CDigitalSet and models of concepts::CDigitalSet</h1>
<p>There are several ways for defining concretely a digital set, this is why digital sets are specified through the concept <a class="el" href="structDGtal_1_1concepts_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">concepts::CDigitalSet</a>. All types and required methods are specified in the documentation of CDigitalSet. It is worthy to note that a digital set is also associated to a digital domain, i.e. any model of <a class="el" href="structDGtal_1_1concepts_1_1CDomain.html" title="Aim: This concept represents a digital domain, i.e. a non mutable subset of points of the given digit...">concepts::CDomain</a>.</p>
<p>There exists several models for <a class="el" href="structDGtal_1_1concepts_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">concepts::CDigitalSet</a>; their difference lies in the way elements are stored (let <em>n</em> be the number of points in the set).</p>
<ul>
<li><a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim: A container class for storing sets of digital points within some given domain. ">DigitalSetBySTLSet</a>: it is the most versatile representation for digital sets, and the one which should be preferred if you have no specific properties for your set. The container is the standard simple associative container <code>std::set</code> (a model of <a class="el" href="structboost_1_1SimpleAssociativeContainer.html" title="Go to http://www.sgi.com/tech/stl/SimpleAssociativeContainer.html. ">boost::SimpleAssociativeContainer</a>). All find, insertion and deletion requests are \( O(\log n) \) complexity. Internal order can be changed by specifiing another Compare functor as template parameter.</li>
<li><a class="el" href="classDGtal_1_1DigitalSetBySTLVector.html" title="Aim: Realizes the concept CDigitalSet by using the STL container std::vector. ">DigitalSetBySTLVector</a>: this representation is suited for very small set of points (for instance a neighborhood). The container is the standard sequence container <code>std::vector</code> (a model of <a class="el" href="structboost_1_1Sequence.html" title="Go to http://www.sgi.com/tech/stl/Sequence.html. ">boost::Sequence</a>). All find, insertion and deletion requests are \( O(n) \) complexity.</li>
<li><a class="el" href="classDGtal_1_1DigitalSetFromMap.html" title="Aim: An adapter for viewing an associative image container like ImageContainerBySTLMap as a simple di...">DigitalSetFromMap</a>: it is <b>not</b> a container but an <b>adapter</b> to an existing map Point -&gt; Value. Elements of the digital set are by definition the keys of the map.</li>
<li><a class="el" href="classDGtal_1_1DigitalSetByAssociativeContainer.html" title="Aim: A wrapper class around a STL associative container for storing sets of digital points within som...">DigitalSetByAssociativeContainer</a>: it is a generic container which adapts any associative container (e.g. from the <a href="https://www.sgi.com/tech/stl/AssociativeContainer.html">STL</a> or from boost). For example, if you instantiate such digital set on a <code>std::set</code>, this class exactly matches with <a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim: A container class for storing sets of digital points within some given domain. ">DigitalSetBySTLSet</a>. The main advantage of this container is its ability to adapt hash function based containers such as <code>std::unordered_set</code> (for C++11 enabled build) or <code>boost::unordered_set</code>. Compared to <a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim: A container class for storing sets of digital points within some given domain. ">DigitalSetBySTLSet</a>, <a class="el" href="classDGtal_1_1DigitalSetByAssociativeContainer.html" title="Aim: A wrapper class around a STL associative container for storing sets of digital points within som...">DigitalSetByAssociativeContainer</a> on <code>std::unordered_set</code> is expected to be 20% - 50% faster when accessing or inserting points in the set.</li>
</ul>
<p>You may choose yourself your representation of digital set, or let <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a> chooses for you the best suited representation with the class <a class="el" href="structDGtal_1_1DigitalSetSelector.html" title="Aim: Automatically defines an adequate digital set type according to the hints given by the user...">DigitalSetSelector</a>. This is done by choosing among the following properties:</p>
<ul>
<li>the expected size of the set with enum DigitalSetSize, from small to huge: <code>SMALL_DS</code>, <code>MEDIUM_DS</code>, <code>BIG_DS</code>, <code>WHOLE_DS</code>.</li>
<li>the expected variability of the set with enum DigitalSetVariability: will the set change a lot during its lifetime (<code>HIGH_VAR_DS</code>) or not (<code>LOW_VAR_DS</code>) ?</li>
<li>the expected number of times you will iterate through the elements of the set with enum DigitalSetIterability, few times is <code>LOW_ITER_DS</code>, many times is <code>HIGH_ITER_DS</code>.</li>
<li>the number of times you will test for the presence of points in the set with enum DigitalSetBelongTestability, few times is <code>LOW_BEL_DS</code>, many times is <code>HIGH_BEL_DS</code>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>By default, <a class="el" href="namespaceDGtal_1_1Z2i.html#a371252c324e496cf8650757c1a2b4eb0">Z2i::DigitalSet</a> and <a class="el" href="namespaceDGtal_1_1Z3i.html#a7b7028f23aee23f64730fb2300dc1ecf">Z3i::DigitalSet</a> in <a class="el" href="StdDefs_8h_source.html">StdDefs.h</a> refer to the associative container with hash functions (fastest on large sets).</dd></dl>
<p>The following lines selects a rather generic representation for digital sets, since the set may be big, will be iterated many times and points will be tested many times:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> SpaceND&lt;2&gt; <a class="code" href="namespaceDGtal_1_1Z2i.html#adf7ebed7141fd4101a0eb93ed99145c5">Z2</a>;</div><div class="line"><span class="keyword">typedef</span> HyperRectDomain&lt;Z2&gt; <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structDGtal_1_1DigitalSetSelector.html#a3fedd6ed479daf13da0649e960b1866a">DigitalSetSelector &lt; Domain, BIG_DS + HIGH_ITER_DS + HIGH_BEL_DS &gt;::Type</a> SpecificSet;</div><div class="line"><span class="comment">// here SpecificSet is DigitalSetByAssociativeContainer&lt;(boost or std)::unordered_set&lt;Point&gt;, Domain&gt;.</span></div></div><!-- fragment --><h1><a class="anchor" id="digital_sets_3"></a>
Using digital sets</h1>
<p>The following snippet shows how to define a digital set in space Z2, within a rectangular domain, then how to insert points, how to visit them and how to test if a point belongs to the set.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> SpaceND&lt;2&gt; <a class="code" href="namespaceDGtal_1_1Z2i.html#adf7ebed7141fd4101a0eb93ed99145c5">Z2</a>;</div><div class="line"><span class="keyword">typedef</span> HyperRectDomain&lt;Z2&gt; <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structDGtal_1_1DigitalSetSelector.html#a3fedd6ed479daf13da0649e960b1866a">DigitalSetSelector &lt; Domain, BIG_DS + HIGH_ITER_DS + HIGH_BEL_DS &gt;::Type</a> SpecificSet;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Z2::Point</a> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>;</div><div class="line"><span class="comment">// instantiating rectangular domain</span></div><div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> p1(  -10, -10  );</div><div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> p2(  10, 10  );</div><div class="line"><a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>( p1, p2 );</div><div class="line"><span class="comment">// instanciating set within this domain.</span></div><div class="line">SpecificSet mySet( <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a> );</div><div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> c(  0, 0  );</div><div class="line">mySet.insert( c ); <span class="comment">// inserting point (0,0)</span></div><div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> d(  5, 2  );</div><div class="line">mySet.insert( d ); <span class="comment">// inserting point (5,2)</span></div><div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> e(  1, -3  );</div><div class="line">mySet.insert( e ); <span class="comment">// inserting point (1,-3)</span></div><div class="line"><span class="comment">// Iterating through the set</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SpecificSet::ConstIterator</a> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a>;</div><div class="line"><span class="keywordflow">for</span> ( <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a> it = mySet.begin(), itEnd = mySet.end();</div><div class="line">      it != itEnd; ++it )</div><div class="line">  std::cout &lt;&lt; *it &lt;&lt; std::endl;</div><div class="line"><span class="comment">// Checking points within set</span></div><div class="line"><span class="keywordtype">bool</span> ok_c = mySet( c ); <span class="comment">// should be true</span></div><div class="line"><span class="keywordtype">bool</span> ok_d = mySet( d ); <span class="comment">// should be true</span></div><div class="line"><span class="keywordtype">bool</span> ok_e = mySet( e ); <span class="comment">// should be true</span></div><div class="line"><span class="keywordtype">bool</span> not_ok = mySet( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>( 1,1) ); <span class="comment">// should be false</span></div></div><!-- fragment --><p>Other methods may be found in the concept definition of digital sets (CDigitalSet).</p>
<h1><a class="anchor" id="digital_sets_4"></a>
Digital sets and point predicates</h1>
<p>Since 0.6, any digital set is also a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a>. You may thus use a digital set directly in functions and methods requiring a predicate on points. However, the class <a class="el" href="structDGtal_1_1deprecated_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the set given at construction. The set given at construction is aliased in the predicate and not cloned, which means that the lifetime of the set should exceed the lifetime of the predicate. ">deprecated::SetPredicate</a>, which builds a predicate on points around a digital set, is deprecated since 0.6. You may still used it by referecing it with <a class="el" href="structDGtal_1_1deprecated_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the set given at construction. The set given at construction is aliased in the predicate and not cloned, which means that the lifetime of the set should exceed the lifetime of the predicate. ">DGtal::deprecated::SetPredicate</a>, but it will no longer be maintained.</p>
<h1><a class="anchor" id="digital_sets_5"></a>
A digital set may be transformed into a domain</h1>
<p>Sometimes it is useful to see a digital set as a new domain for further computation. This is possible with the facade class <a class="el" href="classDGtal_1_1DigitalSetDomain.html" title="Aim: Constructs a domain limited to the given digital set. ">DigitalSetDomain</a>, which wraps around some given digital set all necessary methods and types so that it satisfies the concept <a class="el" href="structDGtal_1_1concepts_1_1CDomain.html" title="Aim: This concept represents a digital domain, i.e. a non mutable subset of points of the given digit...">concepts::CDomain</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> DigitalSetDomain&lt; SpecificSet &gt; RestrictedDomain;</div><div class="line">RestrictedDomain myDomain( mySet );</div><div class="line"><span class="comment">// this domain is limited to three points c, d and e.</span></div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The <a class="el" href="classDGtal_1_1DigitalSetDomain.html" title="Aim: Constructs a domain limited to the given digital set. ">DigitalSetDomain</a> class is only a wrapper around the digital set. The lifetime of the digital set must thus exceed the lifetime of the <a class="el" href="classDGtal_1_1DigitalSetDomain.html" title="Aim: Constructs a domain limited to the given digital set. ">DigitalSetDomain</a>. </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Mar 18 2018 09:40:35 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
