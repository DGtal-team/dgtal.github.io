<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: DGtal::functions::Hull2D Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.9.4beta</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceDGtal.html">DGtal</a></li><li class="navelem"><a class="el" href="namespaceDGtal_1_1functions.html">functions</a></li><li class="navelem"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html">Hull2D</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DGtal::functions::Hull2D Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ade3b11c94c4d3736bb8efc7abcc58735"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ade3b11c94c4d3736bb8efc7abcc58735">ThicknessDefinition</a> { <a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ade3b11c94c4d3736bb8efc7abcc58735a602f83cef2331731bf233abeaf2c0ff6">HorizontalVerticalThickness</a>, 
<a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ade3b11c94c4d3736bb8efc7abcc58735aff78d557b689bb7423b38a557884134e">EuclideanThickness</a>
 }</td></tr>
<tr class="separator:ade3b11c94c4d3736bb8efc7abcc58735"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad39d6db9714b4194a49a178916ad886c"><td class="memTemplParams" colspan="2">template&lt;typename Stack , typename Point , typename Predicate &gt; </td></tr>
<tr class="memitem:ad39d6db9714b4194a49a178916ad886c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ad39d6db9714b4194a49a178916ad886c">updateHullWithStack</a> (Stack &amp;aStack, const <a class="el" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> &amp;aNewPoint, const Predicate &amp;aPredicate)</td></tr>
<tr class="separator:ad39d6db9714b4194a49a178916ad886c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9e05cfa0179a24f8db24e3b5abaeae"><td class="memTemplParams" colspan="2">template&lt;typename Stack , typename Point , typename Predicate &gt; </td></tr>
<tr class="memitem:aca9e05cfa0179a24f8db24e3b5abaeae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#aca9e05cfa0179a24f8db24e3b5abaeae">updateHullWithAdaptedStack</a> (Stack aStack, const <a class="el" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> &amp;aNewPoint, const Predicate &amp;aPredicate)</td></tr>
<tr class="separator:aca9e05cfa0179a24f8db24e3b5abaeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b3737b4aeb5443d541b9336116f6d8"><td class="memTemplParams" colspan="2">template&lt;typename Stack , typename ForwardIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:a22b3737b4aeb5443d541b9336116f6d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a22b3737b4aeb5443d541b9336116f6d8">buildHullWithStack</a> (Stack &amp;aStack, const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, const Predicate &amp;aPredicate)</td></tr>
<tr class="separator:a22b3737b4aeb5443d541b9336116f6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c864509908d68566f323096fbe7bbcc"><td class="memTemplParams" colspan="2">template&lt;typename Stack , typename ForwardIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:a6c864509908d68566f323096fbe7bbcc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a6c864509908d68566f323096fbe7bbcc">buildHullWithAdaptedStack</a> (Stack aStack, const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, const Predicate &amp;aPredicate)</td></tr>
<tr class="separator:a6c864509908d68566f323096fbe7bbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f28de021eaafe900082eb65d90f37d1"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:a7f28de021eaafe900082eb65d90f37d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a7f28de021eaafe900082eb65d90f37d1">openGrahamScan</a> (const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, OutputIterator res, const Predicate &amp;aPredicate)</td></tr>
<tr class="separator:a7f28de021eaafe900082eb65d90f37d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2e79bf291793719f2425323ae61fee"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:aec2e79bf291793719f2425323ae61fee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#aec2e79bf291793719f2425323ae61fee">closedGrahamScanFromVertex</a> (const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, OutputIterator res, const Predicate &amp;aPredicate)</td></tr>
<tr class="separator:aec2e79bf291793719f2425323ae61fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a5b9f6ff0943c40f07fb9128313af7"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:a36a5b9f6ff0943c40f07fb9128313af7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a36a5b9f6ff0943c40f07fb9128313af7">closedGrahamScanFromAnyPoint</a> (const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, OutputIterator res, const Predicate &amp;aPredicate)</td></tr>
<tr class="separator:a36a5b9f6ff0943c40f07fb9128313af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9140238e424c6e4121991d410a19011"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate , typename PolarComparator &gt; </td></tr>
<tr class="memitem:ae9140238e424c6e4121991d410a19011"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ae9140238e424c6e4121991d410a19011">grahamConvexHullAlgorithm</a> (const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, OutputIterator res, const Predicate &amp;aPredicate, PolarComparator &amp;aPolarComparator)</td></tr>
<tr class="separator:ae9140238e424c6e4121991d410a19011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e12e0b39f5b9a4f766d9915fb51c15a"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate , typename PolarComparator &gt; </td></tr>
<tr class="memitem:a9e12e0b39f5b9a4f766d9915fb51c15a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a9e12e0b39f5b9a4f766d9915fb51c15a">grahamConvexHullAlgorithm</a> (const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, OutputIterator res, const Predicate &amp;aPredicate)</td></tr>
<tr class="separator:a9e12e0b39f5b9a4f766d9915fb51c15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248898c40cc98e35b6dbcfe944c8adff"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:a248898c40cc98e35b6dbcfe944c8adff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a248898c40cc98e35b6dbcfe944c8adff">andrewConvexHullAlgorithm</a> (const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, OutputIterator res, const Predicate &amp;aPredicate)</td></tr>
<tr class="separator:a248898c40cc98e35b6dbcfe944c8adff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85c48fa77f6284d8d43808576ba474b"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:aa85c48fa77f6284d8d43808576ba474b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#aa85c48fa77f6284d8d43808576ba474b">computeHullThickness</a> (const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, const <a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ade3b11c94c4d3736bb8efc7abcc58735">ThicknessDefinition</a> &amp;def)</td></tr>
<tr class="separator:aa85c48fa77f6284d8d43808576ba474b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88085aa9d56842df67fe82301da58c0"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename TInputPoint &gt; </td></tr>
<tr class="memitem:ab88085aa9d56842df67fe82301da58c0"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ab88085aa9d56842df67fe82301da58c0">computeHullThickness</a> (const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, const <a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ade3b11c94c4d3736bb8efc7abcc58735">ThicknessDefinition</a> &amp;def, TInputPoint &amp;antipodalEdgeP, TInputPoint &amp;antipodalEdgeQ, TInputPoint &amp;antipodalVertexR)</td></tr>
<tr class="separator:ab88085aa9d56842df67fe82301da58c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb410b2e853bbdbece9846f67ba8205"><td class="memTemplParams" colspan="2">template&lt;typename TInputPoint &gt; </td></tr>
<tr class="memitem:a5cb410b2e853bbdbece9846f67ba8205"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a5cb410b2e853bbdbece9846f67ba8205">getAngle</a> (const TInputPoint &amp;a, const TInputPoint &amp;b, const TInputPoint &amp;c, const TInputPoint &amp;d)</td></tr>
<tr class="separator:a5cb410b2e853bbdbece9846f67ba8205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac0d68ce84ccfb5fe88ffb0d05b2882"><td class="memTemplParams" colspan="2">template&lt;typename TInputPoint &gt; </td></tr>
<tr class="memitem:a9ac0d68ce84ccfb5fe88ffb0d05b2882"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a9ac0d68ce84ccfb5fe88ffb0d05b2882">getThicknessAntipodalPair</a> (const TInputPoint &amp;p, const TInputPoint &amp;q, const TInputPoint &amp;r, const <a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ade3b11c94c4d3736bb8efc7abcc58735">ThicknessDefinition</a> &amp;def)</td></tr>
<tr class="separator:a9ac0d68ce84ccfb5fe88ffb0d05b2882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131a4cdda34d1cc8815c0041d7514174"><td class="memTemplParams" colspan="2">template&lt;typename TInputPoint &gt; </td></tr>
<tr class="memitem:a131a4cdda34d1cc8815c0041d7514174"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a131a4cdda34d1cc8815c0041d7514174">computeHProjDistance</a> (const TInputPoint &amp;a, const TInputPoint &amp;b, const TInputPoint &amp;c, bool &amp;isInside)</td></tr>
<tr class="separator:a131a4cdda34d1cc8815c0041d7514174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4323af52b2db409c4a76e8f4f2245f59"><td class="memTemplParams" colspan="2">template&lt;typename TInputPoint &gt; </td></tr>
<tr class="memitem:a4323af52b2db409c4a76e8f4f2245f59"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a4323af52b2db409c4a76e8f4f2245f59">computeVProjDistance</a> (const TInputPoint &amp;a, const TInputPoint &amp;b, const TInputPoint &amp;c, bool &amp;isInside)</td></tr>
<tr class="separator:a4323af52b2db409c4a76e8f4f2245f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367555edf6627f6b054f5910778e84a5"><td class="memTemplParams" colspan="2">template&lt;typename TInputPoint &gt; </td></tr>
<tr class="memitem:a367555edf6627f6b054f5910778e84a5"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a367555edf6627f6b054f5910778e84a5">computeEuclideanDistance</a> (const TInputPoint &amp;a, const TInputPoint &amp;b, const TInputPoint &amp;c, bool &amp;isInside)</td></tr>
<tr class="separator:a367555edf6627f6b054f5910778e84a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab511ebdfea4fa4b0d02901fa5f1464"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator , typename Functor &gt; </td></tr>
<tr class="memitem:acab511ebdfea4fa4b0d02901fa5f1464"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#acab511ebdfea4fa4b0d02901fa5f1464">melkmanConvexHullAlgorithm</a> (const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, OutputIterator res, <a class="el" href="testConvexHull2DReverse_8cpp.html#a4b95d895f3d8af697b8c550bc833cc9f">Functor</a> &amp;aFunctor)</td></tr>
<tr class="separator:acab511ebdfea4fa4b0d02901fa5f1464"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ade3b11c94c4d3736bb8efc7abcc58735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3b11c94c4d3736bb8efc7abcc58735">&#9670;&nbsp;</a></span>ThicknessDefinition</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ade3b11c94c4d3736bb8efc7abcc58735">DGtal::functions::Hull2D::ThicknessDefinition</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The 2 thickness definitions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ade3b11c94c4d3736bb8efc7abcc58735a602f83cef2331731bf233abeaf2c0ff6"></a>HorizontalVerticalThickness&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ade3b11c94c4d3736bb8efc7abcc58735aff78d557b689bb7423b38a557884134e"></a>EuclideanThickness&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Hull2DHelpers_8h_source.html#l00078">78</a> of file <a class="el" href="Hull2DHelpers_8h_source.html">Hull2DHelpers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;{<a class="code" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ade3b11c94c4d3736bb8efc7abcc58735a602f83cef2331731bf233abeaf2c0ff6">HorizontalVerticalThickness</a>, <a class="code" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ade3b11c94c4d3736bb8efc7abcc58735aff78d557b689bb7423b38a557884134e">EuclideanThickness</a>};</div><div class="ttc" id="namespaceDGtal_1_1functions_1_1Hull2D_html_ade3b11c94c4d3736bb8efc7abcc58735aff78d557b689bb7423b38a557884134e"><div class="ttname"><a href="namespaceDGtal_1_1functions_1_1Hull2D.html#ade3b11c94c4d3736bb8efc7abcc58735aff78d557b689bb7423b38a557884134e">DGtal::functions::Hull2D::EuclideanThickness</a></div><div class="ttdef"><b>Definition:</b> <a href="Hull2DHelpers_8h_source.html#l00078">Hull2DHelpers.h:78</a></div></div>
<div class="ttc" id="namespaceDGtal_1_1functions_1_1Hull2D_html_ade3b11c94c4d3736bb8efc7abcc58735a602f83cef2331731bf233abeaf2c0ff6"><div class="ttname"><a href="namespaceDGtal_1_1functions_1_1Hull2D.html#ade3b11c94c4d3736bb8efc7abcc58735a602f83cef2331731bf233abeaf2c0ff6">DGtal::functions::Hull2D::HorizontalVerticalThickness</a></div><div class="ttdef"><b>Definition:</b> <a href="Hull2DHelpers_8h_source.html#l00078">Hull2DHelpers.h:78</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a248898c40cc98e35b6dbcfe944c8adff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a248898c40cc98e35b6dbcfe944c8adff">&#9670;&nbsp;</a></span>andrewConvexHullAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::Hull2D::andrewConvexHullAlgorithm </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>aPredicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure that retrieves the vertices of the hull of a set of 2D points given by the range [ <em>itb</em> , <em>ite</em> ). This procedure follows the well-known monotone-chain algorithm due to [Andrew, 1979 : <a class="el" href="citelist.html#CITEREF_Andrew1979">[4]</a>]. </p>
<ul>
<li>first, points are sorted along the horizontal axis.</li>
<li>then, the lower and upper convex hull are computed by a simple Graham scan. <dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a7f28de021eaafe900082eb65d90f37d1" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::openGrahamScan</a></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The first point of the resulting list of extremal points follows the one with minimal x-coordinate and y-coordinate. Orientation depends on the predicate.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator </td></tr>
    <tr><td class="paramname">res</td><td>output iterator used to export the retrieved points </td></tr>
    <tr><td class="paramname">aPredicate</td><td>any ternary predicate <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForwardIterator</td><td>a model of forward and readable iterator </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of incrementable and writable iterator <br />
</td></tr>
    <tr><td class="paramname">Predicate</td><td>a model of ternary predicate </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a6c864509908d68566f323096fbe7bbcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c864509908d68566f323096fbe7bbcc">&#9670;&nbsp;</a></span>buildHullWithAdaptedStack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stack , typename ForwardIterator , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::Hull2D::buildHullWithAdaptedStack </td>
          <td>(</td>
          <td class="paramtype">Stack&#160;</td>
          <td class="paramname"><em>aStack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>aPredicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure that calls <a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a22b3737b4aeb5443d541b9336116f6d8" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::buildHullWithStack</a> on a copy of the stack object used to retrieved the hull vertices. Useful when the first argument is a stack adapter returned by a function: it must be copied before being passed by reference in <a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a22b3737b4aeb5443d541b9336116f6d8" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::buildHullWithStack</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aStack</td><td>stack copy </td></tr>
    <tr><td class="paramname">itb</td><td>begin iterator </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator </td></tr>
    <tr><td class="paramname">aPredicate</td><td>predicate <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stack</td><td>a model of CStack </td></tr>
    <tr><td class="paramname">ForwardIterator</td><td>a model of forward and readable iterator </td></tr>
    <tr><td class="paramname">Predicate</td><td>a model of ternary predicate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a22b3737b4aeb5443d541b9336116f6d8" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::buildHullWithStack</a> </dd></dl>

</div>
</div>
<a id="a22b3737b4aeb5443d541b9336116f6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b3737b4aeb5443d541b9336116f6d8">&#9670;&nbsp;</a></span>buildHullWithStack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stack , typename ForwardIterator , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::Hull2D::buildHullWithStack </td>
          <td>(</td>
          <td class="paramtype">Stack &amp;&#160;</td>
          <td class="paramname"><em>aStack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>aPredicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP) in linear-time. This technique is called Sklansky's scan, Graham's scan or 3-coins algorithm. <br />
It works for all WEVP [Toussaint and Avis, 1982 : <a class="el" href="citelist.html#CITEREF_ToussaintAvis1982">[83]</a>]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aStack</td><td>reference to the stack of retrieved vertices </td></tr>
    <tr><td class="paramname">itb</td><td>begin iterator </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator </td></tr>
    <tr><td class="paramname">aPredicate</td><td>predicate <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stack</td><td>a model of CStack </td></tr>
    <tr><td class="paramname">ForwardIterator</td><td>a model of forward and readable iterator </td></tr>
    <tr><td class="paramname">Predicate</td><td>a model of ternary predicate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ad39d6db9714b4194a49a178916ad886c" title="Procedure that updates the hull when an extra point aNewPoint is considered: while the last three con...">Hull2D::updateHullWithStack</a> </dd></dl>

</div>
</div>
<a id="a36a5b9f6ff0943c40f07fb9128313af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a5b9f6ff0943c40f07fb9128313af7">&#9670;&nbsp;</a></span>closedGrahamScanFromAnyPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::Hull2D::closedGrahamScanFromAnyPoint </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>aPredicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP) in linear-time. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a22b3737b4aeb5443d541b9336116f6d8" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::buildHullWithStack</a> <a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#aec2e79bf291793719f2425323ae61fee" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::closedGrahamScanFromVertex</a></dd></dl>
<p>NB: We do not assume that the starting point of the polygon is an extremal point like in <a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#aec2e79bf291793719f2425323ae61fee" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::closedGrahamScanFromVertex</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator </td></tr>
    <tr><td class="paramname">res</td><td>output iterator used to export the retrieved points </td></tr>
    <tr><td class="paramname">aPredicate</td><td>any ternary predicate</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForwardIterator</td><td>a model of forward and readable iterator </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of incremental and writable iterator <br />
</td></tr>
    <tr><td class="paramname">Predicate</td><td>a model of ternary predicate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec2e79bf291793719f2425323ae61fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec2e79bf291793719f2425323ae61fee">&#9670;&nbsp;</a></span>closedGrahamScanFromVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::Hull2D::closedGrahamScanFromVertex </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>aPredicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP) in linear-time. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a22b3737b4aeb5443d541b9336116f6d8" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::buildHullWithStack</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator </td></tr>
    <tr><td class="paramname">res</td><td>output iterator used to export the retrieved points </td></tr>
    <tr><td class="paramname">aPredicate</td><td>any ternary predicate <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>we assume that the starting point of the polygon is an extremal point.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForwardIterator</td><td>a model of forward and readable iterator </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of incremental and writable iterator <br />
</td></tr>
    <tr><td class="paramname">Predicate</td><td>a model of ternary predicate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a367555edf6627f6b054f5910778e84a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367555edf6627f6b054f5910778e84a5">&#9670;&nbsp;</a></span>computeEuclideanDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double DGtal::functions::Hull2D::computeEuclideanDistance </td>
          <td>(</td>
          <td class="paramtype">const TInputPoint &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isInside</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the euclidean distance a point <em>c</em> according to the segment [<em>a</em>, <em>b</em>]. (i.e the distance between <em>c</em> and its projected point on [<em>a</em>,<em>b</em>].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>one point of the segment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>a second point of the segment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>the point for which the vertical distance is computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">isInside</td><td>indicates if the projected point is inside the segment or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a131a4cdda34d1cc8815c0041d7514174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131a4cdda34d1cc8815c0041d7514174">&#9670;&nbsp;</a></span>computeHProjDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double DGtal::functions::Hull2D::computeHProjDistance </td>
          <td>(</td>
          <td class="paramtype">const TInputPoint &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isInside</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the horizontal distance a point <code>according</code> to the segment [ <em>a</em> , <em>b</em> ]. (i.e the horizontal projection distance of <code>on</code> [ <em>a</em> , <em>b</em> ]). </p><dl class="section note"><dt>Note</dt><dd>if the segment [<em>a</em>, <em>b</em>] is horizontal (i.e <em>a</em> [1]==<em>b</em>[1]) then an infinite value (std::numerics&lt;double&gt;::max()) is returned.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>one point of the segment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>a second point of the segment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>the point for which the horizontal distance is computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">isInside</td><td>indicates if the projected point is inside the segment or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa85c48fa77f6284d8d43808576ba474b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85c48fa77f6284d8d43808576ba474b">&#9670;&nbsp;</a></span>computeHullThickness() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double DGtal::functions::Hull2D::computeHullThickness </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ade3b11c94c4d3736bb8efc7abcc58735">ThicknessDefinition</a> &amp;&#160;</td>
          <td class="paramname"><em>def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure to compute the convex hull thickness given from different definitions (Horizontal/vertical or Euclidean distances). It takes as input the vertices of the hull given by the range [<em>itbn</em>, <em>ite</em>). The procedure applies the classic rotating caliper to recover all anti-podal pairs. </p>
<p>Typical use: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> PointVector&lt;2,DGtal::int32_t&gt; <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>;</div><div class="line"><span class="keyword">typedef</span> InHalfPlaneBySimple3x3Matrix&lt;Point, DGtal::int32_t&gt; <a class="code" href="testConvexHull2DReverse_8cpp.html#a4b95d895f3d8af697b8c550bc833cc9f">Functor</a>;  </div><div class="line"><a class="code" href="classDGtal_1_1MelkmanConvexHull.html">DGtal::MelkmanConvexHull&lt;Point, Functor&gt;</a> <a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>; </div><div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0));</div><div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(11,1));</div><div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(12,3));</div><div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(8,3));</div><div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(4,5));</div><div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(2,6));</div><div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1,4));</div><div class="line"><span class="keywordtype">double</span> th = <a class="code" href="namespaceDGtal_1_1functions_1_1Hull2D.html#aa85c48fa77f6284d8d43808576ba474b">computeHullThickness</a>(<a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.begin(), <a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.end(), </div><div class="line">                                 <a class="code" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ade3b11c94c4d3736bb8efc7abcc58735aff78d557b689bb7423b38a557884134e">DGtal::functions::Hull2D::EuclideanThickness</a>);</div></div><!-- fragment --><p> <br />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itb</td><td>begin iterator on the convex hull points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ite</td><td>end iterator on the convex hull points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>definition of the thickness used in the estimation (i.e HorizontalVerticalThickness or EuclideanThickness)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the convex hull contains 0, 1 or 2 points the thickness of 0 is returned. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The convex hull should be oriented in counter clockwise else it will return wrong result. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="geometry_2tools_2exampleConvexHull2D_8cpp-example.html#a18">geometry/tools/exampleConvexHull2D.cpp</a>.</dd>
</dl>
<p class="reference">Referenced by <a class="el" href="exampleConvexHull2D_8cpp_source.html#l00122">convexHull()</a>, and <a class="el" href="testConvexHull2D_8cpp_source.html#l00274">testConvexHullCompThickness()</a>.</p>

</div>
</div>
<a id="ab88085aa9d56842df67fe82301da58c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88085aa9d56842df67fe82301da58c0">&#9670;&nbsp;</a></span>computeHullThickness() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename TInputPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double DGtal::functions::Hull2D::computeHullThickness </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ade3b11c94c4d3736bb8efc7abcc58735">ThicknessDefinition</a> &amp;&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInputPoint &amp;&#160;</td>
          <td class="paramname"><em>antipodalEdgeP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInputPoint &amp;&#160;</td>
          <td class="paramname"><em>antipodalEdgeQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInputPoint &amp;&#160;</td>
          <td class="paramname"><em>antipodalVertexR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure to compute the convex hull thickness given from different definitions (Horizontal/vertical or Euclidean distances). It takes as input the vertices of the hull given by the range [<em>itbn</em>, <em>ite</em>). The procedure applies the classic rotating caliper to recover all anti-podal pairs. </p>
<p>Typical use: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> PointVector&lt;2,DGtal::int32_t&gt; <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>;</div><div class="line"><span class="keyword">typedef</span> InHalfPlaneBySimple3x3Matrix&lt;Point, DGtal::int32_t&gt; <a class="code" href="testConvexHull2DReverse_8cpp.html#a4b95d895f3d8af697b8c550bc833cc9f">Functor</a>;  </div><div class="line"><a class="code" href="classDGtal_1_1MelkmanConvexHull.html">DGtal::MelkmanConvexHull&lt;Point, Functor&gt;</a> <a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>; </div><div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0));</div><div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(11,1));</div><div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(12,3));</div><div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(8,3));</div><div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(4,5));</div><div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(2,6));</div><div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1,4));</div><div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> p, q, s;</div><div class="line"><span class="keywordtype">double</span> th = <a class="code" href="namespaceDGtal_1_1functions_1_1Hull2D.html#aa85c48fa77f6284d8d43808576ba474b">computeHullThickness</a>(<a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.begin(), <a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.end(), </div><div class="line">                                 <a class="code" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ade3b11c94c4d3736bb8efc7abcc58735aff78d557b689bb7423b38a557884134e">DGtal::functions::Hull2D::EuclideanThickness</a>, p, q, s);</div></div><!-- fragment --><p> <br />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itb</td><td>begin iterator on the convex hull points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ite</td><td>end iterator on the convex hull points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>definition of the thickness used in the estimation (i.e HorizontalVerticalThickness or EuclideanThickness) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">antipodalEdgeP</td><td>one point of the antipodal edge associated to the minimal value of convex hull thickness. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">antipodalEdgeQ</td><td>one point of the antipodal edge associated to the minimal value of convex hull thickness. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">antipodalVertexR</td><td>the vertex of the antipodal pair associated to the minimal value of convex hull thickness. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the convex hull contains 0, 1 or 2 points the thickness of 0 is returned and the antipodal points are updated with the first points (if they exist). </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The convex hull should be oriented in counter clockwise else it will return wrong result. </dd></dl>

</div>
</div>
<a id="a4323af52b2db409c4a76e8f4f2245f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4323af52b2db409c4a76e8f4f2245f59">&#9670;&nbsp;</a></span>computeVProjDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double DGtal::functions::Hull2D::computeVProjDistance </td>
          <td>(</td>
          <td class="paramtype">const TInputPoint &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isInside</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the vertical distance a point <code>according</code> to the segment [<em>a</em>, <em>b</em>]. (i.e the vertical projection distance of <code>on</code> [<em>a</em>,<em>b</em>]. </p><dl class="section note"><dt>Note</dt><dd>if the segment [<em>a</em>, <em>b</em>] is vertical (i.e <em>a</em> [0]== <em>b</em> [0]) then an infinite value (std::numerics&lt;double&gt;::max()) is returned.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>one point of the segment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>a second point of the segment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>the point for which the vertical distance is computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">isInside</td><td>indicates if the projected point is inside the segment or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cb410b2e853bbdbece9846f67ba8205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb410b2e853bbdbece9846f67ba8205">&#9670;&nbsp;</a></span>getAngle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputPoint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double DGtal::functions::Hull2D::getAngle </td>
          <td>(</td>
          <td class="paramtype">const TInputPoint &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the angle between the line (<em>a</em>,<em>b</em>) and (<em>c</em>,<em>d</em>) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>one of point defining the first line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>a second point defining the first line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>a third point defining the second line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>a third point defining the second line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ac0d68ce84ccfb5fe88ffb0d05b2882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac0d68ce84ccfb5fe88ffb0d05b2882">&#9670;&nbsp;</a></span>getThicknessAntipodalPair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double DGtal::functions::Hull2D::getThicknessAntipodalPair </td>
          <td>(</td>
          <td class="paramtype">const TInputPoint &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ade3b11c94c4d3736bb8efc7abcc58735">ThicknessDefinition</a> &amp;&#160;</td>
          <td class="paramname"><em>def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the thickness of an anti podal pair (represented by the segment [ <em>p</em> , <em>q</em> ] and vertex <em>r</em>) according to the given distance <em>def</em> definition. <br />
 If the distance definition is <em>HorizontalVerticalThickness</em>, it returns the minimal distance between the vertical/horizontal projection of <em>r</em> on ( <em>p</em> , <em>q</em> ).</p>
<p>If the distance definition is <em>EuclideanThickness</em>, it returns the distance between r and its projection on the line ( <em>p</em> ,<em>q</em> ).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>the first point of the edge anti podal pair. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>the second point of the edge anti podal pair. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>the vertex of the anti podal pair. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>definition of the thickness used in the estimation (i.e HorizontalVerticalThickness or EuclideanThickness). </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="testConvexHull2D_8cpp_source.html#l00274">testConvexHullCompThickness()</a>.</p>

</div>
</div>
<a id="ae9140238e424c6e4121991d410a19011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9140238e424c6e4121991d410a19011">&#9670;&nbsp;</a></span>grahamConvexHullAlgorithm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate , typename PolarComparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::Hull2D::grahamConvexHullAlgorithm </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>aPredicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PolarComparator &amp;&#160;</td>
          <td class="paramname"><em>aPolarComparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure that retrieves the vertices of the convex hull of a set of 2D points given by the range [ <em>itb</em> , <em>ite</em> ). This procedure follows the well-known Graham's algorithm [Graham, 1972 : <a class="el" href="citelist.html#CITEREF_Graham1972">[41]</a>]. </p>
<ul>
<li>choose a pole and sort the points in order of increasing angle about the pole with the given comparator.</li>
<li>scan the sorted list of points and remove some points so that the given predicate returns 'true' for all sets of three consecutive points. <dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#aec2e79bf291793719f2425323ae61fee" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::closedGrahamScanFromVertex</a></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The first point of the resulting list of extremal points is guaranteed to be the one with maximal x-coordinate and y-coordinate.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The orientation of the predicate and of the polar comparator should be the same. Otherwise, the procedure only returns the last convex hull edge. For instance, you may use a predicate that returns 'true' for three points counter-clockwise oriented together with PolarPointComparatorBy2x2DetComputer. <br />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator </td></tr>
    <tr><td class="paramname">res</td><td>output iterator used to export the retrieved points </td></tr>
    <tr><td class="paramname">aPredicate</td><td>any ternary predicate <br />
</td></tr>
    <tr><td class="paramname">aPolarComparator</td><td>any polar comparator</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForwardIterator</td><td>a model of forward and readable iterator </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of incremental and writable iterator <br />
</td></tr>
    <tr><td class="paramname">Predicate</td><td>a model of ternary predicate </td></tr>
    <tr><td class="paramname">PolarComparator</td><td>a model of CPolarPointComparator2D. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a9e12e0b39f5b9a4f766d9915fb51c15a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e12e0b39f5b9a4f766d9915fb51c15a">&#9670;&nbsp;</a></span>grahamConvexHullAlgorithm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate , typename PolarComparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::Hull2D::grahamConvexHullAlgorithm </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>aPredicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure that retrieves the vertices of the convex hull of a set of 2D points given by the range [ <em>itb</em> , <em>ite</em> ). This procedure follows the well-known Graham's algorithm [Graham, 1972 : <a class="el" href="citelist.html#CITEREF_Graham1972">[41]</a>]. </p>
<ul>
<li>choose a pole and sort the points in order of increasing angle about the pole (with a counter-clockwise orientation).</li>
<li>scan the sorted list of points and remove some points so that the given predicate returns 'true' for all sets of three consecutive points. <dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#aec2e79bf291793719f2425323ae61fee" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::closedGrahamScanFromVertex</a></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The first point of the resulting list of extremal points is guaranteed to be the one with maximal x-coordinate and y-coordinate.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The predicate must be chosen so that is returns 'true' for counter-clockwise oriented 3-point sets. Otherwise, the procedure only returns the last convex hull edge. <br />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator </td></tr>
    <tr><td class="paramname">res</td><td>output iterator used to export the retrieved points </td></tr>
    <tr><td class="paramname">aPredicate</td><td>any ternary predicate <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForwardIterator</td><td>a model of forward and readable iterator </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of incremental and writable iterator <br />
</td></tr>
    <tr><td class="paramname">Predicate</td><td>a model of ternary predicate </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="acab511ebdfea4fa4b0d02901fa5f1464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab511ebdfea4fa4b0d02901fa5f1464">&#9670;&nbsp;</a></span>melkmanConvexHullAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::Hull2D::melkmanConvexHullAlgorithm </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="testConvexHull2DReverse_8cpp.html#a4b95d895f3d8af697b8c550bc833cc9f">Functor</a> &amp;&#160;</td>
          <td class="paramname"><em>aFunctor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure that retrieves the vertices of the hull of a set of 2D points given by the range [ <em>itb</em> , <em>ite</em> ). This procedure follows the well-known Melkman algorithm [Melkman, 1979 : <a class="el" href="citelist.html#CITEREF_Melkman1987">[58]</a>]. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1MelkmanConvexHull.html" title="Aim: This class implements the on-line algorithm of Melkman for the computation of the convex hull of...">MelkmanConvexHull</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator </td></tr>
    <tr><td class="paramname">res</td><td>output iterator used to export the retrieved points </td></tr>
    <tr><td class="paramname">aFunctor</td><td>aFunctor <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForwardIterator</td><td>a model of forward and readable iterator </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of incrementable and writable iterator <br />
</td></tr>
    <tr><td class="paramname">Functor</td><td>a model of COrientationFunctor2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f28de021eaafe900082eb65d90f37d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f28de021eaafe900082eb65d90f37d1">&#9670;&nbsp;</a></span>openGrahamScan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::Hull2D::openGrahamScan </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>aPredicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP) in linear-time. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a22b3737b4aeb5443d541b9336116f6d8" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::buildHullWithStack</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator </td></tr>
    <tr><td class="paramname">res</td><td>output iterator used to export the retrieved points </td></tr>
    <tr><td class="paramname">aPredicate</td><td>any ternary predicate <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForwardIterator</td><td>a model of forward and readable iterator </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of incremental and writable iterator <br />
</td></tr>
    <tr><td class="paramname">Predicate</td><td>a model of ternary predicate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca9e05cfa0179a24f8db24e3b5abaeae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9e05cfa0179a24f8db24e3b5abaeae">&#9670;&nbsp;</a></span>updateHullWithAdaptedStack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stack , typename Point , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::Hull2D::updateHullWithAdaptedStack </td>
          <td>(</td>
          <td class="paramtype">Stack&#160;</td>
          <td class="paramname"><em>aStack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aNewPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>aPredicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure that calls <a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ad39d6db9714b4194a49a178916ad886c" title="Procedure that updates the hull when an extra point aNewPoint is considered: while the last three con...">Hull2D::updateHullWithStack</a> on a copy of the stack object used to retrieved the hull vertices. Useful when the first argument is a stack adapter returned by a function: it must be copied before being passed by reference in <a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ad39d6db9714b4194a49a178916ad886c" title="Procedure that updates the hull when an extra point aNewPoint is considered: while the last three con...">Hull2D::updateHullWithStack</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aStack</td><td>stack copy </td></tr>
    <tr><td class="paramname">aNewPoint</td><td>new point </td></tr>
    <tr><td class="paramname">aPredicate</td><td>point predicate <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stack</td><td>a model of CStack </td></tr>
    <tr><td class="paramname">Point</td><td>a model of point <br />
</td></tr>
    <tr><td class="paramname">Predicate</td><td>a model of ternary predicate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad39d6db9714b4194a49a178916ad886c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39d6db9714b4194a49a178916ad886c">&#9670;&nbsp;</a></span>updateHullWithStack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stack , typename Point , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::Hull2D::updateHullWithStack </td>
          <td>(</td>
          <td class="paramtype">Stack &amp;&#160;</td>
          <td class="paramname"><em>aStack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aNewPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>aPredicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure that updates the hull when an extra point <em>aNewPoint</em> is considered: while the last three consecutive points, ie. <em>aNewPoint</em> and the last two points of the container are not oriented such that the predicate <em>aPredicate</em> returns 'true', <br />
the last point of the container is removed. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a22b3737b4aeb5443d541b9336116f6d8" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::buildHullWithStack</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aStack</td><td>reference to the stack of retrieved vertices </td></tr>
    <tr><td class="paramname">aNewPoint</td><td>new point </td></tr>
    <tr><td class="paramname">aPredicate</td><td>point predicate <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stack</td><td>a model of CStack </td></tr>
    <tr><td class="paramname">Point</td><td>a model of point <br />
</td></tr>
    <tr><td class="paramname">Predicate</td><td>a model of ternary predicate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Mar 18 2018 09:41:13 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
