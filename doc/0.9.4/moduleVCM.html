<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Digital Voronoi Covariance Measure and geometry estimation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.9.4beta</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Digital Voronoi Covariance <a class="el" href="classDGtal_1_1Measure.html" title="Aim: Implements a simple measure computation (in the Lesbegue sens) of a set. In dimension 2...">Measure</a> and geometry estimation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#moduleVCM_sec1">Voronoi Covariance Measure</a></li>
<li class="level1"><a href="#moduleVCM_sec2">Computing the Voronoi Covariance Measure of a point set</a></li>
<li class="level1"><a href="#moduleVCM_sec3">Voronoi Covariance Measure of a digital surface</a><ul><li class="level2"><a href="#moduleVCM_sec3_1">The class VoronoiCovarianceMeasureOnDigitalSurface</a></li>
<li class="level2"><a href="#moduleVCM_sec3_2">The class VCMDigitalSurfaceLocalEstimator</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: Jacques-Olivier Lachaud</dt><dd></dd></dl>
<p>Part of the <a class="el" href="packageGeometry.html">Geometry package</a>.</p>
<p>This part of the manual describes classes and functions related to the Voronoi Covariance <a class="el" href="classDGtal_1_1Measure.html" title="Aim: Implements a simple measure computation (in the Lesbegue sens) of a set. In dimension 2...">Measure</a> (VCM) of a set of points in arbitrary dimension. The VCM is a covariance tensor related to a distance function to the input data points. It was introduced by MÃ©rigot, Ovsjanikov and Guibas <a class="el" href="citelist.html#CITEREF_Merigot_2011-tvcg">[61]</a>. The digital version of the VCM was studied by Cuel, Lachaud, and Thibert <a class="el" href="citelist.html#CITEREF_Cuel_2014-dgci">[30]</a>. Stability and multigrid convergence results have been established. This documentation presents the implementation of the digital VCM. The VCM is useful for the following tasks:</p>
<ul>
<li><b>normal</b> <b>cone</b> <b>estimation:</b> Given a set of digital points approximating a surface, the VCM estimates robustly the normal vector to this underlying surface.</li>
<li><b>geometry</b> <b>estimation:</b> Given a digital surface approximating some surface, the VCM can estimate robustly the oriented normal vector and the principal directions of the underlying surface.</li>
<li><b>feature</b> <b>detection:</b> Given a set of digital points approximating a surface, the eigenvalues of the VCM can be combined to define a robust feature detector.</li>
</ul>
<p>Related examples are <a class="el" href="dvcm-2d_8cpp_source.html">geometry/volumes/dvcm-2d.cpp</a>, <a class="el" href="dvcm-3d_8cpp_source.html">geometry/surfaces/dvcm-3d.cpp</a>, <a class="el" href="dvcm-2d-curvature_8cpp_source.html">geometry/surfaces/dvcm-2d-curvature.cpp</a>.</p>
<h1><a class="anchor" id="moduleVCM_sec1"></a>
Voronoi Covariance Measure</h1>
<p>The <em>Voronoi</em> <em>covariance</em> <em>measure</em> (VCM) has been introduced in <a class="el" href="citelist.html#CITEREF_Merigot_2011-tvcg">[61]</a> for normals and curvature estimations. Let <em>K</em> be a compact subset of \(\mathbb{R}^3\) and \(d_K\) the <em>distance</em> <em>function</em> to <em>K</em>, i.e. the map \( d_K(x) := \min_{p\in K} \|p-x\| \). A point <em>p</em> where the previous minimum is reached is called a <em>projection</em> of <em>x</em> on <em>K</em>. Almost every point admits a single projection on <em>K</em>, thus definining a map \( p_K: \mathbb{R}^3 \to K \) almost everywhere. The <em>R-<em>offset</em> of</em> <em>K</em> is the <em>R-sublevel</em> set of \( d_K\), i.e. the set \(K^R:=d_K^{-1}(]-\infty, R[)\). The VCM maps any integrable function \(\chi:\mathbb{R}^3 \to \mathbb{R}^+\) to the matrix </p><p class="formulaDsp">
\[ \mathcal{V}_{K,R}(\chi) := \int_{K^R}(x-p_K(x))(x-p_K(x))^{\mathbf{t}} \chi(p_K(x)) d x. \]
</p>
<div class="image">
<img src="vcm.png" alt="vcm.png"/>
<div class="caption">
Voronoi Covariance Measure of a point set in the plane.</div></div>
<dl class="section note"><dt>Note</dt><dd>The stability result of <a class="el" href="citelist.html#CITEREF_Merigot_2011-tvcg">[61]</a> implies that information extracted from the covariance matrix such as normals or principal directions are <b>stable</b> with respect to <b>Hausdorff</b> <b>perturbation</b>.</dd></dl>
<dl class="section user"><dt>Advanced: Remark that this definition matches the definition</dt><dd>introduced in <a class="el" href="citelist.html#CITEREF_Merigot_2011-tvcg">[61]</a> : when \(\chi\) is the characteristic function of a ball, one recovers a notion similar to the convolved VCM.</dd></dl>
<h1><a class="anchor" id="moduleVCM_sec2"></a>
Computing the Voronoi Covariance Measure of a point set</h1>
<p>Let <em>K</em> be some point set. In this case, the computation of the VCM can be split into isolated calculations in each Voronoi cell of <em>K</em>. In the digital setting, the Voronoi cells can be efficiently computed by repeated scans of the domain (see <a class="el" href="moduleVolumetric.html">nD Volumetric Analysis using Separable Processes</a>). That's exactly how is computed the VCM. The computational complexity of the VCM is thus the computational complexity of the Voronoi map in nD. The templated class <a class="el" href="classDGtal_1_1VoronoiCovarianceMeasure.html" title="Aim: This class precomputes the Voronoi Covariance Measure of a set of points. It can compute the cov...">VoronoiCovarianceMeasure</a> is the one taking of the computation. It requires two type parameters:</p>
<ul>
<li><b>TSpace:</b> the digital space (any model of CSpace), like <a class="el" href="classDGtal_1_1SpaceND.html">SpaceND</a>.</li>
<li><b>TSeparableMetric:</b> the metric used for computing the Voronoi map (any model of CSeparableMetric), like <a class="el" href="classDGtal_1_1ExactPredicateLpSeparableMetric.html">ExactPredicateLpSeparableMetric&lt;TSpace, 2&gt;</a> for the Euclidean metric.</li>
</ul>
<p>The instantiation of the class <a class="el" href="classDGtal_1_1VoronoiCovarianceMeasure.html" title="Aim: This class precomputes the Voronoi Covariance Measure of a set of points. It can compute the cov...">VoronoiCovarianceMeasure</a> requires the following parameters:</p>
<ul>
<li><b>R</b> the offset radius for the set of points. Voronoi cells are intersected with this offset. The unit corresponds to a step in the digital space.</li>
<li><b>r</b> (an upper bound of) the radius of the support of forthcoming kernel functions ( \( \chi \)). The unit corresponds to a step in the digital space. This parameter is used for preparing the data structure that answers to proximity queries.</li>
<li><b>aMetric</b> an instance of the chosen metric.</li>
</ul>
<p>Then, the set of input points is specified by a range of input iterators given to the method <a class="el" href="classDGtal_1_1VoronoiCovarianceMeasure.html#a8863e14ee7fa2eb82e10de137e6facc9">VoronoiCovarianceMeasure::init</a>. This method computes the VCM of each Voronoi cell determined by the given points.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="namespaceDGtal_1_1Z2i.html#a9b96ab8175cf9c54b1f451858ccd46a4">Z2i::Space</a> <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a38dfaf1641eab4d3fb805df4b52ab10d">Space</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>;</div><div class="line"><span class="keyword">typedef</span> ExactPredicateLpSeparableMetric&lt;Space, 2&gt; Metric; <span class="comment">// L2-metric</span></div><div class="line"><span class="keyword">typedef</span> VoronoiCovarianceMeasure&lt;Space,Metric&gt; VCM;</div><div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> tbl[] = { { 0, 1 }, { 3, 2 }, { 5, 3 } };</div><div class="line">Metric l2;</div><div class="line">VCM vcm( R, ceil( r ), l2, <span class="keyword">true</span> ); <span class="comment">// last parameter is verbose mode</span></div><div class="line">vcm.init( tbl, tbl + 3 );</div></div><!-- fragment --><p>You may then access to the following elements:</p>
<ul>
<li>the voronoi map giving for any point the closest point in <em>K</em> is accessed through method <a class="el" href="classDGtal_1_1VoronoiCovarianceMeasure.html#a49b2f1dfc6030b1620c6b6caa8d0faf9">VoronoiCovarianceMeasure::voronoiMap</a>.</li>
<li>the Voronoi Covariance Matrix of each Voronoi cell as a map Point -&gt; Matrix is returned by method <a class="el" href="classDGtal_1_1VoronoiCovarianceMeasure.html#a1c1f66b384256213b95e0f78fec7c227">VoronoiCovarianceMeasure::vcmMap</a>.</li>
<li>the \( \chi \) VCM is returned by method <a class="el" href="classDGtal_1_1VoronoiCovarianceMeasure.html#a2018ce88b2460f36dad17054979d8a91">VoronoiCovarianceMeasure::measure</a>, where a kernel function must be specified. The type of the kernel function can be <a class="el" href="structDGtal_1_1functors_1_1HatPointFunction.html">functors::HatPointFunction</a> or <a class="el" href="structDGtal_1_1functors_1_1BallConstantPointFunction.html">functors::BallConstantPointFunction</a>, but you may define your own.</li>
</ul>
<p>Example <a class="el" href="dvcm-2d_8cpp_source.html">geometry/volumes/dvcm-2d.cpp</a> gives the full code for computing the \( \chi \)-VCM of an arbitrary set of digital points, and then estimating the normal vector as well as detecting corners.</p>
<div class="image">
<img src="dvcm-hat-r.png" alt="dvcm-hat-r.png"/>
<div class="caption">
Normal vector and feature detection with Voronoi Covariance Measure.</div></div>
<h1><a class="anchor" id="moduleVCM_sec3"></a>
Voronoi Covariance Measure of a digital surface</h1>
<p>In the case where the input data is a digital surface, we provide several classes that helps the computation and the usage of the VCM. Furthermore, having as input data a volume or a set of oriented surfels allows us to orient the normal direction given by the VCM. The main classes are <a class="el" href="classDGtal_1_1VoronoiCovarianceMeasureOnDigitalSurface.html">VoronoiCovarianceMeasureOnDigitalSurface</a> and <a class="el" href="classDGtal_1_1VCMDigitalSurfaceLocalEstimator.html">VCMDigitalSurfaceLocalEstimator</a>.</p>
<h2><a class="anchor" id="moduleVCM_sec3_1"></a>
The class VoronoiCovarianceMeasureOnDigitalSurface</h2>
<p>The class <a class="el" href="classDGtal_1_1VoronoiCovarianceMeasureOnDigitalSurface.html" title="Aim: This class specializes the Voronoi covariance measure for digital surfaces. It adds notably the ...">VoronoiCovarianceMeasureOnDigitalSurface</a> is templated by the following types:</p>
<ul>
<li><b>TDigitalSurfaceContainer</b> the type of digital surface container (model of <a class="el" href="structDGtal_1_1concepts_1_1CDigitalSurfaceContainer.html" title="Aim: The digital surface container concept describes a minimal set of inner types and methods so as t...">concepts::CDigitalSurfaceContainer</a>), e.g. an <a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">ImplicitDigitalSurface</a>.</li>
<li><b>TSeparableMetric</b> a model of <a class="el" href="structDGtal_1_1concepts_1_1CSeparableMetric.html" title="Aim: defines the concept of separable metrics. ">concepts::CSeparableMetric</a> used for computing the Voronoi map (e.g. Euclidean metric is DGtal::ExactPredicateLpSeparableMetric&lt;TSpace, 2&gt; )</li>
<li><b>TKernelFunction</b> the type of the kernel function \( \chi \) used for integrating the VCM, a map: Point -&gt; Scalar, e.g. <a class="el" href="structDGtal_1_1functors_1_1HatPointFunction.html">functors::HatPointFunction</a> or <a class="el" href="structDGtal_1_1functors_1_1BallConstantPointFunction.html">functors::BallConstantPointFunction</a>, but you may define your own.</li>
</ul>
<p>At instanciation, you have to precise several parameters:</p>
<ul>
<li><b>surface</b> the digital surface that is aliased in this. The user can <b>secure</b> the aliasing by passing a <a class="el" href="classDGtal_1_1CountedConstPtrOrConstPtr.html" title="Aim: Smart or simple const pointer on T. It can be a smart pointer based on reference counts or a sim...">CountedConstPtrOrConstPtr</a>.</li>
<li><b>surfelEmbedding</b> the chosen embedding for surfels (Pointels, InnerSpel, OuterSpel). This embedding defines the digital points that are used in the computation of the VCM (see <a class="el" href="classDGtal_1_1VoronoiCovarianceMeasure.html" title="Aim: This class precomputes the Voronoi Covariance Measure of a set of points. It can compute the cov...">VoronoiCovarianceMeasure</a>).</li>
<li><b>R</b> the offset radius for the set of points. Voronoi cells are intersected with this offset. The unit corresponds to a step in the digital space.</li>
<li><b>r</b> (an upper bound of) the radius of the support of forthcoming kernel functions ( \( \chi \)). The unit corresponds to a step in the digital space. This parameter is used for preparing the data structure that answers to proximity queries.</li>
<li><b>chi_r</b> the kernel function whose support has radius less or equal to <em>r</em>.</li>
<li><b>t</b> the radius for the trivial normal estimator, which is used for finding the correct orientation inside/outside for the VCM.</li>
<li><b>aMetric</b> an instance of the chosen metric.</li>
</ul>
<p>The following piece of code shows how to wrap a VCM around a digital surface <code>surface</code>.</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ExactPredicateLpSeparableMetric&lt;Space, 2&gt; Metric;          <span class="comment">// L2-metric type</span></div><div class="line">  <span class="keyword">typedef</span> functors::HatPointFunction&lt;Point,double&gt;  KernelFunction;  <span class="comment">// chi function type</span></div><div class="line">  <span class="keyword">typedef</span> VoronoiCovarianceMeasureOnDigitalSurface&lt; DigitalSurfaceContainer, Metric,</div><div class="line">                                                    KernelFunction &gt; VCMOnSurface;</div><div class="line">  <span class="keyword">typedef</span> VCMOnSurface::Surfel2Normals::const_iterator S2NConstIterator;</div></div><!-- fragment --><div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal.html#aaad242ffef715835e8928579a506b2d5">Surfel2PointEmbedding</a> embType = <a class="code" href="namespaceDGtal.html#aaad242ffef715835e8928579a506b2d5ac0a8bc5774ff6530ee71a7cacd6ca6f4">Pointels</a>; <span class="comment">// Could be Pointels|InnerSpel|OuterSpel;</span></div><div class="line">  Metric l2;                                <span class="comment">// Euclidean L2 metric</span></div><div class="line">  KernelFunction chi( 1.0, r );             <span class="comment">// hat function with support of radius r</span></div><div class="line">  VCMOnSurface vcm_surface( surface, embType, R, r,</div><div class="line">                            chi, trivial_r, l2, <span class="keyword">true</span> <span class="comment">/* verbose */</span> );</div></div><!-- fragment --><p> The whole VCM computation is done in the constructor. Once this is done, you may access to the whole VCM tensor information with the methods:</p>
<ul>
<li><a class="el" href="classDGtal_1_1VoronoiCovarianceMeasureOnDigitalSurface.html#a8ce4ffd9be912de58d1286e2e10daad6">VoronoiCovarianceMeasureOnDigitalSurface::mapSurfel2Normals</a> returns the map associating to each surfel a structure containing both the normal estimated by VCM and the normal estimated from the trivial surfel normals.</li>
<li><a class="el" href="classDGtal_1_1VoronoiCovarianceMeasureOnDigitalSurface.html#a1a8ca0b5bd095d0e0c4e4b5acf03f418">VoronoiCovarianceMeasureOnDigitalSurface::mapPoint2ChiVCM</a> returns the map associating with each admissible digital point (so depending on the <em>surfelEmbedding</em>) the eigenstructure of the VCM tensor (principal directions, eigenvalues).</li>
<li><a class="el" href="classDGtal_1_1VoronoiCovarianceMeasureOnDigitalSurface.html#a71661a082d7d86edffea3d479abc90f8">VoronoiCovarianceMeasureOnDigitalSurface::getChiVCMEigenvalues</a> outputs the eigenvalues at the specified <em>surfel</em>.</li>
<li><a class="el" href="classDGtal_1_1VoronoiCovarianceMeasureOnDigitalSurface.html#ad52143f09d5901c3b6a46bc028f92112">VoronoiCovarianceMeasureOnDigitalSurface::getChiVCMEigenStructure</a> outputs the whole eigenstructure at the specified <em>surfel</em>.</li>
</ul>
<p>Example <a class="el" href="dvcm-3d_8cpp_source.html">geometry/surfaces/dvcm-3d.cpp</a> gives the full code for computing the \( \chi \)-VCM of an arbitrary digital surface, and then estimating the normal vector as well as detecting corners. Here is a small piece of code that extracts the VCM normal for each surfel.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> ( S2NConstIterator it = vcm_surface.mapSurfel2Normals().begin(), </div><div class="line">        itE = vcm_surface.mapSurfel2Normals().end(); it != itE; ++it )</div><div class="line">  {</div><div class="line">    Surfel s     = it-&gt;first;            <span class="comment">// gets surfel</span></div><div class="line">    <a class="code" href="classDGtal_1_1PointVector.html">RealVector</a> n = it-&gt;second.vcmNormal; <span class="comment">// gets the estimated VCM normal vector</span></div><div class="line">  }</div></div><!-- fragment --><div class="image">
<img src="dvcm-3d-hat-r.png" alt="dvcm-3d-hat-r.png"/>
<div class="caption">
Normal vector and feature detection with Voronoi Covariance Measure.</div></div>
<h2><a class="anchor" id="moduleVCM_sec3_2"></a>
The class VCMDigitalSurfaceLocalEstimator</h2>
<p>The class <a class="el" href="classDGtal_1_1VCMDigitalSurfaceLocalEstimator.html" title="Aim: This class adapts a VoronoiCovarianceMeasureOnDigitalSurface to be a model of CDigitalSurfaceLoc...">VCMDigitalSurfaceLocalEstimator</a> adapts a <a class="el" href="classDGtal_1_1VoronoiCovarianceMeasureOnDigitalSurface.html" title="Aim: This class specializes the Voronoi covariance measure for digital surfaces. It adds notably the ...">VoronoiCovarianceMeasureOnDigitalSurface</a> to be a model of <a class="el" href="structDGtal_1_1concepts_1_1CDigitalSurfaceLocalEstimator.html" title="Aim: This concept describes an object that can process a range over some generic digital surface so a...">concepts::CDigitalSurfaceLocalEstimator</a>. It uses the <b>Voronoi</b> <b>Covariance</b> <b><a class="el" href="classDGtal_1_1Measure.html" title="Aim: Implements a simple measure computation (in the Lesbegue sens) of a set. In dimension 2...">Measure</a></b> to estimate geometric quantities. The template type <b>TVCMGeometricFunctor</b> specifies what is the estimated quantity. Standard geometric functors for VCM are defined in file <a class="el" href="VCMGeometricFunctors_8h_source.html">DGtal/geometry/surfaces/estimation/VCMGeometricFunctors.h</a>. For instance, <a class="el" href="structDGtal_1_1functors_1_1VCMNormalVectorFunctor.html" title="Aim: A functor Surfel -&gt; Quantity that returns the outer normal vector at given surfel. ">functors::VCMNormalVectorFunctor</a> returns the estimated VCM surface <b>outward</b> normal for given surfels, <a class="el" href="structDGtal_1_1functors_1_1VCMAbsoluteCurvatureFunctor.html" title="Aim: A functor Surfel -&gt; Quantity that returns the absolute curvature at given surfel. This class has meaning only in 2D. ">functors::VCMAbsoluteCurvatureFunctor</a> returns the absolute curvature (see namespace functors:: and those functors starting with VCM).</p>
<p>In order to fulfill concept requirements, a <a class="el" href="classDGtal_1_1VCMDigitalSurfaceLocalEstimator.html" title="Aim: This class adapts a VoronoiCovarianceMeasureOnDigitalSurface to be a model of CDigitalSurfaceLoc...">VCMDigitalSurfaceLocalEstimator</a> can be instantiated in several ways:</p>
<ul>
<li>it can be <b>default</b> <b>constructed</b>. In this case, the object is not valid and further methods must be called (first <a class="el" href="classDGtal_1_1VCMDigitalSurfaceLocalEstimator.html#aeb402602983f3da62821a76dd2579bd9">VCMDigitalSurfaceLocalEstimator::attach</a> to attach a digital surface to the estimator, then <a class="el" href="classDGtal_1_1VCMDigitalSurfaceLocalEstimator.html#a9848e10e5a530f371d25e28a49c40b58">VCMDigitalSurfaceLocalEstimator::setParams</a> to specify all required parameters in the VCM) before calling <a class="el" href="classDGtal_1_1VCMDigitalSurfaceLocalEstimator.html#ae5bc2aef3a43da2a719472cea7a7b852">VCMDigitalSurfaceLocalEstimator::init</a>.</li>
<li>it can be <b>copy</b> <b>constructed</b>. In this case, the object is valid or invalid depending on the cloned object. Further methods may be called afterwards like <a class="el" href="classDGtal_1_1VCMDigitalSurfaceLocalEstimator.html#aeb402602983f3da62821a76dd2579bd9">VCMDigitalSurfaceLocalEstimator::attach</a> or <a class="el" href="classDGtal_1_1VCMDigitalSurfaceLocalEstimator.html#a9848e10e5a530f371d25e28a49c40b58">VCMDigitalSurfaceLocalEstimator::setParams</a>.</li>
<li>it can be <b>constructed</b> <b>from</b> <b>a</b> <b>surface</b>. In this case, the object is still invalid. You have to call <a class="el" href="classDGtal_1_1VCMDigitalSurfaceLocalEstimator.html#a9848e10e5a530f371d25e28a49c40b58">VCMDigitalSurfaceLocalEstimator::setParams</a> to specify all required parameters in the VCM before calling <a class="el" href="classDGtal_1_1VCMDigitalSurfaceLocalEstimator.html#ae5bc2aef3a43da2a719472cea7a7b852">VCMDigitalSurfaceLocalEstimator::init</a>.</li>
<li>it can be <b>constructed</b> <b>from</b> <b>a</b> <b><a class="el" href="classDGtal_1_1VoronoiCovarianceMeasureOnDigitalSurface.html" title="Aim: This class specializes the Voronoi covariance measure for digital surfaces. It adds notably the ...">VoronoiCovarianceMeasureOnDigitalSurface</a></b> <b>object</b>. In this case, the object is directly valid. You may call <a class="el" href="classDGtal_1_1VCMDigitalSurfaceLocalEstimator.html#ae5bc2aef3a43da2a719472cea7a7b852">VCMDigitalSurfaceLocalEstimator::init</a> directly.</li>
</ul>
<p>Once a <a class="el" href="classDGtal_1_1VCMDigitalSurfaceLocalEstimator.html" title="Aim: This class adapts a VoronoiCovarianceMeasureOnDigitalSurface to be a model of CDigitalSurfaceLoc...">VCMDigitalSurfaceLocalEstimator</a> is instantiated, you have to call its <em>init</em> method like all estimators (<a class="el" href="classDGtal_1_1VCMDigitalSurfaceLocalEstimator.html#ae5bc2aef3a43da2a719472cea7a7b852">VCMDigitalSurfaceLocalEstimator::init</a>). Note that for the VCM this method does nothing (except checking that the object is valid). Indeed, the VCM is necessarily computed for the whole surface, since it depends on a global distance transform.</p>
<dl class="section note"><dt>Note</dt><dd>The digital surface and the VCM on this surface are referenced in the estimator by <b>smart</b> <b>pointers</b>. While this avoids duplication, it also allows you to have duplication on demand if you handle a <a class="el" href="classDGtal_1_1CountedPtr.html" title="Aim: Smart pointer based on reference counts. ">CountedPtr</a> either at instantiation or when calling <a class="el" href="classDGtal_1_1VCMDigitalSurfaceLocalEstimator.html#aeb402602983f3da62821a76dd2579bd9">VCMDigitalSurfaceLocalEstimator::attach</a> or <a class="el" href="classDGtal_1_1VCMDigitalSurfaceLocalEstimator.html#a9848e10e5a530f371d25e28a49c40b58">VCMDigitalSurfaceLocalEstimator::setParams</a>.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> VCMDigitalSurfaceNormalEstimator&lt;SurfaceContainer,Metric,KernelFunction&gt; VCMNormalEstimator;</div><div class="line"><span class="keyword">typedef</span> functors::VCMNormalVectorFunctor&lt;VCMOnSurface&gt; NormalVectorFunctor;</div><div class="line"><span class="keyword">typedef</span> VCMDigitalSurfaceLocalEstimator&lt;SurfaceContainer,Metric,</div><div class="line">                                        KernelFunction, NormalVectorFunctor&gt; VCMNormalEstimator;</div><div class="line">CountedConstPtrOrConstPtr&lt;Surface&gt; ptrSurface( <span class="keyword">new</span> Surface( surfaceContainer ) ); <span class="comment">// acquired</span></div><div class="line">KernelFunction chi( 1.0, 7.0 );</div><div class="line">CountedPtr&lt;VCMOnSurface&gt; vcm_surface( <span class="keyword">new</span> VCMOnSurface( ptrSurface, <a class="code" href="namespaceDGtal.html#aaad242ffef715835e8928579a506b2d5ac0a8bc5774ff6530ee71a7cacd6ca6f4">Pointels</a>, </div><div class="line">                                      15.0, 7.0, chi, 7.0, l2, <span class="keyword">true</span> ) ); <span class="comment">// avoid duplications</span></div><div class="line">VCMNormalEstimator estimator( vcm_surface );</div><div class="line">estimator.init( 1.0, ptrSurface-&gt;begin(), ptrSurface-&gt;end() );</div><div class="line"><span class="keywordflow">for</span> ( <span class="keyword">typename</span> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">Surface::ConstIterator</a> it = ptrSurface-&gt;begin(), </div><div class="line">        itE = ptrSurface-&gt;end(); it != itE; ++it )</div><div class="line">  {</div><div class="line">    <a class="code" href="classDGtal_1_1PointVector.html">RealVector</a> n_est  = estimator.eval( it );</div><div class="line">  }</div></div><!-- fragment --><p>Example <a class="el" href="dvcm-2d-curvature_8cpp_source.html">geometry/surfaces/dvcm-2d-curvature.cpp</a> shows how to extract the curvature field (in absolute value) of a digital contour with <a class="el" href="classDGtal_1_1VCMDigitalSurfaceLocalEstimator.html" title="Aim: This class adapts a VoronoiCovarianceMeasureOnDigitalSurface to be a model of CDigitalSurfaceLoc...">VCMDigitalSurfaceLocalEstimator</a> templated by functor <a class="el" href="structDGtal_1_1functors_1_1VCMAbsoluteCurvatureFunctor.html" title="Aim: A functor Surfel -&gt; Quantity that returns the absolute curvature at given surfel. This class has meaning only in 2D. ">functors::VCMAbsoluteCurvatureFunctor</a>.</p>
<div class="image">
<img src="dvcm-curvature.png" alt="dvcm-curvature.png"/>
<div class="caption">
Absolute curvature estimation with Voronoi Covariance Measure.</div></div>
 </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Mar 18 2018 09:40:34 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
