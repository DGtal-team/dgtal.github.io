<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DGtal: Decomposition of 2D digital curves</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DGtal&#160;<span id="projectnumber">0.3.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Decomposition of 2D digital curves </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><dl class="author"><dt><b>Author:</b></dt><dd>Tristan Roussillon</dd></dl>
<p>This part of the manual describes how to decompose a digital curve into geometric primitives such as digital straight segments (DSS for short), thick segments, convex and concave parts, digital circular arcs, etc.</p>
<ol type="1">
<li><a class="el" href="geometry2d.html#geometryIntro">Bacis concepts : sequences and segments.</a></li>
<li><a class="el" href="geometry2d.html#geometrySegments">Detection of segments.</a></li>
<li><a class="el" href="geometry2d.html#geometryDecompositions">Decompositions into segments.</a><ol type="a">
<li><a class="el" href="geometry2d.html#geometryGreedyDecomposition">Greedy decomposition</a></li>
<li><a class="el" href="geometry2d.html#geometryUniqueDecomposition">Unique decomposition into maximal segments.</a></li>
</ol>
</li>
</ol>
<h2><a class="anchor" id="geometryIntro"></a>
Bacis concepts : sequences and segments.</h2>
<p>The 2d geometry kernel of <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> can decompose any given digital curve in a very generic framework. Indeed, the more abstract concept of <em>sequence of elements</em> replaces the one of digital curve. Note that we use the terme sequence because the order matters. Elements are abstract objects. They can be points of course, but also more sophisticated geometric objects such as straight line segments, squares, etc. They can also be letters (as in the Freeman representation of a connected digital curve) or any other user-defined object. What is requiered is that the sequence provides an <em>iterator</em> that can be used to access to the elements in order.</p>
<p>In a geometric framework, the sequence may be defined as a STL vector of 2D points as follow:</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">typedef</span> PointVector&lt;2,int&gt; <a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>;               <span class="comment">//element type</span>
 <span class="keyword">typedef</span> std::vector&lt;Point&gt; DigitalCurve;        <span class="comment">//sequence type</span>
 <span class="keyword">typedef</span> DigitalCurve::iterator Iterator;        <span class="comment">//iterator type</span>
</pre></div><p>In a word combinatorics framework, the sequence may be defined as a STL string as follow:</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">typedef</span> std::string Word;                   <span class="comment">//sequence type</span>
 <span class="keyword">typedef</span> Word::iterator Iterator;            <span class="comment">//iterator type</span>
</pre></div><p>A primitive is usually defined as a specific digital object. In order to recall that we only focus on parts of digital curves (viewed as sequences of elements), the term <em>segment</em> is used instead of primitive. More precisely, a segment is a subsequence having a given property, which can be built from conjunctions and disjunctions of other properties. However, the resulting property has to be true for any subsequence of any segment. For instance, the properties "to be a 4-connected DSS" or "to be a balanced word" can define a segment, but "to contain at least k elements (k &gt; 1)" cannot define a segment because it does not hold for subsequences of strictly less than k elements.</p>
<h2><a class="anchor" id="geometrySegments"></a>
Detection of segments.</h2>
<p>Since the goal is to decompose a sequence into segments, we focus on their detection along the sequence. Detection algorithms should verify the concept CSegmentComputer. A CSegmentComputer model should define the following inner type:</p>
<ul>
<li>Iterator: the sequence iterator.</li>
</ul>
<p>In addition to the default and copy constructors, it should also define the following methods :</p>
<ul>
<li>void init ( const Iterator&amp; it ) : initialise the algorithm from one element.</li>
<li>bool extend ( const Iterator&amp; it ) : extend the current segment to the next element and return TRUE if it is possible.</li>
</ul>
<p>The detection is incremental. A segment is initialised at a starting point and then can be extended to the next point if the property still holds.</p>
<p>A model of CSegmentComputer is the class <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>, devoted to the dynamic recognition of DSSs, defined as a sequence of connected points (x,y) such that <img class="formulaInl" alt="$ \mu \leq ax - by < \mu + \omega $" src="form_37.png"/> (see Debled and Reveilles, 1995).</p>
<p>Here is a short example of how to use this class in the 8-connected case: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">typedef</span> PointVector&lt;2,int&gt; <a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>;               <span class="comment">//element type</span>
 <span class="keyword">typedef</span> std::vector&lt;Point&gt; DigitalCurve;        <span class="comment">//sequence type</span>
 <span class="keyword">typedef</span> DigitalCurve::iterator Iterator;        <span class="comment">//iterator type</span>
 <span class="keyword">typedef</span> ArithmeticalDSS&lt;Iterator, int, 8&gt; DSS8; <span class="comment">//segment computer type</span>

 DigitalCurve contour;                           <span class="comment">//instance of sequence </span>
 contour.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(0,0));                  <span class="comment">//input elements</span>
 contour.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(1,1));
 contour.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(2,1));
 contour.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(3,2));
 contour.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(4,2));
 contour.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(5,2));
 contour.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(6,3));

 <span class="comment">// Add points while it is possible</span>
 Iterator i = contour.<a class="code" href="classDGtal_1_1PointVector.html#a0f725f0c46d21618b00c5113858951c7">begin</a>();
 DSS8 theDSS8;                                   <span class="comment">//instance of the segment computer</span>
 theDSS8.init(i);                                <span class="comment">//initialisation</span>
 <span class="keywordflow">do</span> { i++; } <span class="keywordflow">while</span> ( (i!=contour.end())  
                   &amp;&amp;(theDSS8.extend(i)) );      <span class="comment">//extension of the segment</span>
</pre></div><p>Here is a short example of how to use this class in the 4-connected case: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">typedef</span> PointVector&lt;2,int&gt; <a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>;               <span class="comment">//element type</span>
 <span class="keyword">typedef</span> std::vector&lt;Point&gt; DigitalCurve;        <span class="comment">//sequence type</span>
 <span class="keyword">typedef</span> DigitalCurve::iterator Iterator;        <span class="comment">//iterator type</span>
 <span class="keyword">typedef</span> ArithmeticalDSS&lt;Iterator, int, 4&gt; DSS4; <span class="comment">//segment computer type</span>

 DigitalCurve contour;                           <span class="comment">//instance of sequence </span>
 contour.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(0,0));                  <span class="comment">//input elements</span>
 contour.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(1,0));
 contour.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(1,1));
 contour.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(2,1));
 contour.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(3,1));
 contour.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(3,2));
 contour.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(4,2));
 contour.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(5,2));
 contour.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(6,2));
 contour.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(6,3));

 <span class="comment">// Add points while it is possible</span>
 Iterator i = contour.<a class="code" href="classDGtal_1_1PointVector.html#a0f725f0c46d21618b00c5113858951c7">begin</a>();
 DSS4 theDSS4;                                   <span class="comment">//instance of the segment computer</span>
 theDSS4.init(i);                                <span class="comment">//initialisation</span>
 <span class="keywordflow">do</span> { i++; } <span class="keywordflow">while</span> ( (i!=contour.end())  
                   &amp;&amp;(theDSS4.extend(i)) );      <span class="comment">//extension of the segment</span>
</pre></div><p>The resulting DSSs of the two previous pieces of code are drawing below:</p>
<table class="doxtable">
<tr>
<td><div align="center">
<img src="DSS8.png" alt="DSS8.png"/>
<p><strong>8-connected DSS drawn with the paving mode</strong></p></div>
   </td><td><div align="center">
<img src="DSS4.png" alt="DSS4.png"/>
<p><strong>4-connected DSS drawn with the grid mode</strong></p></div>
    </td></tr>
</table>
<p>See file examples/geometry/ArithmeticalDSS.cpp for the whole code and see <a class="el" href="dgtalboard_8dox.html">dgtalboard.dox</a> for the drawing mechanism.</p>
<h2><a class="anchor" id="geometryDecompositions"></a>
Decompositions into segments.</h2>
<p>A given sequence contains a finite set of segments. A <em>decomposition</em> is a subset of the whole set of segments, such that no segment contains another segment of the subset. By definition, the segments of a decomposition can be ordered (according to the position of their first element for instance).</p>
<p>Decomposition algorithms should verify the concept CDecomposition. A CDecomposition model should define the following inner type:</p>
<ul>
<li>SegmentIterator</li>
</ul>
<p>It should also define a constructor taking as input parameters:</p>
<ul>
<li>begin/end iterators of the sequence.</li>
<li>an instance of a segment computer.</li>
<li>a boolean equal to TRUE if the sequence has to be processed as a circular one.</li>
</ul>
<h3><a class="anchor" id="geometryGreedyDecomposition"></a>
Greedy decomposition</h3>
<p>The first and simplest decomposition is the greedy one: from a starting point, extend a segment while it is possible, get the last point of the resulting segment (or the next point) and iterate. This decomposition is implemented in the class <a class="el" href="classDGtal_1_1GreedyDecomposition.html" title="Aim: Computes the greedy decomposition of a sequence into segments (the last element of a given segme...">GreedyDecomposition</a>.</p>
<p>In the short example below, a digital curve stored in a STL vector is segmented into 8-connected DSSs whose parameters are sent to the standard output. </p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> PointVector&lt;2,int&gt; <a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>;               <span class="comment">//element type</span>
<span class="keyword">typedef</span> std::vector&lt;Point&gt; DigitalCurve;        <span class="comment">//sequence type</span>
<span class="keyword">typedef</span> DigitalCurve::iterator Iterator;        <span class="comment">//iterator type</span>
<span class="keyword">typedef</span> ArithmeticalDSS&lt;Iterator, int, 8&gt; DSS;  <span class="comment">//segment computer type</span>
<span class="keyword">typedef</span> GreedyDecomposition&lt;DSS&gt; Decomposition; <span class="comment">//decomposition type</span>

DigitalCurve curve;                             <span class="comment">//instance of a sequence</span>
curve.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(1,1));                    <span class="comment">//input elements</span>
curve.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(2,1));
curve.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(3,2));
curve.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(4,2));
curve.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(5,2));
curve.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(6,2));
curve.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(7,2));
curve.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(8,1));
curve.push_back(<a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Point</a>(9,1));

DSS dssRecognition;                             <span class="comment">//instance of segment computer</span>
Decomposition theDecomposition(
        curve.begin(), curve.end(), 
        dssRecognition, <span class="keyword">false</span>);                 <span class="comment">//instance of decomposition</span>
                                 
Decomposition::ConstIterator i = theDecomposition.<a class="code" href="classDGtal_1_1PointVector.html#a0f725f0c46d21618b00c5113858951c7">begin</a>();
<span class="keywordflow">for</span> ( ; i != theDecomposition.end(); ++i) {     <span class="comment">//iterate on the segments</span>
        DSS currentSegment(*i);
        <a class="code" href="namespaceDGtal.html#a12ec1f42a02c105edd4796c98926fc9e">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a269e1bb274603546481b9d0413470bd4">info</a>() &lt;&lt; currentSegment &lt;&lt; std::endl;    <span class="comment">//standard output</span>
} 
</pre></div><p>If you want to get the segmentation of the digital curve when it is scanned in the reverse way, you can use the reverse iterator of the STL vector: </p>
<div class="fragment"><pre class="fragment">...
typedef Sequence::reverse_iterator Iterator;  <span class="comment">//iterator type</span>
...
Decomposition theDecomposition(
        curve.rbegin(), curve.rend(), 
        dssRecognition, <span class="keyword">false</span>);               <span class="comment">//instance of decomposition</span>
...
</pre></div><p>The resulting segmentations are shown in the figures below:</p>
<table class="doxtable">
<tr>
<td><div align="center">
<img src="left_right.png" alt="left_right.png"/>
<p><strong>segmented from left to right</strong></p></div>
   </td><td><div align="center">
<img src="right_left.png" alt="right_left.png"/>
<p><strong>segmented from right to left</strong></p></div>
    </td></tr>
</table>
<p>See file examples/geometry/greedy-dss-decomposition.cpp for another example using the class <a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a>.</p>
<h3><a class="anchor" id="geometryUniqueDecomposition"></a>
Unique decomposition into maximal segments.</h3>
<p>A unique and richer decomposition is the set of <em>maximal segments</em> (a maximal segment is a segment that cannot be contained in a greater segment). This decomposition is implemented in the class <a class="el" href="classDGtal_1_1MaximalSegments.html" title="Aim: Computes the set of maximal segments of a sequence. Maximal segments are segments that cannot be...">MaximalSegments</a>.</p>
<p>In the previous decomposition code, instead of the line: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> GreedyDecomposition&lt;DSS&gt; Decomposition; <span class="comment">//decomposition type</span>
</pre></div><p> it is enough to write the following line: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> MaximalSegments&lt;DSS&gt; Decomposition; <span class="comment">//decomposition type</span>
</pre></div><p> to get the following figure: </p>
<div align="center">
<img src="maxseg.png" alt="maxseg.png"/>
<p><strong>maximal segments</strong></p></div>
 <p>Note that a same digital curve can be processed as open or closed as illustrated below:</p>
<table class="doxtable">
<tr>
<td><div align="center">
<img src="ClosedCurveProcessedAsOpen.png" alt="ClosedCurveProcessedAsOpen.png"/>
<p><strong>processed as open</strong></p></div>
   </td><td><div align="center">
<img src="ClosedCurveProcessedAsClosed.png" alt="ClosedCurveProcessedAsClosed.png"/>
<p><strong>processed as closed</strong></p></div>
    </td></tr>
</table>
<p>When an open digital curve (the first and last points are not connected) is processed as a closed one, it is merely processed as a closed but disconnected curve just as any other disconnected curve. As shown below, two consecutive maximal segments may not intersect.</p>
<div align="center">
<img src="DisconnectedCurveDecomposition.png" alt="DisconnectedCurveDecomposition.png"/>
<p><strong>Decomposition of a disconnected curve into maximal 4-connected DSSs</strong></p></div>
 <p>TODO brief description of the implementation</p>
<p>See file examples/geometry/convex-and-concave-parts.cpp for an example of how to use maximal DSSs to decompose a digital curve into convex and concave parts. </p>
</div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2011 09:16:40 for DGtal by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
