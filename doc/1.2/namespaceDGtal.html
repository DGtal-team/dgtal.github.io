<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: DGtal Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">DGtal Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code><a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a></code> is the top-level namespace which contains all <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> functions and types.  
<a href="namespaceDGtal.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceDGtal_1_1concepts"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1concepts.html">concepts</a></td></tr>
<tr class="memdesc:namespaceDGtal_1_1concepts"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Gathers several functions useful for concept checks. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceDGtal_1_1dec__helper"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1dec__helper.html">dec_helper</a></td></tr>
<tr class="memdesc:namespaceDGtal_1_1dec__helper"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for functions useful to Discrete Exterior Calculus package. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceDGtal_1_1deprecated"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1deprecated.html">deprecated</a></td></tr>
<tr class="memdesc:namespaceDGtal_1_1deprecated"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>Deprecated</code> functions and types of the <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceDGtal_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespaceDGtal_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>detail</code> namespace gathers internal classes and functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceDGtal_1_1details"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1details.html">details</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceDGtal_1_1experimental"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1experimental.html">experimental</a></td></tr>
<tr class="memdesc:namespaceDGtal_1_1experimental"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>Experimental</code> functions and types of the <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceDGtal_1_1functions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html">functions</a></td></tr>
<tr class="memdesc:namespaceDGtal_1_1functions"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>functions</code> namespace gathers all <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> functionsxs. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceDGtal_1_1functors"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors.html">functors</a></td></tr>
<tr class="memdesc:namespaceDGtal_1_1functors"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>functors</code> namespace gathers all <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> functors. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceDGtal_1_1Z2i"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1Z2i.html">Z2i</a></td></tr>
<tr class="memdesc:namespaceDGtal_1_1Z2i"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="namespaceDGtal_1_1Z2i.html" title="Z2i this namespace gathers the standard of types for 2D imagery.">Z2i</a></code> this namespace gathers the standard of types for 2D imagery. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceDGtal_1_1Z3i"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1Z3i.html">Z3i</a></td></tr>
<tr class="memdesc:namespaceDGtal_1_1Z3i"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="namespaceDGtal_1_1Z3i.html" title="Z3i this namespace gathers the standard of types for 3D imagery.">Z3i</a></code> this namespace gathers the standard of types for 3D imagery. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ClosedIntegerHalfPlane.html">ClosedIntegerHalfPlane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A half-space specified by a vector N and a constant c. The half-space is the set \( \{ P \in Z^2, N.P \le c \} \).  <a href="structDGtal_1_1ClosedIntegerHalfPlane.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IntegerComputer.html">IntegerComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class gathers several types and methods to make computation with integers.  <a href="classDGtal_1_1IntegerComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LatticePolytope2D.html">LatticePolytope2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a 2D polytope, i.e. a convex polygon, in the two-dimensional digital plane. The list of points must follow the <b>clockwise</b> ordering.  <a href="classDGtal_1_1LatticePolytope2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LighterSternBrocot.html">LighterSternBrocot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The Stern-Brocot tree is the tree of irreducible fractions. This class allows to construct it progressively and to navigate within fractions in O(1) time for most operations. It is well known that the structure of this tree is a coding of the continued fraction representation of fractions.  <a href="classDGtal_1_1LighterSternBrocot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LightSternBrocot.html">LightSternBrocot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The Stern-Brocot tree is the tree of irreducible fractions. This class allows to construct it progressively and to navigate within fractions in O(1) time for most operations. It is well known that the structure of this tree is a coding of the continued fraction representation of fractions.  <a href="classDGtal_1_1LightSternBrocot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ModuloComputer.html">ModuloComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implements basic functions on modular arithmetic.  <a href="classDGtal_1_1ModuloComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Pattern.html">Pattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class represents a pattern, i.e. the path between two consecutive upper leaning points on a digital straight line.  <a href="classDGtal_1_1Pattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1StandardDSLQ0.html">StandardDSLQ0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a digital straight line with slope in the first quadrant (Q0: x &gt;= 0, y &gt;= 0 ).  <a href="classDGtal_1_1StandardDSLQ0.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SternBrocot.html">SternBrocot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The Stern-Brocot tree is the tree of irreducible fractions. This class allows to construct it progressively and to navigate within fractions in O(1) time for most operations. It is well known that the structure of this tree is a coding of the continued fraction representation of fractions.  <a href="classDGtal_1_1SternBrocot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Alias.html">Alias</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class encapsulates its parameter class so that to indicate to the user that the object/pointer will be only aliased. Therefore the user is reminded that the argument parameter is given to the function without any additional cost and may be modified, while he is aware that the lifetime of the argument parameter must be at least as long as the object itself. Note that an instance of Alias&lt;T&gt; is itself a light object (it holds only an enum and a pointer).  <a href="classDGtal_1_1Alias.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1BackInsertionSequenceToStackAdapter.html">BackInsertionSequenceToStackAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class implements a dynamic adapter to an instance of a model of back insertion sequence in order to get a stack interface. This class is a model of CStack.  <a href="classDGtal_1_1BackInsertionSequenceToStackAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSinglePassIteratorArchetype.html">CSinglePassIteratorArchetype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An archetype of SingePassIterator.  <a href="structDGtal_1_1CSinglePassIteratorArchetype.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBidirectionalIteratorArchetype.html">CBidirectionalIteratorArchetype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An archetype of BidirectionalIterator.  <a href="structDGtal_1_1CBidirectionalIteratorArchetype.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CConstBidirectionalIteratorArchetype.html">CConstBidirectionalIteratorArchetype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An archetype of ConstBidirectionalIterator.  <a href="structDGtal_1_1CConstBidirectionalIteratorArchetype.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CForwardIteratorArchetype.html">CForwardIteratorArchetype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An archetype of ForwardIterator.  <a href="structDGtal_1_1CForwardIteratorArchetype.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Bits.html">Bits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Circulator.html">Circulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Provides an adapter for classical iterators that can iterate through the underlying data structure as in a loop. The increment (resp. decrement) operator encapsulates the validity test and the assignement to the begin (resp. end) iterator of a given range, when the end (resp. beginning) has been reached. For instance, the pre-increment operator does: <br  />
  <a href="classDGtal_1_1Circulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Clock.html">Clock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Clone.html">Clone</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class encapsulates its parameter class to indicate that the given parameter is required to be duplicated (generally, this is done to have a longer lifetime than the function itself). On one hand, the user is reminded of the possible cost of duplicating the argument parameter, while he is also aware that the lifetime of the parameter is not a problem for the function. On the other hand, the <a class="el" href="classDGtal_1_1Clone.html" title="Aim: This class encapsulates its parameter class to indicate that the given parameter is required to ...">Clone</a> class is smart enough to enforce duplication <b>only</b> <b>if</b> <b>needed</b>. Substantial speed-up can be achieve through this mechanism.  <a href="classDGtal_1_1Clone.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Display3D.html">Display3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like BallVector, <a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim: A container class for storing sets of digital points within some given domain.">DigitalSetBySTLSet</a>, <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> ...). The class <a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a> and <a class="el" href="classDGtal_1_1Board3DTo2D.html" title="Class for PDF, PNG, PS, EPS, SVG export drawings with Cairo with 3D-&gt;2D projection.">Board3DTo2D</a> implement two different ways to display 3D objects. The first one (<a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a>), permits an interactive visualisation (based on <em>OpenGL</em> ) and the second one (Board3dto2d) provides 3D visualisation from 2D vectorial display (based on the CAIRO library)  <a href="classDGtal_1_1Display3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Board3DTo2D.html">Board3DTo2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for PDF, PNG, PS, EPS, SVG export drawings with Cairo with 3D-&gt;2D projection.  <a href="classDGtal_1_1Board3DTo2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawableWithBoard3DTo2D.html">DrawableWithBoard3DTo2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawableWithDisplay3D.html">DrawableWithDisplay3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawableWithBoard2D.html">DrawableWithBoard2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TagFalse.html">TagFalse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TagTrue.html">TagTrue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TagUnknown.html">TagUnknown</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Negate.html">Negate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Negate_3_01TagTrue_01_4.html">Negate&lt; TagTrue &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Negate_3_01TagFalse_01_4.html">Negate&lt; TagFalse &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DummyObject.html">DummyObject</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ConstAlias.html">ConstAlias</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class encapsulates its parameter class so that to indicate to the user that the object/pointer will be only const aliased (and hence left unchanged). Therefore the <b>user</b> is reminded that the argument parameter is given to the function without any additional cost and may not be modified, while he is aware that the lifetime of the argument parameter must be at least as long as the object itself. Note that an instance of ConstAlias&lt;T&gt; is itself a light object (it holds only an enum and a pointer).  <a href="classDGtal_1_1ConstAlias.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ConstIteratorAdapter.html">ConstIteratorAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class adapts any iterator so that operator* returns another element than the one pointed to by the iterator.  <a href="classDGtal_1_1ConstIteratorAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ConstRangeAdapter.html">ConstRangeAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of CConstBidirectionalRange that adapts any range of elements bounded by two iterators [itb, ite) and provides services to (circularly)iterate over it (in a read-only manner).  <a href="classDGtal_1_1ConstRangeAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ConstRangeFromPointAdapter.html">ConstRangeFromPointAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of CConstBidirectionalRangeFromPoint that adapts any bidirectional range and provides services to iterate over it (in a read-only manner).  <a href="classDGtal_1_1ConstRangeFromPointAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NotContainerCategory.html">NotContainerCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ContainerCategory.html">ContainerCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SequenceCategory.html">SequenceCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1AssociativeCategory.html">AssociativeCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SimpleAssociativeCategory.html">SimpleAssociativeCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1PairAssociativeCategory.html">PairAssociativeCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UniqueAssociativeCategory.html">UniqueAssociativeCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1MultipleAssociativeCategory.html">MultipleAssociativeCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1OrderedAssociativeCategory.html">OrderedAssociativeCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedAssociativeCategory.html">UnorderedAssociativeCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SetAssociativeCategory.html">SetAssociativeCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1MultisetAssociativeCategory.html">MultisetAssociativeCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1MapAssociativeCategory.html">MapAssociativeCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1MultimapAssociativeCategory.html">MultimapAssociativeCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetAssociativeCategory.html">UnorderedSetAssociativeCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedMultisetAssociativeCategory.html">UnorderedMultisetAssociativeCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedMapAssociativeCategory.html">UnorderedMapAssociativeCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedMultimapAssociativeCategory.html">UnorderedMultimapAssociativeCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ContainerTraits.html">ContainerTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines default container traits for arbitrary types.  <a href="structDGtal_1_1ContainerTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ContainerTraits_3_01std_1_1vector_3_01T_00_01Alloc_01_4_01_4.html">ContainerTraits&lt; std::vector&lt; T, Alloc &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines container traits for std::vector&lt;&gt;.  <a href="structDGtal_1_1ContainerTraits_3_01std_1_1vector_3_01T_00_01Alloc_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ContainerTraits_3_01std_1_1list_3_01T_00_01Alloc_01_4_01_4.html">ContainerTraits&lt; std::list&lt; T, Alloc &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines container traits for std::list&lt;&gt;.  <a href="structDGtal_1_1ContainerTraits_3_01std_1_1list_3_01T_00_01Alloc_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ContainerTraits_3_01std_1_1deque_3_01T_00_01Alloc_01_4_01_4.html">ContainerTraits&lt; std::deque&lt; T, Alloc &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines container traits for std::deque&lt;&gt;.  <a href="structDGtal_1_1ContainerTraits_3_01std_1_1deque_3_01T_00_01Alloc_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ContainerTraits_3_01std_1_1forward__list_3_01T_00_01Alloc_01_4_01_4.html">ContainerTraits&lt; std::forward_list&lt; T, Alloc &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines container traits for std::forward_list&lt;&gt;.  <a href="structDGtal_1_1ContainerTraits_3_01std_1_1forward__list_3_01T_00_01Alloc_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ContainerTraits_3_01std_1_1array_3_01T_00_01N_01_4_01_4.html">ContainerTraits&lt; std::array&lt; T, N &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines container traits for std::array&lt;&gt;.  <a href="structDGtal_1_1ContainerTraits_3_01std_1_1array_3_01T_00_01N_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ContainerTraits_3_01std_1_1set_3_01T_00_01Compare_00_01Alloc_01_4_01_4.html">ContainerTraits&lt; std::set&lt; T, Compare, Alloc &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines container traits for std::set&lt;&gt;.  <a href="structDGtal_1_1ContainerTraits_3_01std_1_1set_3_01T_00_01Compare_00_01Alloc_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ContainerTraits_3_01std_1_1map_3_01Key_00_01T_00_01Compare_00_01Alloc_01_4_01_4.html">ContainerTraits&lt; std::map&lt; Key, T, Compare, Alloc &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines container traits for std::map&lt;&gt;.  <a href="structDGtal_1_1ContainerTraits_3_01std_1_1map_3_01Key_00_01T_00_01Compare_00_01Alloc_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ContainerTraits_3_01std_1_1multiset_3_01T_00_01Compare_00_01Alloc_01_4_01_4.html">ContainerTraits&lt; std::multiset&lt; T, Compare, Alloc &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines container traits for std::multiset&lt;&gt;.  <a href="structDGtal_1_1ContainerTraits_3_01std_1_1multiset_3_01T_00_01Compare_00_01Alloc_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ContainerTraits_3_01std_1_1multimap_3_01Key_00_01T_00_01Compare_00_01Alloc_01_4_01_4.html">ContainerTraits&lt; std::multimap&lt; Key, T, Compare, Alloc &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines container traits for std::multimap&lt;&gt;.  <a href="structDGtal_1_1ContainerTraits_3_01std_1_1multimap_3_01Key_00_01T_00_01Compare_00_01Alloc_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ContainerTraits_3_01boost_1_1unordered__set_3_01Value_00_01Hash_00_01Pred_00_01Alloc_01_4_01_4.html">ContainerTraits&lt; boost::unordered_set&lt; Value, Hash, Pred, Alloc &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines container traits for boost::unordered_set&lt;&gt;.  <a href="structDGtal_1_1ContainerTraits_3_01boost_1_1unordered__set_3_01Value_00_01Hash_00_01Pred_00_01Alloc_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ContainerTraits_3_01boost_1_1unordered__multiset_3_01Value_00_01Hash_00_01Pred_00_01Alloc_01_4_01_4.html">ContainerTraits&lt; boost::unordered_multiset&lt; Value, Hash, Pred, Alloc &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines container traits for boost::unordered_multiset&lt;&gt;.  <a href="structDGtal_1_1ContainerTraits_3_01boost_1_1unordered__multiset_3_01Value_00_01Hash_00_01Pred_00_01Alloc_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ContainerTraits_3_01boost_1_1unordered__map_3_01Value_00_01T_00_01Hash_00_01Pred_00_01Alloc_01_4_01_4.html">ContainerTraits&lt; boost::unordered_map&lt; Value, T, Hash, Pred, Alloc &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines container traits for boost::unordered_map&lt;&gt;.  <a href="structDGtal_1_1ContainerTraits_3_01boost_1_1unordered__map_3_01Value_00_01T_00_01Hash_00_01Pred_00_01Alloc_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ContainerTraits_3_01boost_1_1unordered__multimap_3_01Value_00_01T_00_01Hash_00_01Pred_00_01Alloc_01_4_01_4.html">ContainerTraits&lt; boost::unordered_multimap&lt; Value, T, Hash, Pred, Alloc &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines container traits for boost::unordered_multimap&lt;&gt;.  <a href="structDGtal_1_1ContainerTraits_3_01boost_1_1unordered__multimap_3_01Value_00_01T_00_01Hash_00_01Pred_00_01Alloc_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ContainerTraits_3_01std_1_1unordered__set_3_01Key_00_01Hash_00_01Pred_00_01Alloc_01_4_01_4.html">ContainerTraits&lt; std::unordered_set&lt; Key, Hash, Pred, Alloc &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines container traits for std::unordered_set&lt;&gt;.  <a href="structDGtal_1_1ContainerTraits_3_01std_1_1unordered__set_3_01Key_00_01Hash_00_01Pred_00_01Alloc_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ContainerTraits_3_01std_1_1unordered__multiset_3_01Key_00_01Hash_00_01Pred_00_01Alloc_01_4_01_4.html">ContainerTraits&lt; std::unordered_multiset&lt; Key, Hash, Pred, Alloc &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines container traits for std::unordered_multiset&lt;&gt;.  <a href="structDGtal_1_1ContainerTraits_3_01std_1_1unordered__multiset_3_01Key_00_01Hash_00_01Pred_00_01Alloc_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ContainerTraits_3_01std_1_1unordered__map_3_01Key_00_01T_00_01Hash_00_01Pred_00_01Alloc_01_4_01_4.html">ContainerTraits&lt; std::unordered_map&lt; Key, T, Hash, Pred, Alloc &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines container traits for std::unordered_map&lt;&gt;.  <a href="structDGtal_1_1ContainerTraits_3_01std_1_1unordered__map_3_01Key_00_01T_00_01Hash_00_01Pred_00_01Alloc_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ContainerTraits_3_01std_1_1unordered__multimap_3_01Key_00_01T_00_01Hash_00_01Pred_00_01Alloc_01_4_01_4.html">ContainerTraits&lt; std::unordered_multimap&lt; Key, T, Hash, Pred, Alloc &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines container traits for std::unordered_multimap&lt;&gt;.  <a href="structDGtal_1_1ContainerTraits_3_01std_1_1unordered__multimap_3_01Key_00_01T_00_01Hash_00_01Pred_00_01Alloc_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsContainer.html">IsContainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsSequenceContainer.html">IsSequenceContainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsAssociativeContainer.html">IsAssociativeContainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsOrderedAssociativeContainer.html">IsOrderedAssociativeContainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsUnorderedAssociativeContainer.html">IsUnorderedAssociativeContainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsSimpleAssociativeContainer.html">IsSimpleAssociativeContainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsPairAssociativeContainer.html">IsPairAssociativeContainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsUniqueAssociativeContainer.html">IsUniqueAssociativeContainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsMultipleAssociativeContainer.html">IsMultipleAssociativeContainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CountedConstPtrOrConstPtr.html">CountedConstPtrOrConstPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Smart or simple const pointer on <code>T</code>. It can be a smart pointer based on reference counts or a simple pointer on <em>T</em> depending either on a boolean value given at construction or on the constructor used. In the first case, we will call this pointer object <b>smart</b>, otherwise we will call it <b>simple</b>.  <a href="classDGtal_1_1CountedConstPtrOrConstPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CountedPtrOrPtr.html">CountedPtrOrPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Smart or simple pointer on <em>T</em>. It can be a smart pointer based on reference counts or a simple pointer on <em>T</em> depending either on a boolean value given at construction or on the constructor used. In the first case, we will call this pointer object <b>smart</b>, otherwise we will call it <b>simple</b>.  <a href="classDGtal_1_1CountedPtrOrPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CountedPtr.html">CountedPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Smart pointer based on reference counts.  <a href="classDGtal_1_1CountedPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CowPtr.html">CowPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Copy on write shared pointer.  <a href="classDGtal_1_1CowPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IOException.html">IOException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1InputException.html">InputException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ConnectivityException.html">ConnectivityException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MemoryException.html">MemoryException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1InfiniteNumberException.html">InfiniteNumberException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1POW.html">POW</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1POW_3_01X_00_011_01_4.html">POW&lt; X, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1POW_3_01X_00_010_01_4.html">POW&lt; X, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LOG2.html">LOG2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LOG2_3_012_01_4.html">LOG2&lt; 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LOG2_3_011_01_4.html">LOG2&lt; 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1FrontInsertionSequenceToStackAdapter.html">FrontInsertionSequenceToStackAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class implements a dynamic adapter to an instance of a model of front insertion sequence in order to get a stack interface. This class is a model of CStack.  <a href="classDGtal_1_1FrontInsertionSequenceToStackAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IndexedListWithBlocks.html">IndexedListWithBlocks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a mixed list/array structure which is useful in some context. It is essentially a list of blocks.  <a href="classDGtal_1_1IndexedListWithBlocks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1InputIteratorWithRankOnSequence.html">InputIteratorWithRankOnSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Useful to create an iterator that returns a pair (value,rank) when visiting a sequence. The sequence is smartly copied within the iterator. Hence, the given sequence need not to persist during the visit. Since it is only an input sequence, it is not necessary to give a valid sequence when creating the end() iterator.  <a href="classDGtal_1_1InputIteratorWithRankOnSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IntegerSequenceIterator.html">IntegerSequenceIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: It is a simple class that mimics a (non mutable) iterator over integers. You can increment it, decrement it, displace it, compare it, etc. It is useful if you have a collection of consecutive integers, and you wish to create an iterator over it. It is used in the class <a class="el" href="classDGtal_1_1TriangulatedSurface.html" title="Aim: Represents a triangulated surface. The topology is stored with a half-edge data structure....">TriangulatedSurface</a> for example, since vertices are numbers from 0 to nbVertices - 1.  <a href="classDGtal_1_1IntegerSequenceIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IteratorAdapter.html">IteratorAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class adapts any lvalue iterator so that operator* returns a member on the element pointed to by the iterator, instead the element itself.  <a href="classDGtal_1_1IteratorAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ForwardCategory.html">ForwardCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1BidirectionalCategory.html">BidirectionalCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1RandomAccessCategory.html">RandomAccessCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsCirculator.html">IsCirculator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Checks whether type <em>IC</em> is a circular or a classical iterator. Static value set to 'true' for a circulator, 'false' otherwise. <br  />
  <a href="structDGtal_1_1IsCirculator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorType.html">IteratorCirculatorType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Provides the type of <em>IC</em> as a nested type: either <a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a> or <a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>.  <a href="structDGtal_1_1IteratorCirculatorType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ToDGtalCategory.html">ToDGtalCategory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Provides the <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> category matching <em>C</em> <br  />
 {<a class="el" href="structDGtal_1_1ForwardCategory.html">ForwardCategory</a>,<a class="el" href="structDGtal_1_1BidirectionalCategory.html">BidirectionalCategory</a>,<a class="el" href="structDGtal_1_1RandomAccessCategory.html">RandomAccessCategory</a>}.  <a href="structDGtal_1_1ToDGtalCategory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ToDGtalCategory_3_01std_1_1forward__iterator__tag_01_4.html">ToDGtalCategory&lt; std::forward_iterator_tag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ToDGtalCategory_3_01std_1_1bidirectional__iterator__tag_01_4.html">ToDGtalCategory&lt; std::bidirectional_iterator_tag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ToDGtalCategory_3_01std_1_1random__access__iterator__tag_01_4.html">ToDGtalCategory&lt; std::random_access_iterator_tag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ToDGtalCategory_3_01boost_1_1forward__traversal__tag_01_4.html">ToDGtalCategory&lt; boost::forward_traversal_tag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ToDGtalCategory_3_01boost_1_1bidirectional__traversal__tag_01_4.html">ToDGtalCategory&lt; boost::bidirectional_traversal_tag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ToDGtalCategory_3_01boost_1_1random__access__traversal__tag_01_4.html">ToDGtalCategory&lt; boost::random_access_traversal_tag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ToDGtalCategory_3_01boost_1_1iterators_1_1detail_1_1iterator__category__with__tra1420f29943a047e87f8a1879f4727e46.html">ToDGtalCategory&lt; boost::iterators::detail::iterator_category_with_traversal&lt; std::input_iterator_tag, boost::forward_traversal_tag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ToDGtalCategory_3_01boost_1_1iterators_1_1detail_1_1iterator__category__with__tra5f13519ab9c7b4373448083983b5e2c4.html">ToDGtalCategory&lt; boost::iterators::detail::iterator_category_with_traversal&lt; std::input_iterator_tag, boost::bidirectional_traversal_tag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ToDGtalCategory_3_01boost_1_1iterators_1_1detail_1_1iterator__category__with__trae914f9a0929cf720e4391e298ea12c0c.html">ToDGtalCategory&lt; boost::iterators::detail::iterator_category_with_traversal&lt; std::input_iterator_tag, boost::random_access_traversal_tag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTraits.html">IteratorCirculatorTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Provides nested types for both iterators and circulators: <br  />
 Type, Category, Value, Difference, Pointer and Reference.  <a href="structDGtal_1_1IteratorCirculatorTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTraits_3_01T_01_5_01_4.html">IteratorCirculatorTraits&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTraits_3_01T_01const_01_5_01_4.html">IteratorCirculatorTraits&lt; T const * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IteratorCompletionTraits.html">IteratorCompletionTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Traits that must be specialized for each <a class="el" href="classDGtal_1_1IteratorCompletion.html" title="Aim: Class that uses CRTP to add reverse iterators and ranges to a derived class.">IteratorCompletion</a> derived class.  <a href="classDGtal_1_1IteratorCompletionTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IteratorCompletion.html">IteratorCompletion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class that uses CRTP to add reverse iterators and ranges to a derived class.  <a href="classDGtal_1_1IteratorCompletion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LabelledMap.html">LabelledMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a map label -&gt; data, where the label is an integer between 0 and a constant L-1. It is based on a binary coding of labels and a mixed list/array structure. The assumption is that the number of used labels is much less than L. The objective is to minimize the memory usage.  <a href="classDGtal_1_1LabelledMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Labels.html">Labels</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Stores a set of labels in {O..L-1} as a sequence of bits.  <a href="classDGtal_1_1Labels.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1OneItemOutputIterator.html">OneItemOutputIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of output iterator, ie incrementable and writable iterator, which only stores in a variable the last assigned item.  <a href="classDGtal_1_1OneItemOutputIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1OpInSTLContainers.html">OpInSTLContainers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1OpInSTLContainers_3_01Container_00_01std_1_1reverse__iterator_3_01typename_01Container_1_1iterator_01_4_01_4.html">OpInSTLContainers&lt; Container, std::reverse_iterator&lt; typename Container::iterator &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1OrderedAlphabet.html">OrderedAlphabet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Describes an alphabet over an interval of (ascii) letters, where the lexicographic order can be changed (shifted, reversed, ...). Useful for the arithmetic minimum length polygon (AMLP).  <a href="classDGtal_1_1OrderedAlphabet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1OutputIteratorAdapter.html">OutputIteratorAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Adapts an output iterator i with a unary functor f, both given at construction, so that the element pointed to by i is updated with a given value through f.  <a href="classDGtal_1_1OutputIteratorAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1OwningOrAliasingPtr.html">OwningOrAliasingPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class describes a smart pointer that is, given the constructor called by the user, either an alias pointer on existing data or an owning pointer on a copy.  <a href="classDGtal_1_1OwningOrAliasingPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ReverseIterator.html">ReverseIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class adapts any bidirectional iterator so that operator++ calls operator-- and vice versa.  <a href="classDGtal_1_1ReverseIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SimpleConstRange.html">SimpleConstRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of CConstRange that adapts any range of elements bounded by two iterators [itb, ite) and provides services to (circularly)iterate over it (in a read-only manner).  <a href="classDGtal_1_1SimpleConstRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SimpleRandomAccessConstRangeFromPoint.html">SimpleRandomAccessConstRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of CConstBidirectionalRangeFromPoint that adapts any range of elements bounded by two iterators [itb, ite) and provides services to (circularly)iterate over it (in a read-only manner).  <a href="classDGtal_1_1SimpleRandomAccessConstRangeFromPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SimpleRandomAccessRangeFromPoint.html">SimpleRandomAccessRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of CBidirectionalRangeFromPoint that adapts any range of elements bounded by two iterators [itb, ite) and provides services to (circularly)iterate over it (in a read-only manner).  <a href="classDGtal_1_1SimpleRandomAccessRangeFromPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1StdMapRebinder.html">StdMapRebinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TiledImageBidirectionalConstRangeFromPoint.html">TiledImageBidirectionalConstRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of CConstBidirectionalRangeFromPoint that adapts a <a class="el" href="classDGtal_1_1TiledImage.html" title="Aim: implements a tiled image from a &quot;bigger/original&quot; one from an ImageFactory.">TiledImage</a> range of elements bounded by two iterators [itb, ite) and provides services to (circularly)iterate over it (in a read-only manner).  <a href="classDGtal_1_1TiledImageBidirectionalConstRangeFromPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TiledImageBidirectionalRangeFromPoint.html">TiledImageBidirectionalRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of CBidirectionalRangeFromPoint that adapts a <a class="el" href="classDGtal_1_1TiledImage.html" title="Aim: implements a tiled image from a &quot;bigger/original&quot; one from an ImageFactory.">TiledImage</a> range of elements bounded by two iterators [itb, ite) and provides services to (circularly)iterate over it.  <a href="classDGtal_1_1TiledImageBidirectionalRangeFromPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Trace.html">Trace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of basic methods to trace out messages with indentation levels.  <a href="classDGtal_1_1Trace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TraceWriter.html">TraceWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual Class to implement trace writers.  <a href="classDGtal_1_1TraceWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TraceWriterFile.html">TraceWriterFile</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TraceWriterTerm.html">TraceWriterTerm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements trace prefix for color terminals.  <a href="classDGtal_1_1TraceWriterTerm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ATSolver2D.html">ATSolver2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class solves Ambrosio-Tortorelli functional on a two-dimensional digital space (a 2D grid or 2D digital surface) for a piecewise smooth scalar/vector function <em>u</em> represented as one/several 2-form(s) and a discontinuity function <em>v</em> represented as a 0-form. The 2-form(s) <em>u</em> is a regularized approximation of an input vector data <em>g</em>, while <em>v</em> represents the set of discontinuities of <em>u</em>. The norm chosen for <em>u</em> is the \( l_2 \)-norm.  <a href="classDGtal_1_1ATSolver2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DiscreteExteriorCalculusFactory.html">DiscreteExteriorCalculusFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class provides static members to create DEC structures from various other <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> structures.  <a href="classDGtal_1_1DiscreteExteriorCalculusFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DiscreteExteriorCalculus.html">DiscreteExteriorCalculus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: <a class="el" href="classDGtal_1_1DiscreteExteriorCalculus.html" title="Aim: DiscreteExteriorCalculus represents a calculus in the dec package. This is the main structure in...">DiscreteExteriorCalculus</a> represents a calculus in the dec package. This is the main structure in the dec package. This is used to describe the space on which the dec is build and to compute various operators. Once operators or kforms are created, this structure should not be modified.  <a href="classDGtal_1_1DiscreteExteriorCalculus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DiscreteExteriorCalculusSolver.html">DiscreteExteriorCalculusSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This wraps a linear algebra solver around a discrete exterior calculus.  <a href="classDGtal_1_1DiscreteExteriorCalculusSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1OppositeDuality.html">OppositeDuality</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1OppositeDuality_3_01PRIMAL_01_4.html">OppositeDuality&lt; PRIMAL &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1OppositeDuality_3_01DUAL_01_4.html">OppositeDuality&lt; DUAL &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1KForm.html">KForm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: <a class="el" href="classDGtal_1_1KForm.html" title="Aim: KForm represents discrete kforms in the dec package.">KForm</a> represents discrete kforms in the dec package.  <a href="classDGtal_1_1KForm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: <a class="el" href="classDGtal_1_1LinearOperator.html" title="Aim: LinearOperator represents discrete linear operator between discrete kforms in the DEC package.">LinearOperator</a> represents discrete linear operator between discrete kforms in the DEC package.  <a href="classDGtal_1_1LinearOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1VectorField.html">VectorField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: <a class="el" href="classDGtal_1_1VectorField.html" title="Aim: VectorField represents a discrete vector field in the dec package. Vector field values are attac...">VectorField</a> represents a discrete vector field in the dec package. Vector field values are attached to 0-cells with the same duality as the vector field.  <a href="classDGtal_1_1VectorField.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1AlphaThickSegmentComputer.html">AlphaThickSegmentComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is devoted to the recognition of alpha thick segments as described in <a class="el" href="citelist.html#CITEREF_FaureTangential2008">[44]</a> . From a maximal diagonal alphaMax thickness, it recognizes thick segments and may thus take into account some noise in the input contour. Moreover points of the segment may not be (digitally) connected and may have floating point coordinates. Connection is only given by the order of the points.  <a href="classDGtal_1_1AlphaThickSegmentComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ArithDSSIterator.html">ArithDSSIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: An iterator on the points of a Digital Straight Segment. Template parameters are the integer type and the connectivity of the DSS (8-connectivity as default value).  <a href="classDGtal_1_1ArithDSSIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class represents a naive (resp. standard) digital straight segment (DSS), ie. the sequence of simply 8- (resp. 4-)connected digital points contained in a naive (resp. standard) digital straight line (DSL) between two points of it.  <a href="classDGtal_1_1ArithmeticalDSS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ArithmeticalDSL.html">ArithmeticalDSL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class represents a naive (resp. standard) digital straight line (DSL), ie. the set of digital points \( (x,y) \in \mathbb{Z}^2 \) such that \( \mu \leq ax - by &lt; \mu + \omega \) with \( a,b,\mu,\omega \in \mathbb{Z} \), \( \gcd(a,b) = 1 \) and \( \omega = \max(|a|,|b|) \) (resp. \( \omega = |a| + |b| \)). Note that any DSL such that \( \omega = \max(|a|,|b|) \) (resp. \( \omega = |a| + |b| \)) is simply 8-connected (resp. 4-connected).  <a href="classDGtal_1_1ArithmeticalDSL.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1StandardDSL.html">StandardDSL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is an alias of <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a> for standard DSL. It represents a standard digital straight line (DSL), ie. the set of digital points \( (x,y) \in \mathbb{Z}^2 \) such that \( \mu \leq ax - by &lt; \mu + \omega \) with \( a,b,\mu,\omega \in \mathbb{Z} \), \( \gcd(a,b) = 1 \) and \( \omega = |a| + |b| \). Note that any DSL such that \( \omega = |a| + |b| \) is simply 4-connected.  <a href="classDGtal_1_1StandardDSL.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1NaiveDSL.html">NaiveDSL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is an alias of <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a> for naive DSL. It represents a naive digital straight line (DSL), ie. the set of digital points \( (x,y) \in \mathbb{Z}^2 \) such that \( \mu \leq ax - by &lt; \mu + \omega \) with \( a,b,\mu,\omega \in \mathbb{Z} \), \( \gcd(a,b) = 1 \) and \( \omega = \max(|a|,|b|) \). Note that any DSL such that \( \omega = \max(|a|,|b|) \) is simply 8-connected.  <a href="classDGtal_1_1NaiveDSL.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ArithmeticalDSLKernel.html">ArithmeticalDSLKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Small class that contains the code that depends on the arithmetical thickness (either naive or standard) of a digital straight line (DSL). It provides mainly two static methods:  <a href="structDGtal_1_1ArithmeticalDSLKernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ArithmeticalDSLKernel_3_01TCoordinate_00_014_01_4.html">ArithmeticalDSLKernel&lt; TCoordinate, 4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1StandardDSS4.html">StandardDSS4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class represents a standard digital straight segment (DSS), ie. the sequence of simply 4-connected digital points contained in a standard digital straight line (DSL) between two points of it. This class is an alias of <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a>.  <a href="classDGtal_1_1StandardDSS4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1NaiveDSS8.html">NaiveDSS8</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class represents a standard digital straight segment (DSS), ie. the sequence of simply 8-connected digital points contained in a naive digital straight line (DSL) between two points of it. This class is an alias of <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a>.  <a href="classDGtal_1_1NaiveDSS8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html">ArithmeticalDSSComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is a wrapper around <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a> that is devoted to the dynamic recognition of digital straight segments (DSS) along any sequence of digital points.  <a href="classDGtal_1_1ArithmeticalDSSComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ArithmeticalDSSFactory.html">ArithmeticalDSSFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Set of static methods that create digital straight segments (DSS) from some input parameters, eg. patterns (or reversed patterns) from two upper leaning points (or lower leaning points).  <a href="classDGtal_1_1ArithmeticalDSSFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1BinomialConvolver.html">BinomialConvolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class represents a 2D contour convolved by some binomial. It computes first and second order derivatives so as to be able to estimate tangent and curvature. In particular, it smoothes digital contours but could be used for other kind of contours.  <a href="classDGtal_1_1BinomialConvolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TangentFromBinomialConvolverFunctor.html">TangentFromBinomialConvolverFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is a functor for getting the tangent vector of a binomial convolver.  <a href="structDGtal_1_1TangentFromBinomialConvolverFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CurvatureFromBinomialConvolverFunctor.html">CurvatureFromBinomialConvolverFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is a functor for getting the curvature of a binomial convolver.  <a href="structDGtal_1_1CurvatureFromBinomialConvolverFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1BinomialConvolverEstimator.html">BinomialConvolverEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class encapsulates a <a class="el" href="classDGtal_1_1BinomialConvolver.html" title="Aim: This class represents a 2D contour convolved by some binomial. It computes first and second orde...">BinomialConvolver</a> and a functor on <a class="el" href="classDGtal_1_1BinomialConvolver.html" title="Aim: This class represents a 2D contour convolved by some binomial. It computes first and second orde...">BinomialConvolver</a> so as to be a model of CCurveLocalGeometricEstimator.  <a href="classDGtal_1_1BinomialConvolverEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DSLSubsegment.html">DSLSubsegment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Given a Digital Straight line and two endpoints A and B on this line, compute the minimal characteristics of the digital subsegment [AB] in logarithmic time. Two algorithms are implemented: one is based on the local computation of lower and upper convex hulls, the other is based on a dual transformation and uses the Farey fan. Implementation requires that the DSL lies in the first octant (0 &lt;= a &lt;= b).  <a href="classDGtal_1_1DSLSubsegment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1BLUELocalLengthEstimator.html">BLUELocalLengthEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Best Linear Unbiased Two step length estimator.  <a href="classDGtal_1_1BLUELocalLengthEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CompareLocalEstimators.html">CompareLocalEstimators</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Functor to compare two local geometric estimators.  <a href="structDGtal_1_1CompareLocalEstimators.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DSSLengthEstimator.html">DSSLengthEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a model of CGlobalCurveEstimator that segments the digital curve into DSS and computes the length of the resulting (not uniquely defined) polygon.  <a href="classDGtal_1_1DSSLengthEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1FPLengthEstimator.html">FPLengthEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a model of CGlobalCurveEstimator that computes the length of a digital curve using its <a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a> (faithful polygon)  <a href="classDGtal_1_1FPLengthEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TangentFromDSS2DFunctor.html">TangentFromDSS2DFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TangentFromDSS3DFunctor.html">TangentFromDSS3DFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DSSMuteFilter.html">DSSMuteFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DSSLengthLessEqualFilter.html">DSSLengthLessEqualFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1L1LengthEstimator.html">L1LengthEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a simple model of CGlobalCurveEstimator that compute the length of a curve using the l_1 metric (just add 1/h for every step).  <a href="classDGtal_1_1L1LengthEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LambdaMST2DEstimator.html">LambdaMST2DEstimator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LambdaMST2D.html">LambdaMST2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Simplify creation of Lambda MST tangent estimator.  <a href="classDGtal_1_1LambdaMST2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LambdaMST3DEstimator.html">LambdaMST3DEstimator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LambdaMST3D.html">LambdaMST3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Simplify creation of Lambda MST tangent estimator.  <a href="classDGtal_1_1LambdaMST3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LambdaMST3DBy2DEstimator.html">LambdaMST3DBy2DEstimator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TangentFromDSS3DBy2DFunctor.html">TangentFromDSS3DBy2DFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LambdaMST3DBy2D.html">LambdaMST3DBy2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Simplify creation of Lambda MST tangent estimator.  <a href="classDGtal_1_1LambdaMST3DBy2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MLPLengthEstimator.html">MLPLengthEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a model of CGlobalCurveEstimator that computes the length of a digital curve using its MLP (given by the <a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a>)  <a href="classDGtal_1_1MLPLengthEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MostCenteredMaximalSegmentEstimator.html">MostCenteredMaximalSegmentEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A model of CLocalCurveGeometricEstimator that assigns to each element of a (sub)range a quantity estimated from the most centered maximal segment passing through this element.  <a href="classDGtal_1_1MostCenteredMaximalSegmentEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ParametricShapeArcLengthFunctor.html">ParametricShapeArcLengthFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements a functor that estimates the arc length of a paramtric curve.  <a href="classDGtal_1_1ParametricShapeArcLengthFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ParametricShapeCurvatureFunctor.html">ParametricShapeCurvatureFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements a functor that computes the curvature at a given point of a parametric shape.  <a href="classDGtal_1_1ParametricShapeCurvatureFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ParametricShapeTangentFunctor.html">ParametricShapeTangentFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements a functor that computes the tangent vector at a given point of a parametric shape.  <a href="classDGtal_1_1ParametricShapeTangentFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1RosenProffittLocalLengthEstimator.html">RosenProffittLocalLengthEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Rosen-Proffitt Length Estimator.  <a href="classDGtal_1_1RosenProffittLocalLengthEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TangentFromDSSEstimator.html">TangentFromDSSEstimator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TangentVectorFromDSSEstimator.html">TangentVectorFromDSSEstimator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TangentAngleFromDSSEstimator.html">TangentAngleFromDSSEstimator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CurvatureFromDCAEstimator.html">CurvatureFromDCAEstimator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1NormalFromDCAEstimator.html">NormalFromDCAEstimator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TangentFromDCAEstimator.html">TangentFromDCAEstimator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DistanceFromDCAEstimator.html">DistanceFromDCAEstimator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CurvatureFromDSSLengthEstimator.html">CurvatureFromDSSLengthEstimator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CurvatureFromDSSEstimator.html">CurvatureFromDSSEstimator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TrueGlobalEstimatorOnPoints.html">TrueGlobalEstimatorOnPoints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the true quantity associated to a parametric shape or to a subrange associated to a parametric shape.  <a href="classDGtal_1_1TrueGlobalEstimatorOnPoints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TrueLocalEstimatorOnPoints.html">TrueLocalEstimatorOnPoints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the true quantity to each element of a range associated to a parametric shape.  <a href="classDGtal_1_1TrueLocalEstimatorOnPoints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TwoStepLocalLengthEstimator.html">TwoStepLocalLengthEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a simple model of CGlobalCurveEstimator that compute the length of a curve using the l_1 metric (just add 1/h for every step).  <a href="classDGtal_1_1TwoStepLocalLengthEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1FP.html">FP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the faithful polygon (<a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a>) of a range of 4/8-connected 2D Points.  <a href="classDGtal_1_1FP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1FrechetShortcut.html">FrechetShortcut</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: On-line computation Computation of the longest shortcut according to the Fréchet distance for a given error. See related article: Sivignon, I., (2011). A Near-Linear Time Guaranteed Algorithm for Digital Curve Simplification under the Fréchet Distance. DGCI 2011. Retrieved from <a href="http://link.springer.com/chapter/10.1007/978-3-642-19867-0_28">http://link.springer.com/chapter/10.1007/978-3-642-19867-0_28</a>.  <a href="classDGtal_1_1FrechetShortcut.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GreedySegmentation.html">GreedySegmentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the greedy segmentation of a range given by a pair of ConstIterators. The last element of a given segment is the first one one of the next segment.  <a href="classDGtal_1_1GreedySegmentation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GridCurve.html">GridCurve</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: describes, in a cellular space of dimension n, a closed or open sequence of signed d-cells (or d-scells), d being either equal to 1 or (n-1).  <a href="classDGtal_1_1GridCurve.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Naive3DDSSComputer.html">Naive3DDSSComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Dynamic recognition of a 3d-digital straight segment (DSS)  <a href="classDGtal_1_1Naive3DDSSComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1OneBalancedWordComputer.html">OneBalancedWordComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="classDGtal_1_1OneBalancedWordComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DecoratorParametricCurveTransformation.html">DecoratorParametricCurveTransformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements a decorator for applying transformations to parametric curves.  <a href="classDGtal_1_1DecoratorParametricCurveTransformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1EllipticHelix.html">EllipticHelix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implement a parametric curve – elliptic helix.  <a href="classDGtal_1_1EllipticHelix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Knot__3__1.html">Knot_3_1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implement a parametrized knot 3, 1.  <a href="classDGtal_1_1Knot__3__1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Knot__3__2.html">Knot_3_2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implement a parametrized knot 3, 2.  <a href="classDGtal_1_1Knot__3__2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Knot__4__1.html">Knot_4_1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implement a parametrized knot 4, 1.  <a href="classDGtal_1_1Knot__4__1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Knot__4__3.html">Knot_4_3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implement a parametrized knot 4, 3.  <a href="classDGtal_1_1Knot__4__3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Knot__5__1.html">Knot_5_1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implement a parametrized knot 5, 1.  <a href="classDGtal_1_1Knot__5__1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Knot__5__2.html">Knot_5_2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implement a parametrized knot 5, 2.  <a href="classDGtal_1_1Knot__5__2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Knot__6__2.html">Knot_6_2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implement a parametrized knot 6, 2.  <a href="classDGtal_1_1Knot__6__2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Knot__7__4.html">Knot_7_4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implement a parametrized knot 7, 4.  <a href="classDGtal_1_1Knot__7__4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1NaiveParametricCurveDigitizer3D.html">NaiveParametricCurveDigitizer3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Digitization of 3D parametric curves. This method produces, for good parameters step and k_next, a 26-connected digital curves obtained from a digitization process of 3D parametric curves.  <a href="classDGtal_1_1NaiveParametricCurveDigitizer3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SaturatedSegmentation.html">SaturatedSegmentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the saturated segmentation, that is the whole set of maximal segments within a range given by a pair of ConstIterators (maximal segments are segments that cannot be included in greater segments).  <a href="classDGtal_1_1SaturatedSegmentation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">ForwardSegmentComputer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DynamicSegmentComputer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DynamicBidirectionalSegmentComputer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SegmentComputerTraits.html">SegmentComputerTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Provides the category of the segment computer <br  />
 {<a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">ForwardSegmentComputer</a>,<a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a>, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DynamicSegmentComputer</a>, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DynamicBidirectionalSegmentComputer</a>}.  <a href="structDGtal_1_1SegmentComputerTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1StabbingCircleComputer.html">StabbingCircleComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: On-line recognition of a digital circular arcs (DCA) defined as a sequence of connected grid edges such that there is at least one (Euclidean) circle that separates the centers of the two incident pixels of each grid edge.  <a href="classDGtal_1_1StabbingCircleComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1StabbingLineComputer.html">StabbingLineComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: On-line recognition of a digital straight segment (DSS) defined as a sequence of connected grid edges such that there is at least one straight line that separates the centers of the two incident pixels of each grid edge.  <a href="classDGtal_1_1StabbingLineComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1StandardDSS6Computer.html">StandardDSS6Computer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Dynamic recognition of a 3d-digital straight segment (DSS)  <a href="classDGtal_1_1StandardDSS6Computer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ContourHelper.html">ContourHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a helper class to process sequences of points.  <a href="classDGtal_1_1ContourHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ArithmeticalDSSComputerOnSurfels.html">ArithmeticalDSSComputerOnSurfels</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is a wrapper around <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a> that is devoted to the dynamic recognition of digital straight segments (DSS) along any sequence of 3D surfels.  <a href="classDGtal_1_1ArithmeticalDSSComputerOnSurfels.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ChordGenericNaivePlaneComputer.html">ChordGenericNaivePlaneComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1, it corresponds to naive planes. Contrary to <a class="el" href="classDGtal_1_1ChordNaivePlaneComputer.html" title="Aim: A class that contains the chord-based algorithm for recognizing pieces of digital planes of give...">ChordNaivePlaneComputer</a>, the axis is <b>not</b> specified at initialization of the object. This class uses three instances of <a class="el" href="classDGtal_1_1ChordNaivePlaneComputer.html" title="Aim: A class that contains the chord-based algorithm for recognizing pieces of digital planes of give...">ChordNaivePlaneComputer</a>, one per axis.  <a href="classDGtal_1_1ChordGenericNaivePlaneComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ChordGenericStandardPlaneComputer.html">ChordGenericStandardPlaneComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A class that recognizes pieces of digital planes of given diagonal width. When the width is \(1 \times \sqrt{3}\), it corresponds to standard planes. Contrary to ChordStandardPlaneComputer, the axis is <b>not</b> specified at initialization of the object. This class uses four instances of ChordStandardPlaneComputer of axis z, by transforming points \((x,y,z)\) to \((x \pm z, y \pm z, z)\).  <a href="classDGtal_1_1ChordGenericStandardPlaneComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ChordNaivePlaneComputer.html">ChordNaivePlaneComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A class that contains the chord-based algorithm for recognizing pieces of digital planes of given axis width [ Gerard, Debled-Rennesson, Zimmermann, 2005 ]. When the width is 1, it corresponds to naive planes. The axis is specified at initialization of the object.  <a href="classDGtal_1_1ChordNaivePlaneComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html">COBAGenericNaivePlaneComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1, it corresponds to naive planes. Contrary to <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a>, the axis is <b>not</b> specified at initialization of the object. This class uses three instances of <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a>, one per axis.  <a href="classDGtal_1_1COBAGenericNaivePlaneComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1COBAGenericStandardPlaneComputer.html">COBAGenericStandardPlaneComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A class that recognizes pieces of digital planes of given axis width. When the diagonal width is \( 1 \times \sqrt{3} \), it corresponds to standard planes. Contrary to <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a>, the axis is <b>not</b> specified at initialization of the object. This class uses four instances of <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a> of axis z, by transforming points \((x,y,z)\) to \((x \pm z, y \pm z, z)\).  <a href="classDGtal_1_1COBAGenericStandardPlaneComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html">COBANaivePlaneComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizing pieces of digital planes of given axis width. When the width is 1, it corresponds to naive planes. The axis is specified at initialization of the object.  <a href="classDGtal_1_1COBANaivePlaneComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalPlanePredicate.html">DigitalPlanePredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Representing digital planes, which are digitizations of Euclidean planes, as point predicates.  <a href="classDGtal_1_1DigitalPlanePredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSurfaceConvolver.html">DigitalSurfaceConvolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSurfaceConvolver_3_01TFunctor_00_01TKernelFunctor_00_01TKSpace_00_01TDigitalKernel_00_012_01_4.html">DigitalSurfaceConvolver&lt; TFunctor, TKernelFunctor, TKSpace, TDigitalKernel, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSurfaceConvolver_3_01TFunctor_00_01TKernelFunctor_00_01TKSpace_00_01TDigitalKernel_00_013_01_4.html">DigitalSurfaceConvolver&lt; TFunctor, TKernelFunctor, TKSpace, TDigitalKernel, 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSurfacePredicate.html">DigitalSurfacePredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A point predicate which tells whether a point belongs to the set of pointels of a given digital surface or not.  <a href="classDGtal_1_1DigitalSurfacePredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSurfaceRegularization.html">DigitalSurfaceRegularization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements Digital Surface Regularization as described in <a class="el" href="citelist.html#CITEREF_coeurjolly17regDGCI">[28]</a>.  <a href="classDGtal_1_1DigitalSurfaceRegularization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSurfaceEmbedderWithNormalVectorEstimatorGradientMap.html">DigitalSurfaceEmbedderWithNormalVectorEstimatorGradientMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSurfaceEmbedderWithNormalVectorEstimator.html">DigitalSurfaceEmbedderWithNormalVectorEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Combines a digital surface embedder with a normal vector estimator to get a model of CDigitalSurfaceEmbedder and CWithGradientMap. (also default constructible, copy constructible, assignable).  <a href="classDGtal_1_1DigitalSurfaceEmbedderWithNormalVectorEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1EstimatorCache.html">EstimatorCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: this class adapts any local surface estimator to cache the estimated values in a associative container (Surfel &lt;-&gt; estimated value).  <a href="classDGtal_1_1EstimatorCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IntegralInvariantCovarianceEstimator.html">IntegralInvariantCovarianceEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class implement an Integral Invariant estimator which computes for each surfel the covariance matrix of the intersection of the shape with a ball of given radius centered on the surfel.  <a href="classDGtal_1_1IntegralInvariantCovarianceEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IntegralInvariantVolumeEstimator.html">IntegralInvariantVolumeEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class implement an Integral Invariant estimator which computes for each surfel the volume of the intersection of the shape with a ball of given radius centered on the surfel.  <a href="classDGtal_1_1IntegralInvariantVolumeEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LocalEstimatorFromSurfelFunctorAdapter.html">LocalEstimatorFromSurfelFunctorAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: this class adapts any local functor on digital surface element to define a local estimator. This class is model of CDigitalSurfaceLocalEstimator.  <a href="classDGtal_1_1LocalEstimatorFromSurfelFunctorAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MaximalSegmentSliceEstimation.html">MaximalSegmentSliceEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="classDGtal_1_1MaximalSegmentSliceEstimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1NormalVectorEstimatorLinearCellEmbedder.html">NormalVectorEstimatorLinearCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of cellular embedder for normal vector estimators on digital surface, (default constructible, copy constructible, assignable).  <a href="classDGtal_1_1NormalVectorEstimatorLinearCellEmbedder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1PlaneProbingDigitalSurfaceLocalEstimator.html">PlaneProbingDigitalSurfaceLocalEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Adapt a plane-probing estimator on a digital surface to estimate normal vectors.  <a href="classDGtal_1_1PlaneProbingDigitalSurfaceLocalEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1PlaneProbingHNeighborhood.html">PlaneProbingHNeighborhood</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent a way to probe the H-neighborhood.  <a href="classDGtal_1_1PlaneProbingHNeighborhood.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1PlaneProbingNeighborhood.html">PlaneProbingNeighborhood</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A base virtual class that represents a way to probe a neighborhood, used in the plane probing based estimators, see <a class="el" href="classDGtal_1_1PlaneProbingTetrahedronEstimator.html" title="Aim: A class that locally estimates a normal on a digital set using only a predicate &quot;does a point x ...">DGtal::PlaneProbingTetrahedronEstimator</a> or <a class="el" href="classDGtal_1_1PlaneProbingParallelepipedEstimator.html" title="Aim:">DGtal::PlaneProbingParallelepipedEstimator</a>.  <a href="classDGtal_1_1PlaneProbingNeighborhood.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1PlaneProbingParallelepipedEstimator.html">PlaneProbingParallelepipedEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="classDGtal_1_1PlaneProbingParallelepipedEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1PlaneProbingR1Neighborhood.html">PlaneProbingR1Neighborhood</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent a way to probe the R-neighborhood, with the R1 optimization, see <a class="el" href="citelist.html#CITEREF_RLDGCI2019">[89]</a> for details.  <a href="classDGtal_1_1PlaneProbingR1Neighborhood.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1PlaneProbingRNeighborhood.html">PlaneProbingRNeighborhood</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent a way to probe the R-neighborhood.  <a href="classDGtal_1_1PlaneProbingRNeighborhood.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1PlaneProbingTetrahedronEstimator.html">PlaneProbingTetrahedronEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A class that locally estimates a normal on a digital set using only a predicate "does a point x belong to the digital set or not?".  <a href="classDGtal_1_1PlaneProbingTetrahedronEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TrueDigitalSurfaceLocalEstimator.html">TrueDigitalSurfaceLocalEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: An estimator on digital surfaces that returns the reference local geometric quantity. This is used for comparing estimators.  <a href="classDGtal_1_1TrueDigitalSurfaceLocalEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1VCMDigitalSurfaceLocalEstimator.html">VCMDigitalSurfaceLocalEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class adapts a <a class="el" href="classDGtal_1_1VoronoiCovarianceMeasureOnDigitalSurface.html" title="Aim: This class specializes the Voronoi covariance measure for digital surfaces. It adds notably the ...">VoronoiCovarianceMeasureOnDigitalSurface</a> to be a model of CDigitalSurfaceLocalEstimator. It uses the <b>Voronoi</b> <b>Covariance</b> <b><a class="el" href="classDGtal_1_1Measure.html" title="Aim: Implements a simple measure computation (in the Lesbegue sens) of a set. In dimension 2,...">Measure</a></b> to estimate geometric quantities. The type TVCMGeometricFunctor specifies which is the estimated quantity. For instance, VCMGeometricFunctors::VCMNormalVectorFunctor returns the estimated VCM surface <b>outward</b> normal for given surfels.  <a href="classDGtal_1_1VCMDigitalSurfaceLocalEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1VoronoiCovarianceMeasureOnDigitalSurface.html">VoronoiCovarianceMeasureOnDigitalSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class specializes the Voronoi covariance measure for digital surfaces. It adds notably the embedding of surface elements, the diagonalisation of the VCM, and the orientation of the first VCM eigenvector toward the interior of the surface.  <a href="classDGtal_1_1VoronoiCovarianceMeasureOnDigitalSurface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1FunctorOnCells.html">FunctorOnCells</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Convert a functor on Digital Point to a Functor on Khalimsky Cell.  <a href="classDGtal_1_1FunctorOnCells.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ParallelStrip.html">ParallelStrip</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A parallel strip in the space is the intersection of two parallel half-planes such that each half-plane includes the other.  <a href="classDGtal_1_1ParallelStrip.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ShroudsRegularization.html">ShroudsRegularization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements the Shrouds Regularization algorithm of Nielson et al <a class="el" href="citelist.html#CITEREF_nielson2003shrouds">[78]</a>.  <a href="classDGtal_1_1ShroudsRegularization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1AvnaimEtAl2x2DetSignComputer.html">AvnaimEtAl2x2DetSignComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class that provides a way of computing the sign of the determinant of a 2x2 matrix from its four coefficients, ie.  <a href="classDGtal_1_1AvnaimEtAl2x2DetSignComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1C2x2DetComputer.html">C2x2DetComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept gathers all models that are able to compute the (sign of the) determinant of a 2x2 matrix with integral entries.  <a href="structDGtal_1_1C2x2DetComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Filtered2x2DetComputer.html">Filtered2x2DetComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class that provides a way of computing the sign of the determinant of a 2x2 matrix from its four coefficients, ie.  <a href="classDGtal_1_1Filtered2x2DetComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1InGeneralizedDiskOfGivenRadius.html">InGeneralizedDiskOfGivenRadius</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class implements an orientation functor that <br  />
 provides a way to determine the position of a given point with respect to the unique circle passing by the same two given points and whose radius and orientation is given.  <a href="classDGtal_1_1InGeneralizedDiskOfGivenRadius.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1InHalfPlaneBy2x2DetComputer.html">InHalfPlaneBy2x2DetComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class that implements an orientation functor, ie. it provides a way to compute the orientation of three given 2d points. More precisely, it returns:  <a href="classDGtal_1_1InHalfPlaneBy2x2DetComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1InHalfPlaneBySimple3x3Matrix.html">InHalfPlaneBySimple3x3Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class that implements an orientation functor, ie. it provides a way to compute the orientation of three given 2d points. More precisely, it returns:  <a href="classDGtal_1_1InHalfPlaneBySimple3x3Matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1PredicateFromOrientationFunctor2.html">PredicateFromOrientationFunctor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Small adapter to models of COrientationFunctor2. It is a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">concepts::CPointPredicate</a>. It is also a ternary predicate on points, useful for basic geometric tasks such as convex hull computation.  <a href="classDGtal_1_1PredicateFromOrientationFunctor2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Simple2x2DetComputer.html">Simple2x2DetComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Small class useful to compute the determinant of a 2x2 matrix from its four coefficients, ie. \( \begin{vmatrix} a &amp; x \\ b &amp; y \end{vmatrix} \).  <a href="classDGtal_1_1Simple2x2DetComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SimpleIncremental2x2DetComputer.html">SimpleIncremental2x2DetComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Small class useful to compute, in an incremental way, the determinant of a 2x2 matrix from its four coefficients, ie. \( \begin{vmatrix} a &amp; x \\ b &amp; y \end{vmatrix} \).  <a href="classDGtal_1_1SimpleIncremental2x2DetComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MelkmanConvexHull.html">MelkmanConvexHull</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class implements the on-line algorithm of Melkman for the computation of the convex hull of a simple polygonal line (without self-intersection) [Melkman, 1987: <a class="el" href="citelist.html#CITEREF_Melkman1987">[73]</a>].  <a href="classDGtal_1_1MelkmanConvexHull.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Preimage2D.html">Preimage2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the preimage of the 2D Euclidean shapes crossing a sequence of n straigth segments in O(n), with the algorithm of O'Rourke (1981).  <a href="classDGtal_1_1Preimage2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1QuickHull.html">QuickHull</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements the quickhull algorithm by Barber et al. <a class="el" href="citelist.html#CITEREF_barber1996">[9]</a>, a famous arbitrary dimensional convex hull computation algorithm. It relies on dedicated geometric kernels for computing and comparing facet geometries.  <a href="structDGtal_1_1QuickHull.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ConvexHullCommonKernel.html">ConvexHullCommonKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: the common part of all geometric kernels for computing the convex hull or Delaunay triangulation of a range of points.  <a href="structDGtal_1_1ConvexHullCommonKernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ConvexHullIntegralKernel.html">ConvexHullIntegralKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a geometric kernel to compute the convex hull of digital points with integer-only arithmetic.  <a href="structDGtal_1_1ConvexHullIntegralKernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DelaunayIntegralKernel.html">DelaunayIntegralKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a geometric kernel to compute the Delaunay triangulation of digital points with integer-only arithmetic. It casts lattice point into a higher dimensional space and computes its convex hull. Facets pointing toward the bottom form the simplices of the Delaunay triangulation.  <a href="structDGtal_1_1DelaunayIntegralKernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ConvexHullRationalKernel.html">ConvexHullRationalKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a geometric kernel to compute the convex hull of floating points with integer-only arithmetic. Floating points are approximated with rational points with fixed precision (a given number of bits). All remaining computations are exact, as long as there is no overflow.  <a href="structDGtal_1_1ConvexHullRationalKernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DelaunayRationalKernel.html">DelaunayRationalKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a geometric kernel to compute the Delaunay triangulation of a range of floating points with integer-only arithmetic. Floating points are approximated with rational points with fixed precision (a given number of bits), which are cast in a higher dimensional space and lifted onto the "norm" paraboloid, as classically done when computing a Delaunay triangulation from a convex hull. All remaining computations are exact, as long as there is no overflow.  <a href="structDGtal_1_1DelaunayRationalKernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1RayIntersectionPredicate.html">RayIntersectionPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements various intersection predicates between a ray and a triangle, a quad or a surfel in dimension 3.  <a href="structDGtal_1_1RayIntersectionPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SpatialCubicalSubdivision.html">SpatialCubicalSubdivision</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is a data structure that subdivides a rectangular domains into cubical domains of size \( r^n \) in order to store points into different bins (each cubical domain is a bin, characterized by one coordinate). This data structure may be used for proximity queries, generally to get the points at distance <em>r</em> from a given point.  <a href="classDGtal_1_1SpatialCubicalSubdivision.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SphericalAccumulator.html">SphericalAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements an accumulator (as histograms for 1D scalars) adapted to spherical point samples.  <a href="classDGtal_1_1SphericalAccumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents an nD lattice polytope, i.e. a convex polyhedron bounded with vertices with integer coordinates, as a set of inequalities. Otherwise said, it is a H-representation of a polytope (as an intersection of half-spaces). A limitation is that we model only bounded polytopes, i.e. polytopes that can be included in a finite bounding box.  <a href="classDGtal_1_1BoundedLatticePolytope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents an nD rational polytope, i.e. a convex polyhedron bounded by vertices with rational coordinates, as a set of inequalities. Otherwise said, it is a H-representation of a polytope (as an intersection of half-spaces). A limitation is that we model only bounded polytopes, i.e. polytopes that can be included in a finite bounding box.  <a href="classDGtal_1_1BoundedRationalPolytope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CellGeometry.html">CellGeometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes and stores sets of cells and provides methods to compute intersections of lattice and rational polytopes with cells.  <a href="classDGtal_1_1CellGeometry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CellGeometryFunctions.html">CellGeometryFunctions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CellGeometryFunctions_3_01TKSpace_00_011_00_012_01_4.html">CellGeometryFunctions&lt; TKSpace, 1, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CellGeometryFunctions_3_01TKSpace_00_011_00_013_01_4.html">CellGeometryFunctions&lt; TKSpace, 1, 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CellGeometryFunctions_3_01TKSpace_00_012_00_012_01_4.html">CellGeometryFunctions&lt; TKSpace, 2, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CellGeometryFunctions_3_01TKSpace_00_012_00_013_01_4.html">CellGeometryFunctions&lt; TKSpace, 2, 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CellGeometryFunctions_3_01TKSpace_00_013_00_013_01_4.html">CellGeometryFunctions&lt; TKSpace, 3, 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ConvexCellComplex.html">ConvexCellComplex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: represents a d-dimensional complex in a d-dimensional space with the following properties and restrictions:  <a href="structDGtal_1_1ConvexCellComplex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ConvexityHelper.html">ConvexityHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Provides a set of functions to facilitate the computation of convex hulls and polytopes, as well as shortcuts to build cell complex representing a Delaunay complex.  <a href="structDGtal_1_1ConvexityHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalConvexity.html">DigitalConvexity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A helper class to build polytopes from digital sets and to check digital k-convexity.  <a href="classDGtal_1_1DigitalConvexity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalMetricAdapter.html">DigitalMetricAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: simple adapter class which adapts any models of <a class="el" href="structDGtal_1_1concepts_1_1CMetricSpace.html" title="Aim: defines the concept of metric spaces.">concepts::CMetricSpace</a> to a model of <a class="el" href="structDGtal_1_1concepts_1_1CDigitalMetricSpace.html" title="Aim: defines the concept of digital metric spaces.">concepts::CDigitalMetricSpace</a>.  <a href="classDGtal_1_1DigitalMetricAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DistanceTransformation.html">DistanceTransformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implementation of the linear in time distance transformation for separable metrics.  <a href="classDGtal_1_1DistanceTransformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ExactPredicateLpPowerSeparableMetric.html">ExactPredicateLpPowerSeparableMetric</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements weighted separable l_p metrics with exact predicates.  <a href="classDGtal_1_1ExactPredicateLpPowerSeparableMetric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ExactPredicateLpPowerSeparableMetric_3_01TSpace_00_012_00_01TPromoted_01_4.html">ExactPredicateLpPowerSeparableMetric&lt; TSpace, 2, TPromoted &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ExactPredicateLpSeparableMetric.html">ExactPredicateLpSeparableMetric</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements separable l_p metrics with exact predicates.  <a href="classDGtal_1_1ExactPredicateLpSeparableMetric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ExactPredicateLpSeparableMetric_3_01TSpace_00_012_00_01TRawValue_01_4.html">ExactPredicateLpSeparableMetric&lt; TSpace, 2, TRawValue &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1FMM.html">FMM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Fast Marching Method (<a class="el" href="classDGtal_1_1FMM.html" title="Aim: Fast Marching Method (FMM) for nd distance transforms.">FMM</a>) for nd distance transforms.  <a href="classDGtal_1_1FMM.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1L2FirstOrderLocalDistance.html">L2FirstOrderLocalDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class for the computation of the Euclidean distance at some point p, from the available distance values of some points lying in the 1-neighborhood of p (ie. points at a L1-distance to p equal to 1).  <a href="classDGtal_1_1L2FirstOrderLocalDistance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1L2SecondOrderLocalDistance.html">L2SecondOrderLocalDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class for the computation of the Euclidean distance at some point p, from the available distance values of some points lying in the neighborhood of p, such that only one of their coordinate differ from the coordinates of p by at most two.  <a href="classDGtal_1_1L2SecondOrderLocalDistance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LInfLocalDistance.html">LInfLocalDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class for the computation of the LInf-distance at some point p, from the available distance values of some points lying in the 1-neighborhood of p (ie. points at a L1-distance to p equal to 1).  <a href="classDGtal_1_1LInfLocalDistance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1L1LocalDistance.html">L1LocalDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class for the computation of the L1-distance at some point p, from the available distance values of some points lying in the 1-neighborhood of p (ie. points at a L1-distance to p equal to 1).  <a href="classDGtal_1_1L1LocalDistance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1L2FirstOrderLocalDistanceFromCells.html">L2FirstOrderLocalDistanceFromCells</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class for the computation of the Euclidean distance at some point p, from the available distance values in the neighborhood of p. Contrary to <a class="el" href="classDGtal_1_1L2FirstOrderLocalDistance.html" title="Aim: Class for the computation of the Euclidean distance at some point p, from the available distance...">L2FirstOrderLocalDistance</a>, the distance values are not available from the points adjacent to p but instead from the (d-1)-cells lying between p and these points. <br  />
  <a href="classDGtal_1_1L2FirstOrderLocalDistanceFromCells.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SpeedExtrapolator.html">SpeedExtrapolator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class for the computation of the a speed value at some point p, from the available distance values and speed values of some points lying in the 1-neighborhood of p (ie. points at a L1-distance to p equal to 1) in order to extrapolate a speed field in the normal direction to the interface.  <a href="classDGtal_1_1SpeedExtrapolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1InexactPredicateLpSeparableMetric.html">InexactPredicateLpSeparableMetric</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements separable l_p metrics with approximated predicates.  <a href="classDGtal_1_1InexactPredicateLpSeparableMetric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LpMetric.html">LpMetric</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements l_p metrics.  <a href="classDGtal_1_1LpMetric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1PowerMap.html">PowerMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implementation of the linear in time Power map construction.  <a href="classDGtal_1_1PowerMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ReducedMedialAxis.html">ReducedMedialAxis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implementation of the separable medial axis extraction.  <a href="structDGtal_1_1ReducedMedialAxis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ReverseDistanceTransformation.html">ReverseDistanceTransformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implementation of the linear in time reverse distance transformation for separable metrics.  <a href="classDGtal_1_1ReverseDistanceTransformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SeparableMetricAdapter.html">SeparableMetricAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Adapts any model of CMetric to construct a separable metric (model of CSeparableMetric).  <a href="classDGtal_1_1SeparableMetricAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1VoronoiMap.html">VoronoiMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implementation of the linear in time Voronoi map construction.  <a href="classDGtal_1_1VoronoiMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Measure.html">Measure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements a simple measure computation (in the Lesbegue sens) of a set. In dimension 2, it corresponds to the area of the set, to the volume in dimension 3,...  <a href="classDGtal_1_1Measure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1VoronoiCovarianceMeasure.html">VoronoiCovarianceMeasure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class precomputes the Voronoi Covariance <a class="el" href="classDGtal_1_1Measure.html" title="Aim: Implements a simple measure computation (in the Lesbegue sens) of a set. In dimension 2,...">Measure</a> of a set of points. It can compute the covariance measure of an arbitrary function with given support.  <a href="classDGtal_1_1VoronoiCovarianceMeasure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1KanungoNoise.html">KanungoNoise</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: From a point predicate (model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">concepts::CPointPredicate</a>), this class constructs another point predicate as a noisy version of the input one.  <a href="classDGtal_1_1KanungoNoise.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1BreadthFirstVisitor.html">BreadthFirstVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is useful to perform a breadth-first exploration of a graph given a starting point or set (called initial core).  <a href="classDGtal_1_1BreadthFirstVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DepthFirstVisitor.html">DepthFirstVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is useful to perform a depth-first exploration of a graph given a starting point or set (called initial core).  <a href="classDGtal_1_1DepthFirstVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DistanceBreadthFirstVisitor.html">DistanceBreadthFirstVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is useful to perform an exploration of a graph given a starting point or set (called initial core) and a distance criterion.  <a href="classDGtal_1_1DistanceBreadthFirstVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Expander.html">Expander</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is useful to visit an object by adjacencies, layer by layer.  <a href="classDGtal_1_1Expander.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GraphVisitorRange.html">GraphVisitorRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Transforms a graph visitor into a single pass input range.  <a href="classDGtal_1_1GraphVisitorRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1STLMapToVertexMapAdapter.html">STLMapToVertexMapAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class adapts any map of the STL to match with the CVertexMap concept.  <a href="classDGtal_1_1STLMapToVertexMapAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ParameterValue.html">ParameterValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Parameters.html">Parameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Shortcuts.html">Shortcuts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is used to simplify shape and surface creation. With it, you can create new shapes and surface with few lines of code. The drawback is that you use specific types or objects, which could lead to faster code or more compact data structures.  <a href="classDGtal_1_1Shortcuts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ShortcutsGeometry.html">ShortcutsGeometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is used to simplify shape and surface creation. With it, you can create new shapes and surface in a few lines. The drawback is that you use specific types or objects, which could lead to faster code or more compact data structures.  <a href="classDGtal_1_1ShortcutsGeometry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ArrayImageAdapter_3_01TArrayIterator_00_01HyperRectDomain_3_01TSpace_01_4_01_4.html">ArrayImageAdapter&lt; TArrayIterator, HyperRectDomain&lt; TSpace &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> adapter for generic arrays with sub-domain view capability.  <a href="classDGtal_1_1ArrayImageAdapter_3_01TArrayIterator_00_01HyperRectDomain_3_01TSpace_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IteratorCompletionTraits_3_01ArrayImageAdapter_3_01TArrayIterator_00_01TDomain_01_4_01_4.html">IteratorCompletionTraits&lt; ArrayImageAdapter&lt; TArrayIterator, TDomain &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">[<a class="el" href="classDGtal_1_1IteratorCompletionTraits.html" title="Aim: Traits that must be specialized for each IteratorCompletion derived class.">IteratorCompletionTraits</a>]  <a href="classDGtal_1_1IteratorCompletionTraits_3_01ArrayImageAdapter_3_01TArrayIterator_00_01TDomain_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ArrayImageIterator.html">ArrayImageIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Random access iterator over an image given his definition domain and viewable domain.  <a href="classDGtal_1_1ArrayImageIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ConstImageAdapter.html">ConstImageAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for domain, f for accessing point values.  <a href="classDGtal_1_1ConstImageAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DefaultConstImageRange.html">DefaultConstImageRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of CConstBidirectionalRangeFromPoint that adapts the domain of an image in order to iterate over the values associated to its domain points (in a read-only as well as a write-only manner). <br  />
  <a href="classDGtal_1_1DefaultConstImageRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DefaultImageRange.html">DefaultImageRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of CConstBidirectionalRangeFromPoint and CBidirectionalRangeWithWritableIteratorFromPoint that adapts the domain of an image in order to iterate over the values associated to its domain points (in a read-only as well as a write-only manner). <br  />
  <a href="classDGtal_1_1DefaultImageRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Image.html">Image</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements association bewteen points lying in a digital domain and values.  <a href="classDGtal_1_1Image.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageAdapter.html">ImageAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements an image adapter with a given domain (i.e. a subdomain) and 3 functors : g for domain, f for accessing point values and f-1 for writing point values.  <a href="classDGtal_1_1ImageAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageCache.html">ImageCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements an images cache with 'read and write' policies.  <a href="classDGtal_1_1ImageCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageCacheReadPolicyLAST.html">ImageCacheReadPolicyLAST</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements a 'LAST' read policy cache.  <a href="classDGtal_1_1ImageCacheReadPolicyLAST.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageCacheReadPolicyFIFO.html">ImageCacheReadPolicyFIFO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements a 'FIFO' read policy cache.  <a href="classDGtal_1_1ImageCacheReadPolicyFIFO.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageCacheWritePolicyWT.html">ImageCacheWritePolicyWT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements a 'WT (Write-through)' write policy cache.  <a href="classDGtal_1_1ImageCacheWritePolicyWT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageCacheWritePolicyWB.html">ImageCacheWritePolicyWB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements a 'WB (Write-back or Write-behind)' write policy cache.  <a href="classDGtal_1_1ImageCacheWritePolicyWB.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageContainerByITKImage.html">ImageContainerByITKImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements a model of CImageContainer using a ITK <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>.  <a href="classDGtal_1_1ImageContainerByITKImage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DistanceFunctorFromPoint.html">DistanceFunctorFromPoint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1H5DSpecializations.html">H5DSpecializations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements HDF5 reading and writing for specialized type T.  <a href="structDGtal_1_1H5DSpecializations.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1H5DSpecializations_3_01TImageFactory_00_01DGtal_1_1uint8__t_01_4.html">H5DSpecializations&lt; TImageFactory, DGtal::uint8_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements HDF5 reading and writing for specialized type <a class="el" href="namespaceDGtal.html#a3f01c0f785c605d021be8e328180f502" title="unsigned 8-bit integer.">DGtal::uint8_t</a>.  <a href="structDGtal_1_1H5DSpecializations_3_01TImageFactory_00_01DGtal_1_1uint8__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1H5DSpecializations_3_01TImageFactory_00_01DGtal_1_1int32__t_01_4.html">H5DSpecializations&lt; TImageFactory, DGtal::int32_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements HDF5 reading and writing for specialized type <a class="el" href="namespaceDGtal.html#ac1e9ac6a329319ae13c51c0c9e92486a" title="signed 32-bit integer.">DGtal::int32_t</a>.  <a href="structDGtal_1_1H5DSpecializations_3_01TImageFactory_00_01DGtal_1_1int32__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1H5DSpecializations_3_01TImageFactory_00_01DGtal_1_1int64__t_01_4.html">H5DSpecializations&lt; TImageFactory, DGtal::int64_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements HDF5 reading and writing for specialized type <a class="el" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63" title="signed 94-bit integer.">DGtal::int64_t</a>.  <a href="structDGtal_1_1H5DSpecializations_3_01TImageFactory_00_01DGtal_1_1int64__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1H5DSpecializations_3_01TImageFactory_00_01double_01_4.html">H5DSpecializations&lt; TImageFactory, double &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements HDF5 reading and writing for specialized type double.  <a href="structDGtal_1_1H5DSpecializations_3_01TImageFactory_00_01double_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageFactoryFromHDF5.html">ImageFactoryFromHDF5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements a factory from an HDF5 file.  <a href="classDGtal_1_1ImageFactoryFromHDF5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageFactoryFromImage.html">ImageFactoryFromImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements a factory to produce images from a "bigger/original" one according to a given domain.  <a href="classDGtal_1_1ImageFactoryFromImage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageToConstantFunctor.html">ImageToConstantFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageLinearCellEmbedder.html">ImageLinearCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a cellular embedder for images. (default constructible, copy constructible, assignable). Model of CCellEmbedder.  <a href="classDGtal_1_1ImageLinearCellEmbedder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ImageSelector.html">ImageSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Automatically defines an adequate image type according to the hints given by the user. <br  />
  <a href="structDGtal_1_1ImageSelector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ImageFromSet.html">ImageFromSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define utilities to convert a digital set into an image.  <a href="structDGtal_1_1ImageFromSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SetFromImage.html">SetFromImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define utilities to convert a digital set into an image.  <a href="structDGtal_1_1SetFromImage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Morton.html">Morton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements the binary <a class="el" href="classDGtal_1_1Morton.html" title="Aim: Implements the binary Morton code construction in nD.">Morton</a> code construction in nD.  <a href="classDGtal_1_1Morton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SetValueIterator.html">SetValueIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements an output iterator, which is able to write values in an underlying image, by calling its setValue method.  <a href="classDGtal_1_1SetValueIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TiledImage.html">TiledImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements a tiled image from a "bigger/original" one from an ImageFactory.  <a href="classDGtal_1_1TiledImage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Board2D.html">Board2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class specializes a 'Board' class so as to display <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> objects more naturally (with &lt;&lt;). The user has simply to declare a <a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (with &lt;&lt;)....">Board2D</a> object and uses stream operators to display most digital objects. Furthermore, one can use this class to modify the current style for drawing.  <a href="classDGtal_1_1Board2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawWithBoardModifier.html">DrawWithBoardModifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomStyle.html">CustomStyle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SetMode.html">SetMode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifier class in a <a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (with &lt;&lt;)....">Board2D</a> stream. Useful to choose your own mode for a given class. Realizes the concept CDrawableWithBoard2D.  <a href="structDGtal_1_1SetMode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomColors.html">CustomColors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom style class redefining the pen color and the fill color. You may use Board2D::Color::None for transparent color.  <a href="structDGtal_1_1CustomColors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomPenColor.html">CustomPenColor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom style class redefining the pen color. You may use Board2D::Color::None for transparent color.  <a href="structDGtal_1_1CustomPenColor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomFillColor.html">CustomFillColor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom style class redefining the fill color. You may use Board2D::Color::None for transparent color.  <a href="structDGtal_1_1CustomFillColor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomPen.html">CustomPen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom style class redefining the pen attributes. You may use Board2D::Color::None for transparent color.  <a href="structDGtal_1_1CustomPen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Board3D.html">Board3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class <a class="el" href="classDGtal_1_1Board3D.html" title="The class Board3D is a type of Display3D which export the figures in the format OBJ/MTL when calling ...">Board3D</a> is a type of <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like BallVector,...">Display3D</a> which export the figures in the format OBJ/MTL when calling the method saveOBJ.  <a href="classDGtal_1_1Board3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Board3DTo2DFactory.html">Board3DTo2DFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for GPL <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like BallVector,...">Display3D</a>:  <a href="structDGtal_1_1Board3DTo2DFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawWithBoard3DTo2DModifier.html">DrawWithBoard3DTo2DModifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class specifying the methods for classes which intend to modify a <a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a> stream.  <a href="structDGtal_1_1DrawWithBoard3DTo2DModifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CameraPosition.html">CameraPosition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structDGtal_1_1CameraPosition.html" title="CameraPosition class to set camera position.">CameraPosition</a> class to set camera position.  <a href="structDGtal_1_1CameraPosition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CameraDirection.html">CameraDirection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structDGtal_1_1CameraDirection.html" title="CameraDirection class to set camera direction.">CameraDirection</a> class to set camera direction.  <a href="structDGtal_1_1CameraDirection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CameraUpVector.html">CameraUpVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structDGtal_1_1CameraUpVector.html" title="CameraUpVector class to set camera up-vector.">CameraUpVector</a> class to set camera up-vector.  <a href="structDGtal_1_1CameraUpVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CameraZNearFar.html">CameraZNearFar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structDGtal_1_1CameraZNearFar.html" title="CameraZNearFar class to set near and far distance.">CameraZNearFar</a> class to set near and far distance.  <a href="structDGtal_1_1CameraZNearFar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Color.html">Color</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing an RGB triple with alpha component.  <a href="classDGtal_1_1Color.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ColorBrightnessColorMap.html">ColorBrightnessColorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class template may be used to (linearly) convert scalar values in a given range into a color with given lightness.  <a href="classDGtal_1_1ColorBrightnessColorMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GradientColorMap.html">GradientColorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class template may be used to (linearly) convert scalar values in a given range into a color in a gradient defined by two or more colors.  <a href="classDGtal_1_1GradientColorMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GrayscaleColorMap.html">GrayscaleColorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class template may be used to (linearly) convert scalar values in a given range into gray levels.  <a href="classDGtal_1_1GrayscaleColorMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1HueShadeColorMap.html">HueShadeColorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class template may be used to (linearly) convert scalar values in a given range into a color in a <em>cyclic</em> hue shade colormap, maybe aka rainbow color map. This color map is suitable, for example, to colorize distance functions. By default, only one hue cycle is used.  <a href="classDGtal_1_1HueShadeColorMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1RandomColorMap.html">RandomColorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: access to random color from a gradientColorMap.  <a href="classDGtal_1_1RandomColorMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SimpleDistanceColorMap.html">SimpleDistanceColorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: simple blue to red colormap for distance information for instance.  <a href="classDGtal_1_1SimpleDistanceColorMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TickedColorMap.html">TickedColorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class adapts any colormap to add "ticks" in the colormap colors.  <a href="classDGtal_1_1TickedColorMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Display2DFactory.html">Display2DFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for Display2D:  <a href="structDGtal_1_1Display2DFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Display3DFactory.html">Display3DFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for GPL <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like BallVector,...">Display3D</a>:  <a href="structDGtal_1_1Display3DFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawWithDisplay3DModifier.html">DrawWithDisplay3DModifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class specifying the methods for classes which intend to modify a <a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a> stream.  <a href="structDGtal_1_1DrawWithDisplay3DModifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SetMode3D.html">SetMode3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifier class in a <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like BallVector,...">Display3D</a> stream. Useful to choose your own mode for a given class. Realizes the concept CDrawableWithDisplay3D.  <a href="structDGtal_1_1SetMode3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomStyle3D.html">CustomStyle3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifier class in a <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like BallVector,...">Display3D</a> stream. Useful to choose your own style for a given class. Realizes the concept CDrawableWithDisplay3D.  <a href="structDGtal_1_1CustomStyle3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomColors3D.html">CustomColors3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ClippingPlane.html">ClippingPlane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for adding a Clipping plane through the <a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a> stream. Realizes the concept CDrawableWithViewer3D.  <a href="structDGtal_1_1ClippingPlane.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TransformedPrism.html">TransformedPrism</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class to modify the position and scale to construct better illustration mode.  <a href="structDGtal_1_1TransformedPrism.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SetName3D.html">SetName3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SetSelectCallback3D.html">SetSelectCallback3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ITKIOTrait.html">ITKIOTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Provide type trait for ITK reader and ITK writer.  <a href="structDGtal_1_1ITKIOTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ITKIOTrait_3_01bool_01_4.html">ITKIOTrait&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DicomReader.html">DicomReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Import a 3D DICOM image from file series.  <a href="structDGtal_1_1DicomReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1GenericReader.html">GenericReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Provide a mechanism to load with the bestloader according to an image (2D or 3D) filename (by parsing the extension).  <a href="structDGtal_1_1GenericReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1GenericReader_3_01TContainer_00_013_00_01TValue_01_4.html">GenericReader&lt; TContainer, 3, TValue &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1GenericReader_3_01TContainer_00_013_00_01DGtal_1_1uint32__t_01_4.html">GenericReader&lt; TContainer, 3, DGtal::uint32_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1GenericReader_3_01TContainer_00_013_00_01DGtal_1_1uint64__t_01_4.html">GenericReader&lt; TContainer, 3, DGtal::uint64_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1GenericReader_3_01TContainer_00_012_00_01TValue_01_4.html">GenericReader&lt; TContainer, 2, TValue &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1GenericReader_3_01TContainer_00_012_00_01DGtal_1_1uint32__t_01_4.html">GenericReader&lt; TContainer, 2, DGtal::uint32_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1HDF5Reader.html">HDF5Reader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Import a HDF5 file.  <a href="structDGtal_1_1HDF5Reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ITKDicomReader.html">ITKDicomReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Import a 2D/3D DICOM <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> from file series.  <a href="structDGtal_1_1ITKDicomReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ITKReader.html">ITKReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Import a 2D/3D <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> using the ITK formats.  <a href="structDGtal_1_1ITKReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1LongvolReader.html">LongvolReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements methods to read a "Longvol" file format (with <a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5" title="unsigned 64-bit integer.">DGtal::uint64_t</a> value type).  <a href="structDGtal_1_1LongvolReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1MagickReader.html">MagickReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements methods to read a 2D image using the ImageMagick library.  <a href="structDGtal_1_1MagickReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1MeshReader.html">MeshReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defined to import OFF and OFS surface mesh. It allows to import a <a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces....">Mesh</a> object and takes into accouts the optional color faces.  <a href="structDGtal_1_1MeshReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1MPolynomialGrammar.html">MPolynomialGrammar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialReader.html">MPolynomialReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class converts a string polynomial expression in a multivariate polynomial.  <a href="classDGtal_1_1MPolynomialReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1PGMReader.html">PGMReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Import a 2D or 3D using the Netpbm formats (ASCII mode).  <a href="structDGtal_1_1PGMReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1PointListReader.html">PointListReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements method to read a set of points represented in each line of a file.  <a href="structDGtal_1_1PointListReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1PPMReader.html">PPMReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Import a 2D or 3D using the Netpbm formats (ASCII mode).  <a href="structDGtal_1_1PPMReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1RawReader.html">RawReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Raw binary import of an <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>.  <a href="structDGtal_1_1RawReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SurfaceMeshReader.html">SurfaceMeshReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: An helper class for reading mesh files (Wavefront OBJ at this point) and creating a <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a>.  <a href="structDGtal_1_1SurfaceMeshReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TableReader.html">TableReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements method to read a set of numbers represented in each line of a file.  <a href="structDGtal_1_1TableReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1VolReader.html">VolReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements methods to read a "Vol" file format.  <a href="structDGtal_1_1VolReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Style2DFactory.html">Style2DFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawWithViewer3DModifier.html">DrawWithViewer3DModifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class specifying the methods for classes which intend to modify a <a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a> stream.  <a href="structDGtal_1_1DrawWithViewer3DModifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UpdateImage3DEmbedding.html">UpdateImage3DEmbedding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class to modify the 3d embedding of the image (useful to display not only 2D slice images). The embdding can be explicitly given from the 3D position of the four bounding points.  <a href="structDGtal_1_1UpdateImage3DEmbedding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UpdateImagePosition.html">UpdateImagePosition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class to modify the position and orientation of an textured 2D image.  <a href="structDGtal_1_1UpdateImagePosition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1AddTextureImage2DWithFunctor.html">AddTextureImage2DWithFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class to insert a custom 2D textured image by using a conversion functor and allows to change the default mode (GrayScale mode) to color mode.  <a href="structDGtal_1_1AddTextureImage2DWithFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1AddTextureImage3DWithFunctor.html">AddTextureImage3DWithFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class to insert a custom 3D textured image by using a conversion functor and allows to change the default mode (GrayScale mode) to color mode.  <a href="structDGtal_1_1AddTextureImage3DWithFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UpdateLastImagePosition.html">UpdateLastImagePosition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class to modify the position and orientation of an textured 2D image.  <a href="structDGtal_1_1UpdateLastImagePosition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UpdateImageData.html">UpdateImageData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class to modify the data of an given image and also the possibility to translate it (optional).  <a href="structDGtal_1_1UpdateImageData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Translate2DDomain.html">Translate2DDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class to modify the data of an given image and also the possibility to translate it (optional).  <a href="structDGtal_1_1Translate2DDomain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Update2DDomainPosition.html">Update2DDomainPosition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class to modify the position and orientation of an 2D domain.  <a href="structDGtal_1_1Update2DDomainPosition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Viewer3DFactory.html">Viewer3DFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for GPL <a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a>:  <a href="structDGtal_1_1Viewer3DFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1GenericWriter.html">GenericWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Provide a mechanism to save image (2D or 3D) into file with the best saver loader according to an filename (by parsing the extension).  <a href="structDGtal_1_1GenericWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1GenericWriter_3_01TContainer_00_013_00_01unsigned_01char_00_01TFunctor_01_4.html">GenericWriter&lt; TContainer, 3, unsigned char, TFunctor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1GenericWriter_3_01TContainer_00_013_00_01DGtal_1_1uint64__t_00_01TFunctor_01_4.html">GenericWriter&lt; TContainer, 3, DGtal::uint64_t, TFunctor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1GenericWriter_3_01TContainer_00_013_00_01TValue_00_01TFunctor_01_4.html">GenericWriter&lt; TContainer, 3, TValue, TFunctor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1GenericWriter_3_01TContainer_00_012_00_01TValue_00_01TFunctor_01_4.html">GenericWriter&lt; TContainer, 2, TValue, TFunctor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1GenericWriter_3_01TContainer_00_012_00_01DGtal_1_1Color_00_01TFunctor_01_4.html">GenericWriter&lt; TContainer, 2, DGtal::Color, TFunctor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1GenericWriter_3_01TContainer_00_012_00_01unsigned_01char_00_01TFunctor_01_4.html">GenericWriter&lt; TContainer, 2, unsigned char, TFunctor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1HDF5Writer.html">HDF5Writer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Export an <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> with the HDF5 format.  <a href="structDGtal_1_1HDF5Writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ITKWriter.html">ITKWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export a 2D/3D <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> using the ITK formats.  <a href="structDGtal_1_1ITKWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ITKWriter_3_01ImageContainerByITKImage_3_01TDomain_00_01TValue_01_4_00_01TFunctor_01_4.html">ITKWriter&lt; ImageContainerByITKImage&lt; TDomain, TValue &gt;, TFunctor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1LongvolWriter.html">LongvolWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Export a 3D <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> using the Longvol formats (volumetric image with <a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5" title="unsigned 64-bit integer.">DGtal::uint64_t</a> value type).  <a href="structDGtal_1_1LongvolWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1MagickWriter.html">MagickWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Export image using Imagemagick backend.  <a href="structDGtal_1_1MagickWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1MeshWriter.html">MeshWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Export a <a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces....">Mesh</a> (<a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces....">Mesh</a> object) in different format as OFF and OBJ).  <a href="structDGtal_1_1MeshWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1PGMWriter.html">PGMWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Export a 2D and a 3D <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> using the Netpbm PGM formats (ASCII mode).  <a href="structDGtal_1_1PGMWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1PPMWriter.html">PPMWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Export a 2D and a 3D <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> using the Netpbm PPM formats (ASCII mode).  <a href="structDGtal_1_1PPMWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1RawWriter.html">RawWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Raw binary export of an <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>.  <a href="structDGtal_1_1RawWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SurfaceMeshWriter.html">SurfaceMeshWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: An helper class for writing mesh file formats (Waverfront OBJ at this point) and creating a <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a>.  <a href="structDGtal_1_1SurfaceMeshWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1VolWriter.html">VolWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Export a 3D <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> using the Vol formats.  <a href="structDGtal_1_1VolWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ArithmeticConversionTraits.html">ArithmeticConversionTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Trait class to get result type of arithmetic binary operators between two given types.  <a href="structDGtal_1_1ArithmeticConversionTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ArithmeticConversionTraits_3_01T_00_01U_00_01typename_01std_1_1enable__if_3_01_9_25eb7aff75c55bf534e325120cc74d30.html">ArithmeticConversionTraits&lt; T, U, typename std::enable_if&lt; ! std::is_same&lt; T, typename std::remove_cv&lt; typename std::remove_reference&lt; T &gt;::type &gt;::type &gt;::value||! std::is_same&lt; U, typename std::remove_cv&lt; typename std::remove_reference&lt; U &gt;::type &gt;::type &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization in order to remove const specifiers and references from given types.  <a href="structDGtal_1_1ArithmeticConversionTraits_3_01T_00_01U_00_01typename_01std_1_1enable__if_3_01_9_25eb7aff75c55bf534e325120cc74d30.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ArithmeticConversionTraits_3_01T_00_01U_00_01typename_01std_1_1enable__if_3_01std2787cbba3903f94501b19c9830eb81d4.html">ArithmeticConversionTraits&lt; T, U, typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value &amp;&amp;std::is_arithmetic&lt; U &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for (fundamental) arithmetic types.  <a href="structDGtal_1_1ArithmeticConversionTraits_3_01T_00_01U_00_01typename_01std_1_1enable__if_3_01std2787cbba3903f94501b19c9830eb81d4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsArithmeticConversionValid.html">IsArithmeticConversionValid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to determine if an arithmetic operation between two given types has a valid result type (ie is valid).  <a href="structDGtal_1_1IsArithmeticConversionValid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsArithmeticConversionValid_3_01T_00_01U_00_01typename_01std_1_1conditional_3_01f3d12afaad57391e67b8a4fff74de6483.html">IsArithmeticConversionValid&lt; T, U, typename std::conditional&lt; false, ArithmeticConversionType&lt; T, U &gt;, void &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization when arithmetic operation between the two given type is valid.  <a href="structDGtal_1_1IsArithmeticConversionValid_3_01T_00_01U_00_01typename_01std_1_1conditional_3_01f3d12afaad57391e67b8a4fff74de6483.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ArithmeticConversionTraits_3_01T_00_01____gmp__expr_3_01GMP1_00_01GMP2_01_4_00_0133a16a4dabbd5969379c467370a1b33e.html">ArithmeticConversionTraits&lt; T, __gmp_expr&lt; GMP1, GMP2 &gt;, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization when first operand is a <a class="el" href="namespaceDGtal.html#ad14cde66089fcbdefb20c819562d2a0d">BigInteger</a>.  <a href="structDGtal_1_1ArithmeticConversionTraits_3_01T_00_01____gmp__expr_3_01GMP1_00_01GMP2_01_4_00_0133a16a4dabbd5969379c467370a1b33e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ArithmeticConversionTraits_3_01____gmp__expr_3_01GMP1_00_01GMP2_01_4_00_01U_00_01b7e75f2d4577aabc7b63b093e79af931.html">ArithmeticConversionTraits&lt; __gmp_expr&lt; GMP1, GMP2 &gt;, U, typename std::enable_if&lt; std::is_integral&lt; U &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization when second operand is a <a class="el" href="namespaceDGtal.html#ad14cde66089fcbdefb20c819562d2a0d">BigInteger</a>.  <a href="structDGtal_1_1ArithmeticConversionTraits_3_01____gmp__expr_3_01GMP1_00_01GMP2_01_4_00_01U_00_01b7e75f2d4577aabc7b63b093e79af931.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ArithmeticConversionTraits_3_01____gmp__expr_3_01GMPL1_00_01GMPL2_01_4_00_01____g3f293f408150e028b5eeaf2ad0f0698b.html">ArithmeticConversionTraits&lt; __gmp_expr&lt; GMPL1, GMPL2 &gt;, __gmp_expr&lt; GMPR1, GMPR2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization when both operands are <a class="el" href="namespaceDGtal.html#ad14cde66089fcbdefb20c819562d2a0d">BigInteger</a>.  <a href="structDGtal_1_1ArithmeticConversionTraits_3_01____gmp__expr_3_01GMPL1_00_01GMPL2_01_4_00_01____g3f293f408150e028b5eeaf2ad0f0698b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CanonicEmbedder.html">CanonicEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A trivial embedder for digital points, which corresponds to the canonic injection of Zn into Rn.  <a href="structDGtal_1_1CanonicEmbedder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1HyperRectDomain.html">HyperRectDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Parallelepidec region of a digital space, model of a 'CDomain'.  <a href="classDGtal_1_1HyperRectDomain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1HyperRectDomain__ReverseIterator.html">HyperRectDomain_ReverseIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator for <a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a>.  <a href="classDGtal_1_1HyperRectDomain__ReverseIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1HyperRectDomain__Iterator.html">HyperRectDomain_Iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for <a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a>.  <a href="classDGtal_1_1HyperRectDomain__Iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1HyperRectDomain__subIterator.html">HyperRectDomain_subIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1RowMajorStorage.html">RowMajorStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag (empty structure) specifying a row-major storage order.  <a href="structDGtal_1_1RowMajorStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ColMajorStorage.html">ColMajorStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag (empty structure) specifying a col-major storage order.  <a href="structDGtal_1_1ColMajorStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Linearizer.html">Linearizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Linearization and de-linearization interface for domains.  <a href="structDGtal_1_1Linearizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Linearizer_3_01HyperRectDomain_3_01TSpace_01_4_00_01TStorageOrder_01_4.html">Linearizer&lt; HyperRectDomain&lt; TSpace &gt;, TStorageOrder &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Linearization and de-linearization interface for <a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a>.  <a href="structDGtal_1_1Linearizer_3_01HyperRectDomain_3_01TSpace_01_4_00_01TStorageOrder_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IntegerConverter.html">IntegerConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">----------&mdash; INTEGER/POINT CONVERSION SERVICES -----------------&mdash;  <a href="structDGtal_1_1IntegerConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IntegerConverter_3_01dim_00_01DGtal_1_1int32__t_01_4.html">IntegerConverter&lt; dim, DGtal::int32_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IntegerConverter_3_01dim_00_01DGtal_1_1int64__t_01_4.html">IntegerConverter&lt; dim, DGtal::int64_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IntegerConverter_3_01dim_00_01DGtal_1_1BigInteger_01_4.html">IntegerConverter&lt; dim, DGtal::BigInteger &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1LinearAlgebra.html">LinearAlgebra</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A utility class that contains methods to perform integral linear algebra.  <a href="structDGtal_1_1LinearAlgebra.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraitsImpl.html">NumberTraitsImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The traits class for all models of Cinteger (implementation)  <a href="structDGtal_1_1NumberTraitsImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraitsImpl_3_01T_00_01typename_01std_1_1enable__if_3_01std_1_1is__integral_1ce5c08ef142b54c10962f6a14786276.html">NumberTraitsImpl&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structDGtal_1_1NumberTraitsImpl.html" title="Aim: The traits class for all models of Cinteger (implementation)">NumberTraitsImpl</a> for fundamental integer types.  <a href="structDGtal_1_1NumberTraitsImpl_3_01T_00_01typename_01std_1_1enable__if_3_01std_1_1is__integral_1ce5c08ef142b54c10962f6a14786276.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraitsImpl_3_01T_00_01typename_01std_1_1enable__if_3_01std_1_1is__floating_29bbe2652e6d58e33f41f614fd754864.html">NumberTraitsImpl&lt; T, typename std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structDGtal_1_1NumberTraitsImpl.html" title="Aim: The traits class for all models of Cinteger (implementation)">NumberTraitsImpl</a> for fundamental floating-point types.  <a href="structDGtal_1_1NumberTraitsImpl_3_01T_00_01typename_01std_1_1enable__if_3_01std_1_1is__floating_29bbe2652e6d58e33f41f614fd754864.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraitsImpl_3_01DGtal_1_1BigInteger_00_01Enable_01_4.html">NumberTraitsImpl&lt; DGtal::BigInteger, Enable &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structDGtal_1_1NumberTraitsImpl.html" title="Aim: The traits class for all models of Cinteger (implementation)">NumberTraitsImpl</a> for <a class="el" href="namespaceDGtal.html#ad14cde66089fcbdefb20c819562d2a0d" title="Multi-precision integer with GMP implementation.">DGtal::BigInteger</a>.  <a href="structDGtal_1_1NumberTraitsImpl_3_01DGtal_1_1BigInteger_00_01Enable_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits.html">NumberTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The traits class for all models of Cinteger.  <a href="structDGtal_1_1NumberTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Warning__promote__trait__not__specialized__for__this__case.html">Warning_promote_trait_not_specialized_for_this_case</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1promote__trait.html">promote_trait</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1promote__trait_3_01int32__t_00_01int64__t_01_4.html">promote_trait&lt; int32_t, int64_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements basic operations that will be used in Point and Vector classes.  <a href="classDGtal_1_1PointVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsAPointVector.html">IsAPointVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a given type is a <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>.  <a href="structDGtal_1_1IsAPointVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsAPointVector_3_01PointVector_3_01dim_00_01TEuclideanRing_00_01TContainer_01_4_01_4.html">IsAPointVector&lt; PointVector&lt; dim, TEuclideanRing, TContainer &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structDGtal_1_1IsAPointVector.html">IsAPointVector</a> for a <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>.  <a href="structDGtal_1_1IsAPointVector_3_01PointVector_3_01dim_00_01TEuclideanRing_00_01TContainer_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ArithmeticConversionTraits_3_01PointVector_3_01dim_00_01LeftEuclideanRing_00_01Lea2d6c81d8c48156a1bdb04d6a31b2c2e.html">ArithmeticConversionTraits&lt; PointVector&lt; dim, LeftEuclideanRing, LeftContainer &gt;, PointVector&lt; dim, RightEuclideanRing, RightContainer &gt;, typename std::enable_if&lt; IsArithmeticConversionValid&lt; LeftEuclideanRing, RightEuclideanRing &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structDGtal_1_1ArithmeticConversionTraits.html">ArithmeticConversionTraits</a> when both operands are <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>.  <a href="structDGtal_1_1ArithmeticConversionTraits_3_01PointVector_3_01dim_00_01LeftEuclideanRing_00_01Lea2d6c81d8c48156a1bdb04d6a31b2c2e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ArithmeticConversionTraits_3_01PointVector_3_01dim_00_01LeftEuclideanRing_00_01Lefee31e8ea496a9030cd45ee96b9b299b.html">ArithmeticConversionTraits&lt; PointVector&lt; dim, LeftEuclideanRing, LeftContainer &gt;, RightEuclideanRing, typename std::enable_if&lt; IsArithmeticConversionValid&lt; LeftEuclideanRing, RightEuclideanRing &gt;::value &amp;&amp;! IsAPointVector&lt; RightEuclideanRing &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structDGtal_1_1ArithmeticConversionTraits.html">ArithmeticConversionTraits</a> when left operand is a <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>.  <a href="structDGtal_1_1ArithmeticConversionTraits_3_01PointVector_3_01dim_00_01LeftEuclideanRing_00_01Lefee31e8ea496a9030cd45ee96b9b299b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ArithmeticConversionTraits_3_01LeftEuclideanRing_00_01PointVector_3_01dim_00_01Ribf6ad7e141184df67feec87dc4b91b9f.html">ArithmeticConversionTraits&lt; LeftEuclideanRing, PointVector&lt; dim, RightEuclideanRing, RightContainer &gt;, typename std::enable_if&lt; IsArithmeticConversionValid&lt; LeftEuclideanRing, RightEuclideanRing &gt;::value &amp;&amp;! IsAPointVector&lt; LeftEuclideanRing &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structDGtal_1_1ArithmeticConversionTraits.html">ArithmeticConversionTraits</a> when right operand is a <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>.  <a href="structDGtal_1_1ArithmeticConversionTraits_3_01LeftEuclideanRing_00_01PointVector_3_01dim_00_01Ribf6ad7e141184df67feec87dc4b91b9f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1RegularPointEmbedder.html">RegularPointEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A simple point embedder where grid steps are given for each axis. Note that the real point (0,...,0) is mapped onto the digital point (0,...,0).  <a href="classDGtal_1_1RegularPointEmbedder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSetByAssociativeContainer.html">DigitalSetByAssociativeContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A wrapper class around a STL associative container for storing sets of digital points within some given domain.  <a href="classDGtal_1_1DigitalSetByAssociativeContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html">DigitalSetBySTLSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A container class for storing sets of digital points within some given domain.  <a href="classDGtal_1_1DigitalSetBySTLSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSetBySTLVector.html">DigitalSetBySTLVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Realizes the concept CDigitalSet by using the STL container std::vector.  <a href="classDGtal_1_1DigitalSetBySTLVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DigitalSetConverter.html">DigitalSetConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Utility class to convert between types of sets.  <a href="structDGtal_1_1DigitalSetConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSetDomain.html">DigitalSetDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Constructs a domain limited to the given digital set.  <a href="classDGtal_1_1DigitalSetDomain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSetFromMap.html">DigitalSetFromMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: An adapter for viewing an associative image container like <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> as a simple digital set. This class is merely based on an aliasing pointer on the image, which must exists elsewhere. <br  />
  <a href="classDGtal_1_1DigitalSetFromMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSetInserter.html">DigitalSetInserter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: this output iterator class is designed to allow algorithms to insert points in the digital set. Using the assignment operator, even when dereferenced, causes the digital set to insert a point.  <a href="classDGtal_1_1DigitalSetInserter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DigitalSetSelector.html">DigitalSetSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Automatically defines an adequate digital set type according to the hints given by the user.  <a href="structDGtal_1_1DigitalSetSelector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SpaceND.html">SpaceND</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Splitter.html">Splitter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">UnorderedSetByBlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1AngleComputer.html">AngleComputer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1AngleLinearMinimizer.html">AngleLinearMinimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Used to minimize the angle variation between different angles while taking into accounts min and max constraints. Example (.  <a href="classDGtal_1_1AngleLinearMinimizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1AngleLinearMinimizerByRelaxation.html">AngleLinearMinimizerByRelaxation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1AngleLinearMinimizerByGradientDescent.html">AngleLinearMinimizerByGradientDescent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1AngleLinearMinimizerByAdaptiveStepGradientDescent.html">AngleLinearMinimizerByAdaptiveStepGradientDescent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1RegularBinner.html">RegularBinner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents an elementary functor that partitions quantities into regular intervals, given a range [<em>min</em>,<em>max</em>] range and a number <em>nb</em> of intervals (each interval is called a bin).  <a href="structDGtal_1_1RegularBinner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Histogram.html">Histogram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a typical histogram in statistics, which is a discrete estimate of the probability distribution of a continuous variable.  <a href="classDGtal_1_1Histogram.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1EigenDecomposition.html">EigenDecomposition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class provides methods to compute the eigen decomposition of a matrix. Its objective is to replace a specialized matrix library when none are available.  <a href="classDGtal_1_1EigenDecomposition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1EigenLinearAlgebraBackend.html">EigenLinearAlgebraBackend</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Provide linear algebra backend using Eigen dense and sparse matrix as well as dense vector. 6 linear solvers available:  <a href="structDGtal_1_1EigenLinearAlgebraBackend.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SimpleMatrix.html">SimpleMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements basic MxN Matrix services (M,N&gt;=1).  <a href="classDGtal_1_1SimpleMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SimpleMatrixSpecializations.html">SimpleMatrixSpecializations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implement internal matrix services for specialized matrix size.  <a href="structDGtal_1_1SimpleMatrixSpecializations.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SimpleMatrixSpecializations_3_01TMatrix_00_012_00_012_01_4.html">SimpleMatrixSpecializations&lt; TMatrix, 2, 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="structDGtal_1_1SimpleMatrixSpecializations_3_01TMatrix_00_012_00_012_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SimpleMatrixSpecializations_3_01TMatrix_00_011_00_011_01_4.html">SimpleMatrixSpecializations&lt; TMatrix, 1, 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="structDGtal_1_1SimpleMatrixSpecializations_3_01TMatrix_00_011_00_011_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SimpleMatrixSpecializations_3_01TMatrix_00_013_00_013_01_4.html">SimpleMatrixSpecializations&lt; TMatrix, 3, 3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="structDGtal_1_1SimpleMatrixSpecializations_3_01TMatrix_00_013_00_013_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MeaningfulScaleAnalysis.html">MeaningfulScaleAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class implements different methods used to define the meaningful scale analysis as proposed in <a class="el" href="citelist.html#CITEREF_kerautret_meaningful_2012">[55]</a> . In particular, it uses the <a class="el" href="classDGtal_1_1Profile.html" title="Aim: This class can be used to represent a profile (PX, PY) defined from an input set of samples (Xi,...">Profile</a> class to represent a multi-scale profile and to compute a meaningful scale. It also permits to get a noise estimation from the given profile.  <a href="classDGtal_1_1MeaningfulScaleAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MeasureOfStraightLines.html">MeasureOfStraightLines</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The aim of this class is to compute the measure in the Lebesgues sense of the set of straight lines associated to domains defined as polygons in the (a,b)-parameter space. This parameter space maps the line $ax-y+b=0$ to the point $(a,b)$.  <a href="classDGtal_1_1MeasureOfStraightLines.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a multivariate polynomial, i.e. an element of \( K[X_0, ..., X_{n-1}] \), where <em>K</em> is some ring or field.  <a href="classDGtal_1_1MPolynomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialDerivativeComputer.html">MPolynomialDerivativeComputer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialEvaluator.html">MPolynomialEvaluator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialEvaluatorImpl.html">MPolynomialEvaluatorImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialEvaluatorImpl_3_011_00_01TRing_00_01TOwner_00_01TAlloc_00_01TX_01_4.html">MPolynomialEvaluatorImpl&lt; 1, TRing, TOwner, TAlloc, TX &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialEvaluator_3_011_00_01TRing_00_01TAlloc_00_01TX_01_4.html">MPolynomialEvaluator&lt; 1, TRing, TAlloc, TX &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomial_3_010_00_01TRing_00_01TAlloc_01_4.html">MPolynomial&lt; 0, TRing, TAlloc &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Specialization of <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field.">MPolynomial</a> for degree 0.  <a href="classDGtal_1_1MPolynomial_3_010_00_01TRing_00_01TAlloc_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IVector.html">IVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IVector_3_01T_00_01TAlloc_00_01true_01_4.html">IVector&lt; T, TAlloc, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Xe__kComputer.html">Xe_kComputer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Xe__kComputer_3_010_00_01Ring_00_01Alloc_01_4.html">Xe_kComputer&lt; 0, Ring, Alloc &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialDerivativeComputer_3_010_00_01n_00_01Ring_00_01Alloc_01_4.html">MPolynomialDerivativeComputer&lt; 0, n, Ring, Alloc &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialDerivativeComputer_3_010_00_010_00_01Ring_00_01Alloc_01_4.html">MPolynomialDerivativeComputer&lt; 0, 0, Ring, Alloc &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialDerivativeComputer_3_01N_00_010_00_01Ring_00_01Alloc_01_4.html">MPolynomialDerivativeComputer&lt; N, 0, Ring, Alloc &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MultiStatistics.html">MultiStatistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class stores a set of sample values for several variables and can then compute different statistics, like sample mean, sample variance, sample unbiased variance, etc.  <a href="classDGtal_1_1MultiStatistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1OrderedLinearRegression.html">OrderedLinearRegression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of class '<a class="el" href="classDGtal_1_1OrderedLinearRegression.html" title="Description of class &#39;OrderedLinearRegression&#39;.">OrderedLinearRegression</a>'.  <a href="classDGtal_1_1OrderedLinearRegression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Profile.html">Profile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class can be used to represent a profile (PX, PY) defined from an input set of samples (Xi, Yi). For all sample (Xk, Yk) having the same value Xk, the associated value PY is computed (by default) by the mean of the values Yk. Note that other definitions can be used (MAX, MIN or MEDIAN). Internally each sample abscissa is an instance of <a class="el" href="classDGtal_1_1Statistic.html" title="Aim: This class processes a set of sample values for one variable and can then compute different stat...">DGtal::Statistic</a>.  <a href="classDGtal_1_1Profile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1RealFFT_3_01HyperRectDomain_3_01TSpace_01_4_00_01T_01_4.html">RealFFT&lt; HyperRectDomain&lt; TSpace &gt;, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SignalData.html">SignalData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Signal.html">Signal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a discrete signal, periodic or not. The signal can be passed by value since it is only cloned when modified.  <a href="classDGtal_1_1Signal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SimpleLinearRegression.html">SimpleLinearRegression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of class '<a class="el" href="classDGtal_1_1SimpleLinearRegression.html" title="Description of class &#39;SimpleLinearRegression&#39;.">SimpleLinearRegression</a>'.  <a href="classDGtal_1_1SimpleLinearRegression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Statistic.html">Statistic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class processes a set of sample values for one variable and can then compute different statistics, like sample mean, sample variance, sample unbiased variance, etc. It is minimalistic for space efficiency. For multiple variables, sample storage and others, see Statistics class.  <a href="classDGtal_1_1Statistic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalShapesCSG.html">DigitalShapesCSG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Constructive Solid Geometry (CSG) between models of CDigitalBoundedShape and CDigitalOrientedShape Use CSG operation (union, intersection, minus) from a shape of Type ShapeA with one (or more) shapes of Type ShapeB. Can combine differents operations. Limitations: Since we don't have a class derived by all shapes, operations can be done by only one type of shapes. Use CSG of CSG to go beyond this limitation.  <a href="classDGtal_1_1DigitalShapesCSG.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1EuclideanShapesCSG.html">EuclideanShapesCSG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Constructive Solid Geometry (CSG) between models of CEuclideanBoundedShape and CEuclideanOrientedShape Use CSG operation (union, intersection, minus) from a shape of Type ShapeA with one (or more) shapes of Type ShapeB. Can combine differents operations. Limitations: Since we don't have a class derived by all shapes, operations can be done by only one type of shapes. Use CSG of CSG to go beyond this limitation.  <a href="classDGtal_1_1EuclideanShapesCSG.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CircleFrom2Points.html">CircleFrom2Points</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a circle that passes through a given point and that is thus uniquely defined by two other points. It is able to return for any given point its signed distance to itself.  <a href="classDGtal_1_1CircleFrom2Points.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CircleFrom3Points.html">CircleFrom3Points</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a circle uniquely defined by three 2D points and that is able to return for any given 2D point its signed distance to itself.  <a href="classDGtal_1_1CircleFrom3Points.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1StraightLineFrom2Points.html">StraightLineFrom2Points</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a straight line uniquely defined by two 2D points and that is able to return for any given 2D point its signed distance to itself.  <a href="classDGtal_1_1StraightLineFrom2Points.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GaussDigitizer.html">GaussDigitizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A class for computing the Gauss digitization of some Euclidean shape, i.e. its intersection with some \( h_1 Z \times h_2 Z \times \cdots \times h_n Z \). Note that the real point (0,...,0) is mapped onto the digital point (0,...,0).  <a href="classDGtal_1_1GaussDigitizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitBall.html">ImplicitBall</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create a ball in nD..  <a href="classDGtal_1_1ImplicitBall.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitFunctionDiff1LinearCellEmbedderGradientMap.html">ImplicitFunctionDiff1LinearCellEmbedderGradientMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="classDGtal_1_1ImplicitFunctionDiff1LinearCellEmbedderGradientMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitFunctionDiff1LinearCellEmbedder.html">ImplicitFunctionDiff1LinearCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a cellular embedder for implicit functions, (default constructible, copy constructible, assignable). Model of CCellEmbedder and CWithGradientMap.  <a href="classDGtal_1_1ImplicitFunctionDiff1LinearCellEmbedder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitFunctionLinearCellEmbedder.html">ImplicitFunctionLinearCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a cellular embedder for implicit functions, (default constructible, copy constructible, assignable). Model of CCellEmbedder.  <a href="classDGtal_1_1ImplicitFunctionLinearCellEmbedder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitHyperCube.html">ImplicitHyperCube</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create an hypercube in nD..  <a href="classDGtal_1_1ImplicitHyperCube.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitNorm1Ball.html">ImplicitNorm1Ball</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create a ball for the L_1 norm in nD.  <a href="classDGtal_1_1ImplicitNorm1Ball.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitPolynomial3Shape.html">ImplicitPolynomial3Shape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of CEuclideanOrientedShape concepts to create a shape from a polynomial.  <a href="classDGtal_1_1ImplicitPolynomial3Shape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitRoundedHyperCube.html">ImplicitRoundedHyperCube</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create a rounded hypercube in nD..  <a href="classDGtal_1_1ImplicitRoundedHyperCube.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IntersectionTargetTrait.html">IntersectionTargetTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A class for intersection target used for voxelization.  <a href="structDGtal_1_1IntersectionTargetTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Mesh.html">Mesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is defined to represent a surface mesh through a set of vertices and faces. By using the default constructor, the mesh does not store any color information (it can be changed by setting the default constructor parameter saveFaceColor to 'true').  <a href="classDGtal_1_1Mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MeshHelpers.html">MeshHelpers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Static class that provides builder and converters between meshes.  <a href="classDGtal_1_1MeshHelpers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MeshVoxelizer.html">MeshVoxelizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A class for computing the digitization of a triangle or a <a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces....">Mesh</a>.  <a href="classDGtal_1_1MeshVoxelizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1AccFlower2D.html">AccFlower2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept StarShaped represents any accelerated flower in the plane.  <a href="classDGtal_1_1AccFlower2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Astroid2D.html">Astroid2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept StarShaped represents an astroid.  <a href="classDGtal_1_1Astroid2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Ball2D.html">Ball2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept StarShaped represents any circle in the plane.  <a href="classDGtal_1_1Ball2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Ball3D.html">Ball3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept <a class="el" href="classDGtal_1_1StarShaped3D.html">StarShaped3D</a> represents any Sphere in the space.  <a href="classDGtal_1_1Ball3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Ellipse2D.html">Ellipse2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept StarShaped represents any ellipse in the plane.  <a href="classDGtal_1_1Ellipse2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Flower2D.html">Flower2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept StarShaped represents any flower with k-petals in the plane.  <a href="classDGtal_1_1Flower2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Lemniscate2D.html">Lemniscate2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept StarShaped represents a lemniscate.  <a href="classDGtal_1_1Lemniscate2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1NGon2D.html">NGon2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept StarShaped represents any regular k-gon in the plane.  <a href="classDGtal_1_1NGon2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1StarShaped2D.html">StarShaped2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1StarShaped3D.html">StarShaped3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1PolygonalSurface.html">PolygonalSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a polygon mesh, i.e. a 2-dimensional combinatorial surface whose faces are (topologically at least) simple polygons. The topology is stored with a half-edge data structure. This object stored the positions of vertices in space. If you need further data attached to the surface, you may use property maps (see <code><a class="el" href="classDGtal_1_1PolygonalSurface.html#a2f4a7d1871b0a4b487b01c2b12ddc671">PolygonalSurface::makeVertexMap</a></code>).  <a href="classDGtal_1_1PolygonalSurface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Shapes.html">Shapes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A utility class for constructing different shapes (balls, diamonds, and others).  <a href="classDGtal_1_1Shapes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SurfaceMesh.html">SurfaceMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces but no specific topology is required. However, you also have methods to navigate between neighbor vertices, faces, etc. The mesh can be equipped with normals at faces and/or vertices.  <a href="structDGtal_1_1SurfaceMesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SurfaceMeshHelper.html">SurfaceMeshHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: An helper class for building classical meshes.  <a href="structDGtal_1_1SurfaceMeshHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TriangulatedSurface.html">TriangulatedSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a triangulated surface. The topology is stored with a half-edge data structure. This object stored the positions of vertices in space. If you need further data attached to the surface, you may use property maps (see <code><a class="el" href="classDGtal_1_1TriangulatedSurface.html#ab35510ce21e2e7885a49b947c0bdb112">TriangulatedSurface::makeVertexMap</a></code>).  <a href="classDGtal_1_1TriangulatedSurface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CanonicCellEmbedder.html">CanonicCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A trivial embedder for signed and unsigned cell, which corresponds to the canonic injection of cell centroids into Rn.  <a href="structDGtal_1_1CanonicCellEmbedder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CanonicDigitalSurfaceEmbedder.html">CanonicDigitalSurfaceEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A trivial embedder for digital surfaces, which corresponds to the canonic injection of cell centroids into Rn.  <a href="structDGtal_1_1CanonicDigitalSurfaceEmbedder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CanonicSCellEmbedder.html">CanonicSCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A trivial embedder for signed cell, which corresponds to the canonic injection of cell centroids into Rn.  <a href="structDGtal_1_1CanonicSCellEmbedder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CubicalCellData.html">CubicalCellData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class represents an arbitrary cubical complex living in some Khalimsky space. Cubical complexes are sets of cells of different dimensions related together with incidence relations. Two cells in a cubical complex are incident if and only if they are incident in the surrounding Khalimsky space. In other words, cubical complexes are defined here as subsets of Khalimsky spaces.  <a href="classDGtal_1_1CubicalComplex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ContainerTraits_3_01CubicalComplex_3_01TKSpace_00_01TCellContainer_01_4_01_4.html">ContainerTraits&lt; CubicalComplex&lt; TKSpace, TCellContainer &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSetBoundary.html">DigitalSetBoundary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of a given digital set.  <a href="classDGtal_1_1DigitalSetBoundary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSurface.html">DigitalSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cells. Therefore, a digital surface is a pure cubical complex (model of CCubicalComplex), made of k-cells, 0 &lt;= k &lt; n. This complex is generally not a manifold (i.e. a kind of surface), except when it has the property of being well-composed.  <a href="classDGtal_1_1DigitalSurface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSurface2DSlice.html">DigitalSurface2DSlice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a 2-dimensional slice in a <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>. In a sense, it is a 4-connected contour, open or not. To be valid, it must be connected to some digital surface and a starting surfel.  <a href="classDGtal_1_1DigitalSurface2DSlice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalTopology.html">DigitalTopology</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a digital topology as a couple of adjacency relations.  <a href="classDGtal_1_1DigitalTopology.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DigitalTopologyTraits.html">DigitalTopologyTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: the traits classes for <a class="el" href="classDGtal_1_1DigitalTopology.html" title="Aim: Represents a digital topology as a couple of adjacency relations.">DigitalTopology</a> types.  <a href="structDGtal_1_1DigitalTopologyTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DigitalTopologyTraits_3_01MetricAdjacency_3_01TSpace_00_011_01_4_00_01MetricAdjac06cfee9ede448beddab595341bf8da45.html">DigitalTopologyTraits&lt; MetricAdjacency&lt; TSpace, 1 &gt;, MetricAdjacency&lt; TSpace, 2 &gt;, 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Specialization of the traits classes for <a class="el" href="classDGtal_1_1DigitalTopology.html" title="Aim: Represents a digital topology as a couple of adjacency relations.">DigitalTopology</a> types for any 2D Space, for topology (4,8).  <a href="structDGtal_1_1DigitalTopologyTraits_3_01MetricAdjacency_3_01TSpace_00_011_01_4_00_01MetricAdjac06cfee9ede448beddab595341bf8da45.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DigitalTopologyTraits_3_01MetricAdjacency_3_01TSpace_00_012_01_4_00_01MetricAdjac201c1779eb2f50e0034539cb53f56f01.html">DigitalTopologyTraits&lt; MetricAdjacency&lt; TSpace, 2 &gt;, MetricAdjacency&lt; TSpace, 1 &gt;, 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Specialization of the traits classes for <a class="el" href="classDGtal_1_1DigitalTopology.html" title="Aim: Represents a digital topology as a couple of adjacency relations.">DigitalTopology</a> types for any 2D Space, for topology (8,4).  <a href="structDGtal_1_1DigitalTopologyTraits_3_01MetricAdjacency_3_01TSpace_00_012_01_4_00_01MetricAdjac201c1779eb2f50e0034539cb53f56f01.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DigitalTopologyTraits_3_01MetricAdjacency_3_01TSpace_00_011_01_4_00_01MetricAdjacde3734735d1eccc5fbf7d6f7325c8d5f.html">DigitalTopologyTraits&lt; MetricAdjacency&lt; TSpace, 1 &gt;, MetricAdjacency&lt; TSpace, 3 &gt;, 3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Specialization of the traits classes for <a class="el" href="classDGtal_1_1DigitalTopology.html" title="Aim: Represents a digital topology as a couple of adjacency relations.">DigitalTopology</a> types for any 2D Space, for topology (6,26).  <a href="structDGtal_1_1DigitalTopologyTraits_3_01MetricAdjacency_3_01TSpace_00_011_01_4_00_01MetricAdjacde3734735d1eccc5fbf7d6f7325c8d5f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DigitalTopologyTraits_3_01MetricAdjacency_3_01TSpace_00_011_01_4_00_01MetricAdjac75a65f102d2af20aaa2508a722cd03c0.html">DigitalTopologyTraits&lt; MetricAdjacency&lt; TSpace, 1 &gt;, MetricAdjacency&lt; TSpace, 2 &gt;, 3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Specialization of the traits classes for <a class="el" href="classDGtal_1_1DigitalTopology.html" title="Aim: Represents a digital topology as a couple of adjacency relations.">DigitalTopology</a> types for any 2D Space, for topology (6,18).  <a href="structDGtal_1_1DigitalTopologyTraits_3_01MetricAdjacency_3_01TSpace_00_011_01_4_00_01MetricAdjac75a65f102d2af20aaa2508a722cd03c0.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DigitalTopologyTraits_3_01MetricAdjacency_3_01TSpace_00_012_01_4_00_01MetricAdjac295bf7f227800ad6435fcd18401c4237.html">DigitalTopologyTraits&lt; MetricAdjacency&lt; TSpace, 2 &gt;, MetricAdjacency&lt; TSpace, 1 &gt;, 3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Specialization of the traits classes for <a class="el" href="classDGtal_1_1DigitalTopology.html" title="Aim: Represents a digital topology as a couple of adjacency relations.">DigitalTopology</a> types for any 2D Space, for topology (18,6).  <a href="structDGtal_1_1DigitalTopologyTraits_3_01MetricAdjacency_3_01TSpace_00_012_01_4_00_01MetricAdjac295bf7f227800ad6435fcd18401c4237.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DigitalTopologyTraits_3_01MetricAdjacency_3_01TSpace_00_013_01_4_00_01MetricAdjac1853805a85cff1808e38908d0ecd7d1b.html">DigitalTopologyTraits&lt; MetricAdjacency&lt; TSpace, 3 &gt;, MetricAdjacency&lt; TSpace, 1 &gt;, 3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Specialization of the traits classes for <a class="el" href="classDGtal_1_1DigitalTopology.html" title="Aim: Represents a digital topology as a couple of adjacency relations.">DigitalTopology</a> types for any 2D Space, for topology (26,6).  <a href="structDGtal_1_1DigitalTopologyTraits_3_01MetricAdjacency_3_01TSpace_00_013_01_4_00_01MetricAdjac1853805a85cff1808e38908d0ecd7d1b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DomainAdjacency.html">DomainAdjacency</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Given a domain and an adjacency, limits the given adjacency to the specified domain for all adjacency and neighborhood computations.  <a href="classDGtal_1_1DomainAdjacency.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html">ExplicitDigitalSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels. The shape is determined by a predicate telling whether a given surfel belongs or not to the shape boundary. Compute once the boundary of the surface with a tracking.  <a href="classDGtal_1_1ExplicitDigitalSurface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1HalfEdgeDataStructure.html">HalfEdgeDataStructure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class represents an half-edge data structure, which is a structure for representing the topology of a combinatorial 2-dimensional surface or an embedding of a planar graph in the plane. It does not store any geometry. As a minimal example, these lines of code build two triangles connected by the edge {1,2}.  <a href="classDGtal_1_1HalfEdgeDataStructure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A utility class for constructing surfaces (i.e. set of (n-1)-cells).  <a href="classDGtal_1_1Surfaces.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html">ImplicitDigitalSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an implicitly define shape. Compute once the boundary of the surface with a tracking.  <a href="classDGtal_1_1ImplicitDigitalSurface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html">IndexedDigitalSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a digital surface with the topology of its dual surface. Its aim is to mimick the standard <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>, but to optimize its traversal and topology services. The idea is simply to number all its vertices (ie surfels), arcs, and faces and to store its topology with an half-edge data structure. It is essentially a <a class="el" href="classDGtal_1_1PolygonalSurface.html" title="Aim: Represents a polygon mesh, i.e. a 2-dimensional combinatorial surface whose faces are (topologic...">PolygonalSurface</a> but with services specific to <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>, like a tracker, a DigitalSurfaceContainer, etc. In theory, it can replace a <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a> in many algorithms, and is more efficient if you need to do a lot of traversal on it (like many k-ring operations).  <a href="classDGtal_1_1IndexedDigitalSurface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1KhalimskyPreSpaceND.html">KhalimskyPreSpaceND</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is a model of CPreCellularGridSpaceND. It represents the cubical grid as a cell complex, whose cells are defined as an array of integers. The topology of the cells is defined by the parity of the coordinates (even: closed, odd: open).  <a href="classDGtal_1_1KhalimskyPreSpaceND.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1KhalimskyPreCell.html">KhalimskyPreCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an unsigned cell in an unbounded cellular grid space by its Khalimsky coordinates.  <a href="structDGtal_1_1KhalimskyPreCell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SignedKhalimskyPreCell.html">SignedKhalimskyPreCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a signed cell in an unbounded cellular grid space by its Khalimsky coordinates and a boolean value.  <a href="structDGtal_1_1SignedKhalimskyPreCell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1PreCellDirectionIterator.html">PreCellDirectionIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is useful for looping on all "interesting" coordinates of a pre-cell.  <a href="classDGtal_1_1PreCellDirectionIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1KhalimskySpaceND.html">KhalimskySpaceND</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex, whose cells are defined as an array of integers. The topology of the cells is defined by the parity of the coordinates (even: closed, odd: open).  <a href="classDGtal_1_1KhalimskySpaceND.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1KhalimskySpaceNDHelper.html">KhalimskySpaceNDHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class of <a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex,...">KhalimskySpaceND</a> that provides some optimizations depending on the space type.  <a href="classDGtal_1_1KhalimskySpaceNDHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1KhalimskyCell.html">KhalimskyCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an (unsigned) cell in a cellular grid space by its Khalimsky coordinates.  <a href="structDGtal_1_1KhalimskyCell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SignedKhalimskyCell.html">SignedKhalimskyCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a signed cell in a cellular grid space by its Khalimsky coordinates and a boolean value.  <a href="structDGtal_1_1SignedKhalimskyCell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html">LightExplicitDigitalSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels. The shape is determined by a predicate telling whether a given surfel belongs or not to the shape boundary. The whole boundary is not precomputed nor stored. You may use an iterator to visit it.  <a href="classDGtal_1_1LightExplicitDigitalSurface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html">LightImplicitDigitalSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an implicitly define shape. The whole boundary is not precomputed nor stored. You may use an iterator to visit it.  <a href="classDGtal_1_1LightImplicitDigitalSurface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MetricAdjacency.html">MetricAdjacency</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Describes digital adjacencies in digital spaces that are defined with the 1-norm and the infinity-norm.  <a href="classDGtal_1_1MetricAdjacency.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Object.html">Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: An object (or digital object) represents a set in some digital space associated with a digital topology.  <a href="classDGtal_1_1Object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ParDirCollapse.html">ParDirCollapse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements thinning algorithms in cubical complexes. The implementation supports any model of cubical complex, for instance a <a class="el" href="classDGtal_1_1CubicalComplex.html" title="Aim: This class represents an arbitrary cubical complex living in some Khalimsky space....">DGtal::CubicalComplex</a>&lt; KhalimskySpaceND&lt; 3, int &gt; &gt;. Three approaches are provided. The first&mdash;<a class="el" href="classDGtal_1_1ParDirCollapse.html" title="Aim: Implements thinning algorithms in cubical complexes. The implementation supports any model of cu...">ParDirCollapse</a>&mdash;bases on directional collapse of free pairs of faces. Second&mdash;CollapseSurface&mdash;is an extension of <a class="el" href="classDGtal_1_1ParDirCollapse.html" title="Aim: Implements thinning algorithms in cubical complexes. The implementation supports any model of cu...">ParDirCollapse</a> such that faces of dimension one lower than the dimension of the complex are kept. The last approach &mdash;CollapseIsthmus&mdash;is also an extension of <a class="el" href="classDGtal_1_1ParDirCollapse.html" title="Aim: Implements thinning algorithms in cubical complexes. The implementation supports any model of cu...">ParDirCollapse</a> such that faces of dimension one lower than the complex are preserved when they do not contain free faces of dimension two lower than the complex. Paper: Chaussard, J. and Couprie, M., Surface Thinning in 3D Cubical Complexes, Combinatorial <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> Analysis, (2009)  <a href="classDGtal_1_1ParDirCollapse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SetOfSurfels.html">SetOfSurfels</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels. The shape is determined by the set of surfels that composed the surface. The set of surfels is stored in this container.  <a href="classDGtal_1_1SetOfSurfels.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent adjacencies between surfel elements, telling if it follows an interior to exterior ordering or exterior to interior ordering. It allows tracking of boundaries and of surfaces.  <a href="classDGtal_1_1SurfelAdjacency.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This helper class is useful to compute the neighboring surfels of a given surfel, especially over a digital surface or over an object boundary. Two signed surfels are incident if they share a common n-2 cell. This class uses a <a class="el" href="classDGtal_1_1SurfelAdjacency.html" title="Aim: Represent adjacencies between surfel elements, telling if it follows an interior to exterior ord...">SurfelAdjacency</a> so as to determine adjacent surfels (either looking for them from interior to exterior or inversely).  <a href="classDGtal_1_1SurfelNeighborhood.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1UmbrellaComputer.html">UmbrellaComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Useful for computing umbrellas on '<a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>'s, ie set of n-1 cells around a n-3 cell.  <a href="classDGtal_1_1UmbrellaComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1VoxelComplex.html">VoxelComplex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a voxel complex living in some Khalimsky space. Voxel complexes are derived from.  <a href="classDGtal_1_1VoxelComplex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3f01c0f785c605d021be8e328180f502"><td class="memItemLeft" align="right" valign="top">typedef boost::uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3f01c0f785c605d021be8e328180f502">uint8_t</a></td></tr>
<tr class="memdesc:a3f01c0f785c605d021be8e328180f502"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned 8-bit integer.  <a href="namespaceDGtal.html#a3f01c0f785c605d021be8e328180f502">More...</a><br /></td></tr>
<tr class="separator:a3f01c0f785c605d021be8e328180f502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f912c6a9d587320495d627df2719ba"><td class="memItemLeft" align="right" valign="top">typedef boost::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a30f912c6a9d587320495d627df2719ba">uint16_t</a></td></tr>
<tr class="memdesc:a30f912c6a9d587320495d627df2719ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned 16-bit integer.  <a href="namespaceDGtal.html#a30f912c6a9d587320495d627df2719ba">More...</a><br /></td></tr>
<tr class="separator:a30f912c6a9d587320495d627df2719ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c59126488e9c545120667959d2fc4e"><td class="memItemLeft" align="right" valign="top">typedef boost::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e">uint32_t</a></td></tr>
<tr class="memdesc:a27c59126488e9c545120667959d2fc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned 32-bit integer.  <a href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e">More...</a><br /></td></tr>
<tr class="separator:a27c59126488e9c545120667959d2fc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33c0c25b8cc3cd86de343bca34329f5"><td class="memItemLeft" align="right" valign="top">typedef boost::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5">uint64_t</a></td></tr>
<tr class="memdesc:ab33c0c25b8cc3cd86de343bca34329f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned 64-bit integer.  <a href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5">More...</a><br /></td></tr>
<tr class="separator:ab33c0c25b8cc3cd86de343bca34329f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28d51e0b1672afa52b3c218a32a6a01"><td class="memItemLeft" align="right" valign="top">typedef boost::int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac28d51e0b1672afa52b3c218a32a6a01">int8_t</a></td></tr>
<tr class="memdesc:ac28d51e0b1672afa52b3c218a32a6a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed 8-bit integer. <br  />
  <a href="namespaceDGtal.html#ac28d51e0b1672afa52b3c218a32a6a01">More...</a><br /></td></tr>
<tr class="separator:ac28d51e0b1672afa52b3c218a32a6a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62de8348789e05494b7515c6525baa0"><td class="memItemLeft" align="right" valign="top">typedef boost::int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac62de8348789e05494b7515c6525baa0">int16_t</a></td></tr>
<tr class="memdesc:ac62de8348789e05494b7515c6525baa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed 16-bit integer.  <a href="namespaceDGtal.html#ac62de8348789e05494b7515c6525baa0">More...</a><br /></td></tr>
<tr class="separator:ac62de8348789e05494b7515c6525baa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e9ac6a329319ae13c51c0c9e92486a"><td class="memItemLeft" align="right" valign="top">typedef boost::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac1e9ac6a329319ae13c51c0c9e92486a">int32_t</a></td></tr>
<tr class="memdesc:ac1e9ac6a329319ae13c51c0c9e92486a"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed 32-bit integer.  <a href="namespaceDGtal.html#ac1e9ac6a329319ae13c51c0c9e92486a">More...</a><br /></td></tr>
<tr class="separator:ac1e9ac6a329319ae13c51c0c9e92486a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c09e3f63904ff371f1b99f45069fc63"><td class="memItemLeft" align="right" valign="top">typedef boost::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63">int64_t</a></td></tr>
<tr class="memdesc:a1c09e3f63904ff371f1b99f45069fc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed 94-bit integer.  <a href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63">More...</a><br /></td></tr>
<tr class="separator:a1c09e3f63904ff371f1b99f45069fc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14cde66089fcbdefb20c819562d2a0d"><td class="memItemLeft" align="right" valign="top">typedef mpz_class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad14cde66089fcbdefb20c819562d2a0d">BigInteger</a></td></tr>
<tr class="memdesc:ad14cde66089fcbdefb20c819562d2a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-precision integer with GMP implementation.  <a href="namespaceDGtal.html#ad14cde66089fcbdefb20c819562d2a0d">More...</a><br /></td></tr>
<tr class="separator:ad14cde66089fcbdefb20c819562d2a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbe8c8d47ca5c36ced14284ac62613d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e">DGtal::uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td></tr>
<tr class="separator:a8fbe8c8d47ca5c36ced14284ac62613d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd80f738104ff7f8bf7d39044efe45b"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6fd80f738104ff7f8bf7d39044efe45b">Order</a></td></tr>
<tr class="memdesc:a6fd80f738104ff7f8bf7d39044efe45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Order is used as template parameter for DEC classes.  <a href="namespaceDGtal.html#a6fd80f738104ff7f8bf7d39044efe45b">More...</a><br /></td></tr>
<tr class="separator:a6fd80f738104ff7f8bf7d39044efe45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247514a98187c504cc5592c6823c64db"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TInteger  = typename IteratorCirculatorTraits&lt;TIterator&gt;::Value::Coordinate&gt; </td></tr>
<tr class="memitem:a247514a98187c504cc5592c6823c64db"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a247514a98187c504cc5592c6823c64db">StandardDSS4Computer</a> = <a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html">ArithmeticalDSSComputer</a>&lt; TIterator, TInteger, 4 &gt;</td></tr>
<tr class="memdesc:a247514a98187c504cc5592c6823c64db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This is an alias to <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a> that is devoted to the dynamic recognition of standard and simply 4-connected digital straight segments (DSS) along any sequence of digital points.  <a href="namespaceDGtal.html#a247514a98187c504cc5592c6823c64db">More...</a><br /></td></tr>
<tr class="separator:a247514a98187c504cc5592c6823c64db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1564719d8c78aad60ee9144b757991a1"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TInteger  = typename IteratorCirculatorTraits&lt;TIterator&gt;::Value::Coordinate&gt; </td></tr>
<tr class="memitem:a1564719d8c78aad60ee9144b757991a1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1564719d8c78aad60ee9144b757991a1">NaiveDSS8Computer</a> = <a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html">ArithmeticalDSSComputer</a>&lt; TIterator, TInteger, 8 &gt;</td></tr>
<tr class="memdesc:a1564719d8c78aad60ee9144b757991a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This is an alias to <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a> that is devoted to the dynamic recognition of naive and simply 8-connected digital straight segments (DSS) along any sequence of digital points.  <a href="namespaceDGtal.html#a1564719d8c78aad60ee9144b757991a1">More...</a><br /></td></tr>
<tr class="separator:a1564719d8c78aad60ee9144b757991a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bbc4405f35f8a03161e41068432454"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a55bbc4405f35f8a03161e41068432454"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a55bbc4405f35f8a03161e41068432454">ArithmeticConversionType</a> = typename <a class="el" href="structDGtal_1_1ArithmeticConversionTraits.html">ArithmeticConversionTraits</a>&lt; T, U &gt;::type</td></tr>
<tr class="memdesc:a55bbc4405f35f8a03161e41068432454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type of arithmetic binary operators between two given types.  <a href="namespaceDGtal.html#a55bbc4405f35f8a03161e41068432454">More...</a><br /></td></tr>
<tr class="separator:a55bbc4405f35f8a03161e41068432454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319e1944935b8331846f54001a63525f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a319e1944935b8331846f54001a63525f">NeighborhoodConfiguration</a> = <a class="el" href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e">uint32_t</a></td></tr>
<tr class="separator:a319e1944935b8331846f54001a63525f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9f6cc75dc44e45506a66cd233e0deb41"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41">Orientation</a> { <a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41a528af0eaf947edc94796219523aa9553">INSIDE</a> = 0
, <a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41a7671a5416d92f37137f9999ca23dd65e">ON</a> = 1
, <a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41a5f4bdeccc29812b7de1cc0c05b724734">OUTSIDE</a> = 2
 }</td></tr>
<tr class="separator:a9f6cc75dc44e45506a66cd233e0deb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5859c7f85c05195f2b406298c748169a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5859c7f85c05195f2b406298c748169a">Closest</a> { <a class="el" href="namespaceDGtal.html#a5859c7f85c05195f2b406298c748169aaa7daf317118fd34dd37643632874eda8">ClosestFIRST</a> = 0
, <a class="el" href="namespaceDGtal.html#a5859c7f85c05195f2b406298c748169aa2eafe49238a245201270cbbfa540b53e">ClosestSECOND</a> = 1
, <a class="el" href="namespaceDGtal.html#a5859c7f85c05195f2b406298c748169aa0474a1c5f3fa97e0be68b1ceaadc0c84">ClosestBOTH</a> = 2
 }</td></tr>
<tr class="separator:a5859c7f85c05195f2b406298c748169a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8007ddbb5627666913e18c3b951745d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab8007ddbb5627666913e18c3b951745d">Duality</a> { <a class="el" href="namespaceDGtal.html#ab8007ddbb5627666913e18c3b951745da7b7d86a1d82efbe8b9bc0ad3c7c80bd7">PRIMAL</a> = 0
, <a class="el" href="namespaceDGtal.html#ab8007ddbb5627666913e18c3b951745dac649578cee4b5463ded5048fdaa47a41">DUAL</a> = 1
 }</td></tr>
<tr class="memdesc:ab8007ddbb5627666913e18c3b951745d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Duality enumerator tells if templated object lives in primal or dual space. Used as template parameter for DEC classes.  <a href="namespaceDGtal.html#ab8007ddbb5627666913e18c3b951745d">More...</a><br /></td></tr>
<tr class="separator:ab8007ddbb5627666913e18c3b951745d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb201440d2d4b97d7078c6716a8d6f49"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49">ProbingMode</a> { <a class="el" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ac1d9f50f86825a1a2302ec2449c17196">H</a>
, <a class="el" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ae1e1d3d40573127e9ee0480caf1283d6">R</a>
, <a class="el" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49acda522d4353b166cc2dee84673307b4e">R1</a>
 }</td></tr>
<tr class="separator:abb201440d2d4b97d7078c6716a8d6f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad242ffef715835e8928579a506b2d5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aaad242ffef715835e8928579a506b2d5">Surfel2PointEmbedding</a> { <a class="el" href="namespaceDGtal.html#aaad242ffef715835e8928579a506b2d5ac0a8bc5774ff6530ee71a7cacd6ca6f4">Pointels</a> = 0
, <a class="el" href="namespaceDGtal.html#aaad242ffef715835e8928579a506b2d5a800e26ee60cfa63833cffca955ae401f">InnerSpel</a> = 1
, <a class="el" href="namespaceDGtal.html#aaad242ffef715835e8928579a506b2d5a0630efc9b8129aa1ad3233bba9f08423">OuterSpel</a> = 2
 }</td></tr>
<tr class="memdesc:aaad242ffef715835e8928579a506b2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible embeddings for surfel as point(s)  <a href="namespaceDGtal.html#aaad242ffef715835e8928579a506b2d5">More...</a><br /></td></tr>
<tr class="separator:aaad242ffef715835e8928579a506b2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3384cac6dea91b4d46cc1421854dda"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854dda">ImageIterability</a> { <a class="el" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854ddaacf7975d858b926cba1cc047885d1765c">HIGH_ITER_IMAGE</a> = 0
, <a class="el" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854ddaa66f45381ecc834daac482ee3493a79f7">LOW_ITER_I</a> = 1
 }</td></tr>
<tr class="separator:a7f3384cac6dea91b4d46cc1421854dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbda75b83fdb9094d0e38931838c8d6a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6a">ImageBelongTestability</a> { <a class="el" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6aa3417447f6aa436ccbf37e0c359adac12">HIGH_BEL_I</a> = 0
, <a class="el" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6aa5bb4ca524cc66ff98e8b4ad4b4138630">LOW_BEL_I</a> = 2
 }</td></tr>
<tr class="separator:afbda75b83fdb9094d0e38931838c8d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a142484d2c7efc3d29f5bbde3b449b7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7">ImageSpecificContainer</a> { <a class="el" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7a0a9f2a6126427332825d75e775f59388">NORMAL_CONTAINER_I</a> = 0
, <a class="el" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7ad4deed74c04fa5f801b7c2638d536c1d">VTKIMAGEDATA_CONTAINER_I</a> = 4
 }</td></tr>
<tr class="separator:a0a142484d2c7efc3d29f5bbde3b449b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2526218ffac7b4842d393facbedd9ee3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3">DomainDrawMode</a> { <a class="el" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3a6cfb206d9d6225066329a79e83db654e">GRID</a> = 0
, <a class="el" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3ad788351651a8e983ca1b5b30861ad8ba">PAVING</a> = 1
 }</td></tr>
<tr class="separator:a2526218ffac7b4842d393facbedd9ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68309838cffd86a3c671c44ef129cb2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2">ColorGradientPreset</a> { <br />
&#160;&#160;<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a97a652eb81107a63d65d0d091f48e320">CMAP_CUSTOM</a> = 0
, <a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a03f20e9e057e38ce03220e2a43b1a366">CMAP_GRAYSCALE</a>
, <a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2ad222787b0de6a7d74f0e403da496266c">CMAP_SPRING</a>
, <a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2aa5b0ef9d5b1e2e496ac149d9a42dd3e7">CMAP_SUMMER</a>
, <br />
&#160;&#160;<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a3ff3c09197871bad3bb5921e30223533">CMAP_AUTUMN</a>
, <a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2acd0da059abca1decd6b75ecc6d131be7">CMAP_WINTER</a>
, <a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a40d9e19d8fbedda0f45c0673c6c6dcbf">CMAP_COOL</a>
, <a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a2b8eab305f63590e49a6dab0b628ae33">CMAP_COPPER</a>
, <br />
&#160;&#160;<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a075659185495ce61ea5b09ab439e2abe">CMAP_HOT</a>
, <a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2ac677c31e4299bc29c4e591063b4fc9bb">CMAP_JET</a>
, <a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a0d238d17f03f562e296b94e68b9b4ea4">CMAP_VIRIDIS</a>
<br />
 }</td></tr>
<tr class="separator:aa68309838cffd86a3c671c44ef129cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65228f031a436d2f4edd698ae733ba31"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31">BoundEnum</a> { <a class="el" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31a4b4e195031215bcfc63b5bf65c1c1035">BOUNDED</a> = 0
, <a class="el" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31a1906bfa4ce33f3c129b1e974826f686d">UNBOUNDED</a> = 1
, <a class="el" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31aec51247a223f33a421840eb3cbd5598e">BOUND_UNKNOWN</a> = 2
 }</td></tr>
<tr class="memdesc:a65228f031a436d2f4edd698ae733ba31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounding type of a number.  <a href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31">More...</a><br /></td></tr>
<tr class="separator:a65228f031a436d2f4edd698ae733ba31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679e16b34aad98ff340decf89d1c86db"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86db">SignEnum</a> { <a class="el" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dbae3e0717ad611faed845dd64931b1f99c">SIGNED</a> = 0
, <a class="el" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dba4e5cd9a9d62617341034f3f1c0f79b32">UNSIGNED</a> = 1
, <a class="el" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dba23888a413fb400a53deeb0b0e17d3100">SIGN_UNKNOWN</a> = 2
 }</td></tr>
<tr class="memdesc:a679e16b34aad98ff340decf89d1c86db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign type of a number.  <a href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86db">More...</a><br /></td></tr>
<tr class="separator:a679e16b34aad98ff340decf89d1c86db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a2f5d6c861cd13dd680ea2e64e2dd4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4">DigitalSetSize</a> { <a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4acf48b00343e26a7f40a1fdbbc7af4d70">SMALL_DS</a> = 0
, <a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4a0df10d7a38d07b6795da39a66cbe97cc">MEDIUM_DS</a> = 1
, <a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4a37af4f429983b8069af58a2334f776a0">BIG_DS</a> = 2
, <a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4ac6f14eff3712732f6fa6d608f11e79fe">WHOLE_DS</a> = 3
 }</td></tr>
<tr class="separator:a07a2f5d6c861cd13dd680ea2e64e2dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37267b68e31ee8f7531488f7e88426a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426a">DigitalSetVariability</a> { <a class="el" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426aa453acc6bba092ef2476618fad08d47f3">LOW_VAR_DS</a> = 0
, <a class="el" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426aabef0d75c93891808eaa54c78aa08484a">HIGH_VAR_DS</a> = 4
 }</td></tr>
<tr class="separator:ae37267b68e31ee8f7531488f7e88426a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae5017e6f3a3d5e0c4debd8142e8ccc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccc">DigitalSetIterability</a> { <a class="el" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccca73f1c02534747463a70f05e94ad50b3d">LOW_ITER_DS</a> = 0
, <a class="el" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccca0f85b8033e1532f5c4a0ff3d59a187bc">HIGH_ITER_DS</a> = 8
 }</td></tr>
<tr class="separator:abae5017e6f3a3d5e0c4debd8142e8ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f37e197740e9d7742426109610c513a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513a">DigitalSetBelongTestability</a> { <a class="el" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513aac54bafeace89b71100756e99a7ef368e">LOW_BEL_DS</a> = 0
, <a class="el" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513aadcca3a30244180b4238a80ae3a06e01d">HIGH_BEL_DS</a> = 16
 }</td></tr>
<tr class="separator:a0f37e197740e9d7742426109610c513a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f57dcd68d3056024eec6b4205f7083d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083d">DigitalTopologyProperties</a> { <a class="el" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083dabce62ac78855e24784c74bdd7d8e4e88">UNKNOWN_DT</a> = 0
, <a class="el" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083da76d2c48b4a35a0dcb5ca4e6cf2462ff0">NOT_JORDAN_DT</a> = 1
, <a class="el" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083da731ee8276af4e05e2fe322cf2a4fd179">JORDAN_DT</a> = 2
 }</td></tr>
<tr class="separator:a9f57dcd68d3056024eec6b4205f7083d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df441c76f46779791d077a80f0b902e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902e">Connectedness</a> { <a class="el" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902ea3188ed38ab448384424887958f44beea">DISCONNECTED</a> = 0
, <a class="el" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902ea71b8166fccee5ea03cd61a4a9b3ece1a">CONNECTED</a> = 1
, <a class="el" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902ea01966050c6ac7ceb9818c946cd229fc4">UNKNOWN</a> = 2
 }</td></tr>
<tr class="separator:a5df441c76f46779791d077a80f0b902e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6c5c11e869e737331dc7555ccd76fd6d"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a6c5c11e869e737331dc7555ccd76fd6d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6c5c11e869e737331dc7555ccd76fd6d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1ClosedIntegerHalfPlane.html">ClosedIntegerHalfPlane</a>&lt; TSpace &gt; &amp;object)</td></tr>
<tr class="separator:a6c5c11e869e737331dc7555ccd76fd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fdf109dc892d82f133d5d3ed255e8cf"><td class="memTemplParams" colspan="2">template&lt;typename TInteger &gt; </td></tr>
<tr class="memitem:a0fdf109dc892d82f133d5d3ed255e8cf"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0fdf109dc892d82f133d5d3ed255e8cf">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1IntegerComputer.html">IntegerComputer</a>&lt; TInteger &gt; &amp;object)</td></tr>
<tr class="separator:a0fdf109dc892d82f133d5d3ed255e8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf45b70010000c54be994f9777daa9c"><td class="memTemplParams" colspan="2">template&lt;typename TSpace , typename TSequence &gt; </td></tr>
<tr class="memitem:afdf45b70010000c54be994f9777daa9c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afdf45b70010000c54be994f9777daa9c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1LatticePolytope2D.html">LatticePolytope2D</a>&lt; TSpace, TSequence &gt; &amp;object)</td></tr>
<tr class="separator:afdf45b70010000c54be994f9777daa9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f0a1e7a73fe21a13f6809e3a47ff0c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae4f0a1e7a73fe21a13f6809e3a47ff0c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae4f0a1e7a73fe21a13f6809e3a47ff0c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ModuloComputer.html">ModuloComputer</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:ae4f0a1e7a73fe21a13f6809e3a47ff0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed0b3f432b36351e8af73cbef27af4f"><td class="memTemplParams" colspan="2">template&lt;typename TFraction &gt; </td></tr>
<tr class="memitem:a5ed0b3f432b36351e8af73cbef27af4f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5ed0b3f432b36351e8af73cbef27af4f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Pattern.html">Pattern</a>&lt; TFraction &gt; &amp;object)</td></tr>
<tr class="separator:a5ed0b3f432b36351e8af73cbef27af4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17188f111ef6f8f55d2e4e8d08c0a57f"><td class="memTemplParams" colspan="2">template&lt;typename TFraction &gt; </td></tr>
<tr class="memitem:a17188f111ef6f8f55d2e4e8d08c0a57f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a17188f111ef6f8f55d2e4e8d08c0a57f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1StandardDSLQ0.html">StandardDSLQ0</a>&lt; TFraction &gt; &amp;object)</td></tr>
<tr class="separator:a17188f111ef6f8f55d2e4e8d08c0a57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfda2e911a663b2b6a0d53d34a67838"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8bfda2e911a663b2b6a0d53d34a67838">assert_failed</a> (const std::string &amp;expr, const std::string &amp;function, const std::string &amp;file, long int line)</td></tr>
<tr class="separator:a8bfda2e911a663b2b6a0d53d34a67838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46480d3544b6298c5c3999a3bec9405"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae46480d3544b6298c5c3999a3bec9405">assert_failed_message</a> (const std::string &amp;expr, const std::string &amp;message, const std::string &amp;function, const std::string &amp;file, long int line)</td></tr>
<tr class="separator:ae46480d3544b6298c5c3999a3bec9405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8219e7b58c9b98239c5e0ac2feeb4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5c8219e7b58c9b98239c5e0ac2feeb4f">fatal_error_failed</a> (const std::string &amp;expr, const std::string &amp;function, const std::string &amp;file, long int line)</td></tr>
<tr class="separator:a5c8219e7b58c9b98239c5e0ac2feeb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250f6ee7761ac4632236f5482238ea02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a250f6ee7761ac4632236f5482238ea02">fatal_error_failed_message</a> (const std::string &amp;expr, const std::string &amp;message, const std::string &amp;function, const std::string &amp;file, long int line)</td></tr>
<tr class="separator:a250f6ee7761ac4632236f5482238ea02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1add7afbe92aeefa8c1d71165b43dc9f"><td class="memTemplParams" colspan="2">template&lt;typename TSequence &gt; </td></tr>
<tr class="memitem:a1add7afbe92aeefa8c1d71165b43dc9f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1add7afbe92aeefa8c1d71165b43dc9f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1BackInsertionSequenceToStackAdapter.html">BackInsertionSequenceToStackAdapter</a>&lt; TSequence &gt; &amp;object)</td></tr>
<tr class="separator:a1add7afbe92aeefa8c1d71165b43dc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc15c973e5c46488ab60f46da9efb71"><td class="memTemplParams" colspan="2">template&lt;typename TSequence &gt; </td></tr>
<tr class="memitem:abdc15c973e5c46488ab60f46da9efb71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1BackInsertionSequenceToStackAdapter.html">BackInsertionSequenceToStackAdapter</a>&lt; TSequence &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abdc15c973e5c46488ab60f46da9efb71">backStack</a> (TSequence &amp;aSequence)</td></tr>
<tr class="separator:abdc15c973e5c46488ab60f46da9efb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b8f8cfdace54a784220c80b36ea651"><td class="memTemplParams" colspan="2">template&lt;typename TIterator &gt; </td></tr>
<tr class="memitem:ae2b8f8cfdace54a784220c80b36ea651"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1Circulator.html">Circulator</a>&lt; TIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae2b8f8cfdace54a784220c80b36ea651">operator+</a> (typename <a class="el" href="structDGtal_1_1IteratorCirculatorTraits.html">IteratorCirculatorTraits</a>&lt; TIterator &gt;::Difference d, <a class="el" href="classDGtal_1_1Circulator.html">Circulator</a>&lt; TIterator &gt; &amp;object)</td></tr>
<tr class="separator:ae2b8f8cfdace54a784220c80b36ea651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d5198d8a044649b47cf6ccecf43549"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac4d5198d8a044649b47cf6ccecf43549">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Clock.html">Clock</a> &amp;object)</td></tr>
<tr class="separator:ac4d5198d8a044649b47cf6ccecf43549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604c07ec391ad12a1f3fb6479993f112"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1Trace.html">Trace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a> (<a class="el" href="namespaceDGtal.html#ae801de7ee4d22c47257dc7e00e0c5dd7">traceWriterTerm</a>)</td></tr>
<tr class="separator:a604c07ec391ad12a1f3fb6479993f112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7ca3a483107d4b69dfa47cf7919663"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TFunctor , typename TReturnType &gt; </td></tr>
<tr class="memitem:a0e7ca3a483107d4b69dfa47cf7919663"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0e7ca3a483107d4b69dfa47cf7919663">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ConstRangeAdapter.html">ConstRangeAdapter</a>&lt; TIterator, TFunctor, TReturnType &gt; &amp;object)</td></tr>
<tr class="separator:a0e7ca3a483107d4b69dfa47cf7919663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba713edeb51f787070eff9f9edc210c7"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:aba713edeb51f787070eff9f9edc210c7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aba713edeb51f787070eff9f9edc210c7">operator&lt;&lt;</a> (std::ostream &amp;out, const std::pair&lt; A, B &gt; &amp;object)</td></tr>
<tr class="separator:aba713edeb51f787070eff9f9edc210c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefaa36d38a78e24915bdcd617e92945"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeefaa36d38a78e24915bdcd617e92945"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aeefaa36d38a78e24915bdcd617e92945">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1CountedConstPtrOrConstPtr.html">CountedConstPtrOrConstPtr</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:aeefaa36d38a78e24915bdcd617e92945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a29027f9af032254ecd7af503707d88"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3a29027f9af032254ecd7af503707d88"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3a29027f9af032254ecd7af503707d88">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1CountedPtr.html">CountedPtr</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a3a29027f9af032254ecd7af503707d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd957666821fd029d79e63cb9f6f7ae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1cd957666821fd029d79e63cb9f6f7ae"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1cd957666821fd029d79e63cb9f6f7ae">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1CountedPtrOrPtr.html">CountedPtrOrPtr</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a1cd957666821fd029d79e63cb9f6f7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50dc282001d37fbfd29aead60ac3d110"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a50dc282001d37fbfd29aead60ac3d110"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a50dc282001d37fbfd29aead60ac3d110">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1CowPtr.html">CowPtr</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a50dc282001d37fbfd29aead60ac3d110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1497ed0b31ec222f4ebc35be862ee16"><td class="memTemplParams" colspan="2">template&lt;typename TSequence &gt; </td></tr>
<tr class="memitem:ae1497ed0b31ec222f4ebc35be862ee16"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae1497ed0b31ec222f4ebc35be862ee16">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1FrontInsertionSequenceToStackAdapter.html">FrontInsertionSequenceToStackAdapter</a>&lt; TSequence &gt; &amp;object)</td></tr>
<tr class="separator:ae1497ed0b31ec222f4ebc35be862ee16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93025ccea6a783aac046740d9649edaa"><td class="memTemplParams" colspan="2">template&lt;typename TSequence &gt; </td></tr>
<tr class="memitem:a93025ccea6a783aac046740d9649edaa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1FrontInsertionSequenceToStackAdapter.html">FrontInsertionSequenceToStackAdapter</a>&lt; TSequence &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a93025ccea6a783aac046740d9649edaa">frontStack</a> (TSequence &amp;aSequence)</td></tr>
<tr class="separator:a93025ccea6a783aac046740d9649edaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0710d6ab8bf5a49ea5634d8c6675ae3"><td class="memTemplParams" colspan="2">template&lt;typename TValue , unsigned int N, unsigned int M&gt; </td></tr>
<tr class="memitem:ac0710d6ab8bf5a49ea5634d8c6675ae3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac0710d6ab8bf5a49ea5634d8c6675ae3">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1IndexedListWithBlocks.html">IndexedListWithBlocks</a>&lt; TValue, N, M &gt; &amp;object)</td></tr>
<tr class="separator:ac0710d6ab8bf5a49ea5634d8c6675ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19ddb54377bb60c5a14e7e9af00c3b8"><td class="memTemplParams" colspan="2">template&lt;typename TSequence , typename TRank &gt; </td></tr>
<tr class="memitem:ae19ddb54377bb60c5a14e7e9af00c3b8"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae19ddb54377bb60c5a14e7e9af00c3b8">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1InputIteratorWithRankOnSequence.html">InputIteratorWithRankOnSequence</a>&lt; TSequence, TRank &gt; &amp;object)</td></tr>
<tr class="separator:ae19ddb54377bb60c5a14e7e9af00c3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b49e997d09ccb163eb82529e8970996"><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr class="memitem:a6b49e997d09ccb163eb82529e8970996"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6b49e997d09ccb163eb82529e8970996">isEmpty</a> (const IC &amp;itb, const IC &amp;ite)</td></tr>
<tr class="separator:a6b49e997d09ccb163eb82529e8970996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1b22211474c60437654c3a0decb8ef"><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr class="memitem:a6f1b22211474c60437654c3a0decb8ef"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6f1b22211474c60437654c3a0decb8ef">isNotEmpty</a> (const IC &amp;itb, const IC &amp;ite)</td></tr>
<tr class="separator:a6f1b22211474c60437654c3a0decb8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30d89880d1c9d74deadc8f199e4051b"><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr class="memitem:ac30d89880d1c9d74deadc8f199e4051b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac30d89880d1c9d74deadc8f199e4051b">advanceIterator</a> (IC &amp;ic, typename <a class="el" href="structDGtal_1_1IteratorCirculatorTraits.html">IteratorCirculatorTraits</a>&lt; IC &gt;::Difference n)</td></tr>
<tr class="separator:ac30d89880d1c9d74deadc8f199e4051b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25eb68dd5105a89999495322717ad375"><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr class="memitem:a25eb68dd5105a89999495322717ad375"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1IteratorCirculatorTraits.html">IteratorCirculatorTraits</a>&lt; IC &gt;::Difference&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a25eb68dd5105a89999495322717ad375">rangeSize</a> (const IC &amp;itb, const IC &amp;ite)</td></tr>
<tr class="separator:a25eb68dd5105a89999495322717ad375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5272d9b624e986d687282c2d2ba21527"><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr class="memitem:a5272d9b624e986d687282c2d2ba21527"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1IteratorCirculatorTraits.html">IteratorCirculatorTraits</a>&lt; IC &gt;::Difference&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5272d9b624e986d687282c2d2ba21527">subRangeSize</a> (const IC &amp;itb, const IC &amp;ite)</td></tr>
<tr class="separator:a5272d9b624e986d687282c2d2ba21527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb96c2af7c44c9d1b5f6690317c8530"><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr class="memitem:a7cb96c2af7c44c9d1b5f6690317c8530"><td class="memTemplItemLeft" align="right" valign="top">IC&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7cb96c2af7c44c9d1b5f6690317c8530">rangeMiddle</a> (const IC &amp;itb, const IC &amp;ite)</td></tr>
<tr class="separator:a7cb96c2af7c44c9d1b5f6690317c8530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b5d1c71b11470ae43ced01591c326d"><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr class="memitem:a66b5d1c71b11470ae43ced01591c326d"><td class="memTemplItemLeft" align="right" valign="top">IC&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a66b5d1c71b11470ae43ced01591c326d">subRangeMiddle</a> (const IC &amp;itb, const IC &amp;ite)</td></tr>
<tr class="separator:a66b5d1c71b11470ae43ced01591c326d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b63a43f6b19a92c34643093e89a3793"><td class="memTemplParams" colspan="2">template&lt;typename TData , unsigned int L, typename TWord , unsigned int N, unsigned int M&gt; </td></tr>
<tr class="memitem:a5b63a43f6b19a92c34643093e89a3793"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5b63a43f6b19a92c34643093e89a3793">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1LabelledMap.html">LabelledMap</a>&lt; TData, L, TWord, N, M &gt; &amp;object)</td></tr>
<tr class="separator:a5b63a43f6b19a92c34643093e89a3793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16183bd6f2ac4e08c138a8cdc6e1bb38"><td class="memTemplParams" colspan="2">template&lt;unsigned int L, typename TWord &gt; </td></tr>
<tr class="memitem:a16183bd6f2ac4e08c138a8cdc6e1bb38"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a16183bd6f2ac4e08c138a8cdc6e1bb38">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Labels.html">Labels</a>&lt; L, TWord &gt; &amp;object)</td></tr>
<tr class="separator:a16183bd6f2ac4e08c138a8cdc6e1bb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad177434c374ac178dd25f8e3f3de4d55"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad177434c374ac178dd25f8e3f3de4d55">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1OrderedAlphabet.html">OrderedAlphabet</a> &amp;object)</td></tr>
<tr class="separator:ad177434c374ac178dd25f8e3f3de4d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7531e627ab525a3f4a9c46b353fed36c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7531e627ab525a3f4a9c46b353fed36c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7531e627ab525a3f4a9c46b353fed36c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1OwningOrAliasingPtr.html">OwningOrAliasingPtr</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a7531e627ab525a3f4a9c46b353fed36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4897060261281048cf0bbb18590d5307"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4897060261281048cf0bbb18590d5307">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Trace.html">Trace</a> &amp;object)</td></tr>
<tr class="separator:a4897060261281048cf0bbb18590d5307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a0c72f3ea963c433d33b86d1fba535"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa1a0c72f3ea963c433d33b86d1fba535">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1TraceWriter.html">TraceWriter</a> &amp;object)</td></tr>
<tr class="separator:aa1a0c72f3ea963c433d33b86d1fba535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0ae3e476260be1ddbbe6c881738e81"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abb0ae3e476260be1ddbbe6c881738e81">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1TraceWriterFile.html">TraceWriterFile</a> &amp;object)</td></tr>
<tr class="separator:abb0ae3e476260be1ddbbe6c881738e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60540f21dc15c6580824e2e370a7600"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa60540f21dc15c6580824e2e370a7600">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1TraceWriterTerm.html">TraceWriterTerm</a> &amp;object)</td></tr>
<tr class="separator:aa60540f21dc15c6580824e2e370a7600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8541826ace2aebbe88c8a08875cf91"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add8541826ace2aebbe88c8a08875cf91"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#add8541826ace2aebbe88c8a08875cf91">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ATSolver2D.html">ATSolver2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:add8541826ace2aebbe88c8a08875cf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7adead813e8d0e92752ff8e086bbbad1"><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename TInteger &gt; </td></tr>
<tr class="memitem:a7adead813e8d0e92752ff8e086bbbad1"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7adead813e8d0e92752ff8e086bbbad1">hash_value</a> (const <a class="el" href="structDGtal_1_1KhalimskyCell.html">KhalimskyCell</a>&lt; <a class="el" href="viewDualSurface_8cpp.html#a1a254aa17418553bc21790001a69262a">dim</a>, TInteger &gt; &amp;cell)</td></tr>
<tr class="separator:a7adead813e8d0e92752ff8e086bbbad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e2087ab5ab59ae97290712aa847f3b"><td class="memTemplParams" colspan="2">template&lt;Dimension dimEmbedded, Dimension dimAmbient, typename TLinearAlgebraBackend , typename TInteger &gt; </td></tr>
<tr class="memitem:a99e2087ab5ab59ae97290712aa847f3b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a99e2087ab5ab59ae97290712aa847f3b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DiscreteExteriorCalculus.html">DiscreteExteriorCalculus</a>&lt; dimEmbedded, dimAmbient, TLinearAlgebraBackend, TInteger &gt; &amp;object)</td></tr>
<tr class="separator:a99e2087ab5ab59ae97290712aa847f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ef2b4a196c4e948d4af4d9c912d31e"><td class="memTemplParams" colspan="2">template&lt;typename C , typename S , Order order_in, Duality duality_in, Order order_out, Duality duality_out&gt; </td></tr>
<tr class="memitem:a60ef2b4a196c4e948d4af4d9c912d31e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a60ef2b4a196c4e948d4af4d9c912d31e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DiscreteExteriorCalculusSolver.html">DiscreteExteriorCalculusSolver</a>&lt; C, S, order_in, duality_in, order_out, duality_out &gt; &amp;object)</td></tr>
<tr class="separator:a60ef2b4a196c4e948d4af4d9c912d31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c7d9a956b5cff0d4d26c3d44ea890e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a57c7d9a956b5cff0d4d26c3d44ea890e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="namespaceDGtal.html#ab8007ddbb5627666913e18c3b951745d">Duality</a> &amp;object)</td></tr>
<tr class="separator:a57c7d9a956b5cff0d4d26c3d44ea890e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe554a60d1abe7f9058e3da39bff5f2"><td class="memTemplParams" colspan="2">template&lt;typename Calculus , Order order, Duality duality&gt; </td></tr>
<tr class="memitem:a9fe554a60d1abe7f9058e3da39bff5f2"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9fe554a60d1abe7f9058e3da39bff5f2">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt; Calculus, order, duality &gt; &amp;object)</td></tr>
<tr class="separator:a9fe554a60d1abe7f9058e3da39bff5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49620ee5f3ed8761257b992c5f8e407"><td class="memTemplParams" colspan="2">template&lt;typename Calculus , Order order, Duality duality&gt; </td></tr>
<tr class="memitem:ac49620ee5f3ed8761257b992c5f8e407"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt; Calculus, order, duality &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac49620ee5f3ed8761257b992c5f8e407">operator+</a> (const <a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt; Calculus, order, duality &gt; &amp;form_a, const <a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt; Calculus, order, duality &gt; &amp;form_b)</td></tr>
<tr class="separator:ac49620ee5f3ed8761257b992c5f8e407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec6f2f58473756f2ba913ebda2a5d1a"><td class="memTemplParams" colspan="2">template&lt;typename Calculus , Order order, Duality duality&gt; </td></tr>
<tr class="memitem:adec6f2f58473756f2ba913ebda2a5d1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt; Calculus, order, duality &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#adec6f2f58473756f2ba913ebda2a5d1a">operator-</a> (const <a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt; Calculus, order, duality &gt; &amp;form_a, const <a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt; Calculus, order, duality &gt; &amp;form_b)</td></tr>
<tr class="separator:adec6f2f58473756f2ba913ebda2a5d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70c40c0349f5404672003567a189506"><td class="memTemplParams" colspan="2">template&lt;typename Calculus , Order order, Duality duality&gt; </td></tr>
<tr class="memitem:aa70c40c0349f5404672003567a189506"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt; Calculus, order, duality &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa70c40c0349f5404672003567a189506">operator*</a> (const typename Calculus::Scalar &amp;scalar, const <a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt; Calculus, order, duality &gt; &amp;form)</td></tr>
<tr class="separator:aa70c40c0349f5404672003567a189506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a350eb811553a00e8696dca7638eef"><td class="memTemplParams" colspan="2">template&lt;typename Calculus , Order order, Duality duality&gt; </td></tr>
<tr class="memitem:a68a350eb811553a00e8696dca7638eef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt; Calculus, order, duality &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a68a350eb811553a00e8696dca7638eef">operator-</a> (const <a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt; Calculus, order, duality &gt; &amp;form)</td></tr>
<tr class="separator:a68a350eb811553a00e8696dca7638eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6834567c24d154928475a6b96342a843"><td class="memTemplParams" colspan="2">template&lt;typename Calculus , Order order_in, Duality duality_in, Order order_out, Duality duality_out&gt; </td></tr>
<tr class="memitem:a6834567c24d154928475a6b96342a843"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6834567c24d154928475a6b96342a843">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_in, duality_in, order_out, duality_out &gt; &amp;object)</td></tr>
<tr class="separator:a6834567c24d154928475a6b96342a843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157fb77aee59a66348106f1fd39067b5"><td class="memTemplParams" colspan="2">template&lt;typename Calculus , Order order_in, Duality duality_in, Order order_out, Duality duality_out&gt; </td></tr>
<tr class="memitem:a157fb77aee59a66348106f1fd39067b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_in, duality_in, order_out, duality_out &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a157fb77aee59a66348106f1fd39067b5">operator+</a> (const <a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_in, duality_in, order_out, duality_out &gt; &amp;linear_operator_a, const <a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_in, duality_in, order_out, duality_out &gt; &amp;linear_operator_b)</td></tr>
<tr class="separator:a157fb77aee59a66348106f1fd39067b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1af6b3e28a9f1298422b89588efecfb"><td class="memTemplParams" colspan="2">template&lt;typename Calculus , Order order_in, Duality duality_in, Order order_out, Duality duality_out&gt; </td></tr>
<tr class="memitem:ad1af6b3e28a9f1298422b89588efecfb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_in, duality_in, order_out, duality_out &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad1af6b3e28a9f1298422b89588efecfb">operator-</a> (const <a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_in, duality_in, order_out, duality_out &gt; &amp;linear_operator_a, const <a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_in, duality_in, order_out, duality_out &gt; &amp;linear_operator_b)</td></tr>
<tr class="separator:ad1af6b3e28a9f1298422b89588efecfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5276ede383635a215f61ac918dc2d185"><td class="memTemplParams" colspan="2">template&lt;typename Calculus , Order order_in, Duality duality_in, Order order_out, Duality duality_out&gt; </td></tr>
<tr class="memitem:a5276ede383635a215f61ac918dc2d185"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_in, duality_in, order_out, duality_out &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5276ede383635a215f61ac918dc2d185">operator*</a> (const typename Calculus::Scalar &amp;scalar, const <a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_in, duality_in, order_out, duality_out &gt; &amp;linear_operator)</td></tr>
<tr class="separator:a5276ede383635a215f61ac918dc2d185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa434f809abed79a881725bafd3656089"><td class="memTemplParams" colspan="2">template&lt;typename Calculus , Order order_in, Duality duality_in, Order order_fold, Duality duality_fold, Order order_out, Duality duality_out&gt; </td></tr>
<tr class="memitem:aa434f809abed79a881725bafd3656089"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_in, duality_in, order_out, duality_out &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa434f809abed79a881725bafd3656089">operator*</a> (const <a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_fold, duality_fold, order_out, duality_out &gt; &amp;operator_left, const <a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_in, duality_in, order_fold, duality_fold &gt; &amp;operator_right)</td></tr>
<tr class="separator:aa434f809abed79a881725bafd3656089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6171236ccfadbd59609e1b43ae1ece3e"><td class="memTemplParams" colspan="2">template&lt;typename Calculus , Order order_in, Duality duality_in, Order order_out, Duality duality_out&gt; </td></tr>
<tr class="memitem:a6171236ccfadbd59609e1b43ae1ece3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt; Calculus, order_out, duality_out &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6171236ccfadbd59609e1b43ae1ece3e">operator*</a> (const <a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_in, duality_in, order_out, duality_out &gt; &amp;linear_operator, const <a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt; Calculus, order_in, duality_in &gt; &amp;input_form)</td></tr>
<tr class="separator:a6171236ccfadbd59609e1b43ae1ece3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d1c40f41aa395c8c020538f27b3d6d"><td class="memTemplParams" colspan="2">template&lt;typename Calculus , Order order_in, Duality duality_in, Order order_out, Duality duality_out&gt; </td></tr>
<tr class="memitem:ac8d1c40f41aa395c8c020538f27b3d6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_in, duality_in, order_out, duality_out &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac8d1c40f41aa395c8c020538f27b3d6d">operator-</a> (const <a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_in, duality_in, order_out, duality_out &gt; &amp;linear_operator)</td></tr>
<tr class="separator:ac8d1c40f41aa395c8c020538f27b3d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad080b33a7338e70ac2095ecbfc1d463a"><td class="memTemplParams" colspan="2">template&lt;typename Calculus , Duality duality&gt; </td></tr>
<tr class="memitem:ad080b33a7338e70ac2095ecbfc1d463a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad080b33a7338e70ac2095ecbfc1d463a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1VectorField.html">VectorField</a>&lt; Calculus, duality &gt; &amp;object)</td></tr>
<tr class="separator:ad080b33a7338e70ac2095ecbfc1d463a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1ef43ca7a715577e740ad49d4da0ca"><td class="memTemplParams" colspan="2">template&lt;typename Calculus , Duality duality&gt; </td></tr>
<tr class="memitem:a8f1ef43ca7a715577e740ad49d4da0ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1VectorField.html">VectorField</a>&lt; Calculus, duality &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8f1ef43ca7a715577e740ad49d4da0ca">operator+</a> (const <a class="el" href="classDGtal_1_1VectorField.html">VectorField</a>&lt; Calculus, duality &gt; &amp;vector_field_a, const <a class="el" href="classDGtal_1_1VectorField.html">VectorField</a>&lt; Calculus, duality &gt; &amp;vector_field_b)</td></tr>
<tr class="separator:a8f1ef43ca7a715577e740ad49d4da0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef3b60bbf6d8d3847d7b69945454c20"><td class="memTemplParams" colspan="2">template&lt;typename Calculus , Duality duality&gt; </td></tr>
<tr class="memitem:a7ef3b60bbf6d8d3847d7b69945454c20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1VectorField.html">VectorField</a>&lt; Calculus, duality &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7ef3b60bbf6d8d3847d7b69945454c20">operator-</a> (const <a class="el" href="classDGtal_1_1VectorField.html">VectorField</a>&lt; Calculus, duality &gt; &amp;vector_field_a, const <a class="el" href="classDGtal_1_1VectorField.html">VectorField</a>&lt; Calculus, duality &gt; &amp;vector_field_b)</td></tr>
<tr class="separator:a7ef3b60bbf6d8d3847d7b69945454c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124e3c51465f61a87c1c37d667aa9e38"><td class="memTemplParams" colspan="2">template&lt;typename Calculus , Duality duality&gt; </td></tr>
<tr class="memitem:a124e3c51465f61a87c1c37d667aa9e38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1VectorField.html">VectorField</a>&lt; Calculus, duality &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a124e3c51465f61a87c1c37d667aa9e38">operator*</a> (const typename Calculus::Scalar &amp;scalar, const <a class="el" href="classDGtal_1_1VectorField.html">VectorField</a>&lt; Calculus, duality &gt; &amp;vector_field)</td></tr>
<tr class="separator:a124e3c51465f61a87c1c37d667aa9e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12aa22271b3a8943a2e49190ca483e2d"><td class="memTemplParams" colspan="2">template&lt;typename Calculus , Duality duality&gt; </td></tr>
<tr class="memitem:a12aa22271b3a8943a2e49190ca483e2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1VectorField.html">VectorField</a>&lt; Calculus, duality &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a12aa22271b3a8943a2e49190ca483e2d">operator-</a> (const <a class="el" href="classDGtal_1_1VectorField.html">VectorField</a>&lt; Calculus, duality &gt; &amp;vector_field)</td></tr>
<tr class="separator:a12aa22271b3a8943a2e49190ca483e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf9c6b4e189ded5d60d22898ad8212e"><td class="memTemplParams" colspan="2">template&lt;typename TInputPoint , typename TConstIterator &gt; </td></tr>
<tr class="memitem:acdf9c6b4e189ded5d60d22898ad8212e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#acdf9c6b4e189ded5d60d22898ad8212e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1AlphaThickSegmentComputer.html">AlphaThickSegmentComputer</a>&lt; TInputPoint, TConstIterator &gt; &amp;object)</td></tr>
<tr class="separator:acdf9c6b4e189ded5d60d22898ad8212e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ba602cd04883e50ce0236387bd2e9d"><td class="memTemplParams" colspan="2">template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </td></tr>
<tr class="memitem:a35ba602cd04883e50ce0236387bd2e9d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a35ba602cd04883e50ce0236387bd2e9d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ArithmeticalDSL.html">ArithmeticalDSL</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;object)</td></tr>
<tr class="separator:a35ba602cd04883e50ce0236387bd2e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcd5a800f76e4b4641af33a32f466d5"><td class="memTemplParams" colspan="2">template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </td></tr>
<tr class="memitem:a2bcd5a800f76e4b4641af33a32f466d5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2bcd5a800f76e4b4641af33a32f466d5">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;object)</td></tr>
<tr class="separator:a2bcd5a800f76e4b4641af33a32f466d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3914f7e1bedd3c522b9a40cbdad75a15"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TInteger , unsigned short adjacency&gt; </td></tr>
<tr class="memitem:a3914f7e1bedd3c522b9a40cbdad75a15"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3914f7e1bedd3c522b9a40cbdad75a15">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html">ArithmeticalDSSComputer</a>&lt; TIterator, TInteger, adjacency &gt; &amp;object)</td></tr>
<tr class="separator:a3914f7e1bedd3c522b9a40cbdad75a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91ddbc6c9aa0527a2bef39c1db5a442"><td class="memTemplParams" colspan="2">template&lt;typename TConstIteratorOnPoints , typename TValue &gt; </td></tr>
<tr class="memitem:ac91ddbc6c9aa0527a2bef39c1db5a442"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac91ddbc6c9aa0527a2bef39c1db5a442">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1BinomialConvolver.html">BinomialConvolver</a>&lt; TConstIteratorOnPoints, TValue &gt; &amp;object)</td></tr>
<tr class="separator:ac91ddbc6c9aa0527a2bef39c1db5a442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e60731c3d380a3d904efbf5c088cf07"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e60731c3d380a3d904efbf5c088cf07"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2e60731c3d380a3d904efbf5c088cf07">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1BLUELocalLengthEstimator.html">BLUELocalLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a2e60731c3d380a3d904efbf5c088cf07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e75d59933161af0498eda25de007ba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a04e75d59933161af0498eda25de007ba"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a04e75d59933161af0498eda25de007ba">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DSSLengthEstimator.html">DSSLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a04e75d59933161af0498eda25de007ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad35009edbde521ecf9374d1efdad61e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aad35009edbde521ecf9374d1efdad61e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aad35009edbde521ecf9374d1efdad61e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1FPLengthEstimator.html">FPLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:aad35009edbde521ecf9374d1efdad61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b4d33a9a76cf8cc90f45fcb62eb256"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad3b4d33a9a76cf8cc90f45fcb62eb256"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad3b4d33a9a76cf8cc90f45fcb62eb256">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1L1LengthEstimator.html">L1LengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:ad3b4d33a9a76cf8cc90f45fcb62eb256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13ca2f20ff58b8ad3ca749681226fa8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac13ca2f20ff58b8ad3ca749681226fa8"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac13ca2f20ff58b8ad3ca749681226fa8">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1MLPLengthEstimator.html">MLPLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:ac13ca2f20ff58b8ad3ca749681226fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1f11e76731f6b53d58741593de1718"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b1f11e76731f6b53d58741593de1718"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4b1f11e76731f6b53d58741593de1718">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1RosenProffittLocalLengthEstimator.html">RosenProffittLocalLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a4b1f11e76731f6b53d58741593de1718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ead3771ef37cd4c242dd0da3ba88a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62ead3771ef37cd4c242dd0da3ba88a1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a62ead3771ef37cd4c242dd0da3ba88a1">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1TwoStepLocalLengthEstimator.html">TwoStepLocalLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a62ead3771ef37cd4c242dd0da3ba88a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07229b7f7c8d1bada146c67528c9de96"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TInteger , int connectivity&gt; </td></tr>
<tr class="memitem:a07229b7f7c8d1bada146c67528c9de96"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a07229b7f7c8d1bada146c67528c9de96">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1FP.html">FP</a>&lt; TIterator, TInteger, connectivity &gt; &amp;object)</td></tr>
<tr class="separator:a07229b7f7c8d1bada146c67528c9de96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae081561d2fa45377630974eff2552f56"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TInteger &gt; </td></tr>
<tr class="memitem:ae081561d2fa45377630974eff2552f56"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae081561d2fa45377630974eff2552f56">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1FrechetShortcut.html">FrechetShortcut</a>&lt; TIterator, TInteger &gt; &amp;object)</td></tr>
<tr class="separator:ae081561d2fa45377630974eff2552f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04f7017782434af4136151691f7a774"><td class="memTemplParams" colspan="2">template&lt;typename TInteger &gt; </td></tr>
<tr class="memitem:af04f7017782434af4136151691f7a774"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af04f7017782434af4136151691f7a774">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a>&lt; TInteger &gt; &amp;object)</td></tr>
<tr class="separator:af04f7017782434af4136151691f7a774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52995248ae36d8cd61977cf8e37c63bc"><td class="memTemplParams" colspan="2">template&lt;typename SegmentComputer &gt; </td></tr>
<tr class="memitem:a52995248ae36d8cd61977cf8e37c63bc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a52995248ae36d8cd61977cf8e37c63bc">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GreedySegmentation.html">GreedySegmentation</a>&lt; <a class="el" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#a51bb21fda3840e1eff0ee53753ebcbc3">SegmentComputer</a> &gt; &amp;object)</td></tr>
<tr class="separator:a52995248ae36d8cd61977cf8e37c63bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33bee6b2124dccce74416d0cfeef2cc1"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace &gt; </td></tr>
<tr class="memitem:a33bee6b2124dccce74416d0cfeef2cc1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a33bee6b2124dccce74416d0cfeef2cc1">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GridCurve.html">GridCurve</a>&lt; TKSpace &gt; &amp;object)</td></tr>
<tr class="separator:a33bee6b2124dccce74416d0cfeef2cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4df6c5ff5ee3dcb5536a58a6e4fb82"><td class="memTemplParams" colspan="2">template&lt;typename TConstIterator , typename TInteger &gt; </td></tr>
<tr class="memitem:abf4df6c5ff5ee3dcb5536a58a6e4fb82"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abf4df6c5ff5ee3dcb5536a58a6e4fb82">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1OneBalancedWordComputer.html">OneBalancedWordComputer</a>&lt; TConstIterator, TInteger &gt; &amp;object)</td></tr>
<tr class="separator:abf4df6c5ff5ee3dcb5536a58a6e4fb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1daa4a8453a4bf2325c1b208fd34c07"><td class="memTemplParams" colspan="2">template&lt;typename TCurve , typename TTransfromation &gt; </td></tr>
<tr class="memitem:ad1daa4a8453a4bf2325c1b208fd34c07"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad1daa4a8453a4bf2325c1b208fd34c07">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DecoratorParametricCurveTransformation.html">DecoratorParametricCurveTransformation</a>&lt; TCurve, TTransfromation &gt; &amp;object)</td></tr>
<tr class="separator:ad1daa4a8453a4bf2325c1b208fd34c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae7db27a17af200544f21c515fdae1a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ae7db27a17af200544f21c515fdae1a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3ae7db27a17af200544f21c515fdae1a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1EllipticHelix.html">EllipticHelix</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a3ae7db27a17af200544f21c515fdae1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a25bfadf0ecc79a624225fa726eda98"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5a25bfadf0ecc79a624225fa726eda98"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5a25bfadf0ecc79a624225fa726eda98">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Knot__3__1.html">Knot_3_1</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a5a25bfadf0ecc79a624225fa726eda98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65dc86a5e952018090bb442075f2f3e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a65dc86a5e952018090bb442075f2f3e5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a65dc86a5e952018090bb442075f2f3e5">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Knot__3__2.html">Knot_3_2</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a65dc86a5e952018090bb442075f2f3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eca44a4ba4ed42741d260583557212f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7eca44a4ba4ed42741d260583557212f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7eca44a4ba4ed42741d260583557212f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Knot__4__1.html">Knot_4_1</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a7eca44a4ba4ed42741d260583557212f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733cf1c9b875cd3f8c18c6bbf1841893"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a733cf1c9b875cd3f8c18c6bbf1841893"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a733cf1c9b875cd3f8c18c6bbf1841893">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Knot__4__3.html">Knot_4_3</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a733cf1c9b875cd3f8c18c6bbf1841893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecadd83849320d83affa80e3c3c852d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ecadd83849320d83affa80e3c3c852d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1ecadd83849320d83affa80e3c3c852d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Knot__5__1.html">Knot_5_1</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a1ecadd83849320d83affa80e3c3c852d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94e5bad4aaefc658eca711c984a893f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad94e5bad4aaefc658eca711c984a893f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad94e5bad4aaefc658eca711c984a893f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Knot__5__2.html">Knot_5_2</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:ad94e5bad4aaefc658eca711c984a893f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbe5917024ddd86e10c8d0ada4d8aa7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aedbe5917024ddd86e10c8d0ada4d8aa7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aedbe5917024ddd86e10c8d0ada4d8aa7">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Knot__6__2.html">Knot_6_2</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:aedbe5917024ddd86e10c8d0ada4d8aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c4d2148956f5217d68919bf2e08aca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa1c4d2148956f5217d68919bf2e08aca"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa1c4d2148956f5217d68919bf2e08aca">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Knot__7__4.html">Knot_7_4</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:aa1c4d2148956f5217d68919bf2e08aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d604a62033fb54ab9e35b77bd9c23a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d604a62033fb54ab9e35b77bd9c23a1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6d604a62033fb54ab9e35b77bd9c23a1">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1NaiveParametricCurveDigitizer3D.html">NaiveParametricCurveDigitizer3D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a6d604a62033fb54ab9e35b77bd9c23a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a932423c11c531c9ecfe4631704aab"><td class="memTemplParams" colspan="2">template&lt;typename SegmentComputer &gt; </td></tr>
<tr class="memitem:a86a932423c11c531c9ecfe4631704aab"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a86a932423c11c531c9ecfe4631704aab">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1SaturatedSegmentation.html">SaturatedSegmentation</a>&lt; <a class="el" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#a51bb21fda3840e1eff0ee53753ebcbc3">SegmentComputer</a> &gt; &amp;object)</td></tr>
<tr class="separator:a86a932423c11c531c9ecfe4631704aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4fb1b2976e5fc35dc1b4073149408e"><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr class="memitem:a8c4fb1b2976e5fc35dc1b4073149408e"><td class="memTemplItemLeft" align="right" valign="top">IC&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8c4fb1b2976e5fc35dc1b4073149408e">getMiddleIterator</a> (const IC &amp;itb, const IC &amp;ite, <a class="el" href="structDGtal_1_1RandomAccessCategory.html">RandomAccessCategory</a>)</td></tr>
<tr class="separator:a8c4fb1b2976e5fc35dc1b4073149408e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf4e9405b276ba5b8b931f72d180d9d"><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr class="memitem:a9cf4e9405b276ba5b8b931f72d180d9d"><td class="memTemplItemLeft" align="right" valign="top">IC&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9cf4e9405b276ba5b8b931f72d180d9d">getMiddleIterator</a> (const IC &amp;itb, const IC &amp;ite, <a class="el" href="structDGtal_1_1BidirectionalCategory.html">BidirectionalCategory</a>)</td></tr>
<tr class="separator:a9cf4e9405b276ba5b8b931f72d180d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f53c482fe83e31093accf95ec7190d9"><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr class="memitem:a8f53c482fe83e31093accf95ec7190d9"><td class="memTemplItemLeft" align="right" valign="top">IC&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8f53c482fe83e31093accf95ec7190d9">getMiddleIterator</a> (const IC &amp;itb, const IC &amp;ite, <a class="el" href="structDGtal_1_1ForwardCategory.html">ForwardCategory</a>)</td></tr>
<tr class="separator:a8f53c482fe83e31093accf95ec7190d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318f9e3e73cd0988af98b3a66a543334"><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr class="memitem:a318f9e3e73cd0988af98b3a66a543334"><td class="memTemplItemLeft" align="right" valign="top">IC&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a318f9e3e73cd0988af98b3a66a543334">getMiddleIterator</a> (const IC &amp;itb, const IC &amp;ite)</td></tr>
<tr class="separator:a318f9e3e73cd0988af98b3a66a543334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4718031e09102bb8f73a874c47e10aaf"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a4718031e09102bb8f73a874c47e10aaf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end, <a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>)</td></tr>
<tr class="separator:a4718031e09102bb8f73a874c47e10aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367841808f36fa49eceaa1671718f3ee"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a367841808f36fa49eceaa1671718f3ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a367841808f36fa49eceaa1671718f3ee">maximalExtension</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;, <a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>)</td></tr>
<tr class="separator:a367841808f36fa49eceaa1671718f3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c7d5ea8b24456694c6fa5f6a25f4cc"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a21c7d5ea8b24456694c6fa5f6a25f4cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a21c7d5ea8b24456694c6fa5f6a25f4cc">maximalExtension</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end)</td></tr>
<tr class="separator:a21c7d5ea8b24456694c6fa5f6a25f4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462eaaf587bc04ebd2e6141bed3fc21e"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a462eaaf587bc04ebd2e6141bed3fc21e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a462eaaf587bc04ebd2e6141bed3fc21e">oppositeEndMaximalExtension</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin, <a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>)</td></tr>
<tr class="separator:a462eaaf587bc04ebd2e6141bed3fc21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f50b26bc3256332ab287e1bb2a3e7cf"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a9f50b26bc3256332ab287e1bb2a3e7cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9f50b26bc3256332ab287e1bb2a3e7cf">oppositeEndMaximalExtension</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin, <a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>)</td></tr>
<tr class="separator:a9f50b26bc3256332ab287e1bb2a3e7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567c997ae858c829256cc8a13c04d230"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a567c997ae858c829256cc8a13c04d230"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a567c997ae858c829256cc8a13c04d230">oppositeEndMaximalExtension</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin)</td></tr>
<tr class="separator:a567c997ae858c829256cc8a13c04d230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d73948fddeeb1f2e0fa94c4c9b03a9"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ad8d73948fddeeb1f2e0fa94c4c9b03a9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad8d73948fddeeb1f2e0fa94c4c9b03a9">maximalSymmetricExtension</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end, <a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>)</td></tr>
<tr class="separator:ad8d73948fddeeb1f2e0fa94c4c9b03a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bd5266c4907488dc943c3fd18b72a0"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a04bd5266c4907488dc943c3fd18b72a0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a04bd5266c4907488dc943c3fd18b72a0">maximalSymmetricExtension</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end, <a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>)</td></tr>
<tr class="separator:a04bd5266c4907488dc943c3fd18b72a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09a396e60a1ff248a246cc2f365fb31"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ad09a396e60a1ff248a246cc2f365fb31"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad09a396e60a1ff248a246cc2f365fb31">maximalSymmetricExtension</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end)</td></tr>
<tr class="separator:ad09a396e60a1ff248a246cc2f365fb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4831d5ff3c1c70bd1c6a26403297a9a"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ad4831d5ff3c1c70bd1c6a26403297a9a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad4831d5ff3c1c70bd1c6a26403297a9a">maximalRetraction</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end)</td></tr>
<tr class="separator:ad4831d5ff3c1c70bd1c6a26403297a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137f26d321873e90065142afff6fa928"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a137f26d321873e90065142afff6fa928"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a137f26d321873e90065142afff6fa928">oppositeEndMaximalRetraction</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin)</td></tr>
<tr class="separator:a137f26d321873e90065142afff6fa928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2034305fadb5376a987519daba4c982a"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a2034305fadb5376a987519daba4c982a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;i, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end, <a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>)</td></tr>
<tr class="separator:a2034305fadb5376a987519daba4c982a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67994f04a54230cdb524e46dba46a127"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a67994f04a54230cdb524e46dba46a127"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a67994f04a54230cdb524e46dba46a127">longestSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;i, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end, <a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>)</td></tr>
<tr class="separator:a67994f04a54230cdb524e46dba46a127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464c32dc87cc7ded90f601f4657664a1"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a464c32dc87cc7ded90f601f4657664a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a464c32dc87cc7ded90f601f4657664a1">longestSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;i, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end)</td></tr>
<tr class="separator:a464c32dc87cc7ded90f601f4657664a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d3175b6c7d86845a0c259f566bd7ea"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ae6d3175b6c7d86845a0c259f566bd7ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">firstMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;i, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end, <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>)</td></tr>
<tr class="separator:ae6d3175b6c7d86845a0c259f566bd7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37d5f56ebcd83255b9c93038deff781"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ae37d5f56ebcd83255b9c93038deff781"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae37d5f56ebcd83255b9c93038deff781">firstMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;i, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end, <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>)</td></tr>
<tr class="separator:ae37d5f56ebcd83255b9c93038deff781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b81102d807d1ec5629d25c6e13ddae7"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a8b81102d807d1ec5629d25c6e13ddae7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8b81102d807d1ec5629d25c6e13ddae7">firstMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;i, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>)</td></tr>
<tr class="separator:a8b81102d807d1ec5629d25c6e13ddae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8ba2a7a4a42e59741df4afed37f449"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:aae8ba2a7a4a42e59741df4afed37f449"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aae8ba2a7a4a42e59741df4afed37f449">firstMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;i, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>)</td></tr>
<tr class="separator:aae8ba2a7a4a42e59741df4afed37f449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c5282eb177f64a2957c29bf51b0e1c"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a18c5282eb177f64a2957c29bf51b0e1c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a18c5282eb177f64a2957c29bf51b0e1c">firstMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;i, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end)</td></tr>
<tr class="separator:a18c5282eb177f64a2957c29bf51b0e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3f25b1f654c74c78819624604e4950"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a1b3f25b1f654c74c78819624604e4950"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1b3f25b1f654c74c78819624604e4950">mostCenteredMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;i, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end, <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>)</td></tr>
<tr class="separator:a1b3f25b1f654c74c78819624604e4950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad153558eaa4afb851f884b64680f4631"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ad153558eaa4afb851f884b64680f4631"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad153558eaa4afb851f884b64680f4631">mostCenteredMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;i, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end, <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>)</td></tr>
<tr class="separator:ad153558eaa4afb851f884b64680f4631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a2cb535d2b0befce8f080d9d1a2414"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a07a2cb535d2b0befce8f080d9d1a2414"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a07a2cb535d2b0befce8f080d9d1a2414">mostCenteredMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;i, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>)</td></tr>
<tr class="separator:a07a2cb535d2b0befce8f080d9d1a2414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43392e8f5aeba868858b9b2c1e52cf7"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:aa43392e8f5aeba868858b9b2c1e52cf7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa43392e8f5aeba868858b9b2c1e52cf7">mostCenteredMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;i, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>)</td></tr>
<tr class="separator:aa43392e8f5aeba868858b9b2c1e52cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7b7f5908ea811a44f41186c7a01e8e"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:adb7b7f5908ea811a44f41186c7a01e8e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#adb7b7f5908ea811a44f41186c7a01e8e">mostCenteredMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;i, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end)</td></tr>
<tr class="separator:adb7b7f5908ea811a44f41186c7a01e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f04b5f095862ee00e620f8246df2f8"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a19f04b5f095862ee00e620f8246df2f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a19f04b5f095862ee00e620f8246df2f8">lastMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;i, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end, <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>)</td></tr>
<tr class="separator:a19f04b5f095862ee00e620f8246df2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5dc0554703f63c1ec705f764f2ba3a"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a8c5dc0554703f63c1ec705f764f2ba3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8c5dc0554703f63c1ec705f764f2ba3a">lastMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;i, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end, <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a>)</td></tr>
<tr class="separator:a8c5dc0554703f63c1ec705f764f2ba3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652ebafea1d9e8891f40d9b0af8fcb02"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a652ebafea1d9e8891f40d9b0af8fcb02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a652ebafea1d9e8891f40d9b0af8fcb02">lastMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;i, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>)</td></tr>
<tr class="separator:a652ebafea1d9e8891f40d9b0af8fcb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47282aa7c7fc28d49e7a52a3f8eeee3c"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a47282aa7c7fc28d49e7a52a3f8eeee3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a47282aa7c7fc28d49e7a52a3f8eeee3c">lastMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;i, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>)</td></tr>
<tr class="separator:a47282aa7c7fc28d49e7a52a3f8eeee3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3e824f983193de48aaf18590edaa52"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:afa3e824f983193de48aaf18590edaa52"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afa3e824f983193de48aaf18590edaa52">lastMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;i, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end)</td></tr>
<tr class="separator:afa3e824f983193de48aaf18590edaa52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c1293187f38e931f5f353d1a38f71c"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a91c1293187f38e931f5f353d1a38f71c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a91c1293187f38e931f5f353d1a38f71c">nextMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end, <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>)</td></tr>
<tr class="separator:a91c1293187f38e931f5f353d1a38f71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4fc5b05689abd850faa6637a64505c"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a0f4fc5b05689abd850faa6637a64505c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0f4fc5b05689abd850faa6637a64505c">nextMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end, <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>)</td></tr>
<tr class="separator:a0f4fc5b05689abd850faa6637a64505c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee548c7f570f6bdb18ce2cc592cb009"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a6ee548c7f570f6bdb18ce2cc592cb009"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6ee548c7f570f6bdb18ce2cc592cb009">nextMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>)</td></tr>
<tr class="separator:a6ee548c7f570f6bdb18ce2cc592cb009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e6d98ecc15fc5062f30060d4452706"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ae9e6d98ecc15fc5062f30060d4452706"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae9e6d98ecc15fc5062f30060d4452706">nextMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>)</td></tr>
<tr class="separator:ae9e6d98ecc15fc5062f30060d4452706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325d2a962cd3410424a45f83c1b32b7a"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a325d2a962cd3410424a45f83c1b32b7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a325d2a962cd3410424a45f83c1b32b7a">nextMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end)</td></tr>
<tr class="separator:a325d2a962cd3410424a45f83c1b32b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabb9ea04f81cba914f3ac178439ffd4"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:adabb9ea04f81cba914f3ac178439ffd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#adabb9ea04f81cba914f3ac178439ffd4">previousMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin, <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>)</td></tr>
<tr class="separator:adabb9ea04f81cba914f3ac178439ffd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e35d35160afaea835678e7bf4a3458c"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a8e35d35160afaea835678e7bf4a3458c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8e35d35160afaea835678e7bf4a3458c">previousMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin, <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>)</td></tr>
<tr class="separator:a8e35d35160afaea835678e7bf4a3458c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1f75e59b72ea5e69760c965e20b3ff"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:afa1f75e59b72ea5e69760c965e20b3ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afa1f75e59b72ea5e69760c965e20b3ff">previousMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>)</td></tr>
<tr class="separator:afa1f75e59b72ea5e69760c965e20b3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14e74091568436294698404dc08c9c5"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ad14e74091568436294698404dc08c9c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad14e74091568436294698404dc08c9c5">previousMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;end, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>)</td></tr>
<tr class="separator:ad14e74091568436294698404dc08c9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03fbf680fc202a21ef0801ee9240934"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:af03fbf680fc202a21ef0801ee9240934"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af03fbf680fc202a21ef0801ee9240934">previousMaximalSegment</a> (SC &amp;s, const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;begin)</td></tr>
<tr class="separator:af03fbf680fc202a21ef0801ee9240934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380ef73ffe8f5104f6782326fc4df10d"><td class="memTemplParams" colspan="2">template&lt;typename TConstIterator &gt; </td></tr>
<tr class="memitem:a380ef73ffe8f5104f6782326fc4df10d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a380ef73ffe8f5104f6782326fc4df10d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1StabbingCircleComputer.html">StabbingCircleComputer</a>&lt; TConstIterator &gt; &amp;object)</td></tr>
<tr class="separator:a380ef73ffe8f5104f6782326fc4df10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8dfae1a3461c126ad5f8deec25cf6ff"><td class="memTemplParams" colspan="2">template&lt;typename TConstIterator &gt; </td></tr>
<tr class="memitem:ab8dfae1a3461c126ad5f8deec25cf6ff"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab8dfae1a3461c126ad5f8deec25cf6ff">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1StabbingLineComputer.html">StabbingLineComputer</a>&lt; TConstIterator &gt; &amp;object)</td></tr>
<tr class="separator:ab8dfae1a3461c126ad5f8deec25cf6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50c40d2df8aae8bd6ba1fd14e633c46"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TInteger , int connectivity&gt; </td></tr>
<tr class="memitem:aa50c40d2df8aae8bd6ba1fd14e633c46"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa50c40d2df8aae8bd6ba1fd14e633c46">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1StandardDSS6Computer.html">StandardDSS6Computer</a>&lt; TIterator, TInteger, connectivity &gt; &amp;object)</td></tr>
<tr class="separator:aa50c40d2df8aae8bd6ba1fd14e633c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf090f2b7c0b27c606e73a5a83a558b7"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#acf090f2b7c0b27c606e73a5a83a558b7">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ContourHelper.html">ContourHelper</a> &amp;object)</td></tr>
<tr class="separator:acf090f2b7c0b27c606e73a5a83a558b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6444c3cd63c5b91e183adffeabf64b"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TIterator , typename TInteger , unsigned short adjacency&gt; </td></tr>
<tr class="memitem:a8b6444c3cd63c5b91e183adffeabf64b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8b6444c3cd63c5b91e183adffeabf64b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ArithmeticalDSSComputerOnSurfels.html">ArithmeticalDSSComputerOnSurfels</a>&lt; TKSpace, TIterator, TInteger, adjacency &gt; &amp;object)</td></tr>
<tr class="separator:a8b6444c3cd63c5b91e183adffeabf64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6714a7a10d4957d494e7ed098c066ee4"><td class="memTemplParams" colspan="2">template&lt;typename TSpace , typename TInputPoint , typename TInternalScalar &gt; </td></tr>
<tr class="memitem:a6714a7a10d4957d494e7ed098c066ee4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6714a7a10d4957d494e7ed098c066ee4">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ChordGenericNaivePlaneComputer.html">ChordGenericNaivePlaneComputer</a>&lt; TSpace, TInputPoint, TInternalScalar &gt; &amp;object)</td></tr>
<tr class="separator:a6714a7a10d4957d494e7ed098c066ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666f5204280b03b007687a7f24b67bdd"><td class="memTemplParams" colspan="2">template&lt;typename TSpace , typename TInputPoint , typename TInternalScalar &gt; </td></tr>
<tr class="memitem:a666f5204280b03b007687a7f24b67bdd"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a666f5204280b03b007687a7f24b67bdd">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ChordGenericStandardPlaneComputer.html">ChordGenericStandardPlaneComputer</a>&lt; TSpace, TInputPoint, TInternalScalar &gt; &amp;object)</td></tr>
<tr class="separator:a666f5204280b03b007687a7f24b67bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00e9304bdefeecac3cc99759225df1e"><td class="memTemplParams" colspan="2">template&lt;typename TSpace , typename TInputPoint , typename TInternalScalar &gt; </td></tr>
<tr class="memitem:aa00e9304bdefeecac3cc99759225df1e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa00e9304bdefeecac3cc99759225df1e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ChordNaivePlaneComputer.html">ChordNaivePlaneComputer</a>&lt; TSpace, TInputPoint, TInternalScalar &gt; &amp;object)</td></tr>
<tr class="separator:aa00e9304bdefeecac3cc99759225df1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bed9b65298e34bd47518694b8890f3"><td class="memTemplParams" colspan="2">template&lt;typename TSpace , typename TInternalInteger &gt; </td></tr>
<tr class="memitem:a64bed9b65298e34bd47518694b8890f3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a64bed9b65298e34bd47518694b8890f3">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html">COBAGenericNaivePlaneComputer</a>&lt; TSpace, TInternalInteger &gt; &amp;object)</td></tr>
<tr class="separator:a64bed9b65298e34bd47518694b8890f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffdff71c4a212bf79860d4205fdf973"><td class="memTemplParams" colspan="2">template&lt;typename TSpace , typename TInternalInteger &gt; </td></tr>
<tr class="memitem:a3ffdff71c4a212bf79860d4205fdf973"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3ffdff71c4a212bf79860d4205fdf973">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1COBAGenericStandardPlaneComputer.html">COBAGenericStandardPlaneComputer</a>&lt; TSpace, TInternalInteger &gt; &amp;object)</td></tr>
<tr class="separator:a3ffdff71c4a212bf79860d4205fdf973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7186d0986fa94a9082a554decc7778ef"><td class="memTemplParams" colspan="2">template&lt;typename TSpace , typename TInternalInteger &gt; </td></tr>
<tr class="memitem:a7186d0986fa94a9082a554decc7778ef"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7186d0986fa94a9082a554decc7778ef">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html">COBANaivePlaneComputer</a>&lt; TSpace, TInternalInteger &gt; &amp;object)</td></tr>
<tr class="separator:a7186d0986fa94a9082a554decc7778ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c45b5dc20ec7451c7a12c524bc32f6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59c45b5dc20ec7451c7a12c524bc32f6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a59c45b5dc20ec7451c7a12c524bc32f6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalPlanePredicate.html">DigitalPlanePredicate</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a59c45b5dc20ec7451c7a12c524bc32f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a63db51cb0f46e9f2dc553c760be867"><td class="memTemplParams" colspan="2">template&lt;typename TF , typename TKF , typename TKS , typename TDK , Dimension dimension&gt; </td></tr>
<tr class="memitem:a9a63db51cb0f46e9f2dc553c760be867"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9a63db51cb0f46e9f2dc553c760be867">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSurfaceConvolver.html">DGtal::DigitalSurfaceConvolver</a>&lt; TF, TKF, TKS, TDK, dimension &gt; &amp;object)</td></tr>
<tr class="separator:a9a63db51cb0f46e9f2dc553c760be867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea206d459862d088c8f84b87e3ae35f6"><td class="memTemplParams" colspan="2">template&lt;typename TF , typename TKF , typename TKS , typename TDK &gt; </td></tr>
<tr class="memitem:aea206d459862d088c8f84b87e3ae35f6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aea206d459862d088c8f84b87e3ae35f6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSurfaceConvolver.html">DGtal::DigitalSurfaceConvolver</a>&lt; TF, TKF, TKS, TDK, 2 &gt; &amp;object)</td></tr>
<tr class="separator:aea206d459862d088c8f84b87e3ae35f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6b3b9050f323b4bc23e4d6d86fb028"><td class="memTemplParams" colspan="2">template&lt;typename TF , typename TKF , typename TKS , typename TDK &gt; </td></tr>
<tr class="memitem:a2d6b3b9050f323b4bc23e4d6d86fb028"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2d6b3b9050f323b4bc23e4d6d86fb028">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSurfaceConvolver.html">DGtal::DigitalSurfaceConvolver</a>&lt; TF, TKF, TKS, TDK, 3 &gt; &amp;object)</td></tr>
<tr class="separator:a2d6b3b9050f323b4bc23e4d6d86fb028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1572c3e1a45017935344cb6abb02ecfb"><td class="memTemplParams" colspan="2">template&lt;typename TSurface &gt; </td></tr>
<tr class="memitem:a1572c3e1a45017935344cb6abb02ecfb"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1572c3e1a45017935344cb6abb02ecfb">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSurfacePredicate.html">DigitalSurfacePredicate</a>&lt; TSurface &gt; &amp;object)</td></tr>
<tr class="separator:a1572c3e1a45017935344cb6abb02ecfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449b924dd8e63c9ae2ebcdc4502c858f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a449b924dd8e63c9ae2ebcdc4502c858f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a449b924dd8e63c9ae2ebcdc4502c858f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSurfaceRegularization.html">DigitalSurfaceRegularization</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a449b924dd8e63c9ae2ebcdc4502c858f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49ad0ee550d45074f0aa5179808eb51"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalSurfaceEmbedder , typename TNormalVectorEstimator &gt; </td></tr>
<tr class="memitem:aa49ad0ee550d45074f0aa5179808eb51"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa49ad0ee550d45074f0aa5179808eb51">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSurfaceEmbedderWithNormalVectorEstimator.html">DigitalSurfaceEmbedderWithNormalVectorEstimator</a>&lt; TDigitalSurfaceEmbedder, TNormalVectorEstimator &gt; &amp;object)</td></tr>
<tr class="separator:aa49ad0ee550d45074f0aa5179808eb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9c279c4bb21a43828810300d1206eb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TC &gt; </td></tr>
<tr class="memitem:a3d9c279c4bb21a43828810300d1206eb"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3d9c279c4bb21a43828810300d1206eb">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1EstimatorCache.html">EstimatorCache</a>&lt; T, TC &gt; &amp;object)</td></tr>
<tr class="separator:a3d9c279c4bb21a43828810300d1206eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7679602f19341f9e6de0d3251974e425"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TPointPredicate , typename TCovarianceMatrixFunctor &gt; </td></tr>
<tr class="memitem:a7679602f19341f9e6de0d3251974e425"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7679602f19341f9e6de0d3251974e425">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1IntegralInvariantCovarianceEstimator.html">IntegralInvariantCovarianceEstimator</a>&lt; TKSpace, TPointPredicate, TCovarianceMatrixFunctor &gt; &amp;object)</td></tr>
<tr class="separator:a7679602f19341f9e6de0d3251974e425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd595721147b6f13350271e1916f163"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TPointPredicate &gt; </td></tr>
<tr class="memitem:a6cd595721147b6f13350271e1916f163"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6cd595721147b6f13350271e1916f163">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1deprecated_1_1IntegralInvariantNormalVectorEstimator.html">DGtal::deprecated::IntegralInvariantNormalVectorEstimator</a>&lt; TKSpace, TPointPredicate &gt; &amp;object)</td></tr>
<tr class="separator:a6cd595721147b6f13350271e1916f163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ea70a7ae784d6d548e9a0f033cfbc2"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TPointPredicate , typename TVolumeFunctor &gt; </td></tr>
<tr class="memitem:af2ea70a7ae784d6d548e9a0f033cfbc2"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af2ea70a7ae784d6d548e9a0f033cfbc2">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1IntegralInvariantVolumeEstimator.html">IntegralInvariantVolumeEstimator</a>&lt; TKSpace, TPointPredicate, TVolumeFunctor &gt; &amp;object)</td></tr>
<tr class="separator:af2ea70a7ae784d6d548e9a0f033cfbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8b645584f9d30e9b1f4d01e378d960"><td class="memTemplParams" colspan="2">template&lt;typename TD , typename TV , typename TF , typename TC &gt; </td></tr>
<tr class="memitem:ace8b645584f9d30e9b1f4d01e378d960"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ace8b645584f9d30e9b1f4d01e378d960">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1LocalEstimatorFromSurfelFunctorAdapter.html">LocalEstimatorFromSurfelFunctorAdapter</a>&lt; TD, TV, TF, TC &gt; &amp;object)</td></tr>
<tr class="separator:ace8b645584f9d30e9b1f4d01e378d960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7832de2b6244193509a272a51cf1b97"><td class="memTemplParams" colspan="2">template&lt;typename TSurface &gt; </td></tr>
<tr class="memitem:ae7832de2b6244193509a272a51cf1b97"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae7832de2b6244193509a272a51cf1b97">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1MaximalSegmentSliceEstimation.html">MaximalSegmentSliceEstimation</a>&lt; TSurface &gt; &amp;object)</td></tr>
<tr class="separator:ae7832de2b6244193509a272a51cf1b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855e675db4e5e115051b87a6c79c6f36"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalSurface , typename TNormalVectorEstimator , typename TEmbedder &gt; </td></tr>
<tr class="memitem:a855e675db4e5e115051b87a6c79c6f36"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a855e675db4e5e115051b87a6c79c6f36">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1NormalVectorEstimatorLinearCellEmbedder.html">NormalVectorEstimatorLinearCellEmbedder</a>&lt; TDigitalSurface, TNormalVectorEstimator, TEmbedder &gt; &amp;object)</td></tr>
<tr class="separator:a855e675db4e5e115051b87a6c79c6f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3182e16aadf3b7972b7ab6a0a4cd1c"><td class="memTemplParams" colspan="2">template&lt;typename TSurface , typename TInternalProbingAlgorithm &gt; </td></tr>
<tr class="memitem:a2d3182e16aadf3b7972b7ab6a0a4cd1c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2d3182e16aadf3b7972b7ab6a0a4cd1c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1PlaneProbingDigitalSurfaceLocalEstimator.html">PlaneProbingDigitalSurfaceLocalEstimator</a>&lt; TSurface, TInternalProbingAlgorithm &gt; &amp;object)</td></tr>
<tr class="separator:a2d3182e16aadf3b7972b7ab6a0a4cd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c63d0d28a2a1e86e6803f77fcff386c"><td class="memTemplParams" colspan="2">template&lt;typename TPredicate &gt; </td></tr>
<tr class="memitem:a5c63d0d28a2a1e86e6803f77fcff386c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5c63d0d28a2a1e86e6803f77fcff386c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1PlaneProbingHNeighborhood.html">PlaneProbingHNeighborhood</a>&lt; TPredicate &gt; &amp;object)</td></tr>
<tr class="separator:a5c63d0d28a2a1e86e6803f77fcff386c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5e1905d819be56862ed900b6ca7f2e"><td class="memTemplParams" colspan="2">template&lt;typename TPredicate &gt; </td></tr>
<tr class="memitem:a7f5e1905d819be56862ed900b6ca7f2e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7f5e1905d819be56862ed900b6ca7f2e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1PlaneProbingNeighborhood.html">PlaneProbingNeighborhood</a>&lt; TPredicate &gt; &amp;object)</td></tr>
<tr class="separator:a7f5e1905d819be56862ed900b6ca7f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab44cd427f90bd85108e3a7ca0e37ca"><td class="memTemplParams" colspan="2">template&lt;typename TPredicate , ProbingMode mode&gt; </td></tr>
<tr class="memitem:acab44cd427f90bd85108e3a7ca0e37ca"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#acab44cd427f90bd85108e3a7ca0e37ca">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1PlaneProbingParallelepipedEstimator.html">PlaneProbingParallelepipedEstimator</a>&lt; TPredicate, mode &gt; &amp;object)</td></tr>
<tr class="separator:acab44cd427f90bd85108e3a7ca0e37ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a71d7c536fd74cbcd231c521d1d412"><td class="memTemplParams" colspan="2">template&lt;typename TPredicate &gt; </td></tr>
<tr class="memitem:a13a71d7c536fd74cbcd231c521d1d412"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a13a71d7c536fd74cbcd231c521d1d412">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1PlaneProbingR1Neighborhood.html">PlaneProbingR1Neighborhood</a>&lt; TPredicate &gt; &amp;object)</td></tr>
<tr class="separator:a13a71d7c536fd74cbcd231c521d1d412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5e6dd78ee904d87a2ab3d265bb1039"><td class="memTemplParams" colspan="2">template&lt;typename TPredicate &gt; </td></tr>
<tr class="memitem:a3c5e6dd78ee904d87a2ab3d265bb1039"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3c5e6dd78ee904d87a2ab3d265bb1039">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1PlaneProbingRNeighborhood.html">PlaneProbingRNeighborhood</a>&lt; TPredicate &gt; &amp;object)</td></tr>
<tr class="separator:a3c5e6dd78ee904d87a2ab3d265bb1039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9b640720251af967daebe4feec737e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#adc9b640720251af967daebe4feec737e">operator&lt;&lt;</a> (std::ostream &amp;aOs, <a class="el" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49">ProbingMode</a> const &amp;aMode)</td></tr>
<tr class="separator:adc9b640720251af967daebe4feec737e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a09c62703bd3f2595baf3fa6c10223"><td class="memTemplParams" colspan="2">template&lt;typename TPredicate , ProbingMode mode&gt; </td></tr>
<tr class="memitem:af9a09c62703bd3f2595baf3fa6c10223"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af9a09c62703bd3f2595baf3fa6c10223">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1PlaneProbingTetrahedronEstimator.html">PlaneProbingTetrahedronEstimator</a>&lt; TPredicate, mode &gt; &amp;object)</td></tr>
<tr class="separator:af9a09c62703bd3f2595baf3fa6c10223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92007b632b9e7f503b6404c7254efe4f"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TShape , typename TGeometricFunctor &gt; </td></tr>
<tr class="memitem:a92007b632b9e7f503b6404c7254efe4f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a92007b632b9e7f503b6404c7254efe4f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1TrueDigitalSurfaceLocalEstimator.html">TrueDigitalSurfaceLocalEstimator</a>&lt; TKSpace, TShape, TGeometricFunctor &gt; &amp;object)</td></tr>
<tr class="separator:a92007b632b9e7f503b6404c7254efe4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0261bc5b59d46e47f7d5292c86d53df"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalSurfaceContainer , typename TSeparableMetric , typename TKernelFunction , typename TVCMGeometricFunctor &gt; </td></tr>
<tr class="memitem:ae0261bc5b59d46e47f7d5292c86d53df"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae0261bc5b59d46e47f7d5292c86d53df">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1VCMDigitalSurfaceLocalEstimator.html">VCMDigitalSurfaceLocalEstimator</a>&lt; TDigitalSurfaceContainer, TSeparableMetric, TKernelFunction, TVCMGeometricFunctor &gt; &amp;object)</td></tr>
<tr class="separator:ae0261bc5b59d46e47f7d5292c86d53df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd535555f8033a00f05ff1ae4206ade1"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalSurfaceContainer , typename TSeparableMetric , typename TKernelFunction &gt; </td></tr>
<tr class="memitem:afd535555f8033a00f05ff1ae4206ade1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afd535555f8033a00f05ff1ae4206ade1">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1VoronoiCovarianceMeasureOnDigitalSurface.html">VoronoiCovarianceMeasureOnDigitalSurface</a>&lt; TDigitalSurfaceContainer, TSeparableMetric, TKernelFunction &gt; &amp;object)</td></tr>
<tr class="separator:afd535555f8033a00f05ff1ae4206ade1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa72caba0ce21c2d9ae0ef622f6ca29"><td class="memTemplParams" colspan="2">template&lt;typename TF , typename TKS &gt; </td></tr>
<tr class="memitem:a3fa72caba0ce21c2d9ae0ef622f6ca29"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3fa72caba0ce21c2d9ae0ef622f6ca29">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1FunctorOnCells.html">FunctorOnCells</a>&lt; TF, TKS &gt; &amp;object)</td></tr>
<tr class="separator:a3fa72caba0ce21c2d9ae0ef622f6ca29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9f55a1f2ef1516d16626eb5dc1cc3b"><td class="memTemplParams" colspan="2">template&lt;typename TSpace , bool muIncluded, bool muPlusNuIncluded&gt; </td></tr>
<tr class="memitem:a0f9f55a1f2ef1516d16626eb5dc1cc3b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0f9f55a1f2ef1516d16626eb5dc1cc3b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ParallelStrip.html">ParallelStrip</a>&lt; TSpace, muIncluded, muPlusNuIncluded &gt; &amp;object)</td></tr>
<tr class="separator:a0f9f55a1f2ef1516d16626eb5dc1cc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d8c1b64f3a1ecebc8132001fecd7f6"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalSurfaceContainer &gt; </td></tr>
<tr class="memitem:ad0d8c1b64f3a1ecebc8132001fecd7f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1ShroudsRegularization.html">ShroudsRegularization</a>&lt; TDigitalSurfaceContainer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad0d8c1b64f3a1ecebc8132001fecd7f6">makeShroudsRegularization</a> (<a class="el" href="classDGtal_1_1CountedPtr.html">CountedPtr</a>&lt; <a class="el" href="classDGtal_1_1IndexedDigitalSurface.html">IndexedDigitalSurface</a>&lt; TDigitalSurfaceContainer &gt; &gt; surface, double eps=0.00001)</td></tr>
<tr class="separator:ad0d8c1b64f3a1ecebc8132001fecd7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccee26befa27175cfcc96042ae4fc79"><td class="memTemplParams" colspan="2">template&lt;typename TInteger &gt; </td></tr>
<tr class="memitem:a1ccee26befa27175cfcc96042ae4fc79"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1ccee26befa27175cfcc96042ae4fc79">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1AvnaimEtAl2x2DetSignComputer.html">AvnaimEtAl2x2DetSignComputer</a>&lt; TInteger &gt; &amp;object)</td></tr>
<tr class="separator:a1ccee26befa27175cfcc96042ae4fc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1091b09723068081fb14bcbc8c17c0b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae1091b09723068081fb14bcbc8c17c0b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae1091b09723068081fb14bcbc8c17c0b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Filtered2x2DetComputer.html">Filtered2x2DetComputer</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:ae1091b09723068081fb14bcbc8c17c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebae8f75da20280aa574fe408cbb297"><td class="memTemplParams" colspan="2">template&lt;typename TPoint , typename TDetComputer &gt; </td></tr>
<tr class="memitem:a2ebae8f75da20280aa574fe408cbb297"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2ebae8f75da20280aa574fe408cbb297">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1InGeneralizedDiskOfGivenRadius.html">InGeneralizedDiskOfGivenRadius</a>&lt; TPoint, TDetComputer &gt; &amp;object)</td></tr>
<tr class="separator:a2ebae8f75da20280aa574fe408cbb297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0731f53e4d71e43de135446d19c83c5e"><td class="memTemplParams" colspan="2">template&lt;typename TPoint , typename TDetComputer &gt; </td></tr>
<tr class="memitem:a0731f53e4d71e43de135446d19c83c5e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0731f53e4d71e43de135446d19c83c5e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1InHalfPlaneBy2x2DetComputer.html">InHalfPlaneBy2x2DetComputer</a>&lt; TPoint, TDetComputer &gt; &amp;object)</td></tr>
<tr class="separator:a0731f53e4d71e43de135446d19c83c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8708acb96a6cc02fd2e7b68e6a7bd94"><td class="memTemplParams" colspan="2">template&lt;typename TPoint , typename TInteger &gt; </td></tr>
<tr class="memitem:aa8708acb96a6cc02fd2e7b68e6a7bd94"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa8708acb96a6cc02fd2e7b68e6a7bd94">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1InHalfPlaneBySimple3x3Matrix.html">InHalfPlaneBySimple3x3Matrix</a>&lt; TPoint, TInteger &gt; &amp;object)</td></tr>
<tr class="separator:aa8708acb96a6cc02fd2e7b68e6a7bd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1c2a1e2b1936e56a80d2fd54819fdc"><td class="memTemplParams" colspan="2">template&lt;typename TOrientationFunctor , bool acceptNeg, bool acceptZero&gt; </td></tr>
<tr class="memitem:a2e1c2a1e2b1936e56a80d2fd54819fdc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2e1c2a1e2b1936e56a80d2fd54819fdc">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1PredicateFromOrientationFunctor2.html">PredicateFromOrientationFunctor2</a>&lt; TOrientationFunctor, acceptNeg, acceptZero &gt; &amp;object)</td></tr>
<tr class="separator:a2e1c2a1e2b1936e56a80d2fd54819fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f57d0e6ee214b01ef88f829878d7fc"><td class="memTemplParams" colspan="2">template&lt;typename TI , typename TO &gt; </td></tr>
<tr class="memitem:a87f57d0e6ee214b01ef88f829878d7fc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a87f57d0e6ee214b01ef88f829878d7fc">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Simple2x2DetComputer.html">Simple2x2DetComputer</a>&lt; TI, TO &gt; &amp;object)</td></tr>
<tr class="separator:a87f57d0e6ee214b01ef88f829878d7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bcaa727229c1493e25beed64213f1f"><td class="memTemplParams" colspan="2">template&lt;typename TI , typename TO &gt; </td></tr>
<tr class="memitem:a70bcaa727229c1493e25beed64213f1f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a70bcaa727229c1493e25beed64213f1f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1SimpleIncremental2x2DetComputer.html">SimpleIncremental2x2DetComputer</a>&lt; TI, TO &gt; &amp;object)</td></tr>
<tr class="separator:a70bcaa727229c1493e25beed64213f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1abd773c091694b461af4dbcce4f2f0"><td class="memTemplParams" colspan="2">template&lt;typename TPoint , typename TOrientationFunctor &gt; </td></tr>
<tr class="memitem:aa1abd773c091694b461af4dbcce4f2f0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa1abd773c091694b461af4dbcce4f2f0">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1MelkmanConvexHull.html">MelkmanConvexHull</a>&lt; TPoint, TOrientationFunctor &gt; &amp;object)</td></tr>
<tr class="separator:aa1abd773c091694b461af4dbcce4f2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16925448c97db7223238e00a3babd36"><td class="memTemplParams" colspan="2">template&lt;typename Shape &gt; </td></tr>
<tr class="memitem:af16925448c97db7223238e00a3babd36"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af16925448c97db7223238e00a3babd36">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Preimage2D.html">Preimage2D</a>&lt; <a class="el" href="testAstroid2D_8cpp.html#a71f4199b023fa1f3b1d8a36a946e7759">Shape</a> &gt; &amp;object)</td></tr>
<tr class="separator:af16925448c97db7223238e00a3babd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8287a37f3aa45b30a7b90f62e2aed9c"><td class="memTemplParams" colspan="2">template&lt;typename TKernel &gt; </td></tr>
<tr class="memitem:ab8287a37f3aa45b30a7b90f62e2aed9c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab8287a37f3aa45b30a7b90f62e2aed9c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1QuickHull.html">QuickHull</a>&lt; TKernel &gt; &amp;object)</td></tr>
<tr class="separator:ab8287a37f3aa45b30a7b90f62e2aed9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eafb6806e63650dd8bc0f75a3e86dc3"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a6eafb6806e63650dd8bc0f75a3e86dc3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6eafb6806e63650dd8bc0f75a3e86dc3">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1SpatialCubicalSubdivision.html">SpatialCubicalSubdivision</a>&lt; TSpace &gt; &amp;object)</td></tr>
<tr class="separator:a6eafb6806e63650dd8bc0f75a3e86dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed024e0d86a6156e10292c6bee91231"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ed024e0d86a6156e10292c6bee91231"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9ed024e0d86a6156e10292c6bee91231">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1SphericalAccumulator.html">SphericalAccumulator</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a9ed024e0d86a6156e10292c6bee91231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf4801901b7957941d7f14f370f1cbf"><td class="memTemplParams" colspan="2">template&lt;typename TPoint &gt; </td></tr>
<tr class="memitem:acaf4801901b7957941d7f14f370f1cbf"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#acaf4801901b7957941d7f14f370f1cbf">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1ConvexCellComplex.html">ConvexCellComplex</a>&lt; TPoint &gt; &amp;object)</td></tr>
<tr class="separator:acaf4801901b7957941d7f14f370f1cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b596b7d29143ff8043e4666349b7c4b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1b596b7d29143ff8043e4666349b7c4b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1b596b7d29143ff8043e4666349b7c4b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1experimental_1_1ChamferNorm2D.html">experimental::ChamferNorm2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a1b596b7d29143ff8043e4666349b7c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04f1bbd3a9fbe61dd9dd02aea02d982"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab04f1bbd3a9fbe61dd9dd02aea02d982"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab04f1bbd3a9fbe61dd9dd02aea02d982">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalMetricAdapter.html">DigitalMetricAdapter</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:ab04f1bbd3a9fbe61dd9dd02aea02d982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6fd271d4780ea13d45a7b0a62849e9"><td class="memTemplParams" colspan="2">template&lt;typename S , typename P , typename TSep &gt; </td></tr>
<tr class="memitem:a0d6fd271d4780ea13d45a7b0a62849e9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0d6fd271d4780ea13d45a7b0a62849e9">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DistanceTransformation.html">DistanceTransformation</a>&lt; S, P, TSep &gt; &amp;object)</td></tr>
<tr class="separator:a0d6fd271d4780ea13d45a7b0a62849e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6e278dc3833c3664cdd0cd9a20898a"><td class="memTemplParams" colspan="2">template&lt;typename T , DGtal::uint32_t p, typename P &gt; </td></tr>
<tr class="memitem:afa6e278dc3833c3664cdd0cd9a20898a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afa6e278dc3833c3664cdd0cd9a20898a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ExactPredicateLpPowerSeparableMetric.html">ExactPredicateLpPowerSeparableMetric</a>&lt; T, p, P &gt; &amp;object)</td></tr>
<tr class="separator:afa6e278dc3833c3664cdd0cd9a20898a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6b29dfb8da033f13dc6afc0728d1c4"><td class="memTemplParams" colspan="2">template&lt;typename T , DGtal::uint32_t p, typename P &gt; </td></tr>
<tr class="memitem:a8b6b29dfb8da033f13dc6afc0728d1c4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8b6b29dfb8da033f13dc6afc0728d1c4">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ExactPredicateLpSeparableMetric.html">ExactPredicateLpSeparableMetric</a>&lt; T, p, P &gt; &amp;object)</td></tr>
<tr class="separator:a8b6b29dfb8da033f13dc6afc0728d1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84025008f3aed7e1e9f290b1822b711"><td class="memTemplParams" colspan="2">template&lt;typename TImage , typename TSet , typename TPointPredicate , typename TPointFunctor &gt; </td></tr>
<tr class="memitem:aa84025008f3aed7e1e9f290b1822b711"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa84025008f3aed7e1e9f290b1822b711">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1FMM.html">FMM</a>&lt; TImage, TSet, TPointPredicate, TPointFunctor &gt; &amp;object)</td></tr>
<tr class="separator:aa84025008f3aed7e1e9f290b1822b711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6ff11f2a468df0c081b71d67268e96"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:a3b6ff11f2a468df0c081b71d67268e96"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3b6ff11f2a468df0c081b71d67268e96">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1InexactPredicateLpSeparableMetric.html">InexactPredicateLpSeparableMetric</a>&lt; T, V &gt; &amp;object)</td></tr>
<tr class="separator:a3b6ff11f2a468df0c081b71d67268e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b42fcfed8d9da681ea8e96f44e3c968"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b42fcfed8d9da681ea8e96f44e3c968"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4b42fcfed8d9da681ea8e96f44e3c968">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1LpMetric.html">LpMetric</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a4b42fcfed8d9da681ea8e96f44e3c968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1daf9f63758c23c887f82362f4375bca"><td class="memTemplParams" colspan="2">template&lt;typename W , typename Sep , typename Image &gt; </td></tr>
<tr class="memitem:a1daf9f63758c23c887f82362f4375bca"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1daf9f63758c23c887f82362f4375bca">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1PowerMap.html">PowerMap</a>&lt; W, Sep, <a class="el" href="classDGtal_1_1Image.html">Image</a> &gt; &amp;object)</td></tr>
<tr class="separator:a1daf9f63758c23c887f82362f4375bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e0a7004286b0579aa6a27ca6804e85"><td class="memTemplParams" colspan="2">template&lt;typename W , typename TSep &gt; </td></tr>
<tr class="memitem:a94e0a7004286b0579aa6a27ca6804e85"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a94e0a7004286b0579aa6a27ca6804e85">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ReverseDistanceTransformation.html">ReverseDistanceTransformation</a>&lt; W, TSep &gt; &amp;object)</td></tr>
<tr class="separator:a94e0a7004286b0579aa6a27ca6804e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5335bdab6ea6b638c3143e952a0280"><td class="memTemplParams" colspan="2">template&lt;typename TM &gt; </td></tr>
<tr class="memitem:aba5335bdab6ea6b638c3143e952a0280"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aba5335bdab6ea6b638c3143e952a0280">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1SeparableMetricAdapter.html">SeparableMetricAdapter</a>&lt; TM &gt; &amp;object)</td></tr>
<tr class="separator:aba5335bdab6ea6b638c3143e952a0280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0a7c1e2501fb4352ecb8e8922cba23"><td class="memTemplParams" colspan="2">template&lt;typename S , typename P , typename Sep , typename TI &gt; </td></tr>
<tr class="memitem:a9b0a7c1e2501fb4352ecb8e8922cba23"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9b0a7c1e2501fb4352ecb8e8922cba23">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1VoronoiMap.html">VoronoiMap</a>&lt; S, P, Sep, TI &gt; &amp;object)</td></tr>
<tr class="separator:a9b0a7c1e2501fb4352ecb8e8922cba23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ebae2f928719f51222d9830f580ab6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a71ebae2f928719f51222d9830f580ab6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a71ebae2f928719f51222d9830f580ab6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Measure.html">Measure</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a71ebae2f928719f51222d9830f580ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44966d3cf1d860c33b6865fd6eb01ceb"><td class="memTemplParams" colspan="2">template&lt;typename TSpace , typename TSeparableMetric &gt; </td></tr>
<tr class="memitem:a44966d3cf1d860c33b6865fd6eb01ceb"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a44966d3cf1d860c33b6865fd6eb01ceb">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1VoronoiCovarianceMeasure.html">VoronoiCovarianceMeasure</a>&lt; TSpace, TSeparableMetric &gt; &amp;object)</td></tr>
<tr class="separator:a44966d3cf1d860c33b6865fd6eb01ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ff5382c423736c8d4abc902b00f86b"><td class="memTemplParams" colspan="2">template&lt;typename TO , typename TD , typename TS &gt; </td></tr>
<tr class="memitem:a77ff5382c423736c8d4abc902b00f86b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a77ff5382c423736c8d4abc902b00f86b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1KanungoNoise.html">KanungoNoise</a>&lt; TO, TD, TS &gt; &amp;object)</td></tr>
<tr class="separator:a77ff5382c423736c8d4abc902b00f86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f70d0ba908b7e05676658fa82734b4"><td class="memTemplParams" colspan="2">template&lt;typename TGraph , typename TMarkSet &gt; </td></tr>
<tr class="memitem:a75f70d0ba908b7e05676658fa82734b4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a75f70d0ba908b7e05676658fa82734b4">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1BreadthFirstVisitor.html">BreadthFirstVisitor</a>&lt; TGraph, TMarkSet &gt; &amp;object)</td></tr>
<tr class="separator:a75f70d0ba908b7e05676658fa82734b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26df83c104fdb5fe631aebda8f31d3b"><td class="memTemplParams" colspan="2">template&lt;typename TGraph , typename TMarkSet &gt; </td></tr>
<tr class="memitem:ae26df83c104fdb5fe631aebda8f31d3b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae26df83c104fdb5fe631aebda8f31d3b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DepthFirstVisitor.html">DepthFirstVisitor</a>&lt; TGraph, TMarkSet &gt; &amp;object)</td></tr>
<tr class="separator:ae26df83c104fdb5fe631aebda8f31d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49730b5a6af3e6dacff53ec86a215a06"><td class="memTemplParams" colspan="2">template&lt;typename TGraph , typename TVertexFunctor , typename TMarkSet &gt; </td></tr>
<tr class="memitem:a49730b5a6af3e6dacff53ec86a215a06"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a49730b5a6af3e6dacff53ec86a215a06">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DistanceBreadthFirstVisitor.html">DistanceBreadthFirstVisitor</a>&lt; TGraph, TVertexFunctor, TMarkSet &gt; &amp;object)</td></tr>
<tr class="separator:a49730b5a6af3e6dacff53ec86a215a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92bbcb0c90cddb06c7f84134c1e4a5f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa92bbcb0c90cddb06c7f84134c1e4a5f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa92bbcb0c90cddb06c7f84134c1e4a5f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Expander.html">Expander</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:aa92bbcb0c90cddb06c7f84134c1e4a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff5ef7c415d75ea4c324c23b7f49140"><td class="memTemplParams" colspan="2">template&lt;typename TGraphVisitor &gt; </td></tr>
<tr class="memitem:a4ff5ef7c415d75ea4c324c23b7f49140"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4ff5ef7c415d75ea4c324c23b7f49140">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GraphVisitorRange.html">GraphVisitorRange</a>&lt; TGraphVisitor &gt; &amp;object)</td></tr>
<tr class="separator:a4ff5ef7c415d75ea4c324c23b7f49140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3092d3b481169e879b1df8ca176dc6"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1c3092d3b481169e879b1df8ca176dc6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1ParameterValue.html">ParameterValue</a> &amp;object)</td></tr>
<tr class="separator:a1c3092d3b481169e879b1df8ca176dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb639abb32e1e88448c12452b197e63"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abbb639abb32e1e88448c12452b197e63">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1Parameters.html">Parameters</a> &amp;object)</td></tr>
<tr class="separator:abbb639abb32e1e88448c12452b197e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb255b0240525e530d72279416b7db56"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb255b0240525e530d72279416b7db56"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aeb255b0240525e530d72279416b7db56">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Shortcuts.html">Shortcuts</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:aeb255b0240525e530d72279416b7db56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3290776c6f437b487cca376b72a32364"><td class="memTemplParams" colspan="2">template&lt;typename TArrayIterator , typename TDomain &gt; </td></tr>
<tr class="memitem:a3290776c6f437b487cca376b72a32364"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3290776c6f437b487cca376b72a32364">operator&lt;&lt;</a> (std::ostream &amp;out, const ArrayImageAdapter&lt; TArrayIterator, TDomain &gt; &amp;object)</td></tr>
<tr class="memdesc:a3290776c6f437b487cca376b72a32364"><td class="mdescLeft">&#160;</td><td class="mdescRight">[<a class="el" href="classDGtal_1_1IteratorCompletionTraits.html" title="Aim: Traits that must be specialized for each IteratorCompletion derived class.">IteratorCompletionTraits</a>]  <a href="namespaceDGtal.html#a3290776c6f437b487cca376b72a32364">More...</a><br /></td></tr>
<tr class="separator:a3290776c6f437b487cca376b72a32364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7cc85d6072793cb8f15694be4d0d44"><td class="memTemplParams" colspan="2">template&lt;typename TArrayIterator , typename TDomain &gt; </td></tr>
<tr class="memitem:a4d7cc85d6072793cb8f15694be4d0d44"><td class="memTemplItemLeft" align="right" valign="top">ArrayImageAdapter&lt; TArrayIterator, TDomain &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4d7cc85d6072793cb8f15694be4d0d44">makeArrayImageAdapterFromIterator</a> (TArrayIterator anArrayIterator, TDomain const &amp;aFullDomain, TDomain const &amp;aViewDomain)</td></tr>
<tr class="separator:a4d7cc85d6072793cb8f15694be4d0d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a5010ce777b848a0978e57b93a42bc"><td class="memTemplParams" colspan="2">template&lt;typename TArrayIterator , typename TDomain &gt; </td></tr>
<tr class="memitem:ae2a5010ce777b848a0978e57b93a42bc"><td class="memTemplItemLeft" align="right" valign="top">ArrayImageAdapter&lt; TArrayIterator, TDomain &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae2a5010ce777b848a0978e57b93a42bc">makeArrayImageAdapterFromIterator</a> (TArrayIterator anArrayIterator, TDomain const &amp;aFullDomain)</td></tr>
<tr class="separator:ae2a5010ce777b848a0978e57b93a42bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8f2b0c05fa81f94692c1c48bb44c6b"><td class="memTemplParams" colspan="2">template&lt;typename TImage , typename TDomain  = typename TImage::Domain&gt; </td></tr>
<tr class="memitem:a5d8f2b0c05fa81f94692c1c48bb44c6b"><td class="memTemplItemLeft" align="right" valign="top">ArrayImageAdapter&lt; decltype(((TImage *) nullptr) -&gt;begin()), TDomain &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5d8f2b0c05fa81f94692c1c48bb44c6b">makeArrayImageAdapterFromImage</a> (TImage &amp;anImage, TDomain const &amp;aViewDomain)</td></tr>
<tr class="separator:a5d8f2b0c05fa81f94692c1c48bb44c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39878d0bfd6ec38b7dfee7bb095ffb4"><td class="memTemplParams" colspan="2">template&lt;typename TImage , typename TDomain  = typename TImage::Domain&gt; </td></tr>
<tr class="memitem:ac39878d0bfd6ec38b7dfee7bb095ffb4"><td class="memTemplItemLeft" align="right" valign="top">ArrayImageAdapter&lt; decltype(((TImage *) nullptr) -&gt;begin()), TDomain &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac39878d0bfd6ec38b7dfee7bb095ffb4">makeArrayImageAdapterFromImage</a> (TImage &amp;anImage)</td></tr>
<tr class="separator:ac39878d0bfd6ec38b7dfee7bb095ffb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf1432bfdb1b6298b58a87b7abe81cf"><td class="memTemplParams" colspan="2">template&lt;typename TIterableClass &gt; </td></tr>
<tr class="memitem:acdf1432bfdb1b6298b58a87b7abe81cf"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#acdf1432bfdb1b6298b58a87b7abe81cf">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ArrayImageIterator.html">ArrayImageIterator</a>&lt; TIterableClass &gt; &amp;object)</td></tr>
<tr class="separator:acdf1432bfdb1b6298b58a87b7abe81cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d89ceb668c40a2e86d1ff5b41fbf59"><td class="memTemplParams" colspan="2">template&lt;typename TImageContainer , typename TNewDomain , typename TFunctorD , typename TNewValue , typename TFunctorV &gt; </td></tr>
<tr class="memitem:a44d89ceb668c40a2e86d1ff5b41fbf59"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a44d89ceb668c40a2e86d1ff5b41fbf59">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ConstImageAdapter.html">ConstImageAdapter</a>&lt; TImageContainer, TNewDomain, TFunctorD, TNewValue, TFunctorV &gt; &amp;object)</td></tr>
<tr class="separator:a44d89ceb668c40a2e86d1ff5b41fbf59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4801ed1e1263f017f891f2ad81c73beb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4801ed1e1263f017f891f2ad81c73beb"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4801ed1e1263f017f891f2ad81c73beb">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Image.html">Image</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a4801ed1e1263f017f891f2ad81c73beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6600699772a4cb84168f5df6de7fb9fb"><td class="memTemplParams" colspan="2">template&lt;typename TImageContainer , typename TNewDomain , typename TFunctorD , typename TNewValue , typename TFunctorV , typename TFunctorVm1 &gt; </td></tr>
<tr class="memitem:a6600699772a4cb84168f5df6de7fb9fb"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6600699772a4cb84168f5df6de7fb9fb">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImageAdapter.html">ImageAdapter</a>&lt; TImageContainer, TNewDomain, TFunctorD, TNewValue, TFunctorV, TFunctorVm1 &gt; &amp;object)</td></tr>
<tr class="separator:a6600699772a4cb84168f5df6de7fb9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023df84c861e7dd414bae501a62aff19"><td class="memTemplParams" colspan="2">template&lt;typename TImageContainer , typename TImageFactory , typename TReadPolicy , typename TWritePolicy &gt; </td></tr>
<tr class="memitem:a023df84c861e7dd414bae501a62aff19"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a023df84c861e7dd414bae501a62aff19">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImageCache.html">ImageCache</a>&lt; TImageContainer, TImageFactory, TReadPolicy, TWritePolicy &gt; &amp;object)</td></tr>
<tr class="separator:a023df84c861e7dd414bae501a62aff19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf8e0ddcbbe3ba4780a5c8589c4fc41"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TV &gt; </td></tr>
<tr class="memitem:aeaf8e0ddcbbe3ba4780a5c8589c4fc41"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aeaf8e0ddcbbe3ba4780a5c8589c4fc41">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImageContainerByITKImage.html">ImageContainerByITKImage</a>&lt; T, TV &gt; &amp;object)</td></tr>
<tr class="separator:aeaf8e0ddcbbe3ba4780a5c8589c4fc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d8ad5b6fd2dc5b1a3cff0afc4e3a5c"><td class="memTemplParams" colspan="2">template&lt;typename TDomain , typename TValue &gt; </td></tr>
<tr class="memitem:a30d8ad5b6fd2dc5b1a3cff0afc4e3a5c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a30d8ad5b6fd2dc5b1a3cff0afc4e3a5c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a>&lt; TDomain, TValue &gt; &amp;object)</td></tr>
<tr class="separator:a30d8ad5b6fd2dc5b1a3cff0afc4e3a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec460eda081b4dc6922174819cae6cc"><td class="memTemplParams" colspan="2">template&lt;typename Domain , typename V &gt; </td></tr>
<tr class="memitem:afec460eda081b4dc6922174819cae6cc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afec460eda081b4dc6922174819cae6cc">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>&lt; <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a>, V &gt; &amp;object)</td></tr>
<tr class="separator:afec460eda081b4dc6922174819cae6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c7224d39e1bb3537f8c5d6012e1921"><td class="memTemplParams" colspan="2">template&lt;typename TImageContainer &gt; </td></tr>
<tr class="memitem:a11c7224d39e1bb3537f8c5d6012e1921"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a11c7224d39e1bb3537f8c5d6012e1921">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImageFactoryFromHDF5.html">ImageFactoryFromHDF5</a>&lt; TImageContainer &gt; &amp;object)</td></tr>
<tr class="separator:a11c7224d39e1bb3537f8c5d6012e1921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86c21332bf1c7be1c10b6f80939273a"><td class="memTemplParams" colspan="2">template&lt;typename TImageContainer &gt; </td></tr>
<tr class="memitem:aa86c21332bf1c7be1c10b6f80939273a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa86c21332bf1c7be1c10b6f80939273a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImageFactoryFromImage.html">ImageFactoryFromImage</a>&lt; TImageContainer &gt; &amp;object)</td></tr>
<tr class="separator:aa86c21332bf1c7be1c10b6f80939273a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67647d42db11b7b3d3533e1cba6c2ba"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename P &gt; </td></tr>
<tr class="memitem:ad67647d42db11b7b3d3533e1cba6c2ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad67647d42db11b7b3d3533e1cba6c2ba">setFromPointsRangeAndPredicate</a> (const I &amp;itb, const I &amp;ite, const O &amp;ito, const P &amp;aPred)</td></tr>
<tr class="memdesc:ad67647d42db11b7b3d3533e1cba6c2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">useful functions  <a href="namespaceDGtal.html#ad67647d42db11b7b3d3533e1cba6c2ba">More...</a><br /></td></tr>
<tr class="separator:ad67647d42db11b7b3d3533e1cba6c2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57d4465e40fe4c1982ec2e01985be73"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename F &gt; </td></tr>
<tr class="memitem:ad57d4465e40fe4c1982ec2e01985be73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad57d4465e40fe4c1982ec2e01985be73">setFromPointsRangeAndFunctor</a> (const I &amp;itb, const I &amp;ite, const O &amp;ito, const F &amp;aFunctor, const typename <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">F::Value</a> &amp;aThreshold=0)</td></tr>
<tr class="separator:ad57d4465e40fe4c1982ec2e01985be73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202be24e94b5bdfba2d8563d0947f373"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:a202be24e94b5bdfba2d8563d0947f373"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a202be24e94b5bdfba2d8563d0947f373">setFromImage</a> (const I &amp;aImg, const O &amp;ito, const typename <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">I::Value</a> &amp;aThreshold=0)</td></tr>
<tr class="separator:a202be24e94b5bdfba2d8563d0947f373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecddf53312d4b765f34a022b049627c3"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:aecddf53312d4b765f34a022b049627c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aecddf53312d4b765f34a022b049627c3">setFromImage</a> (const I &amp;aImg, const O &amp;ito, const typename <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">I::Value</a> &amp;low, const typename <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">I::Value</a> &amp;up)</td></tr>
<tr class="separator:aecddf53312d4b765f34a022b049627c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1511d84bd2b82df82bea3aefc3af2dd"><td class="memTemplParams" colspan="2">template&lt;typename It , typename Im &gt; </td></tr>
<tr class="memitem:ac1511d84bd2b82df82bea3aefc3af2dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac1511d84bd2b82df82bea3aefc3af2dd">imageFromRangeAndValue</a> (const It &amp;itb, const It &amp;ite, Im &amp;aImg, const typename <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Im::Value</a> &amp;aValue=0)</td></tr>
<tr class="separator:ac1511d84bd2b82df82bea3aefc3af2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff03c6c44f0ec8ad182440aad1b4e86a"><td class="memTemplParams" colspan="2">template&lt;typename R , typename I &gt; </td></tr>
<tr class="memitem:aff03c6c44f0ec8ad182440aad1b4e86a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aff03c6c44f0ec8ad182440aad1b4e86a">imageFromRangeAndValue</a> (const R &amp;aRange, I &amp;aImg, const typename <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">I::Value</a> &amp;aValue=0)</td></tr>
<tr class="separator:aff03c6c44f0ec8ad182440aad1b4e86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46234d3693677caa52b0ffb6db059d5d"><td class="memTemplParams" colspan="2">template&lt;typename I , typename F &gt; </td></tr>
<tr class="memitem:a46234d3693677caa52b0ffb6db059d5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a46234d3693677caa52b0ffb6db059d5d">imageFromFunctor</a> (I &amp;aImg, const F &amp;aFun)</td></tr>
<tr class="separator:a46234d3693677caa52b0ffb6db059d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8c71069e10fc24d2a0e0ae927635ac"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename I2 &gt; </td></tr>
<tr class="memitem:a9e8c71069e10fc24d2a0e0ae927635ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9e8c71069e10fc24d2a0e0ae927635ac">imageFromImage</a> (I1 &amp;aImg1, const I2 &amp;aImg2)</td></tr>
<tr class="separator:a9e8c71069e10fc24d2a0e0ae927635ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f01a70f2cf84e9c08d1308e77911a08"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S &gt; </td></tr>
<tr class="memitem:a5f01a70f2cf84e9c08d1308e77911a08"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5f01a70f2cf84e9c08d1308e77911a08">insertAndSetValue</a> (I &amp;aImg, S &amp;aSet, const typename <a class="el" href="examplePlaneProbingTetrahedronEstimator_8cpp.html#aa735f3a0c2faee42eae6a625d2ae8760">I::Point</a> &amp;<a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a9ae40316aa447d5a39eb6f76dba59444">aPoint</a>, const typename <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">I::Value</a> &amp;aValue)</td></tr>
<tr class="separator:a5f01a70f2cf84e9c08d1308e77911a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac920bc98f866a2e17ee53faddc67ff80"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S &gt; </td></tr>
<tr class="memitem:ac920bc98f866a2e17ee53faddc67ff80"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac920bc98f866a2e17ee53faddc67ff80">insertAndAlwaysSetValue</a> (I &amp;aImg, S &amp;aSet, const typename <a class="el" href="examplePlaneProbingTetrahedronEstimator_8cpp.html#aa735f3a0c2faee42eae6a625d2ae8760">I::Point</a> &amp;<a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a9ae40316aa447d5a39eb6f76dba59444">aPoint</a>, const typename <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">I::Value</a> &amp;aValue)</td></tr>
<tr class="separator:ac920bc98f866a2e17ee53faddc67ff80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f73d6217f05eef8225781a523efc077"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S &gt; </td></tr>
<tr class="memitem:a3f73d6217f05eef8225781a523efc077"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3f73d6217f05eef8225781a523efc077">findAndGetValue</a> (const I &amp;aImg, const S &amp;aSet, const typename <a class="el" href="examplePlaneProbingTetrahedronEstimator_8cpp.html#aa735f3a0c2faee42eae6a625d2ae8760">I::Point</a> &amp;<a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a9ae40316aa447d5a39eb6f76dba59444">aPoint</a>, typename <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">I::Value</a> &amp;aValue)</td></tr>
<tr class="separator:a3f73d6217f05eef8225781a523efc077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad893514689ceaf38eb331feb0cbb83"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TImage , typename TEmbedder &gt; </td></tr>
<tr class="memitem:a2ad893514689ceaf38eb331feb0cbb83"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2ad893514689ceaf38eb331feb0cbb83">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImageLinearCellEmbedder.html">ImageLinearCellEmbedder</a>&lt; TKSpace, TImage, TEmbedder &gt; &amp;object)</td></tr>
<tr class="separator:a2ad893514689ceaf38eb331feb0cbb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0c6e42a58ca70e5d28281050c88574"><td class="memTemplParams" colspan="2">template&lt;typename TImageContainer , typename TImageFactory , typename TImageCacheReadPolicy , typename TImageCacheWritePolicy &gt; </td></tr>
<tr class="memitem:aaa0c6e42a58ca70e5d28281050c88574"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aaa0c6e42a58ca70e5d28281050c88574">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1TiledImage.html">TiledImage</a>&lt; TImageContainer, TImageFactory, TImageCacheReadPolicy, TImageCacheWritePolicy &gt; &amp;object)</td></tr>
<tr class="separator:aaa0c6e42a58ca70e5d28281050c88574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48eda6ac0ad627de337fbf0f380f446a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a48eda6ac0ad627de337fbf0f380f446a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Board2D.html">Board2D</a> &amp;object)</td></tr>
<tr class="separator:a48eda6ac0ad627de337fbf0f380f446a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764912e949cef91dac5e9620e985074e"><td class="memTemplParams" colspan="2">template&lt;typename Space , typename KSpace &gt; </td></tr>
<tr class="memitem:a764912e949cef91dac5e9620e985074e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a764912e949cef91dac5e9620e985074e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Board3D.html">Board3D</a>&lt; <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a38dfaf1641eab4d3fb805df4b52ab10d">Space</a>, <a class="el" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a> &gt; &amp;object)</td></tr>
<tr class="separator:a764912e949cef91dac5e9620e985074e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02bb85760b407e96a4e4a3c2159f558"><td class="memTemplParams" colspan="2">template&lt;typename Space , typename KSpace &gt; </td></tr>
<tr class="memitem:aa02bb85760b407e96a4e4a3c2159f558"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa02bb85760b407e96a4e4a3c2159f558">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Board3DTo2D.html">Board3DTo2D</a>&lt; <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a38dfaf1641eab4d3fb805df4b52ab10d">Space</a>, <a class="el" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a> &gt; &amp;object)</td></tr>
<tr class="separator:aa02bb85760b407e96a4e4a3c2159f558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea63233a5efe92ca5048ea4e965155cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1Color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aea63233a5efe92ca5048ea4e965155cd">operator*</a> (const double coeff, const <a class="el" href="classDGtal_1_1Color.html">Color</a> &amp;aColor)</td></tr>
<tr class="separator:aea63233a5efe92ca5048ea4e965155cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af044fcd2d297fa25c9000469042edbe0"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af044fcd2d297fa25c9000469042edbe0">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Color.html">Color</a> &amp;aColor)</td></tr>
<tr class="separator:af044fcd2d297fa25c9000469042edbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f741db2aff5b278688197ead61fbf84"><td class="memTemplParams" colspan="2">template&lt;typename PValue , int PDefaultColor&gt; </td></tr>
<tr class="memitem:a1f741db2aff5b278688197ead61fbf84"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1f741db2aff5b278688197ead61fbf84">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ColorBrightnessColorMap.html">ColorBrightnessColorMap</a>&lt; PValue, PDefaultColor &gt; &amp;object)</td></tr>
<tr class="separator:a1f741db2aff5b278688197ead61fbf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780bffe88dbcc0c1e8d268c165f2730c"><td class="memTemplParams" colspan="2">template&lt;typename PValue , int PDefaultPreset, int PDefaultFirstColor, int PDefaultLastColor&gt; </td></tr>
<tr class="memitem:a780bffe88dbcc0c1e8d268c165f2730c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a780bffe88dbcc0c1e8d268c165f2730c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GradientColorMap.html">GradientColorMap</a>&lt; PValue, PDefaultPreset, PDefaultFirstColor, PDefaultLastColor &gt; &amp;object)</td></tr>
<tr class="separator:a780bffe88dbcc0c1e8d268c165f2730c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485151b618f71a80d057c3c7d35e84ca"><td class="memTemplParams" colspan="2">template&lt;typename PValue &gt; </td></tr>
<tr class="memitem:a485151b618f71a80d057c3c7d35e84ca"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a485151b618f71a80d057c3c7d35e84ca">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GrayscaleColorMap.html">GrayscaleColorMap</a>&lt; PValue &gt; &amp;object)</td></tr>
<tr class="separator:a485151b618f71a80d057c3c7d35e84ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f3490f30f770c8fc9fc6dd445cd93c"><td class="memTemplParams" colspan="2">template&lt;typename PValue , int DefaultCycles&gt; </td></tr>
<tr class="memitem:a69f3490f30f770c8fc9fc6dd445cd93c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a69f3490f30f770c8fc9fc6dd445cd93c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1HueShadeColorMap.html">HueShadeColorMap</a>&lt; PValue, DefaultCycles &gt; &amp;object)</td></tr>
<tr class="separator:a69f3490f30f770c8fc9fc6dd445cd93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53148a67ad6de6ed49d57c605def778b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a53148a67ad6de6ed49d57c605def778b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1RandomColorMap.html">RandomColorMap</a> &amp;object)</td></tr>
<tr class="separator:a53148a67ad6de6ed49d57c605def778b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd6d86a7d67dd305921a4cf496fe392"><td class="memTemplParams" colspan="2">template&lt;typename TValue , typename CMAP &gt; </td></tr>
<tr class="memitem:abfd6d86a7d67dd305921a4cf496fe392"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abfd6d86a7d67dd305921a4cf496fe392">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1TickedColorMap.html">TickedColorMap</a>&lt; TValue, CMAP &gt; &amp;object)</td></tr>
<tr class="separator:abfd6d86a7d67dd305921a4cf496fe392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0736f0d4cdf97e4590b4b9ca7fb7f46a"><td class="memTemplParams" colspan="2">template&lt;typename Space , typename KSpace &gt; </td></tr>
<tr class="memitem:a0736f0d4cdf97e4590b4b9ca7fb7f46a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0736f0d4cdf97e4590b4b9ca7fb7f46a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Display3D.html">DGtal::Display3D</a>&lt; <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a38dfaf1641eab4d3fb805df4b52ab10d">Space</a>, <a class="el" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a> &gt; &amp;object)</td></tr>
<tr class="separator:a0736f0d4cdf97e4590b4b9ca7fb7f46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf670898dd1e99bc4c6447117ed29eb7"><td class="memTemplParams" colspan="2">template&lt;typename Space , typename KSpace &gt; </td></tr>
<tr class="memitem:abf670898dd1e99bc4c6447117ed29eb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abf670898dd1e99bc4c6447117ed29eb7">operator&gt;&gt;</a> (const <a class="el" href="classDGtal_1_1Display3D.html">Display3D</a>&lt; <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a38dfaf1641eab4d3fb805df4b52ab10d">Space</a>, <a class="el" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a> &gt; &amp;aDisplay3D, <a class="el" href="classDGtal_1_1Mesh.html">DGtal::Mesh</a>&lt; typename <a class="el" href="classDGtal_1_1Display3D.html">Display3D</a>&lt; <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a38dfaf1641eab4d3fb805df4b52ab10d">Space</a>, <a class="el" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a> &gt;::<a class="el" href="testAstroid2D_8cpp.html#ac914bb734ccb5a7c569747c1e699c1aa">RealPoint</a> &gt; &amp;aMesh)</td></tr>
<tr class="separator:abf670898dd1e99bc4c6447117ed29eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb296bcee16299e888ac032e4ec5c31c"><td class="memTemplParams" colspan="2">template&lt;typename Space , typename KSpace &gt; </td></tr>
<tr class="memitem:aeb296bcee16299e888ac032e4ec5c31c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aeb296bcee16299e888ac032e4ec5c31c">operator&gt;&gt;</a> (const <a class="el" href="classDGtal_1_1Display3D.html">Display3D</a>&lt; <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a38dfaf1641eab4d3fb805df4b52ab10d">Space</a>, <a class="el" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a> &gt; &amp;aDisplay3D, std::string aFilename)</td></tr>
<tr class="separator:aeb296bcee16299e888ac032e4ec5c31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a3903fa935b85eb3a22de1d383df9d"><td class="memTemplParams" colspan="2">template&lt;typename TPoint &gt; </td></tr>
<tr class="memitem:a55a3903fa935b85eb3a22de1d383df9d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a55a3903fa935b85eb3a22de1d383df9d">operator&lt;&lt;</a> (<a class="el" href="classDGtal_1_1Mesh.html">Mesh</a>&lt; TPoint &gt; &amp;mesh, const std::string &amp;filename)</td></tr>
<tr class="separator:a55a3903fa935b85eb3a22de1d383df9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94a183d64e1d3e73261193fb5268ed6"><td class="memTemplParams" colspan="2">template&lt;int n, typename TRing , typename TAlloc , typename TIterator &gt; </td></tr>
<tr class="memitem:ab94a183d64e1d3e73261193fb5268ed6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab94a183d64e1d3e73261193fb5268ed6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1MPolynomialReader.html">MPolynomialReader</a>&lt; n, TRing, TAlloc, TIterator &gt; &amp;object)</td></tr>
<tr class="separator:ab94a183d64e1d3e73261193fb5268ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11563209db63d64213d8ca0f0e1b849"><td class="memTemplParams" colspan="2">template&lt;int n, typename TRing , class TAlloc &gt; </td></tr>
<tr class="memitem:ad11563209db63d64213d8ca0f0e1b849"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad11563209db63d64213d8ca0f0e1b849">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, TRing, TAlloc &gt; &amp;aMPolynomial)</td></tr>
<tr class="separator:ad11563209db63d64213d8ca0f0e1b849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ae76fb7492c32363914f09e8ad5d23"><td class="memTemplParams" colspan="2">template&lt;typename Word &gt; </td></tr>
<tr class="memitem:aa1ae76fb7492c32363914f09e8ad5d23"><td class="memTemplItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa1ae76fb7492c32363914f09e8ad5d23">raw_reader_read_word</a> (FILE *fin, Word &amp;aValue)</td></tr>
<tr class="separator:aa1ae76fb7492c32363914f09e8ad5d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8db91c68b970e26585a4e832a08f99"><td class="memTemplParams" colspan="2">template&lt;typename TSpace , typename TKSpace &gt; </td></tr>
<tr class="memitem:aab8db91c68b970e26585a4e832a08f99"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aab8db91c68b970e26585a4e832a08f99">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a>&lt; TSpace, TKSpace &gt; &amp;object)</td></tr>
<tr class="separator:aab8db91c68b970e26585a4e832a08f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26182a3cb414de00abe8a72418594cb9"><td class="memTemplParams" colspan="2">template&lt;typename TImageContainer &gt; </td></tr>
<tr class="memitem:a26182a3cb414de00abe8a72418594cb9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a26182a3cb414de00abe8a72418594cb9">operator&gt;&gt;</a> (const TImageContainer &amp;aContainer, const std::string &amp;aFilename)</td></tr>
<tr class="separator:a26182a3cb414de00abe8a72418594cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec0f66667f87bf9084634774c580216"><td class="memTemplParams" colspan="2">template&lt;typename TPoint &gt; </td></tr>
<tr class="memitem:abec0f66667f87bf9084634774c580216"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abec0f66667f87bf9084634774c580216">operator&gt;&gt;</a> (<a class="el" href="classDGtal_1_1Mesh.html">Mesh</a>&lt; TPoint &gt; &amp;aMesh, const std::string &amp;aFilename)</td></tr>
<tr class="separator:abec0f66667f87bf9084634774c580216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978d84bb767fd5317f6b5a34fc943bc6"><td class="memTemplParams" colspan="2">template&lt;typename TPoint &gt; </td></tr>
<tr class="memitem:a978d84bb767fd5317f6b5a34fc943bc6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a978d84bb767fd5317f6b5a34fc943bc6">operator&gt;&gt;</a> (<a class="el" href="classDGtal_1_1Mesh.html">Mesh</a>&lt; TPoint &gt; &amp;aMesh, std::ostream &amp;out)</td></tr>
<tr class="separator:a978d84bb767fd5317f6b5a34fc943bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4f65e9452ec5865b8959a728a0f2db"><td class="memTemplParams" colspan="2">template&lt;typename Word &gt; </td></tr>
<tr class="memitem:a6e4f65e9452ec5865b8959a728a0f2db"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6e4f65e9452ec5865b8959a728a0f2db">raw_writer_write_word</a> (std::ostream &amp;outs, Word value)</td></tr>
<tr class="separator:a6e4f65e9452ec5865b8959a728a0f2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6d219dcad7382fbe63f8b98941d0d8"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename... Args&gt; </td></tr>
<tr class="memitem:abc6d219dcad7382fbe63f8b98941d0d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDGtal.html#a55bbc4405f35f8a03161e41068432454">ArithmeticConversionType</a>&lt; LHS, RHS &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">constructFromArithmeticConversion</a> (LHS const &amp;lhs, RHS const &amp;rhs, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:abc6d219dcad7382fbe63f8b98941d0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call constructor for the result type of an arithmetic operation.  <a href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">More...</a><br /></td></tr>
<tr class="separator:abc6d219dcad7382fbe63f8b98941d0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09507195f1c90b1e477e54afd0b3365d"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a09507195f1c90b1e477e54afd0b3365d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a09507195f1c90b1e477e54afd0b3365d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1CanonicEmbedder.html">CanonicEmbedder</a>&lt; TSpace &gt; &amp;object)</td></tr>
<tr class="separator:a09507195f1c90b1e477e54afd0b3365d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af95afbaeec3e49ad813181f4f2f115"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a2af95afbaeec3e49ad813181f4f2f115"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2af95afbaeec3e49ad813181f4f2f115">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1HyperRectDomain.html">HyperRectDomain</a>&lt; TSpace &gt; &amp;object)</td></tr>
<tr class="separator:a2af95afbaeec3e49ad813181f4f2f115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ed66b76e2b393001ace71569e839ff"><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename Container &gt; </td></tr>
<tr class="memitem:af1ed66b76e2b393001ace71569e839ff"><td class="memTemplItemLeft" align="right" valign="top">std::bitset&lt; <a class="el" href="viewDualSurface_8cpp.html#a1a254aa17418553bc21790001a69262a">dim</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af1ed66b76e2b393001ace71569e839ff">setDimensionsIn</a> (const Container &amp;dimensions)</td></tr>
<tr class="separator:af1ed66b76e2b393001ace71569e839ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d0cc741e29aea32636e795dda2f109"><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename Container &gt; </td></tr>
<tr class="memitem:ac0d0cc741e29aea32636e795dda2f109"><td class="memTemplItemLeft" align="right" valign="top">std::bitset&lt; <a class="el" href="viewDualSurface_8cpp.html#a1a254aa17418553bc21790001a69262a">dim</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac0d0cc741e29aea32636e795dda2f109">setDimensionsNotIn</a> (const Container &amp;dimensions)</td></tr>
<tr class="separator:ac0d0cc741e29aea32636e795dda2f109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25becea09496daadf802e0b440a2a31c"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </td></tr>
<tr class="memitem:a25becea09496daadf802e0b440a2a31c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a25becea09496daadf802e0b440a2a31c">operator==</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;lhs, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a25becea09496daadf802e0b440a2a31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator between two Points/Vectors.  <a href="namespaceDGtal.html#a25becea09496daadf802e0b440a2a31c">More...</a><br /></td></tr>
<tr class="separator:a25becea09496daadf802e0b440a2a31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5239018e29ed723fad811621f0ec0432"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </td></tr>
<tr class="memitem:a5239018e29ed723fad811621f0ec0432"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5239018e29ed723fad811621f0ec0432">operator!=</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;lhs, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a5239018e29ed723fad811621f0ec0432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Difference operator on Points/Vectors.  <a href="namespaceDGtal.html#a5239018e29ed723fad811621f0ec0432">More...</a><br /></td></tr>
<tr class="separator:a5239018e29ed723fad811621f0ec0432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aea121a396821797edc0eff58f2cb7a"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </td></tr>
<tr class="memitem:a7aea121a396821797edc0eff58f2cb7a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7aea121a396821797edc0eff58f2cb7a">operator&lt;</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;lhs, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a7aea121a396821797edc0eff58f2cb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator on Points/Vectors (LesserThan).  <a href="namespaceDGtal.html#a7aea121a396821797edc0eff58f2cb7a">More...</a><br /></td></tr>
<tr class="separator:a7aea121a396821797edc0eff58f2cb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94cc295d2a53018ab279b554ad84259"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </td></tr>
<tr class="memitem:ad94cc295d2a53018ab279b554ad84259"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad94cc295d2a53018ab279b554ad84259">operator&gt;</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;lhs, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:ad94cc295d2a53018ab279b554ad84259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator on Points/Vectors (GreaterThan).  <a href="namespaceDGtal.html#ad94cc295d2a53018ab279b554ad84259">More...</a><br /></td></tr>
<tr class="separator:ad94cc295d2a53018ab279b554ad84259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762b7a56c29d9277e293fe02da37e075"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </td></tr>
<tr class="memitem:a762b7a56c29d9277e293fe02da37e075"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a762b7a56c29d9277e293fe02da37e075">operator&lt;=</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;lhs, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a762b7a56c29d9277e293fe02da37e075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator on Points/Vectors (LesserOrEqualThan).  <a href="namespaceDGtal.html#a762b7a56c29d9277e293fe02da37e075">More...</a><br /></td></tr>
<tr class="separator:a762b7a56c29d9277e293fe02da37e075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003343ddf52f61621688be55f2c9e463"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </td></tr>
<tr class="memitem:a003343ddf52f61621688be55f2c9e463"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a003343ddf52f61621688be55f2c9e463">operator&gt;=</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;lhs, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a003343ddf52f61621688be55f2c9e463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator on Points/Vectors (GreaterOrEqualThan).  <a href="namespaceDGtal.html#a003343ddf52f61621688be55f2c9e463">More...</a><br /></td></tr>
<tr class="separator:a003343ddf52f61621688be55f2c9e463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86626d443cf72fd15d58a94d709d566f"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </td></tr>
<tr class="memitem:a86626d443cf72fd15d58a94d709d566f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a86626d443cf72fd15d58a94d709d566f">operator+</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;lhs, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;rhs) -&gt; decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td></tr>
<tr class="memdesc:a86626d443cf72fd15d58a94d709d566f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator between two Points/Vectors.  <a href="namespaceDGtal.html#a86626d443cf72fd15d58a94d709d566f">More...</a><br /></td></tr>
<tr class="separator:a86626d443cf72fd15d58a94d709d566f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73bc107bf5faa1dfbb4ad23d2dda9099"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </td></tr>
<tr class="memitem:a73bc107bf5faa1dfbb4ad23d2dda9099"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a73bc107bf5faa1dfbb4ad23d2dda9099">operator-</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;lhs, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;rhs) -&gt; decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td></tr>
<tr class="memdesc:a73bc107bf5faa1dfbb4ad23d2dda9099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator between two Points/Vectors.  <a href="namespaceDGtal.html#a73bc107bf5faa1dfbb4ad23d2dda9099">More...</a><br /></td></tr>
<tr class="separator:a73bc107bf5faa1dfbb4ad23d2dda9099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fd09c1e06ec1263fe83cba764b54c7"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </td></tr>
<tr class="memitem:a40fd09c1e06ec1263fe83cba764b54c7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a40fd09c1e06ec1263fe83cba764b54c7">operator*</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;lhs, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;rhs) -&gt; decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td></tr>
<tr class="memdesc:a40fd09c1e06ec1263fe83cba764b54c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator between two Points/Vectors.  <a href="namespaceDGtal.html#a40fd09c1e06ec1263fe83cba764b54c7">More...</a><br /></td></tr>
<tr class="separator:a40fd09c1e06ec1263fe83cba764b54c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa320999d6387f35c03264c5984355c3f"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </td></tr>
<tr class="memitem:aa320999d6387f35c03264c5984355c3f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa320999d6387f35c03264c5984355c3f">operator/</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;lhs, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;rhs) -&gt; decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td></tr>
<tr class="memdesc:aa320999d6387f35c03264c5984355c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator between two Points/Vectors.  <a href="namespaceDGtal.html#aa320999d6387f35c03264c5984355c3f">More...</a><br /></td></tr>
<tr class="separator:aa320999d6387f35c03264c5984355c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91983378c10b6d909535e581661daae"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightScalar &gt; </td></tr>
<tr class="memitem:aa91983378c10b6d909535e581661daae"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa91983378c10b6d909535e581661daae">operator+</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;lhs, RightScalar const &amp;rhs) -&gt; decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td></tr>
<tr class="memdesc:aa91983378c10b6d909535e581661daae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator between a Point/Vector and a scalar.  <a href="namespaceDGtal.html#aa91983378c10b6d909535e581661daae">More...</a><br /></td></tr>
<tr class="separator:aa91983378c10b6d909535e581661daae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0269f9a89baa463f71fec06c5487fd6"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftScalar , typename RightEuclideanRing , typename RightContainer &gt; </td></tr>
<tr class="memitem:ac0269f9a89baa463f71fec06c5487fd6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac0269f9a89baa463f71fec06c5487fd6">operator+</a> (LeftScalar const &amp;lhs, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;rhs) -&gt; decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td></tr>
<tr class="memdesc:ac0269f9a89baa463f71fec06c5487fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator between a scalar and a Point/Vector.  <a href="namespaceDGtal.html#ac0269f9a89baa463f71fec06c5487fd6">More...</a><br /></td></tr>
<tr class="separator:ac0269f9a89baa463f71fec06c5487fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcda92e8bf3c2c9337277fb908b3f258"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightScalar &gt; </td></tr>
<tr class="memitem:abcda92e8bf3c2c9337277fb908b3f258"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abcda92e8bf3c2c9337277fb908b3f258">operator-</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;lhs, RightScalar const &amp;rhs) -&gt; decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td></tr>
<tr class="memdesc:abcda92e8bf3c2c9337277fb908b3f258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator between a Point/Vector and a scalar.  <a href="namespaceDGtal.html#abcda92e8bf3c2c9337277fb908b3f258">More...</a><br /></td></tr>
<tr class="separator:abcda92e8bf3c2c9337277fb908b3f258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e1a107bc846d1fc6df40d9a7ffa571"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftScalar , typename RightEuclideanRing , typename RightContainer &gt; </td></tr>
<tr class="memitem:a25e1a107bc846d1fc6df40d9a7ffa571"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a25e1a107bc846d1fc6df40d9a7ffa571">operator-</a> (LeftScalar const &amp;lhs, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;rhs) -&gt; decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td></tr>
<tr class="memdesc:a25e1a107bc846d1fc6df40d9a7ffa571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substraction operator between a scalar and a Point/Vector.  <a href="namespaceDGtal.html#a25e1a107bc846d1fc6df40d9a7ffa571">More...</a><br /></td></tr>
<tr class="separator:a25e1a107bc846d1fc6df40d9a7ffa571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d6a8275616ead7a8ed793de952eb46"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightScalar &gt; </td></tr>
<tr class="memitem:a33d6a8275616ead7a8ed793de952eb46"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a33d6a8275616ead7a8ed793de952eb46">operator*</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;lhs, RightScalar const &amp;rhs) -&gt; decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td></tr>
<tr class="memdesc:a33d6a8275616ead7a8ed793de952eb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator between a Point/Vector and a scalar.  <a href="namespaceDGtal.html#a33d6a8275616ead7a8ed793de952eb46">More...</a><br /></td></tr>
<tr class="separator:a33d6a8275616ead7a8ed793de952eb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f23c185684bf04a88db79a08999be4"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftScalar , typename RightEuclideanRing , typename RightContainer &gt; </td></tr>
<tr class="memitem:a15f23c185684bf04a88db79a08999be4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a15f23c185684bf04a88db79a08999be4">operator*</a> (LeftScalar const &amp;lhs, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;rhs) -&gt; decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td></tr>
<tr class="memdesc:a15f23c185684bf04a88db79a08999be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator between a scalar and a Point/Vector.  <a href="namespaceDGtal.html#a15f23c185684bf04a88db79a08999be4">More...</a><br /></td></tr>
<tr class="separator:a15f23c185684bf04a88db79a08999be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd3a380a6eb27322cc72b886c290734"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightScalar &gt; </td></tr>
<tr class="memitem:affd3a380a6eb27322cc72b886c290734"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#affd3a380a6eb27322cc72b886c290734">operator/</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;lhs, RightScalar const &amp;rhs) -&gt; decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td></tr>
<tr class="memdesc:affd3a380a6eb27322cc72b886c290734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator between a Point/Vector and a scalar.  <a href="namespaceDGtal.html#affd3a380a6eb27322cc72b886c290734">More...</a><br /></td></tr>
<tr class="separator:affd3a380a6eb27322cc72b886c290734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73bff88284b00b08e9aea5aa050b2d20"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftScalar , typename RightEuclideanRing , typename RightContainer &gt; </td></tr>
<tr class="memitem:a73bff88284b00b08e9aea5aa050b2d20"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a73bff88284b00b08e9aea5aa050b2d20">operator/</a> (LeftScalar const &amp;lhs, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;rhs) -&gt; decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td></tr>
<tr class="memdesc:a73bff88284b00b08e9aea5aa050b2d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator between a scalar and a Point/Vector.  <a href="namespaceDGtal.html#a73bff88284b00b08e9aea5aa050b2d20">More...</a><br /></td></tr>
<tr class="separator:a73bff88284b00b08e9aea5aa050b2d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144dca4ff96493af561a3006d44a8a78"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </td></tr>
<tr class="memitem:a144dca4ff96493af561a3006d44a8a78"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDGtal.html#a55bbc4405f35f8a03161e41068432454">DGtal::ArithmeticConversionType</a>&lt; LeftEuclideanRing, RightEuclideanRing &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a144dca4ff96493af561a3006d44a8a78">dotProduct</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;lhs, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a144dca4ff96493af561a3006d44a8a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product between two points/vectors.  <a href="namespaceDGtal.html#a144dca4ff96493af561a3006d44a8a78">More...</a><br /></td></tr>
<tr class="separator:a144dca4ff96493af561a3006d44a8a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ceabc071a958546b2e65cedb4ff342"><td class="memTemplParams" colspan="2">template&lt;typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </td></tr>
<tr class="memitem:a18ceabc071a958546b2e65cedb4ff342"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a18ceabc071a958546b2e65cedb4ff342">crossProduct</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; 3, LeftEuclideanRing, LeftContainer &gt; const &amp;lhs, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; 3, RightEuclideanRing, RightContainer &gt; const &amp;rhs) -&gt; decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td></tr>
<tr class="memdesc:a18ceabc071a958546b2e65cedb4ff342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross product of two 3D Points/Vectors.  <a href="namespaceDGtal.html#a18ceabc071a958546b2e65cedb4ff342">More...</a><br /></td></tr>
<tr class="separator:a18ceabc071a958546b2e65cedb4ff342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461bb682654c5626fb3dc09b91a6252e"><td class="memTemplParams" colspan="2">template&lt;typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </td></tr>
<tr class="memitem:a461bb682654c5626fb3dc09b91a6252e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; 3, <a class="el" href="namespaceDGtal.html#a55bbc4405f35f8a03161e41068432454">DGtal::ArithmeticConversionType</a>&lt; LeftEuclideanRing, RightEuclideanRing &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a461bb682654c5626fb3dc09b91a6252e">crossProduct</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; 2, LeftEuclideanRing, LeftContainer &gt; const &amp;lhs, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; 2, RightEuclideanRing, RightContainer &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a461bb682654c5626fb3dc09b91a6252e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross product of two 2D Points/Vectors.  <a href="namespaceDGtal.html#a461bb682654c5626fb3dc09b91a6252e">More...</a><br /></td></tr>
<tr class="separator:a461bb682654c5626fb3dc09b91a6252e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3caf900c3807cf27e2b8fca80036bcc"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </td></tr>
<tr class="memitem:aa3caf900c3807cf27e2b8fca80036bcc"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa3caf900c3807cf27e2b8fca80036bcc">cosineSimilarity</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;lhs, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:aa3caf900c3807cf27e2b8fca80036bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive angle between two vectors, deduced from their scalar product.  <a href="namespaceDGtal.html#aa3caf900c3807cf27e2b8fca80036bcc">More...</a><br /></td></tr>
<tr class="separator:aa3caf900c3807cf27e2b8fca80036bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19f06bbc70ca7f69e088fd15e16298d"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </td></tr>
<tr class="memitem:ab19f06bbc70ca7f69e088fd15e16298d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab19f06bbc70ca7f69e088fd15e16298d">inf</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;lhs, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;rhs) -&gt; decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td></tr>
<tr class="memdesc:ab19f06bbc70ca7f69e088fd15e16298d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the infimum (or greatest lower bound).  <a href="namespaceDGtal.html#ab19f06bbc70ca7f69e088fd15e16298d">More...</a><br /></td></tr>
<tr class="separator:ab19f06bbc70ca7f69e088fd15e16298d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54927e5046a35cccb452a0b72e27b76"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </td></tr>
<tr class="memitem:af54927e5046a35cccb452a0b72e27b76"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af54927e5046a35cccb452a0b72e27b76">sup</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;lhs, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;rhs) -&gt; decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td></tr>
<tr class="memdesc:af54927e5046a35cccb452a0b72e27b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the supremum (or least upper bound).  <a href="namespaceDGtal.html#af54927e5046a35cccb452a0b72e27b76">More...</a><br /></td></tr>
<tr class="separator:af54927e5046a35cccb452a0b72e27b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afddb6191e2ccc45985a5ecff1989b87e"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </td></tr>
<tr class="memitem:afddb6191e2ccc45985a5ecff1989b87e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afddb6191e2ccc45985a5ecff1989b87e">isLower</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;lhs, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:afddb6191e2ccc45985a5ecff1989b87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first point is below the second point.  <a href="namespaceDGtal.html#afddb6191e2ccc45985a5ecff1989b87e">More...</a><br /></td></tr>
<tr class="separator:afddb6191e2ccc45985a5ecff1989b87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9e179d700c18214b8be7752c7c2d2b"><td class="memTemplParams" colspan="2">template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </td></tr>
<tr class="memitem:a7f9e179d700c18214b8be7752c7c2d2b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7f9e179d700c18214b8be7752c7c2d2b">isUpper</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;lhs, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:a7f9e179d700c18214b8be7752c7c2d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first point is upper the second point.  <a href="namespaceDGtal.html#a7f9e179d700c18214b8be7752c7c2d2b">More...</a><br /></td></tr>
<tr class="separator:a7f9e179d700c18214b8be7752c7c2d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2d7697de6eefcd5500006abfb96cca"><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename Component , typename TC &gt; </td></tr>
<tr class="memitem:a9d2d7697de6eefcd5500006abfb96cca"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9d2d7697de6eefcd5500006abfb96cca">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; <a class="el" href="viewDualSurface_8cpp.html#a1a254aa17418553bc21790001a69262a">dim</a>, Component, TC &gt; &amp;object)</td></tr>
<tr class="memdesc:a9d2d7697de6eefcd5500006abfb96cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator &lt;&lt;.  <a href="namespaceDGtal.html#a9d2d7697de6eefcd5500006abfb96cca">More...</a><br /></td></tr>
<tr class="separator:a9d2d7697de6eefcd5500006abfb96cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27245859284b52d3c6234f620b34252"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:af27245859284b52d3c6234f620b34252"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af27245859284b52d3c6234f620b34252">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1RegularPointEmbedder.html">RegularPointEmbedder</a>&lt; TSpace &gt; &amp;object)</td></tr>
<tr class="separator:af27245859284b52d3c6234f620b34252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb8d3b558694e4b99b9955af0d38b18"><td class="memTemplParams" colspan="2">template&lt;typename Domain , typename Container &gt; </td></tr>
<tr class="memitem:addb8d3b558694e4b99b9955af0d38b18"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#addb8d3b558694e4b99b9955af0d38b18">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSetByAssociativeContainer.html">DigitalSetByAssociativeContainer</a>&lt; <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a>, Container &gt; &amp;object)</td></tr>
<tr class="separator:addb8d3b558694e4b99b9955af0d38b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb588f6147711cedb29da5c595c915cd"><td class="memTemplParams" colspan="2">template&lt;typename Domain , typename Compare &gt; </td></tr>
<tr class="memitem:adb588f6147711cedb29da5c595c915cd"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#adb588f6147711cedb29da5c595c915cd">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html">DigitalSetBySTLSet</a>&lt; <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a>, Compare &gt; &amp;object)</td></tr>
<tr class="separator:adb588f6147711cedb29da5c595c915cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355c26edc3c9eaed443df491553bd12a"><td class="memTemplParams" colspan="2">template&lt;typename Domain &gt; </td></tr>
<tr class="memitem:a355c26edc3c9eaed443df491553bd12a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a355c26edc3c9eaed443df491553bd12a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSetBySTLVector.html">DigitalSetBySTLVector</a>&lt; <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> &gt; &amp;object)</td></tr>
<tr class="separator:a355c26edc3c9eaed443df491553bd12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c1c0996bfe10bd42952cad2d72ecdb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64c1c0996bfe10bd42952cad2d72ecdb"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a64c1c0996bfe10bd42952cad2d72ecdb">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSetDomain.html">DigitalSetDomain</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a64c1c0996bfe10bd42952cad2d72ecdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b6251ea39e4165f4aff000e4131f92"><td class="memTemplParams" colspan="2">template&lt;typename TMapImage &gt; </td></tr>
<tr class="memitem:a49b6251ea39e4165f4aff000e4131f92"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a49b6251ea39e4165f4aff000e4131f92">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSetFromMap.html">DigitalSetFromMap</a>&lt; TMapImage &gt; &amp;object)</td></tr>
<tr class="separator:a49b6251ea39e4165f4aff000e4131f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446432667939719ccd514801eaebbf97"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename TSplitter , class Hash , class KeyEqual , class UnorderedMapAllocator &gt; </td></tr>
<tr class="memitem:a446432667939719ccd514801eaebbf97"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a446432667939719ccd514801eaebbf97">swap</a> (<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt; &amp;s1, <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt; &amp;s2) noexcept</td></tr>
<tr class="separator:a446432667939719ccd514801eaebbf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe792e4bd33613a06d18b3021d580384"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abe792e4bd33613a06d18b3021d580384">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1AngleLinearMinimizer.html">AngleLinearMinimizer</a> &amp;object)</td></tr>
<tr class="separator:abe792e4bd33613a06d18b3021d580384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e04d0ec7f74b2b1cb5c3b91608814f"><td class="memTemplParams" colspan="2">template&lt;typename TQuantity , typename TBinner &gt; </td></tr>
<tr class="memitem:aa0e04d0ec7f74b2b1cb5c3b91608814f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa0e04d0ec7f74b2b1cb5c3b91608814f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Histogram.html">Histogram</a>&lt; TQuantity, TBinner &gt; &amp;object)</td></tr>
<tr class="separator:aa0e04d0ec7f74b2b1cb5c3b91608814f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3767c6329da3b3959bb60341e7ed9adc"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3767c6329da3b3959bb60341e7ed9adc">operator&lt;&lt;</a> (std::ostream &amp;os, const Eigen::ComputationInfo &amp;info)</td></tr>
<tr class="separator:a3767c6329da3b3959bb60341e7ed9adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f758bdd2b85477daaba1b42203956d1"><td class="memTemplParams" colspan="2">template&lt;typename T , DGtal::Dimension M, DGtal::Dimension N&gt; </td></tr>
<tr class="memitem:a4f758bdd2b85477daaba1b42203956d1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4f758bdd2b85477daaba1b42203956d1">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1SimpleMatrix.html">SimpleMatrix</a>&lt; T, M, N &gt; &amp;object)</td></tr>
<tr class="separator:a4f758bdd2b85477daaba1b42203956d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74eb3d39b9b5e8d9fd8700d508a6466"><td class="memTemplParams" colspan="2">template&lt;typename TComponent , DGtal::Dimension TM, DGtal::Dimension TN&gt; </td></tr>
<tr class="memitem:aa74eb3d39b9b5e8d9fd8700d508a6466"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1SimpleMatrix.html">SimpleMatrix</a>&lt; TComponent, TM, TN &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa74eb3d39b9b5e8d9fd8700d508a6466">operator*</a> (const TComponent &amp;scalar, const <a class="el" href="classDGtal_1_1SimpleMatrix.html">SimpleMatrix</a>&lt; TComponent, TM, TN &gt; &amp;matrix)</td></tr>
<tr class="separator:aa74eb3d39b9b5e8d9fd8700d508a6466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0028318421129719df74990e535e5333"><td class="memTemplParams" colspan="2">template&lt;typename TProfile &gt; </td></tr>
<tr class="memitem:a0028318421129719df74990e535e5333"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0028318421129719df74990e535e5333">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1MeaningfulScaleAnalysis.html">MeaningfulScaleAnalysis</a>&lt; TProfile &gt; &amp;object)</td></tr>
<tr class="separator:a0028318421129719df74990e535e5333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd9b278acef50a90b1e4bbe9c902812"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4dd9b278acef50a90b1e4bbe9c902812">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1MeasureOfStraightLines.html">MeasureOfStraightLines</a> &amp;object)</td></tr>
<tr class="separator:a4dd9b278acef50a90b1e4bbe9c902812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbdffe7efc4f8af031964cecfe477a7"><td class="memTemplParams" colspan="2">template&lt;typename TRing , typename TAlloc &gt; </td></tr>
<tr class="memitem:a2bbdffe7efc4f8af031964cecfe477a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2bbdffe7efc4f8af031964cecfe477a7">euclidDiv</a> (const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;f, const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;g, <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;q, <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;r)</td></tr>
<tr class="separator:a2bbdffe7efc4f8af031964cecfe477a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1843226ad5d68036826cf9c7dc70bdd"><td class="memTemplParams" colspan="2">template&lt;int N, typename TRing , class TAlloc &gt; </td></tr>
<tr class="memitem:ab1843226ad5d68036826cf9c7dc70bdd"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab1843226ad5d68036826cf9c7dc70bdd">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; N, TRing, TAlloc &gt; &amp;object)</td></tr>
<tr class="separator:ab1843226ad5d68036826cf9c7dc70bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948cc02e8fe7e8ab1051bce164421fa8"><td class="memTemplParams" colspan="2">template&lt;int n, typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:a948cc02e8fe7e8ab1051bce164421fa8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a948cc02e8fe7e8ab1051bce164421fa8">Xe_k</a> (unsigned int k, unsigned int e)</td></tr>
<tr class="separator:a948cc02e8fe7e8ab1051bce164421fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad099005ab7d493b2ea19026e2fb96a32"><td class="memTemplParams" colspan="2">template&lt;int n, typename Ring &gt; </td></tr>
<tr class="memitem:ad099005ab7d493b2ea19026e2fb96a32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, std::allocator&lt; Ring &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad099005ab7d493b2ea19026e2fb96a32">Xe_k</a> (unsigned int k, unsigned int e)</td></tr>
<tr class="separator:ad099005ab7d493b2ea19026e2fb96a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770659cf50cd49c0ce6c3d4ab08abb46"><td class="memTemplParams" colspan="2">template&lt;typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:a770659cf50cd49c0ce6c3d4ab08abb46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a770659cf50cd49c0ce6c3d4ab08abb46">mmonomial</a> (unsigned int e)</td></tr>
<tr class="separator:a770659cf50cd49c0ce6c3d4ab08abb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04b582eb75ae0cfc14dfc40d57c03f2"><td class="memTemplParams" colspan="2">template&lt;typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:ad04b582eb75ae0cfc14dfc40d57c03f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 2, Ring, Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad04b582eb75ae0cfc14dfc40d57c03f2">mmonomial</a> (unsigned int e, unsigned int f)</td></tr>
<tr class="separator:ad04b582eb75ae0cfc14dfc40d57c03f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b41f1ac0f88d213c7fb8bee8931799"><td class="memTemplParams" colspan="2">template&lt;typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:a46b41f1ac0f88d213c7fb8bee8931799"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 3, Ring, Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a46b41f1ac0f88d213c7fb8bee8931799">mmonomial</a> (unsigned int e, unsigned int f, unsigned int g)</td></tr>
<tr class="separator:a46b41f1ac0f88d213c7fb8bee8931799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ba6c1f73137c9da0365c16635c92e9"><td class="memTemplParams" colspan="2">template&lt;typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:ae6ba6c1f73137c9da0365c16635c92e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 4, Ring, Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae6ba6c1f73137c9da0365c16635c92e9">mmonomial</a> (unsigned int e, unsigned int f, unsigned int g, unsigned int h)</td></tr>
<tr class="separator:ae6ba6c1f73137c9da0365c16635c92e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef248272fbf9b379c272e0ec632289c"><td class="memTemplParams" colspan="2">template&lt;typename Ring &gt; </td></tr>
<tr class="memitem:a9ef248272fbf9b379c272e0ec632289c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9ef248272fbf9b379c272e0ec632289c">mmonomial</a> (unsigned int e)</td></tr>
<tr class="separator:a9ef248272fbf9b379c272e0ec632289c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac70e986a68541f5a9e2b9a4035da2c"><td class="memTemplParams" colspan="2">template&lt;typename Ring &gt; </td></tr>
<tr class="memitem:a9ac70e986a68541f5a9e2b9a4035da2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 2, Ring, std::allocator&lt; Ring &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9ac70e986a68541f5a9e2b9a4035da2c">mmonomial</a> (unsigned int e, unsigned int f)</td></tr>
<tr class="separator:a9ac70e986a68541f5a9e2b9a4035da2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f44e0a9fc1e30d29e52646daeca211d"><td class="memTemplParams" colspan="2">template&lt;typename Ring &gt; </td></tr>
<tr class="memitem:a4f44e0a9fc1e30d29e52646daeca211d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 3, Ring, std::allocator&lt; Ring &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4f44e0a9fc1e30d29e52646daeca211d">mmonomial</a> (unsigned int e, unsigned int f, unsigned int g)</td></tr>
<tr class="separator:a4f44e0a9fc1e30d29e52646daeca211d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a679186eed201b0844c7bf6f83e76c8"><td class="memTemplParams" colspan="2">template&lt;typename Ring &gt; </td></tr>
<tr class="memitem:a4a679186eed201b0844c7bf6f83e76c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 4, Ring, std::allocator&lt; Ring &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4a679186eed201b0844c7bf6f83e76c8">mmonomial</a> (unsigned int e, unsigned int f, unsigned int g, unsigned int h)</td></tr>
<tr class="separator:a4a679186eed201b0844c7bf6f83e76c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd55a2a73cd7b4552dbaf0b62980b323"><td class="memTemplParams" colspan="2">template&lt;int N, int n, typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:afd55a2a73cd7b4552dbaf0b62980b323"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afd55a2a73cd7b4552dbaf0b62980b323">derivative</a> (const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, Alloc &gt; &amp;p)</td></tr>
<tr class="separator:afd55a2a73cd7b4552dbaf0b62980b323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aedf0fbd5b7c5814911d1299be81cb9"><td class="memTemplParams" colspan="2">template&lt;int N, int n, typename Ring &gt; </td></tr>
<tr class="memitem:a9aedf0fbd5b7c5814911d1299be81cb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, std::allocator&lt; Ring &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9aedf0fbd5b7c5814911d1299be81cb9">derivative</a> (const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, std::allocator&lt; Ring &gt; &gt; &amp;p)</td></tr>
<tr class="separator:a9aedf0fbd5b7c5814911d1299be81cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4718ecc21bcecf1618414e982b951c"><td class="memTemplParams" colspan="2">template&lt;typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:afc4718ecc21bcecf1618414e982b951c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afc4718ecc21bcecf1618414e982b951c">euclidDiv</a> (const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;f, const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;g, <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;q, <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;r)</td></tr>
<tr class="separator:afc4718ecc21bcecf1618414e982b951c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e756b9529892b5019066b6d4a4310c"><td class="memTemplParams" colspan="2">template&lt;typename Ring &gt; </td></tr>
<tr class="memitem:a57e756b9529892b5019066b6d4a4310c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a57e756b9529892b5019066b6d4a4310c">euclidDiv</a> (const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;f, const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;g, <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;q, <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;r)</td></tr>
<tr class="separator:a57e756b9529892b5019066b6d4a4310c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fc7e3a7ad4420d8b0b5950ae21c32e"><td class="memTemplParams" colspan="2">template&lt;typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:a38fc7e3a7ad4420d8b0b5950ae21c32e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a38fc7e3a7ad4420d8b0b5950ae21c32e">gcd</a> (const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;f, const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;g)</td></tr>
<tr class="separator:a38fc7e3a7ad4420d8b0b5950ae21c32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28649140d0b09a9b25515660a3e6f12"><td class="memTemplParams" colspan="2">template&lt;typename Ring &gt; </td></tr>
<tr class="memitem:ab28649140d0b09a9b25515660a3e6f12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab28649140d0b09a9b25515660a3e6f12">gcd</a> (const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;f, const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;g)</td></tr>
<tr class="separator:ab28649140d0b09a9b25515660a3e6f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d054227f3036a137b394b4b2dca215b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0d054227f3036a137b394b4b2dca215b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1MultiStatistics.html">MultiStatistics</a> &amp;object)</td></tr>
<tr class="separator:a0d054227f3036a137b394b4b2dca215b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7441c7bd823132ee0e0ab3f59afcfb7"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad7441c7bd823132ee0e0ab3f59afcfb7">operator&lt;&lt;</a> (std::ostream &amp;that_stream, const <a class="el" href="classDGtal_1_1OrderedLinearRegression.html">OrderedLinearRegression</a> &amp;that_object_to_display)</td></tr>
<tr class="separator:ad7441c7bd823132ee0e0ab3f59afcfb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726c89af25ffd816f74c79f63551e5b1"><td class="memTemplParams" colspan="2">template&lt;typename TValueFunctor , typename TValue &gt; </td></tr>
<tr class="memitem:a726c89af25ffd816f74c79f63551e5b1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a726c89af25ffd816f74c79f63551e5b1">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Profile.html">Profile</a>&lt; TValueFunctor, TValue &gt; &amp;object)</td></tr>
<tr class="separator:a726c89af25ffd816f74c79f63551e5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea30053ec6e0099310c2d15ef58f988a"><td class="memTemplParams" colspan="2">template&lt;class TDomain , typename T &gt; </td></tr>
<tr class="memitem:aea30053ec6e0099310c2d15ef58f988a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aea30053ec6e0099310c2d15ef58f988a">operator&lt;&lt;</a> (std::ostream &amp;out, const RealFFT&lt; TDomain, T &gt; &amp;object)</td></tr>
<tr class="separator:aea30053ec6e0099310c2d15ef58f988a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81241d0c7fe22c289041e10289a6a0f"><td class="memTemplParams" colspan="2">template&lt;typename TValue &gt; </td></tr>
<tr class="memitem:ad81241d0c7fe22c289041e10289a6a0f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad81241d0c7fe22c289041e10289a6a0f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Signal.html">Signal</a>&lt; TValue &gt; &amp;object)</td></tr>
<tr class="separator:ad81241d0c7fe22c289041e10289a6a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6e2015e5afa4a87b9ea4fc4e462a11"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#acf6e2015e5afa4a87b9ea4fc4e462a11">operator&lt;&lt;</a> (std::ostream &amp;that_stream, const <a class="el" href="classDGtal_1_1SimpleLinearRegression.html">SimpleLinearRegression</a> &amp;that_object_to_display)</td></tr>
<tr class="separator:acf6e2015e5afa4a87b9ea4fc4e462a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab082ebd8a30a323e3dc31426bd8cccb1"><td class="memTemplParams" colspan="2">template&lt;typename TQuantity &gt; </td></tr>
<tr class="memitem:ab082ebd8a30a323e3dc31426bd8cccb1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab082ebd8a30a323e3dc31426bd8cccb1">operator&lt;&lt;</a> (std::ostream &amp;thatStream, const <a class="el" href="classDGtal_1_1Statistic.html">Statistic</a>&lt; TQuantity &gt; &amp;that_object_to_display)</td></tr>
<tr class="separator:ab082ebd8a30a323e3dc31426bd8cccb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2094d74ad8874607e4f63fdc3a268332"><td class="memTemplParams" colspan="2">template&lt;typename ShapeA , typename ShapeB &gt; </td></tr>
<tr class="memitem:a2094d74ad8874607e4f63fdc3a268332"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2094d74ad8874607e4f63fdc3a268332">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1deprecated_1_1DigitalShapesUnion.html">deprecated::DigitalShapesUnion</a>&lt; ShapeA, ShapeB &gt; &amp;object)</td></tr>
<tr class="separator:a2094d74ad8874607e4f63fdc3a268332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2692bfafe78e4a45477e7fca4d57d64"><td class="memTemplParams" colspan="2">template&lt;typename ShapeA , typename ShapeB &gt; </td></tr>
<tr class="memitem:af2692bfafe78e4a45477e7fca4d57d64"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af2692bfafe78e4a45477e7fca4d57d64">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1deprecated_1_1DigitalShapesIntersection.html">deprecated::DigitalShapesIntersection</a>&lt; ShapeA, ShapeB &gt; &amp;object)</td></tr>
<tr class="separator:af2692bfafe78e4a45477e7fca4d57d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1a7b9fb65df86c693ec23cf429b7bf"><td class="memTemplParams" colspan="2">template&lt;typename ShapeA , typename ShapeB &gt; </td></tr>
<tr class="memitem:a7b1a7b9fb65df86c693ec23cf429b7bf"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7b1a7b9fb65df86c693ec23cf429b7bf">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1deprecated_1_1DigitalShapesMinus.html">deprecated::DigitalShapesMinus</a>&lt; ShapeA, ShapeB &gt; &amp;object)</td></tr>
<tr class="separator:a7b1a7b9fb65df86c693ec23cf429b7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f80249972e1a999a12224db8ac1fbc"><td class="memTemplParams" colspan="2">template&lt;typename ShapeA , typename ShapeB &gt; </td></tr>
<tr class="memitem:a10f80249972e1a999a12224db8ac1fbc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a10f80249972e1a999a12224db8ac1fbc">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1deprecated_1_1EuclideanShapesUnion.html">deprecated::EuclideanShapesUnion</a>&lt; ShapeA, ShapeB &gt; &amp;object)</td></tr>
<tr class="separator:a10f80249972e1a999a12224db8ac1fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522943b7af0902564a6c11c604d0e7a4"><td class="memTemplParams" colspan="2">template&lt;typename ShapeA , typename ShapeB &gt; </td></tr>
<tr class="memitem:a522943b7af0902564a6c11c604d0e7a4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a522943b7af0902564a6c11c604d0e7a4">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1deprecated_1_1EuclideanShapesIntersection.html">deprecated::EuclideanShapesIntersection</a>&lt; ShapeA, ShapeB &gt; &amp;object)</td></tr>
<tr class="separator:a522943b7af0902564a6c11c604d0e7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b800670c124959363ed6f19e5efcce"><td class="memTemplParams" colspan="2">template&lt;typename ShapeA , typename ShapeB &gt; </td></tr>
<tr class="memitem:a69b800670c124959363ed6f19e5efcce"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a69b800670c124959363ed6f19e5efcce">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1deprecated_1_1EuclideanShapesMinus.html">deprecated::EuclideanShapesMinus</a>&lt; ShapeA, ShapeB &gt; &amp;object)</td></tr>
<tr class="separator:a69b800670c124959363ed6f19e5efcce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585a463f4055c1df3774c34bc4d1c5fb"><td class="memTemplParams" colspan="2">template&lt;typename TPoint &gt; </td></tr>
<tr class="memitem:a585a463f4055c1df3774c34bc4d1c5fb"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a585a463f4055c1df3774c34bc4d1c5fb">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1CircleFrom2Points.html">CircleFrom2Points</a>&lt; TPoint &gt; &amp;object)</td></tr>
<tr class="separator:a585a463f4055c1df3774c34bc4d1c5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee88b42fe08c64c833f2b785139063c"><td class="memTemplParams" colspan="2">template&lt;typename TPoint &gt; </td></tr>
<tr class="memitem:a5ee88b42fe08c64c833f2b785139063c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5ee88b42fe08c64c833f2b785139063c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1CircleFrom3Points.html">CircleFrom3Points</a>&lt; TPoint &gt; &amp;object)</td></tr>
<tr class="separator:a5ee88b42fe08c64c833f2b785139063c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab459bc9dd22f00b399b6d8847d6ed92e"><td class="memTemplParams" colspan="2">template&lt;typename TSurface , bool isUpward, bool isClosed&gt; </td></tr>
<tr class="memitem:ab459bc9dd22f00b399b6d8847d6ed92e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab459bc9dd22f00b399b6d8847d6ed92e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1functors_1_1Point2ShapePredicate.html">DGtal::functors::Point2ShapePredicate</a>&lt; TSurface, isUpward, isClosed &gt; &amp;object)</td></tr>
<tr class="separator:ab459bc9dd22f00b399b6d8847d6ed92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9db375c56d37d5a38a7599c7e02e07"><td class="memTemplParams" colspan="2">template&lt;typename TPoint &gt; </td></tr>
<tr class="memitem:a9c9db375c56d37d5a38a7599c7e02e07"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9c9db375c56d37d5a38a7599c7e02e07">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1StraightLineFrom2Points.html">StraightLineFrom2Points</a>&lt; TPoint &gt; &amp;object)</td></tr>
<tr class="separator:a9c9db375c56d37d5a38a7599c7e02e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40ca76cd3d190bc9a1bde85e4610786"><td class="memTemplParams" colspan="2">template&lt;typename TSpace , typename TEuclideanShape &gt; </td></tr>
<tr class="memitem:aa40ca76cd3d190bc9a1bde85e4610786"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa40ca76cd3d190bc9a1bde85e4610786">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GaussDigitizer.html">GaussDigitizer</a>&lt; TSpace, TEuclideanShape &gt; &amp;object)</td></tr>
<tr class="separator:aa40ca76cd3d190bc9a1bde85e4610786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af728c4929cf5c46f199d45708df92f8f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af728c4929cf5c46f199d45708df92f8f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af728c4929cf5c46f199d45708df92f8f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitBall.html">ImplicitBall</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:af728c4929cf5c46f199d45708df92f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc264aee8a9229888ae63aecb0197111"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TImplicitFunctionDiff1 , typename TEmbedder &gt; </td></tr>
<tr class="memitem:abc264aee8a9229888ae63aecb0197111"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abc264aee8a9229888ae63aecb0197111">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitFunctionDiff1LinearCellEmbedder.html">ImplicitFunctionDiff1LinearCellEmbedder</a>&lt; TKSpace, TImplicitFunctionDiff1, TEmbedder &gt; &amp;object)</td></tr>
<tr class="separator:abc264aee8a9229888ae63aecb0197111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af248a4c1de019c3ed17fe479c1f341"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TImplicitFunction , typename TEmbedder &gt; </td></tr>
<tr class="memitem:a4af248a4c1de019c3ed17fe479c1f341"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4af248a4c1de019c3ed17fe479c1f341">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitFunctionLinearCellEmbedder.html">ImplicitFunctionLinearCellEmbedder</a>&lt; TKSpace, TImplicitFunction, TEmbedder &gt; &amp;object)</td></tr>
<tr class="separator:a4af248a4c1de019c3ed17fe479c1f341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d2b3f53e85f184b3a41a78ffbd8e52"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a05d2b3f53e85f184b3a41a78ffbd8e52"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a05d2b3f53e85f184b3a41a78ffbd8e52">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitHyperCube.html">ImplicitHyperCube</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a05d2b3f53e85f184b3a41a78ffbd8e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f3b2e62918e689beb5d66ea49554ea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac1f3b2e62918e689beb5d66ea49554ea"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac1f3b2e62918e689beb5d66ea49554ea">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitNorm1Ball.html">ImplicitNorm1Ball</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:ac1f3b2e62918e689beb5d66ea49554ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c3aec34372e12bb2a4b530ebefb1b6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a31c3aec34372e12bb2a4b530ebefb1b6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a31c3aec34372e12bb2a4b530ebefb1b6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitPolynomial3Shape.html">ImplicitPolynomial3Shape</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a31c3aec34372e12bb2a4b530ebefb1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fb8525ad5cc983a11b2a8a44b70664"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a68fb8525ad5cc983a11b2a8a44b70664"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a68fb8525ad5cc983a11b2a8a44b70664">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitRoundedHyperCube.html">ImplicitRoundedHyperCube</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a68fb8525ad5cc983a11b2a8a44b70664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abcd22e252a4cb35a43eb765c1c9a46"><td class="memTemplParams" colspan="2">template&lt;typename TPoint &gt; </td></tr>
<tr class="memitem:a0abcd22e252a4cb35a43eb765c1c9a46"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0abcd22e252a4cb35a43eb765c1c9a46">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Mesh.html">Mesh</a>&lt; TPoint &gt; &amp;object)</td></tr>
<tr class="separator:a0abcd22e252a4cb35a43eb765c1c9a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2706aab43647ea9f5e8680d198a78058"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2706aab43647ea9f5e8680d198a78058"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2706aab43647ea9f5e8680d198a78058">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1AccFlower2D.html">AccFlower2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a2706aab43647ea9f5e8680d198a78058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a89cd5501bdf942f7a188b680a16330"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7a89cd5501bdf942f7a188b680a16330"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7a89cd5501bdf942f7a188b680a16330">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Astroid2D.html">Astroid2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a7a89cd5501bdf942f7a188b680a16330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3122ee382f11142dd99840d9369962"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e3122ee382f11142dd99840d9369962"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6e3122ee382f11142dd99840d9369962">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Ball2D.html">Ball2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a6e3122ee382f11142dd99840d9369962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec957eba9b6bc73034478bdefa0d9d1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ec957eba9b6bc73034478bdefa0d9d1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1ec957eba9b6bc73034478bdefa0d9d1">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Ball3D.html">Ball3D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a1ec957eba9b6bc73034478bdefa0d9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d10b79644958ed25bff3bb3909edbd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa6d10b79644958ed25bff3bb3909edbd"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa6d10b79644958ed25bff3bb3909edbd">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Ellipse2D.html">Ellipse2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:aa6d10b79644958ed25bff3bb3909edbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bfcec3a6636adb60531b90ebc1818b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac5bfcec3a6636adb60531b90ebc1818b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac5bfcec3a6636adb60531b90ebc1818b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Flower2D.html">Flower2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:ac5bfcec3a6636adb60531b90ebc1818b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620f080132158f27407b75993a208254"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a620f080132158f27407b75993a208254"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a620f080132158f27407b75993a208254">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Lemniscate2D.html">Lemniscate2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a620f080132158f27407b75993a208254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6df2f54fd5c48116deeb8ffdcd315a0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab6df2f54fd5c48116deeb8ffdcd315a0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab6df2f54fd5c48116deeb8ffdcd315a0">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1NGon2D.html">NGon2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:ab6df2f54fd5c48116deeb8ffdcd315a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372f8751a722045053b7fb40e27acc0a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a372f8751a722045053b7fb40e27acc0a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a372f8751a722045053b7fb40e27acc0a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1StarShaped2D.html">StarShaped2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a372f8751a722045053b7fb40e27acc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143ab94b75f148bd8730c4e6acfcbdbc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a143ab94b75f148bd8730c4e6acfcbdbc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a143ab94b75f148bd8730c4e6acfcbdbc">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1StarShaped3D.html">StarShaped3D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:a143ab94b75f148bd8730c4e6acfcbdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5c58861db3a26964000c06a53a8bcb"><td class="memTemplParams" colspan="2">template&lt;typename TPoint &gt; </td></tr>
<tr class="memitem:a1c5c58861db3a26964000c06a53a8bcb"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1c5c58861db3a26964000c06a53a8bcb">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1PolygonalSurface.html">PolygonalSurface</a>&lt; TPoint &gt; &amp;object)</td></tr>
<tr class="separator:a1c5c58861db3a26964000c06a53a8bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173a5f39aef469def94b22065f931ad0"><td class="memTemplParams" colspan="2">template&lt;typename TDomain &gt; </td></tr>
<tr class="memitem:a173a5f39aef469def94b22065f931ad0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a173a5f39aef469def94b22065f931ad0">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Shapes.html">Shapes</a>&lt; TDomain &gt; &amp;object)</td></tr>
<tr class="separator:a173a5f39aef469def94b22065f931ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742bce0b660bee1dc186252d4d130041"><td class="memTemplParams" colspan="2">template&lt;typename TRealPoint , typename TRealVector &gt; </td></tr>
<tr class="memitem:a742bce0b660bee1dc186252d4d130041"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a742bce0b660bee1dc186252d4d130041">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1SurfaceMesh.html">SurfaceMesh</a>&lt; TRealPoint, TRealVector &gt; &amp;object)</td></tr>
<tr class="separator:a742bce0b660bee1dc186252d4d130041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1daac4d4761686c19587065eb69989"><td class="memTemplParams" colspan="2">template&lt;typename TPoint &gt; </td></tr>
<tr class="memitem:a9e1daac4d4761686c19587065eb69989"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9e1daac4d4761686c19587065eb69989">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1TriangulatedSurface.html">TriangulatedSurface</a>&lt; TPoint &gt; &amp;object)</td></tr>
<tr class="separator:a9e1daac4d4761686c19587065eb69989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d94472929eed3723d1405c74e3a0e9"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace &gt; </td></tr>
<tr class="memitem:a83d94472929eed3723d1405c74e3a0e9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a83d94472929eed3723d1405c74e3a0e9">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1CanonicCellEmbedder.html">CanonicCellEmbedder</a>&lt; TKSpace &gt; &amp;object)</td></tr>
<tr class="separator:a83d94472929eed3723d1405c74e3a0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba90e4a5acd6874d3e462e7a26cb9336"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalSurface &gt; </td></tr>
<tr class="memitem:aba90e4a5acd6874d3e462e7a26cb9336"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aba90e4a5acd6874d3e462e7a26cb9336">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1CanonicDigitalSurfaceEmbedder.html">CanonicDigitalSurfaceEmbedder</a>&lt; TDigitalSurface &gt; &amp;object)</td></tr>
<tr class="separator:aba90e4a5acd6874d3e462e7a26cb9336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ea40386af9fb5ff47a649b3b11e7c7"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace &gt; </td></tr>
<tr class="memitem:a77ea40386af9fb5ff47a649b3b11e7c7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a77ea40386af9fb5ff47a649b3b11e7c7">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1CanonicSCellEmbedder.html">CanonicSCellEmbedder</a>&lt; TKSpace &gt; &amp;object)</td></tr>
<tr class="separator:a77ea40386af9fb5ff47a649b3b11e7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad958d9fade88203495529f0fb4dc892b"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:ad958d9fade88203495529f0fb4dc892b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad958d9fade88203495529f0fb4dc892b">operator|=</a> (<a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:ad958d9fade88203495529f0fb4dc892b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397f22d0915165d3a2f0b7f273d8302c"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:a397f22d0915165d3a2f0b7f273d8302c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a397f22d0915165d3a2f0b7f273d8302c">operator&amp;=</a> (<a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:a397f22d0915165d3a2f0b7f273d8302c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f59aad62cd99cb5ea20c3a8ae3eae5"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:a06f59aad62cd99cb5ea20c3a8ae3eae5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a06f59aad62cd99cb5ea20c3a8ae3eae5">operator^=</a> (<a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:a06f59aad62cd99cb5ea20c3a8ae3eae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ca8514c052da8444ab157c10b57add"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:af6ca8514c052da8444ab157c10b57add"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af6ca8514c052da8444ab157c10b57add">operator-=</a> (<a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:af6ca8514c052da8444ab157c10b57add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c2868470d3334e4a75f4aeeec81057"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:ae9c2868470d3334e4a75f4aeeec81057"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae9c2868470d3334e4a75f4aeeec81057">operator|</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:ae9c2868470d3334e4a75f4aeeec81057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23b9018e5c7429c4585bba3f2fdc60b"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:ae23b9018e5c7429c4585bba3f2fdc60b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae23b9018e5c7429c4585bba3f2fdc60b">operator&amp;</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:ae23b9018e5c7429c4585bba3f2fdc60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92450fc7a0bf65f4932235a3f91da5c6"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:a92450fc7a0bf65f4932235a3f91da5c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a92450fc7a0bf65f4932235a3f91da5c6">operator^</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:a92450fc7a0bf65f4932235a3f91da5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d8848c1b6c272844824c892fdb47fa"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:a46d8848c1b6c272844824c892fdb47fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a46d8848c1b6c272844824c892fdb47fa">operator-</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:a46d8848c1b6c272844824c892fdb47fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72222c0249e63a488c6c1ebc23dffb36"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:a72222c0249e63a488c6c1ebc23dffb36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a72222c0249e63a488c6c1ebc23dffb36">operator~</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:a72222c0249e63a488c6c1ebc23dffb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb82504c40b5578aacd454b70190116"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:a1cb82504c40b5578aacd454b70190116"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1cb82504c40b5578aacd454b70190116">operator*</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:a1cb82504c40b5578aacd454b70190116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb3dcff560928e3a800f615a32e2e7a"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:acdb3dcff560928e3a800f615a32e2e7a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#acdb3dcff560928e3a800f615a32e2e7a">operator==</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:acdb3dcff560928e3a800f615a32e2e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9670198dd8ca22231fd61fa042750b02"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:a9670198dd8ca22231fd61fa042750b02"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9670198dd8ca22231fd61fa042750b02">operator!=</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:a9670198dd8ca22231fd61fa042750b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc3c423f122c30fbd6e27dd50c72cd9"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:aecc3c423f122c30fbd6e27dd50c72cd9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aecc3c423f122c30fbd6e27dd50c72cd9">operator&lt;=</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:aecc3c423f122c30fbd6e27dd50c72cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c39f690fb8547062411990779442ae5"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:a6c39f690fb8547062411990779442ae5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6c39f690fb8547062411990779442ae5">operator&gt;=</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:a6c39f690fb8547062411990779442ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa4cf951c1e0d56b28f5112a777c558"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:abfa4cf951c1e0d56b28f5112a777c558"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abfa4cf951c1e0d56b28f5112a777c558">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;object)</td></tr>
<tr class="separator:abfa4cf951c1e0d56b28f5112a777c558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a808836f9b5bef26687f2fad255818d"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TDigitalSet &gt; </td></tr>
<tr class="memitem:a9a808836f9b5bef26687f2fad255818d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9a808836f9b5bef26687f2fad255818d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSetBoundary.html">DigitalSetBoundary</a>&lt; TKSpace, TDigitalSet &gt; &amp;object)</td></tr>
<tr class="separator:a9a808836f9b5bef26687f2fad255818d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa573134cae2a8658a3c6d3da36524cc6"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalSurfaceContainer &gt; </td></tr>
<tr class="memitem:aa573134cae2a8658a3c6d3da36524cc6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa573134cae2a8658a3c6d3da36524cc6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSurface.html">DigitalSurface</a>&lt; TDigitalSurfaceContainer &gt; &amp;object)</td></tr>
<tr class="separator:aa573134cae2a8658a3c6d3da36524cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db2f56807d13a3301f7368ce7246f58"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalSurfaceTracker &gt; </td></tr>
<tr class="memitem:a6db2f56807d13a3301f7368ce7246f58"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6db2f56807d13a3301f7368ce7246f58">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSurface2DSlice.html">DigitalSurface2DSlice</a>&lt; TDigitalSurfaceTracker &gt; &amp;object)</td></tr>
<tr class="separator:a6db2f56807d13a3301f7368ce7246f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbb6c219f9f726cfedde0631fe2f7a9"><td class="memTemplParams" colspan="2">template&lt;typename TForegroundAdjacency , typename TBackgroundAdjacency &gt; </td></tr>
<tr class="memitem:a7fbb6c219f9f726cfedde0631fe2f7a9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7fbb6c219f9f726cfedde0631fe2f7a9">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalTopology.html">DigitalTopology</a>&lt; TForegroundAdjacency, TBackgroundAdjacency &gt; &amp;object)</td></tr>
<tr class="separator:a7fbb6c219f9f726cfedde0631fe2f7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c93240481c27affe2f4d04791c14f08"><td class="memTemplParams" colspan="2">template&lt;typename TDomain , typename TAdjacency &gt; </td></tr>
<tr class="memitem:a3c93240481c27affe2f4d04791c14f08"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3c93240481c27affe2f4d04791c14f08">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DomainAdjacency.html">DomainAdjacency</a>&lt; TDomain, TAdjacency &gt; &amp;object)</td></tr>
<tr class="separator:a3c93240481c27affe2f4d04791c14f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee00a232b8855f43efadbbc22f4111a3"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TSurfelPredicate &gt; </td></tr>
<tr class="memitem:aee00a232b8855f43efadbbc22f4111a3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aee00a232b8855f43efadbbc22f4111a3">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html">ExplicitDigitalSurface</a>&lt; TKSpace, TSurfelPredicate &gt; &amp;object)</td></tr>
<tr class="separator:aee00a232b8855f43efadbbc22f4111a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d394b77876cb7d9afb5a55bd6dd19b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af4d394b77876cb7d9afb5a55bd6dd19b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1HalfEdgeDataStructure.html">HalfEdgeDataStructure</a> &amp;object)</td></tr>
<tr class="separator:af4d394b77876cb7d9afb5a55bd6dd19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1da1d6ecb338834767c80d57338d4fc"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TImage &gt; </td></tr>
<tr class="memitem:af1da1d6ecb338834767c80d57338d4fc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af1da1d6ecb338834767c80d57338d4fc">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1functors_1_1BoundaryPredicate.html">DGtal::functors::BoundaryPredicate</a>&lt; TKSpace, TImage &gt; &amp;object)</td></tr>
<tr class="separator:af1da1d6ecb338834767c80d57338d4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1aa44568f4b2968af009d441cc80a4f"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TImage &gt; </td></tr>
<tr class="memitem:ac1aa44568f4b2968af009d441cc80a4f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac1aa44568f4b2968af009d441cc80a4f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1functors_1_1FrontierPredicate.html">DGtal::functors::FrontierPredicate</a>&lt; TKSpace, TImage &gt; &amp;object)</td></tr>
<tr class="separator:ac1aa44568f4b2968af009d441cc80a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff655e1b0debfe2fbf8ca53c7fe8fa70"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace &gt; </td></tr>
<tr class="memitem:aff655e1b0debfe2fbf8ca53c7fe8fa70"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aff655e1b0debfe2fbf8ca53c7fe8fa70">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a>&lt; TKSpace &gt; &amp;object)</td></tr>
<tr class="separator:aff655e1b0debfe2fbf8ca53c7fe8fa70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbd59ad8a40756a291c741c52dc1712"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TPointPredicate &gt; </td></tr>
<tr class="memitem:abcbd59ad8a40756a291c741c52dc1712"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abcbd59ad8a40756a291c741c52dc1712">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html">ImplicitDigitalSurface</a>&lt; TKSpace, TPointPredicate &gt; &amp;object)</td></tr>
<tr class="separator:abcbd59ad8a40756a291c741c52dc1712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb9dc46e99031f7f6d6969480f906b3"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalSurfaceContainer &gt; </td></tr>
<tr class="memitem:a6cb9dc46e99031f7f6d6969480f906b3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6cb9dc46e99031f7f6d6969480f906b3">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1IndexedDigitalSurface.html">IndexedDigitalSurface</a>&lt; TDigitalSurfaceContainer &gt; &amp;object)</td></tr>
<tr class="separator:a6cb9dc46e99031f7f6d6969480f906b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9cee3dbb4ab230a228781ea72aee8a"><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename TInteger &gt; </td></tr>
<tr class="memitem:a2d9cee3dbb4ab230a228781ea72aee8a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2d9cee3dbb4ab230a228781ea72aee8a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1KhalimskyPreCell.html">KhalimskyPreCell</a>&lt; <a class="el" href="viewDualSurface_8cpp.html#a1a254aa17418553bc21790001a69262a">dim</a>, TInteger &gt; &amp;object)</td></tr>
<tr class="separator:a2d9cee3dbb4ab230a228781ea72aee8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fe10bf3d39b724578b076625e81df3"><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename TInteger &gt; </td></tr>
<tr class="memitem:af5fe10bf3d39b724578b076625e81df3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af5fe10bf3d39b724578b076625e81df3">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1SignedKhalimskyPreCell.html">SignedKhalimskyPreCell</a>&lt; <a class="el" href="viewDualSurface_8cpp.html#a1a254aa17418553bc21790001a69262a">dim</a>, TInteger &gt; &amp;object)</td></tr>
<tr class="separator:af5fe10bf3d39b724578b076625e81df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c5e0b95cb3bf61322d889850690c71"><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename TInteger &gt; </td></tr>
<tr class="memitem:a04c5e0b95cb3bf61322d889850690c71"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a04c5e0b95cb3bf61322d889850690c71">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1KhalimskyPreSpaceND.html">KhalimskyPreSpaceND</a>&lt; <a class="el" href="viewDualSurface_8cpp.html#a1a254aa17418553bc21790001a69262a">dim</a>, TInteger &gt; &amp;object)</td></tr>
<tr class="memdesc:a04c5e0b95cb3bf61322d889850690c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1KhalimskyPreSpaceND.html" title="Aim: This class is a model of CPreCellularGridSpaceND. It represents the cubical grid as a cell compl...">KhalimskyPreSpaceND</a>'.  <a href="namespaceDGtal.html#a04c5e0b95cb3bf61322d889850690c71">More...</a><br /></td></tr>
<tr class="separator:a04c5e0b95cb3bf61322d889850690c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f9d0220351cf40a44a1430fc7dcb6b"><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename TInteger &gt; </td></tr>
<tr class="memitem:a36f9d0220351cf40a44a1430fc7dcb6b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a36f9d0220351cf40a44a1430fc7dcb6b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1KhalimskyCell.html">KhalimskyCell</a>&lt; <a class="el" href="viewDualSurface_8cpp.html#a1a254aa17418553bc21790001a69262a">dim</a>, TInteger &gt; &amp;object)</td></tr>
<tr class="separator:a36f9d0220351cf40a44a1430fc7dcb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6851bd6ddd1a7f9164c8f8273ee2727c"><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename TInteger &gt; </td></tr>
<tr class="memitem:a6851bd6ddd1a7f9164c8f8273ee2727c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6851bd6ddd1a7f9164c8f8273ee2727c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1SignedKhalimskyCell.html">SignedKhalimskyCell</a>&lt; <a class="el" href="viewDualSurface_8cpp.html#a1a254aa17418553bc21790001a69262a">dim</a>, TInteger &gt; &amp;object)</td></tr>
<tr class="separator:a6851bd6ddd1a7f9164c8f8273ee2727c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690f8c5f9f1d11d71b088ef5141506fa"><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename TInteger &gt; </td></tr>
<tr class="memitem:a690f8c5f9f1d11d71b088ef5141506fa"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a690f8c5f9f1d11d71b088ef5141506fa">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1KhalimskySpaceND.html">KhalimskySpaceND</a>&lt; <a class="el" href="viewDualSurface_8cpp.html#a1a254aa17418553bc21790001a69262a">dim</a>, TInteger &gt; &amp;object)</td></tr>
<tr class="memdesc:a690f8c5f9f1d11d71b088ef5141506fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex,...">KhalimskySpaceND</a>'.  <a href="namespaceDGtal.html#a690f8c5f9f1d11d71b088ef5141506fa">More...</a><br /></td></tr>
<tr class="separator:a690f8c5f9f1d11d71b088ef5141506fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15355fc66cdd9267509b7e1820bb849e"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TSurfelPredicate &gt; </td></tr>
<tr class="memitem:a15355fc66cdd9267509b7e1820bb849e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a15355fc66cdd9267509b7e1820bb849e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html">LightExplicitDigitalSurface</a>&lt; TKSpace, TSurfelPredicate &gt; &amp;object)</td></tr>
<tr class="separator:a15355fc66cdd9267509b7e1820bb849e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10dd39d3611456c2f7ed0cfcbaa7607d"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TPointPredicate &gt; </td></tr>
<tr class="memitem:a10dd39d3611456c2f7ed0cfcbaa7607d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a10dd39d3611456c2f7ed0cfcbaa7607d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html">LightImplicitDigitalSurface</a>&lt; TKSpace, TPointPredicate &gt; &amp;object)</td></tr>
<tr class="separator:a10dd39d3611456c2f7ed0cfcbaa7607d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6358ae6509cbb7033680e30b29ef66ed"><td class="memTemplParams" colspan="2">template&lt;typename TSpace , Dimension maxNorm1&gt; </td></tr>
<tr class="memitem:a6358ae6509cbb7033680e30b29ef66ed"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6358ae6509cbb7033680e30b29ef66ed">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1MetricAdjacency.html">MetricAdjacency</a>&lt; TSpace, maxNorm1, TSpace::dimension &gt; &amp;object)</td></tr>
<tr class="separator:a6358ae6509cbb7033680e30b29ef66ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae75cc7ec1fb5546bc6a2f2f8cd23e7"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalTopology , typename TDigitalSet &gt; </td></tr>
<tr class="memitem:a2ae75cc7ec1fb5546bc6a2f2f8cd23e7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2ae75cc7ec1fb5546bc6a2f2f8cd23e7">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Object.html">Object</a>&lt; TDigitalTopology, TDigitalSet &gt; &amp;object)</td></tr>
<tr class="separator:a2ae75cc7ec1fb5546bc6a2f2f8cd23e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e131923f413c708e1f30e1caf7f502f"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TSurfelSet &gt; </td></tr>
<tr class="memitem:a0e131923f413c708e1f30e1caf7f502f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0e131923f413c708e1f30e1caf7f502f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1SetOfSurfels.html">SetOfSurfels</a>&lt; TKSpace, TSurfelSet &gt; &amp;object)</td></tr>
<tr class="separator:a0e131923f413c708e1f30e1caf7f502f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28cd2ea7afa2aa2dd6bf76e54a9e2b0"><td class="memTemplParams" colspan="2">template&lt;Dimension dim&gt; </td></tr>
<tr class="memitem:ad28cd2ea7afa2aa2dd6bf76e54a9e2b0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad28cd2ea7afa2aa2dd6bf76e54a9e2b0">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; <a class="el" href="viewDualSurface_8cpp.html#a1a254aa17418553bc21790001a69262a">dim</a> &gt; &amp;object)</td></tr>
<tr class="separator:ad28cd2ea7afa2aa2dd6bf76e54a9e2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfc586cb4ecd8bb0b1a787a84cb82d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acbfc586cb4ecd8bb0b1a787a84cb82d6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#acbfc586cb4ecd8bb0b1a787a84cb82d6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="separator:acbfc586cb4ecd8bb0b1a787a84cb82d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa315c6c8d41dbc29ddf8acc5be306a4"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalSurfaceTracker &gt; </td></tr>
<tr class="memitem:afa315c6c8d41dbc29ddf8acc5be306a4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afa315c6c8d41dbc29ddf8acc5be306a4">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1UmbrellaComputer.html">UmbrellaComputer</a>&lt; TDigitalSurfaceTracker &gt; &amp;object)</td></tr>
<tr class="separator:afa315c6c8d41dbc29ddf8acc5be306a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9453d81f5c0bc9057de2329c799e798"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:ae9453d81f5c0bc9057de2329c799e798"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1VoxelComplex.html">VoxelComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae9453d81f5c0bc9057de2329c799e798">operator-=</a> (<a class="el" href="classDGtal_1_1VoxelComplex.html">VoxelComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1VoxelComplex.html">VoxelComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:ae9453d81f5c0bc9057de2329c799e798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eccf894da053756ca42d3544bdd7acf"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:a5eccf894da053756ca42d3544bdd7acf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1VoxelComplex.html">VoxelComplex</a>&lt; TKSpace, TCellContainer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5eccf894da053756ca42d3544bdd7acf">operator-</a> (const <a class="el" href="classDGtal_1_1VoxelComplex.html">VoxelComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1VoxelComplex.html">VoxelComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:a5eccf894da053756ca42d3544bdd7acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd92c3e107e9c40b882500181482ee9c"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:acd92c3e107e9c40b882500181482ee9c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#acd92c3e107e9c40b882500181482ee9c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1VoxelComplex.html">VoxelComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;object)</td></tr>
<tr class="separator:acd92c3e107e9c40b882500181482ee9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0c060685d6e9a49445a562a99c5286"><td class="memTemplParams" colspan="2">template&lt;typename KSpace , typename PointPredicate &gt; </td></tr>
<tr class="memitem:a9d0c060685d6e9a49445a562a99c5286"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9d0c060685d6e9a49445a562a99c5286">testImplicitDigitalSurface</a> (const <a class="el" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a> &amp;<a class="el" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, const PointPredicate &amp;pp, const typename <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae4aa1c6d804b5e0ad5de4fb395a96321">KSpace::Surfel</a> &amp;bel)</td></tr>
<tr class="separator:a9d0c060685d6e9a49445a562a99c5286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08886ee117009e48c66e4349c7c47265"><td class="memTemplParams" colspan="2">template&lt;typename KSpace , typename PointPredicate &gt; </td></tr>
<tr class="memitem:a08886ee117009e48c66e4349c7c47265"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a08886ee117009e48c66e4349c7c47265">testLightImplicitDigitalSurface</a> (const <a class="el" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a> &amp;<a class="el" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, const PointPredicate &amp;pp, const typename <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae4aa1c6d804b5e0ad5de4fb395a96321">KSpace::Surfel</a> &amp;bel)</td></tr>
<tr class="separator:a08886ee117009e48c66e4349c7c47265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions related to BoundedLatticePolytope (output, dilation, Minkowski sum)</div></td></tr>
<tr class="memitem:a1f3b6ebf2123436829f58f92ef5a618d"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a1f3b6ebf2123436829f58f92ef5a618d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1f3b6ebf2123436829f58f92ef5a618d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt; &amp;object)</td></tr>
<tr class="separator:a1f3b6ebf2123436829f58f92ef5a618d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bb2fc09d5940620aa4bb6b3246cf50"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a66bb2fc09d5940620aa4bb6b3246cf50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a66bb2fc09d5940620aa4bb6b3246cf50">operator*</a> (typename <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt;::<a class="el" href="examplePlaneProbingParallelepipedEstimator_8cpp.html#ad31c3eca44cf6770809bc47f2b456212">Integer</a> t, const <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt; &amp;P)</td></tr>
<tr class="separator:a66bb2fc09d5940620aa4bb6b3246cf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4f5b9f5ff70e32fc8dcf70cb98bb5f"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a6d4f5b9f5ff70e32fc8dcf70cb98bb5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6d4f5b9f5ff70e32fc8dcf70cb98bb5f">operator+</a> (const <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt; &amp;P, typename <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt;::UnitSegment s)</td></tr>
<tr class="separator:a6d4f5b9f5ff70e32fc8dcf70cb98bb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2989aae399cb671d978428ffd4fbe325"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a2989aae399cb671d978428ffd4fbe325"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2989aae399cb671d978428ffd4fbe325">operator+</a> (const <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt; &amp;P, typename <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt;::UnitCell c)</td></tr>
<tr class="separator:a2989aae399cb671d978428ffd4fbe325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abb6cb52e4cbb2515a9ba6af7d386da"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a5abb6cb52e4cbb2515a9ba6af7d386da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5abb6cb52e4cbb2515a9ba6af7d386da">operator+</a> (const <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt; &amp;P, typename <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt;::RightStrictUnitSegment s)</td></tr>
<tr class="separator:a5abb6cb52e4cbb2515a9ba6af7d386da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678c2d53aa522c5088c77139388a5ccb"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a678c2d53aa522c5088c77139388a5ccb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a678c2d53aa522c5088c77139388a5ccb">operator+</a> (const <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt; &amp;P, typename <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt;::RightStrictUnitCell c)</td></tr>
<tr class="separator:a678c2d53aa522c5088c77139388a5ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df255b5e94781f1f3607c8df815ac66"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a7df255b5e94781f1f3607c8df815ac66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7df255b5e94781f1f3607c8df815ac66">operator+</a> (const <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt; &amp;P, typename <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt;::LeftStrictUnitSegment s)</td></tr>
<tr class="separator:a7df255b5e94781f1f3607c8df815ac66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc7f826e62dbeaca125517a82a5b098"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a0bc7f826e62dbeaca125517a82a5b098"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0bc7f826e62dbeaca125517a82a5b098">operator+</a> (const <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt; &amp;P, typename <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt;::LeftStrictUnitCell c)</td></tr>
<tr class="separator:a0bc7f826e62dbeaca125517a82a5b098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions related to BoundedRationalPolytope (output, dilation, Minkowski sum)</div></td></tr>
<tr class="memitem:a80d062a5c7a6c7e1bcf63cf3e0a9fe73"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a80d062a5c7a6c7e1bcf63cf3e0a9fe73"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a80d062a5c7a6c7e1bcf63cf3e0a9fe73">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; TSpace &gt; &amp;object)</td></tr>
<tr class="separator:a80d062a5c7a6c7e1bcf63cf3e0a9fe73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b89d5d3bfe2fc1b44f147e5ae811f31"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a8b89d5d3bfe2fc1b44f147e5ae811f31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; TSpace &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8b89d5d3bfe2fc1b44f147e5ae811f31">operator*</a> (typename <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; TSpace &gt;::<a class="el" href="examplePlaneProbingParallelepipedEstimator_8cpp.html#ad31c3eca44cf6770809bc47f2b456212">Integer</a> t, const <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; TSpace &gt; &amp;P)</td></tr>
<tr class="separator:a8b89d5d3bfe2fc1b44f147e5ae811f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ad7b4c24afbe69907e4c6b4e9708b0"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:af3ad7b4c24afbe69907e4c6b4e9708b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; TSpace &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af3ad7b4c24afbe69907e4c6b4e9708b0">operator*</a> (typename <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; TSpace &gt;::Rational r, const <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; TSpace &gt; &amp;P)</td></tr>
<tr class="separator:af3ad7b4c24afbe69907e4c6b4e9708b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4771f3aa833a58345269e424b25bd67"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:ab4771f3aa833a58345269e424b25bd67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; TSpace &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab4771f3aa833a58345269e424b25bd67">operator+</a> (const <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; TSpace &gt; &amp;P, typename <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; TSpace &gt;::UnitSegment s)</td></tr>
<tr class="separator:ab4771f3aa833a58345269e424b25bd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc6de5ffec7b9bd8eaf029b9b44ff0c"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a0fc6de5ffec7b9bd8eaf029b9b44ff0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; TSpace &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0fc6de5ffec7b9bd8eaf029b9b44ff0c">operator+</a> (const <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; TSpace &gt; &amp;P, typename <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; TSpace &gt;::UnitCell c)</td></tr>
<tr class="separator:a0fc6de5ffec7b9bd8eaf029b9b44ff0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions related to CellGeometry (output)</div></td></tr>
<tr class="memitem:ae68e77202300ec2a1ebee48ddce0e640"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace &gt; </td></tr>
<tr class="memitem:ae68e77202300ec2a1ebee48ddce0e640"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae68e77202300ec2a1ebee48ddce0e640">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1CellGeometry.html">CellGeometry</a>&lt; TKSpace &gt; &amp;object)</td></tr>
<tr class="separator:ae68e77202300ec2a1ebee48ddce0e640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions related to DigitalConvexity (output)</div></td></tr>
<tr class="memitem:a763c7c06f6d313a99d43a33f62d766b1"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace &gt; </td></tr>
<tr class="memitem:a763c7c06f6d313a99d43a33f62d766b1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a763c7c06f6d313a99d43a33f62d766b1">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalConvexity.html">DigitalConvexity</a>&lt; TKSpace &gt; &amp;object)</td></tr>
<tr class="separator:a763c7c06f6d313a99d43a33f62d766b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8fc7012708b0416880a5c8b12dfdf9dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1Trace.html">Trace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a></td></tr>
<tr class="separator:a8fc7012708b0416880a5c8b12dfdf9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae801de7ee4d22c47257dc7e00e0c5dd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1TraceWriterTerm.html">TraceWriterTerm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae801de7ee4d22c47257dc7e00e0c5dd7">traceWriterTerm</a> (std::cerr)</td></tr>
<tr class="separator:ae801de7ee4d22c47257dc7e00e0c5dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd8233d566e467056fa785b63463416"><td class="memItemLeft" align="right" valign="top">static std::size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5fd8233d566e467056fa785b63463416">HALF_EDGE_INVALID_INDEX</a> = boost::integer_traits&lt;std::size_t&gt;::const_max</td></tr>
<tr class="separator:a5fd8233d566e467056fa785b63463416"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><code><a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a></code> is the top-level namespace which contains all <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> functions and types. </p>
<p>[PrivateMembers]</p>
<p>for embedding</p>
<p><a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> Global variables</p>
<p>This macro is necessary for using spirit/phoenix functions 'at' during the construction of the semantic tree. This macro is necessary for using spirit/phoenix functions 'at' during the construction of the semantic tree. This macro is necessary for using spirit/phoenix functions 'at' during the construction of the semantic tree.</p>
<p>[<a class="el" href="classDGtal_1_1IteratorCompletionTraits.html" title="Aim: Traits that must be specialized for each IteratorCompletion derived class.">IteratorCompletionTraits</a>] </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a55bbc4405f35f8a03161e41068432454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55bbc4405f35f8a03161e41068432454">&#9670;&nbsp;</a></span>ArithmeticConversionType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceDGtal.html#a55bbc4405f35f8a03161e41068432454">DGtal::ArithmeticConversionType</a> = typedef typename <a class="el" href="structDGtal_1_1ArithmeticConversionTraits.html">ArithmeticConversionTraits</a>&lt;T, U&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result type of arithmetic binary operators between two given types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>First operand type. </td></tr>
    <tr><td class="paramname">U</td><td>Second operand type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structDGtal_1_1ArithmeticConversionTraits.html" title="Aim: Trait class to get result type of arithmetic binary operators between two given types.">ArithmeticConversionTraits</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="ArithmeticConversionTraits_8h_source.html#l00135">135</a> of file <a class="el" href="ArithmeticConversionTraits_8h_source.html">ArithmeticConversionTraits.h</a>.</p>

</div>
</div>
<a id="ad14cde66089fcbdefb20c819562d2a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14cde66089fcbdefb20c819562d2a0d">&#9670;&nbsp;</a></span>BigInteger</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef mpz_class <a class="el" href="namespaceDGtal.html#ad14cde66089fcbdefb20c819562d2a0d">DGtal::BigInteger</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi-precision integer with GMP implementation. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="arithmetic_2convergents-biginteger_8cpp-example.html#a2">arithmetic/convergents-biginteger.cpp</a>, and <a class="el" href="arithmetic_2extended-euclid_8cpp-example.html#a2">arithmetic/extended-euclid.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="BasicTypes_8h_source.html#l00079">79</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a id="a8fbe8c8d47ca5c36ced14284ac62613d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fbe8c8d47ca5c36ced14284ac62613d">&#9670;&nbsp;</a></span>Dimension</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e">DGtal::uint32_t</a> <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">DGtal::Dimension</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Global static type to represent the dimension in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="dec_2exampleDiscreteExteriorCalculusSolve_8cpp-example.html#a19">dec/exampleDiscreteExteriorCalculusSolve.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Common_8h_source.html#l00137">137</a> of file <a class="el" href="Common_8h_source.html">Common.h</a>.</p>

</div>
</div>
<a id="ac62de8348789e05494b7515c6525baa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62de8348789e05494b7515c6525baa0">&#9670;&nbsp;</a></span>int16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::int16_t <a class="el" href="namespaceDGtal.html#ac62de8348789e05494b7515c6525baa0">DGtal::int16_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>signed 16-bit integer. </p>

<p class="definition">Definition at line <a class="el" href="BasicTypes_8h_source.html#l00070">70</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a id="ac1e9ac6a329319ae13c51c0c9e92486a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e9ac6a329319ae13c51c0c9e92486a">&#9670;&nbsp;</a></span>int32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::int32_t <a class="el" href="namespaceDGtal.html#ac1e9ac6a329319ae13c51c0c9e92486a">DGtal::int32_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>signed 32-bit integer. </p>

<p class="definition">Definition at line <a class="el" href="BasicTypes_8h_source.html#l00072">72</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a id="a1c09e3f63904ff371f1b99f45069fc63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c09e3f63904ff371f1b99f45069fc63">&#9670;&nbsp;</a></span>int64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::int64_t <a class="el" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63">DGtal::int64_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>signed 94-bit integer. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="geometry_2tools_2checkLatticeBallQuickHull_8cpp-example.html#a1">geometry/tools/checkLatticeBallQuickHull.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="BasicTypes_8h_source.html#l00074">74</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a id="ac28d51e0b1672afa52b3c218a32a6a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28d51e0b1672afa52b3c218a32a6a01">&#9670;&nbsp;</a></span>int8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::int8_t <a class="el" href="namespaceDGtal.html#ac28d51e0b1672afa52b3c218a32a6a01">DGtal::int8_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>signed 8-bit integer. <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="BasicTypes_8h_source.html#l00068">68</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a id="a1564719d8c78aad60ee9144b757991a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1564719d8c78aad60ee9144b757991a1">&#9670;&nbsp;</a></span>NaiveDSS8Computer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TInteger  = typename IteratorCirculatorTraits&lt;TIterator&gt;::Value::Coordinate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceDGtal.html#a1564719d8c78aad60ee9144b757991a1">DGtal::NaiveDSS8Computer</a> = typedef <a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html">ArithmeticalDSSComputer</a>&lt;TIterator, TInteger, 8&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aim: This is an alias to <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a> that is devoted to the dynamic recognition of naive and simply 8-connected digital straight segments (DSS) along any sequence of digital points. </p>
<p>See <a class="el" href="moduleArithDSSReco.html">Digital straight lines and segments <br  />
</a> for further details. See also <a class="el" href="exampleArithmeticalDSSComputer_8cpp.html">exampleArithmeticalDSSComputer.cpp</a> for a basic example using StandardDSS4Computer. The use of NaiveDSS8Computer is quite similar.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIterator</td><td>type of iterator on 2d digital points, at least readable and forward. </td></tr>
    <tr><td class="paramname">TInteger</td><td>type of integers used for the computation of remainders, which is a model of CInteger.</td></tr>
  </table>
  </dd>
</dl>
<p>This alias is a model of CDynamicBidirectionalSegmentComputer. It is also default constructible, copy constructible, assignable and equality comparable.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html" title="Aim: This class is a wrapper around ArithmeticalDSS that is devoted to the dynamic recognition of dig...">ArithmeticalDSSComputer</a> <a class="el" href="namespaceDGtal.html#a247514a98187c504cc5592c6823c64db" title="Aim: This is an alias to ArithmeticalDSS that is devoted to the dynamic recognition of standard and s...">StandardDSS4Computer</a> <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a> </dd>
<dd>
<a class="el" href="exampleArithmeticalDSSComputer_8cpp.html">exampleArithmeticalDSSComputer.cpp</a> <a class="el" href="exampleArithmeticalDSS_8cpp.html">exampleArithmeticalDSS.cpp</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="ArithmeticalDSSComputer_8h_source.html#l00486">486</a> of file <a class="el" href="ArithmeticalDSSComputer_8h_source.html">ArithmeticalDSSComputer.h</a>.</p>

</div>
</div>
<a id="a319e1944935b8331846f54001a63525f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319e1944935b8331846f54001a63525f">&#9670;&nbsp;</a></span>NeighborhoodConfiguration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceDGtal.html#a319e1944935b8331846f54001a63525f">DGtal::NeighborhoodConfiguration</a> = typedef <a class="el" href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e">uint32_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NeighborhoodConfigurationsHelper_8h_source.html#l00043">43</a> of file <a class="el" href="NeighborhoodConfigurationsHelper_8h_source.html">NeighborhoodConfigurationsHelper.h</a>.</p>

</div>
</div>
<a id="a6fd80f738104ff7f8bf7d39044efe45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd80f738104ff7f8bf7d39044efe45b">&#9670;&nbsp;</a></span>Order</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="namespaceDGtal.html#a6fd80f738104ff7f8bf7d39044efe45b">DGtal::Order</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aim: Order is used as template parameter for DEC classes. </p>
<p>Description of 'Order' </p>

<p class="definition">Definition at line <a class="el" href="Duality_8h_source.html#l00089">89</a> of file <a class="el" href="Duality_8h_source.html">Duality.h</a>.</p>

</div>
</div>
<a id="a247514a98187c504cc5592c6823c64db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247514a98187c504cc5592c6823c64db">&#9670;&nbsp;</a></span>StandardDSS4Computer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TInteger  = typename IteratorCirculatorTraits&lt;TIterator&gt;::Value::Coordinate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceDGtal.html#a247514a98187c504cc5592c6823c64db">DGtal::StandardDSS4Computer</a> = typedef <a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html">ArithmeticalDSSComputer</a>&lt;TIterator, TInteger, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aim: This is an alias to <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a> that is devoted to the dynamic recognition of standard and simply 4-connected digital straight segments (DSS) along any sequence of digital points. </p>
<p>Before using a DSS computer, you must include the following header: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/curves/ArithmeticalDSSComputer.h&quot;</span></div>
</div><!-- fragment --><p> Then, you can construct a DSS computer as follows: </p><div class="fragment"><div class="line">  <span class="comment">// Container of digital points</span></div>
<div class="line">  <span class="keyword">typedef</span> std::vector&lt;Z2::Point&gt; Container;</div>
<div class="line">  <span class="comment">// Iterator on the container</span></div>
<div class="line">  <span class="keyword">typedef</span> Container::const_iterator <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a>;</div>
<div class="line">  <span class="comment">// StandardDSS4 computer</span></div>
<div class="line">  <span class="keyword">typedef</span> StandardDSS4Computer&lt;ConstIterator&gt; DSSComputer;  </div>
<div class="line">  <span class="comment">// Construction of the computer</span></div>
<div class="line">  DSSComputer theDSSComputer;    </div>
<div class="ttc" id="agreedy-plane-segmentation-ex2_8cpp_html_a6d06fad433cff067dfcbbbf16d6e2dbf"><div class="ttname"><a href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a></div><div class="ttdeci">MyDigitalSurface::ConstIterator ConstIterator</div><div class="ttdef"><b>Definition:</b> <a href="greedy-plane-segmentation-ex2_8cpp_source.html#l00093">greedy-plane-segmentation-ex2.cpp:93</a></div></div>
</div><!-- fragment --><p> The extention is simply done as follows: </p><div class="fragment"><div class="line">  <span class="comment">// Add points while it is possible</span></div>
<div class="line">  theDSSComputer.init( contour.begin() );</div>
<div class="line">  <span class="keywordflow">while</span> ( ( theDSSComputer.end() != contour.end() ) &amp;&amp;</div>
<div class="line">          ( theDSSComputer.extendFront() ) ) {}</div>
</div><!-- fragment --><p> See <a class="el" href="moduleArithDSSReco.html">Digital straight lines and segments <br  />
</a> for further details.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIterator</td><td>type of iterator on 2d digital points, at least readable and forward. </td></tr>
    <tr><td class="paramname">TInteger</td><td>type of integers used for the computation of remainders, which is a model of CInteger.</td></tr>
  </table>
  </dd>
</dl>
<p>This alias is a model of CDynamicBidirectionalSegmentComputer. It is also default constructible, copy constructible, assignable and equality comparable.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html" title="Aim: This class is a wrapper around ArithmeticalDSS that is devoted to the dynamic recognition of dig...">ArithmeticalDSSComputer</a> <a class="el" href="namespaceDGtal.html#a1564719d8c78aad60ee9144b757991a1" title="Aim: This is an alias to ArithmeticalDSS that is devoted to the dynamic recognition of naive and simp...">NaiveDSS8Computer</a> <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a> </dd>
<dd>
<a class="el" href="exampleArithmeticalDSSComputer_8cpp.html">exampleArithmeticalDSSComputer.cpp</a> <a class="el" href="exampleArithmeticalDSS_8cpp.html">exampleArithmeticalDSS.cpp</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="ArithmeticalDSSComputer_8h_source.html#l00462">462</a> of file <a class="el" href="ArithmeticalDSSComputer_8h_source.html">ArithmeticalDSSComputer.h</a>.</p>

</div>
</div>
<a id="a30f912c6a9d587320495d627df2719ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f912c6a9d587320495d627df2719ba">&#9670;&nbsp;</a></span>uint16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::uint16_t <a class="el" href="namespaceDGtal.html#a30f912c6a9d587320495d627df2719ba">DGtal::uint16_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unsigned 16-bit integer. </p>

<p class="definition">Definition at line <a class="el" href="BasicTypes_8h_source.html#l00061">61</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a id="a27c59126488e9c545120667959d2fc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c59126488e9c545120667959d2fc4e">&#9670;&nbsp;</a></span>uint32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::uint32_t <a class="el" href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e">DGtal::uint32_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unsigned 32-bit integer. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="topology_2cubical-complex-collapse_8cpp-example.html#a8">topology/cubical-complex-collapse.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="BasicTypes_8h_source.html#l00063">63</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a id="ab33c0c25b8cc3cd86de343bca34329f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33c0c25b8cc3cd86de343bca34329f5">&#9670;&nbsp;</a></span>uint64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::uint64_t <a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5">DGtal::uint64_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unsigned 64-bit integer. </p>

<p class="definition">Definition at line <a class="el" href="BasicTypes_8h_source.html#l00065">65</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a id="a3f01c0f785c605d021be8e328180f502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f01c0f785c605d021be8e328180f502">&#9670;&nbsp;</a></span>uint8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::uint8_t <a class="el" href="namespaceDGtal.html#a3f01c0f785c605d021be8e328180f502">DGtal::uint8_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unsigned 8-bit integer. </p>

<p class="definition">Definition at line <a class="el" href="BasicTypes_8h_source.html#l00059">59</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a65228f031a436d2f4edd698ae733ba31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65228f031a436d2f4edd698ae733ba31">&#9670;&nbsp;</a></span>BoundEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31">DGtal::BoundEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bounding type of a number. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a65228f031a436d2f4edd698ae733ba31a4b4e195031215bcfc63b5bf65c1c1035"></a>BOUNDED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a65228f031a436d2f4edd698ae733ba31a1906bfa4ce33f3c129b1e974826f686d"></a>UNBOUNDED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a65228f031a436d2f4edd698ae733ba31aec51247a223f33a421840eb3cbd5598e"></a>BOUND_UNKNOWN&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="NumberTraits_8h_source.html#l00054">54</a> of file <a class="el" href="NumberTraits_8h_source.html">NumberTraits.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;{<a class="code" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31a4b4e195031215bcfc63b5bf65c1c1035">BOUNDED</a> = 0, <a class="code" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31a1906bfa4ce33f3c129b1e974826f686d">UNBOUNDED</a> = 1, <a class="code" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31aec51247a223f33a421840eb3cbd5598e">BOUND_UNKNOWN</a> = 2};</div>
<div class="ttc" id="anamespaceDGtal_html_a65228f031a436d2f4edd698ae733ba31a1906bfa4ce33f3c129b1e974826f686d"><div class="ttname"><a href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31a1906bfa4ce33f3c129b1e974826f686d">DGtal::UNBOUNDED</a></div><div class="ttdeci">@ UNBOUNDED</div><div class="ttdef"><b>Definition:</b> <a href="NumberTraits_8h_source.html#l00054">NumberTraits.h:54</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a65228f031a436d2f4edd698ae733ba31a4b4e195031215bcfc63b5bf65c1c1035"><div class="ttname"><a href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31a4b4e195031215bcfc63b5bf65c1c1035">DGtal::BOUNDED</a></div><div class="ttdeci">@ BOUNDED</div><div class="ttdef"><b>Definition:</b> <a href="NumberTraits_8h_source.html#l00054">NumberTraits.h:54</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a65228f031a436d2f4edd698ae733ba31aec51247a223f33a421840eb3cbd5598e"><div class="ttname"><a href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31aec51247a223f33a421840eb3cbd5598e">DGtal::BOUND_UNKNOWN</a></div><div class="ttdeci">@ BOUND_UNKNOWN</div><div class="ttdef"><b>Definition:</b> <a href="NumberTraits_8h_source.html#l00054">NumberTraits.h:54</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5859c7f85c05195f2b406298c748169a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5859c7f85c05195f2b406298c748169a">&#9670;&nbsp;</a></span>Closest</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a5859c7f85c05195f2b406298c748169a">DGtal::Closest</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Global enum definition for closest point test (geometry/volumes/distance/..). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5859c7f85c05195f2b406298c748169aaa7daf317118fd34dd37643632874eda8"></a>ClosestFIRST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5859c7f85c05195f2b406298c748169aa2eafe49238a245201270cbbfa540b53e"></a>ClosestSECOND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5859c7f85c05195f2b406298c748169aa0474a1c5f3fa97e0be68b1ceaadc0c84"></a>ClosestBOTH&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Common_8h_source.html#l00147">147</a> of file <a class="el" href="Common_8h_source.html">Common.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;{ <a class="code" href="namespaceDGtal.html#a5859c7f85c05195f2b406298c748169aaa7daf317118fd34dd37643632874eda8">ClosestFIRST</a> = 0, <a class="code" href="namespaceDGtal.html#a5859c7f85c05195f2b406298c748169aa2eafe49238a245201270cbbfa540b53e">ClosestSECOND</a> = 1, <a class="code" href="namespaceDGtal.html#a5859c7f85c05195f2b406298c748169aa0474a1c5f3fa97e0be68b1ceaadc0c84">ClosestBOTH</a> = 2};</div>
<div class="ttc" id="anamespaceDGtal_html_a5859c7f85c05195f2b406298c748169aa0474a1c5f3fa97e0be68b1ceaadc0c84"><div class="ttname"><a href="namespaceDGtal.html#a5859c7f85c05195f2b406298c748169aa0474a1c5f3fa97e0be68b1ceaadc0c84">DGtal::ClosestBOTH</a></div><div class="ttdeci">@ ClosestBOTH</div><div class="ttdef"><b>Definition:</b> <a href="Common_8h_source.html#l00147">Common.h:147</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a5859c7f85c05195f2b406298c748169aa2eafe49238a245201270cbbfa540b53e"><div class="ttname"><a href="namespaceDGtal.html#a5859c7f85c05195f2b406298c748169aa2eafe49238a245201270cbbfa540b53e">DGtal::ClosestSECOND</a></div><div class="ttdeci">@ ClosestSECOND</div><div class="ttdef"><b>Definition:</b> <a href="Common_8h_source.html#l00147">Common.h:147</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a5859c7f85c05195f2b406298c748169aaa7daf317118fd34dd37643632874eda8"><div class="ttname"><a href="namespaceDGtal.html#a5859c7f85c05195f2b406298c748169aaa7daf317118fd34dd37643632874eda8">DGtal::ClosestFIRST</a></div><div class="ttdeci">@ ClosestFIRST</div><div class="ttdef"><b>Definition:</b> <a href="Common_8h_source.html#l00147">Common.h:147</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa68309838cffd86a3c671c44ef129cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68309838cffd86a3c671c44ef129cb2">&#9670;&nbsp;</a></span>ColorGradientPreset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2">DGtal::ColorGradientPreset</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa68309838cffd86a3c671c44ef129cb2a97a652eb81107a63d65d0d091f48e320"></a>CMAP_CUSTOM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa68309838cffd86a3c671c44ef129cb2a03f20e9e057e38ce03220e2a43b1a366"></a>CMAP_GRAYSCALE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa68309838cffd86a3c671c44ef129cb2ad222787b0de6a7d74f0e403da496266c"></a>CMAP_SPRING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa68309838cffd86a3c671c44ef129cb2aa5b0ef9d5b1e2e496ac149d9a42dd3e7"></a>CMAP_SUMMER&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa68309838cffd86a3c671c44ef129cb2a3ff3c09197871bad3bb5921e30223533"></a>CMAP_AUTUMN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa68309838cffd86a3c671c44ef129cb2acd0da059abca1decd6b75ecc6d131be7"></a>CMAP_WINTER&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa68309838cffd86a3c671c44ef129cb2a40d9e19d8fbedda0f45c0673c6c6dcbf"></a>CMAP_COOL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa68309838cffd86a3c671c44ef129cb2a2b8eab305f63590e49a6dab0b628ae33"></a>CMAP_COPPER&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa68309838cffd86a3c671c44ef129cb2a075659185495ce61ea5b09ab439e2abe"></a>CMAP_HOT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa68309838cffd86a3c671c44ef129cb2ac677c31e4299bc29c4e591063b4fc9bb"></a>CMAP_JET&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa68309838cffd86a3c671c44ef129cb2a0d238d17f03f562e296b94e68b9b4ea4"></a>CMAP_VIRIDIS&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="GradientColorMap_8h_source.html#l00060">60</a> of file <a class="el" href="GradientColorMap_8h_source.html">GradientColorMap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;                           { <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a97a652eb81107a63d65d0d091f48e320">CMAP_CUSTOM</a> = 0,</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a03f20e9e057e38ce03220e2a43b1a366">CMAP_GRAYSCALE</a>,</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2ad222787b0de6a7d74f0e403da496266c">CMAP_SPRING</a>,</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2aa5b0ef9d5b1e2e496ac149d9a42dd3e7">CMAP_SUMMER</a>,</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a3ff3c09197871bad3bb5921e30223533">CMAP_AUTUMN</a>,</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2acd0da059abca1decd6b75ecc6d131be7">CMAP_WINTER</a>,</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a40d9e19d8fbedda0f45c0673c6c6dcbf">CMAP_COOL</a>,</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a2b8eab305f63590e49a6dab0b628ae33">CMAP_COPPER</a>,</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a075659185495ce61ea5b09ab439e2abe">CMAP_HOT</a>,</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2ac677c31e4299bc29c4e591063b4fc9bb">CMAP_JET</a>,</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a0d238d17f03f562e296b94e68b9b4ea4">CMAP_VIRIDIS</a>};</div>
<div class="ttc" id="anamespaceDGtal_html_aa68309838cffd86a3c671c44ef129cb2a03f20e9e057e38ce03220e2a43b1a366"><div class="ttname"><a href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a03f20e9e057e38ce03220e2a43b1a366">DGtal::CMAP_GRAYSCALE</a></div><div class="ttdeci">@ CMAP_GRAYSCALE</div><div class="ttdef"><b>Definition:</b> <a href="GradientColorMap_8h_source.html#l00061">GradientColorMap.h:61</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_aa68309838cffd86a3c671c44ef129cb2a075659185495ce61ea5b09ab439e2abe"><div class="ttname"><a href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a075659185495ce61ea5b09ab439e2abe">DGtal::CMAP_HOT</a></div><div class="ttdeci">@ CMAP_HOT</div><div class="ttdef"><b>Definition:</b> <a href="GradientColorMap_8h_source.html#l00068">GradientColorMap.h:68</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_aa68309838cffd86a3c671c44ef129cb2a0d238d17f03f562e296b94e68b9b4ea4"><div class="ttname"><a href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a0d238d17f03f562e296b94e68b9b4ea4">DGtal::CMAP_VIRIDIS</a></div><div class="ttdeci">@ CMAP_VIRIDIS</div><div class="ttdef"><b>Definition:</b> <a href="GradientColorMap_8h_source.html#l00070">GradientColorMap.h:70</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_aa68309838cffd86a3c671c44ef129cb2a2b8eab305f63590e49a6dab0b628ae33"><div class="ttname"><a href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a2b8eab305f63590e49a6dab0b628ae33">DGtal::CMAP_COPPER</a></div><div class="ttdeci">@ CMAP_COPPER</div><div class="ttdef"><b>Definition:</b> <a href="GradientColorMap_8h_source.html#l00067">GradientColorMap.h:67</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_aa68309838cffd86a3c671c44ef129cb2a3ff3c09197871bad3bb5921e30223533"><div class="ttname"><a href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a3ff3c09197871bad3bb5921e30223533">DGtal::CMAP_AUTUMN</a></div><div class="ttdeci">@ CMAP_AUTUMN</div><div class="ttdef"><b>Definition:</b> <a href="GradientColorMap_8h_source.html#l00064">GradientColorMap.h:64</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_aa68309838cffd86a3c671c44ef129cb2a40d9e19d8fbedda0f45c0673c6c6dcbf"><div class="ttname"><a href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a40d9e19d8fbedda0f45c0673c6c6dcbf">DGtal::CMAP_COOL</a></div><div class="ttdeci">@ CMAP_COOL</div><div class="ttdef"><b>Definition:</b> <a href="GradientColorMap_8h_source.html#l00066">GradientColorMap.h:66</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_aa68309838cffd86a3c671c44ef129cb2a97a652eb81107a63d65d0d091f48e320"><div class="ttname"><a href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a97a652eb81107a63d65d0d091f48e320">DGtal::CMAP_CUSTOM</a></div><div class="ttdeci">@ CMAP_CUSTOM</div><div class="ttdef"><b>Definition:</b> <a href="GradientColorMap_8h_source.html#l00060">GradientColorMap.h:60</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_aa68309838cffd86a3c671c44ef129cb2aa5b0ef9d5b1e2e496ac149d9a42dd3e7"><div class="ttname"><a href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2aa5b0ef9d5b1e2e496ac149d9a42dd3e7">DGtal::CMAP_SUMMER</a></div><div class="ttdeci">@ CMAP_SUMMER</div><div class="ttdef"><b>Definition:</b> <a href="GradientColorMap_8h_source.html#l00063">GradientColorMap.h:63</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_aa68309838cffd86a3c671c44ef129cb2ac677c31e4299bc29c4e591063b4fc9bb"><div class="ttname"><a href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2ac677c31e4299bc29c4e591063b4fc9bb">DGtal::CMAP_JET</a></div><div class="ttdeci">@ CMAP_JET</div><div class="ttdef"><b>Definition:</b> <a href="GradientColorMap_8h_source.html#l00069">GradientColorMap.h:69</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_aa68309838cffd86a3c671c44ef129cb2acd0da059abca1decd6b75ecc6d131be7"><div class="ttname"><a href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2acd0da059abca1decd6b75ecc6d131be7">DGtal::CMAP_WINTER</a></div><div class="ttdeci">@ CMAP_WINTER</div><div class="ttdef"><b>Definition:</b> <a href="GradientColorMap_8h_source.html#l00065">GradientColorMap.h:65</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_aa68309838cffd86a3c671c44ef129cb2ad222787b0de6a7d74f0e403da496266c"><div class="ttname"><a href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2ad222787b0de6a7d74f0e403da496266c">DGtal::CMAP_SPRING</a></div><div class="ttdeci">@ CMAP_SPRING</div><div class="ttdef"><b>Definition:</b> <a href="GradientColorMap_8h_source.html#l00062">GradientColorMap.h:62</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5df441c76f46779791d077a80f0b902e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df441c76f46779791d077a80f0b902e">&#9670;&nbsp;</a></span>Connectedness</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902e">DGtal::Connectedness</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Kinds of connectedness for an object or a graph. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5df441c76f46779791d077a80f0b902ea3188ed38ab448384424887958f44beea"></a>DISCONNECTED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5df441c76f46779791d077a80f0b902ea71b8166fccee5ea03cd61a4a9b3ece1a"></a>CONNECTED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5df441c76f46779791d077a80f0b902ea01966050c6ac7ceb9818c946cd229fc4"></a>UNKNOWN&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Topology_8h_source.html#l00050">50</a> of file <a class="el" href="Topology_8h_source.html">Topology.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    {</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;      <a class="code" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902ea3188ed38ab448384424887958f44beea">DISCONNECTED</a> = 0, <a class="code" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902ea71b8166fccee5ea03cd61a4a9b3ece1a">CONNECTED</a> = 1, <a class="code" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902ea01966050c6ac7ceb9818c946cd229fc4">UNKNOWN</a> = 2</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    };</div>
<div class="ttc" id="anamespaceDGtal_html_a5df441c76f46779791d077a80f0b902ea01966050c6ac7ceb9818c946cd229fc4"><div class="ttname"><a href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902ea01966050c6ac7ceb9818c946cd229fc4">DGtal::UNKNOWN</a></div><div class="ttdeci">@ UNKNOWN</div><div class="ttdef"><b>Definition:</b> <a href="Topology_8h_source.html#l00053">Topology.h:52</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a5df441c76f46779791d077a80f0b902ea3188ed38ab448384424887958f44beea"><div class="ttname"><a href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902ea3188ed38ab448384424887958f44beea">DGtal::DISCONNECTED</a></div><div class="ttdeci">@ DISCONNECTED</div><div class="ttdef"><b>Definition:</b> <a href="Topology_8h_source.html#l00052">Topology.h:52</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a5df441c76f46779791d077a80f0b902ea71b8166fccee5ea03cd61a4a9b3ece1a"><div class="ttname"><a href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902ea71b8166fccee5ea03cd61a4a9b3ece1a">DGtal::CONNECTED</a></div><div class="ttdeci">@ CONNECTED</div><div class="ttdef"><b>Definition:</b> <a href="Topology_8h_source.html#l00052">Topology.h:52</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0f37e197740e9d7742426109610c513a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f37e197740e9d7742426109610c513a">&#9670;&nbsp;</a></span>DigitalSetBelongTestability</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513a">DGtal::DigitalSetBelongTestability</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0f37e197740e9d7742426109610c513aac54bafeace89b71100756e99a7ef368e"></a>LOW_BEL_DS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0f37e197740e9d7742426109610c513aadcca3a30244180b4238a80ae3a06e01d"></a>HIGH_BEL_DS&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="DigitalSetSelector_8h_source.html#l00063">63</a> of file <a class="el" href="DigitalSetSelector_8h_source.html">DigitalSetSelector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;{ <a class="code" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513aac54bafeace89b71100756e99a7ef368e">LOW_BEL_DS</a> = 0, <a class="code" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513aadcca3a30244180b4238a80ae3a06e01d">HIGH_BEL_DS</a> = 16 };</div>
<div class="ttc" id="anamespaceDGtal_html_a0f37e197740e9d7742426109610c513aac54bafeace89b71100756e99a7ef368e"><div class="ttname"><a href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513aac54bafeace89b71100756e99a7ef368e">DGtal::LOW_BEL_DS</a></div><div class="ttdeci">@ LOW_BEL_DS</div><div class="ttdef"><b>Definition:</b> <a href="DigitalSetSelector_8h_source.html#l00063">DigitalSetSelector.h:63</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a0f37e197740e9d7742426109610c513aadcca3a30244180b4238a80ae3a06e01d"><div class="ttname"><a href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513aadcca3a30244180b4238a80ae3a06e01d">DGtal::HIGH_BEL_DS</a></div><div class="ttdeci">@ HIGH_BEL_DS</div><div class="ttdef"><b>Definition:</b> <a href="DigitalSetSelector_8h_source.html#l00063">DigitalSetSelector.h:63</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abae5017e6f3a3d5e0c4debd8142e8ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae5017e6f3a3d5e0c4debd8142e8ccc">&#9670;&nbsp;</a></span>DigitalSetIterability</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccc">DGtal::DigitalSetIterability</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abae5017e6f3a3d5e0c4debd8142e8ccca73f1c02534747463a70f05e94ad50b3d"></a>LOW_ITER_DS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abae5017e6f3a3d5e0c4debd8142e8ccca0f85b8033e1532f5c4a0ff3d59a187bc"></a>HIGH_ITER_DS&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="DigitalSetSelector_8h_source.html#l00062">62</a> of file <a class="el" href="DigitalSetSelector_8h_source.html">DigitalSetSelector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;{ <a class="code" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccca73f1c02534747463a70f05e94ad50b3d">LOW_ITER_DS</a> = 0, <a class="code" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccca0f85b8033e1532f5c4a0ff3d59a187bc">HIGH_ITER_DS</a> = 8 };</div>
<div class="ttc" id="anamespaceDGtal_html_abae5017e6f3a3d5e0c4debd8142e8ccca0f85b8033e1532f5c4a0ff3d59a187bc"><div class="ttname"><a href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccca0f85b8033e1532f5c4a0ff3d59a187bc">DGtal::HIGH_ITER_DS</a></div><div class="ttdeci">@ HIGH_ITER_DS</div><div class="ttdef"><b>Definition:</b> <a href="DigitalSetSelector_8h_source.html#l00062">DigitalSetSelector.h:62</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_abae5017e6f3a3d5e0c4debd8142e8ccca73f1c02534747463a70f05e94ad50b3d"><div class="ttname"><a href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccca73f1c02534747463a70f05e94ad50b3d">DGtal::LOW_ITER_DS</a></div><div class="ttdeci">@ LOW_ITER_DS</div><div class="ttdef"><b>Definition:</b> <a href="DigitalSetSelector_8h_source.html#l00062">DigitalSetSelector.h:62</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a07a2f5d6c861cd13dd680ea2e64e2dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a2f5d6c861cd13dd680ea2e64e2dd4">&#9670;&nbsp;</a></span>DigitalSetSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4">DGtal::DigitalSetSize</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a07a2f5d6c861cd13dd680ea2e64e2dd4acf48b00343e26a7f40a1fdbbc7af4d70"></a>SMALL_DS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a07a2f5d6c861cd13dd680ea2e64e2dd4a0df10d7a38d07b6795da39a66cbe97cc"></a>MEDIUM_DS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a07a2f5d6c861cd13dd680ea2e64e2dd4a37af4f429983b8069af58a2334f776a0"></a>BIG_DS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a07a2f5d6c861cd13dd680ea2e64e2dd4ac6f14eff3712732f6fa6d608f11e79fe"></a>WHOLE_DS&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="DigitalSetSelector_8h_source.html#l00060">60</a> of file <a class="el" href="DigitalSetSelector_8h_source.html">DigitalSetSelector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;{ <a class="code" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4acf48b00343e26a7f40a1fdbbc7af4d70">SMALL_DS</a> = 0, <a class="code" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4a0df10d7a38d07b6795da39a66cbe97cc">MEDIUM_DS</a> = 1, <a class="code" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4a37af4f429983b8069af58a2334f776a0">BIG_DS</a> = 2, <a class="code" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4ac6f14eff3712732f6fa6d608f11e79fe">WHOLE_DS</a> = 3 };</div>
<div class="ttc" id="anamespaceDGtal_html_a07a2f5d6c861cd13dd680ea2e64e2dd4a0df10d7a38d07b6795da39a66cbe97cc"><div class="ttname"><a href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4a0df10d7a38d07b6795da39a66cbe97cc">DGtal::MEDIUM_DS</a></div><div class="ttdeci">@ MEDIUM_DS</div><div class="ttdef"><b>Definition:</b> <a href="DigitalSetSelector_8h_source.html#l00060">DigitalSetSelector.h:60</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a07a2f5d6c861cd13dd680ea2e64e2dd4a37af4f429983b8069af58a2334f776a0"><div class="ttname"><a href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4a37af4f429983b8069af58a2334f776a0">DGtal::BIG_DS</a></div><div class="ttdeci">@ BIG_DS</div><div class="ttdef"><b>Definition:</b> <a href="DigitalSetSelector_8h_source.html#l00060">DigitalSetSelector.h:60</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a07a2f5d6c861cd13dd680ea2e64e2dd4ac6f14eff3712732f6fa6d608f11e79fe"><div class="ttname"><a href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4ac6f14eff3712732f6fa6d608f11e79fe">DGtal::WHOLE_DS</a></div><div class="ttdeci">@ WHOLE_DS</div><div class="ttdef"><b>Definition:</b> <a href="DigitalSetSelector_8h_source.html#l00060">DigitalSetSelector.h:60</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a07a2f5d6c861cd13dd680ea2e64e2dd4acf48b00343e26a7f40a1fdbbc7af4d70"><div class="ttname"><a href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4acf48b00343e26a7f40a1fdbbc7af4d70">DGtal::SMALL_DS</a></div><div class="ttdeci">@ SMALL_DS</div><div class="ttdef"><b>Definition:</b> <a href="DigitalSetSelector_8h_source.html#l00060">DigitalSetSelector.h:60</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae37267b68e31ee8f7531488f7e88426a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37267b68e31ee8f7531488f7e88426a">&#9670;&nbsp;</a></span>DigitalSetVariability</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426a">DGtal::DigitalSetVariability</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae37267b68e31ee8f7531488f7e88426aa453acc6bba092ef2476618fad08d47f3"></a>LOW_VAR_DS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae37267b68e31ee8f7531488f7e88426aabef0d75c93891808eaa54c78aa08484a"></a>HIGH_VAR_DS&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="DigitalSetSelector_8h_source.html#l00061">61</a> of file <a class="el" href="DigitalSetSelector_8h_source.html">DigitalSetSelector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;{ <a class="code" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426aa453acc6bba092ef2476618fad08d47f3">LOW_VAR_DS</a> = 0, <a class="code" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426aabef0d75c93891808eaa54c78aa08484a">HIGH_VAR_DS</a> = 4 };</div>
<div class="ttc" id="anamespaceDGtal_html_ae37267b68e31ee8f7531488f7e88426aa453acc6bba092ef2476618fad08d47f3"><div class="ttname"><a href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426aa453acc6bba092ef2476618fad08d47f3">DGtal::LOW_VAR_DS</a></div><div class="ttdeci">@ LOW_VAR_DS</div><div class="ttdef"><b>Definition:</b> <a href="DigitalSetSelector_8h_source.html#l00061">DigitalSetSelector.h:61</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_ae37267b68e31ee8f7531488f7e88426aabef0d75c93891808eaa54c78aa08484a"><div class="ttname"><a href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426aabef0d75c93891808eaa54c78aa08484a">DGtal::HIGH_VAR_DS</a></div><div class="ttdeci">@ HIGH_VAR_DS</div><div class="ttdef"><b>Definition:</b> <a href="DigitalSetSelector_8h_source.html#l00061">DigitalSetSelector.h:61</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9f57dcd68d3056024eec6b4205f7083d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f57dcd68d3056024eec6b4205f7083d">&#9670;&nbsp;</a></span>DigitalTopologyProperties</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083d">DGtal::DigitalTopologyProperties</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible properties of digital topologies. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9f57dcd68d3056024eec6b4205f7083dabce62ac78855e24784c74bdd7d8e4e88"></a>UNKNOWN_DT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9f57dcd68d3056024eec6b4205f7083da76d2c48b4a35a0dcb5ca4e6cf2462ff0"></a>NOT_JORDAN_DT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9f57dcd68d3056024eec6b4205f7083da731ee8276af4e05e2fe322cf2a4fd179"></a>JORDAN_DT&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="DigitalTopology_8h_source.html#l00055">55</a> of file <a class="el" href="DigitalTopology_8h_source.html">DigitalTopology.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;                                 { <a class="code" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083dabce62ac78855e24784c74bdd7d8e4e88">UNKNOWN_DT</a> = 0, </div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;           <a class="code" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083da76d2c48b4a35a0dcb5ca4e6cf2462ff0">NOT_JORDAN_DT</a> = 1,</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;           <a class="code" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083da731ee8276af4e05e2fe322cf2a4fd179">JORDAN_DT</a> = 2 };</div>
<div class="ttc" id="anamespaceDGtal_html_a9f57dcd68d3056024eec6b4205f7083da731ee8276af4e05e2fe322cf2a4fd179"><div class="ttname"><a href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083da731ee8276af4e05e2fe322cf2a4fd179">DGtal::JORDAN_DT</a></div><div class="ttdeci">@ JORDAN_DT</div><div class="ttdef"><b>Definition:</b> <a href="DigitalTopology_8h_source.html#l00057">DigitalTopology.h:57</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a9f57dcd68d3056024eec6b4205f7083da76d2c48b4a35a0dcb5ca4e6cf2462ff0"><div class="ttname"><a href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083da76d2c48b4a35a0dcb5ca4e6cf2462ff0">DGtal::NOT_JORDAN_DT</a></div><div class="ttdeci">@ NOT_JORDAN_DT</div><div class="ttdef"><b>Definition:</b> <a href="DigitalTopology_8h_source.html#l00056">DigitalTopology.h:56</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a9f57dcd68d3056024eec6b4205f7083dabce62ac78855e24784c74bdd7d8e4e88"><div class="ttname"><a href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083dabce62ac78855e24784c74bdd7d8e4e88">DGtal::UNKNOWN_DT</a></div><div class="ttdeci">@ UNKNOWN_DT</div><div class="ttdef"><b>Definition:</b> <a href="DigitalTopology_8h_source.html#l00055">DigitalTopology.h:55</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2526218ffac7b4842d393facbedd9ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2526218ffac7b4842d393facbedd9ee3">&#9670;&nbsp;</a></span>DomainDrawMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3">DGtal::DomainDrawMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies the drawing mode for domains. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2526218ffac7b4842d393facbedd9ee3a6cfb206d9d6225066329a79e83db654e"></a>GRID&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2526218ffac7b4842d393facbedd9ee3ad788351651a8e983ca1b5b30861ad8ba"></a>PAVING&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Board2D_8h_source.html#l00057">57</a> of file <a class="el" href="Board2D_8h_source.html">Board2D.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;{ <a class="code" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3a6cfb206d9d6225066329a79e83db654e">GRID</a> = 0, <a class="code" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3ad788351651a8e983ca1b5b30861ad8ba">PAVING</a> = 1 };</div>
<div class="ttc" id="anamespaceDGtal_html_a2526218ffac7b4842d393facbedd9ee3a6cfb206d9d6225066329a79e83db654e"><div class="ttname"><a href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3a6cfb206d9d6225066329a79e83db654e">DGtal::GRID</a></div><div class="ttdeci">@ GRID</div><div class="ttdef"><b>Definition:</b> <a href="Board2D_8h_source.html#l00057">Board2D.h:57</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a2526218ffac7b4842d393facbedd9ee3ad788351651a8e983ca1b5b30861ad8ba"><div class="ttname"><a href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3ad788351651a8e983ca1b5b30861ad8ba">DGtal::PAVING</a></div><div class="ttdeci">@ PAVING</div><div class="ttdef"><b>Definition:</b> <a href="Board2D_8h_source.html#l00057">Board2D.h:57</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab8007ddbb5627666913e18c3b951745d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8007ddbb5627666913e18c3b951745d">&#9670;&nbsp;</a></span>Duality</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#ab8007ddbb5627666913e18c3b951745d">DGtal::Duality</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aim: Duality enumerator tells if templated object lives in primal or dual space. Used as template parameter for DEC classes. </p>
<p>Description of 'Duality' </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab8007ddbb5627666913e18c3b951745da7b7d86a1d82efbe8b9bc0ad3c7c80bd7"></a>PRIMAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab8007ddbb5627666913e18c3b951745dac649578cee4b5463ded5048fdaa47a41"></a>DUAL&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Duality_8h_source.html#l00059">59</a> of file <a class="el" href="Duality_8h_source.html">Duality.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;{</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <a class="code" href="namespaceDGtal.html#ab8007ddbb5627666913e18c3b951745da7b7d86a1d82efbe8b9bc0ad3c7c80bd7">PRIMAL</a> = 0,</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <a class="code" href="namespaceDGtal.html#ab8007ddbb5627666913e18c3b951745dac649578cee4b5463ded5048fdaa47a41">DUAL</a> = 1</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;};</div>
<div class="ttc" id="anamespaceDGtal_html_ab8007ddbb5627666913e18c3b951745da7b7d86a1d82efbe8b9bc0ad3c7c80bd7"><div class="ttname"><a href="namespaceDGtal.html#ab8007ddbb5627666913e18c3b951745da7b7d86a1d82efbe8b9bc0ad3c7c80bd7">DGtal::PRIMAL</a></div><div class="ttdeci">@ PRIMAL</div><div class="ttdef"><b>Definition:</b> <a href="Duality_8h_source.html#l00061">Duality.h:61</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_ab8007ddbb5627666913e18c3b951745dac649578cee4b5463ded5048fdaa47a41"><div class="ttname"><a href="namespaceDGtal.html#ab8007ddbb5627666913e18c3b951745dac649578cee4b5463ded5048fdaa47a41">DGtal::DUAL</a></div><div class="ttdeci">@ DUAL</div><div class="ttdef"><b>Definition:</b> <a href="Duality_8h_source.html#l00063">Duality.h:62</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="afbda75b83fdb9094d0e38931838c8d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbda75b83fdb9094d0e38931838c8d6a">&#9670;&nbsp;</a></span>ImageBelongTestability</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6a">DGtal::ImageBelongTestability</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afbda75b83fdb9094d0e38931838c8d6aa3417447f6aa436ccbf37e0c359adac12"></a>HIGH_BEL_I&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afbda75b83fdb9094d0e38931838c8d6aa5bb4ca524cc66ff98e8b4ad4b4138630"></a>LOW_BEL_I&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ImageSelector_8h_source.html#l00055">55</a> of file <a class="el" href="ImageSelector_8h_source.html">ImageSelector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;{  <a class="code" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6aa3417447f6aa436ccbf37e0c359adac12">HIGH_BEL_I</a> = 0, <a class="code" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6aa5bb4ca524cc66ff98e8b4ad4b4138630">LOW_BEL_I</a> = 2 };</div>
<div class="ttc" id="anamespaceDGtal_html_afbda75b83fdb9094d0e38931838c8d6aa3417447f6aa436ccbf37e0c359adac12"><div class="ttname"><a href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6aa3417447f6aa436ccbf37e0c359adac12">DGtal::HIGH_BEL_I</a></div><div class="ttdeci">@ HIGH_BEL_I</div><div class="ttdef"><b>Definition:</b> <a href="ImageSelector_8h_source.html#l00055">ImageSelector.h:55</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_afbda75b83fdb9094d0e38931838c8d6aa5bb4ca524cc66ff98e8b4ad4b4138630"><div class="ttname"><a href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6aa5bb4ca524cc66ff98e8b4ad4b4138630">DGtal::LOW_BEL_I</a></div><div class="ttdeci">@ LOW_BEL_I</div><div class="ttdef"><b>Definition:</b> <a href="ImageSelector_8h_source.html#l00055">ImageSelector.h:55</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7f3384cac6dea91b4d46cc1421854dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3384cac6dea91b4d46cc1421854dda">&#9670;&nbsp;</a></span>ImageIterability</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854dda">DGtal::ImageIterability</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7f3384cac6dea91b4d46cc1421854ddaacf7975d858b926cba1cc047885d1765c"></a>HIGH_ITER_IMAGE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7f3384cac6dea91b4d46cc1421854ddaa66f45381ecc834daac482ee3493a79f7"></a>LOW_ITER_I&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ImageSelector_8h_source.html#l00054">54</a> of file <a class="el" href="ImageSelector_8h_source.html">ImageSelector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;{  <a class="code" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854ddaacf7975d858b926cba1cc047885d1765c">HIGH_ITER_IMAGE</a> = 0 , <a class="code" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854ddaa66f45381ecc834daac482ee3493a79f7">LOW_ITER_I</a> = 1};</div>
<div class="ttc" id="anamespaceDGtal_html_a7f3384cac6dea91b4d46cc1421854ddaa66f45381ecc834daac482ee3493a79f7"><div class="ttname"><a href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854ddaa66f45381ecc834daac482ee3493a79f7">DGtal::LOW_ITER_I</a></div><div class="ttdeci">@ LOW_ITER_I</div><div class="ttdef"><b>Definition:</b> <a href="ImageSelector_8h_source.html#l00054">ImageSelector.h:54</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a7f3384cac6dea91b4d46cc1421854ddaacf7975d858b926cba1cc047885d1765c"><div class="ttname"><a href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854ddaacf7975d858b926cba1cc047885d1765c">DGtal::HIGH_ITER_IMAGE</a></div><div class="ttdeci">@ HIGH_ITER_IMAGE</div><div class="ttdef"><b>Definition:</b> <a href="ImageSelector_8h_source.html#l00054">ImageSelector.h:54</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0a142484d2c7efc3d29f5bbde3b449b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a142484d2c7efc3d29f5bbde3b449b7">&#9670;&nbsp;</a></span>ImageSpecificContainer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7">DGtal::ImageSpecificContainer</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0a142484d2c7efc3d29f5bbde3b449b7a0a9f2a6126427332825d75e775f59388"></a>NORMAL_CONTAINER_I&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0a142484d2c7efc3d29f5bbde3b449b7ad4deed74c04fa5f801b7c2638d536c1d"></a>VTKIMAGEDATA_CONTAINER_I&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ImageSelector_8h_source.html#l00056">56</a> of file <a class="el" href="ImageSelector_8h_source.html">ImageSelector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;{ <a class="code" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7a0a9f2a6126427332825d75e775f59388">NORMAL_CONTAINER_I</a> = 0, <a class="code" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7ad4deed74c04fa5f801b7c2638d536c1d">VTKIMAGEDATA_CONTAINER_I</a> = 4 };</div>
<div class="ttc" id="anamespaceDGtal_html_a0a142484d2c7efc3d29f5bbde3b449b7a0a9f2a6126427332825d75e775f59388"><div class="ttname"><a href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7a0a9f2a6126427332825d75e775f59388">DGtal::NORMAL_CONTAINER_I</a></div><div class="ttdeci">@ NORMAL_CONTAINER_I</div><div class="ttdef"><b>Definition:</b> <a href="ImageSelector_8h_source.html#l00056">ImageSelector.h:56</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a0a142484d2c7efc3d29f5bbde3b449b7ad4deed74c04fa5f801b7c2638d536c1d"><div class="ttname"><a href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7ad4deed74c04fa5f801b7c2638d536c1d">DGtal::VTKIMAGEDATA_CONTAINER_I</a></div><div class="ttdeci">@ VTKIMAGEDATA_CONTAINER_I</div><div class="ttdef"><b>Definition:</b> <a href="ImageSelector_8h_source.html#l00056">ImageSelector.h:56</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9f6cc75dc44e45506a66cd233e0deb41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6cc75dc44e45506a66cd233e0deb41">&#9670;&nbsp;</a></span>Orientation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41">DGtal::Orientation</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Global enum definition for orientation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9f6cc75dc44e45506a66cd233e0deb41a528af0eaf947edc94796219523aa9553"></a>INSIDE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9f6cc75dc44e45506a66cd233e0deb41a7671a5416d92f37137f9999ca23dd65e"></a>ON&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9f6cc75dc44e45506a66cd233e0deb41a5f4bdeccc29812b7de1cc0c05b724734"></a>OUTSIDE&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Common_8h_source.html#l00142">142</a> of file <a class="el" href="Common_8h_source.html">Common.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;{ <a class="code" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41a528af0eaf947edc94796219523aa9553">INSIDE</a> = 0, <a class="code" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41a7671a5416d92f37137f9999ca23dd65e">ON</a> = 1, <a class="code" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41a5f4bdeccc29812b7de1cc0c05b724734">OUTSIDE</a> = 2};</div>
<div class="ttc" id="anamespaceDGtal_html_a9f6cc75dc44e45506a66cd233e0deb41a528af0eaf947edc94796219523aa9553"><div class="ttname"><a href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41a528af0eaf947edc94796219523aa9553">DGtal::INSIDE</a></div><div class="ttdeci">@ INSIDE</div><div class="ttdef"><b>Definition:</b> <a href="Common_8h_source.html#l00142">Common.h:142</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a9f6cc75dc44e45506a66cd233e0deb41a5f4bdeccc29812b7de1cc0c05b724734"><div class="ttname"><a href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41a5f4bdeccc29812b7de1cc0c05b724734">DGtal::OUTSIDE</a></div><div class="ttdeci">@ OUTSIDE</div><div class="ttdef"><b>Definition:</b> <a href="Common_8h_source.html#l00142">Common.h:142</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a9f6cc75dc44e45506a66cd233e0deb41a7671a5416d92f37137f9999ca23dd65e"><div class="ttname"><a href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41a7671a5416d92f37137f9999ca23dd65e">DGtal::ON</a></div><div class="ttdeci">@ ON</div><div class="ttdef"><b>Definition:</b> <a href="Common_8h_source.html#l00142">Common.h:142</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abb201440d2d4b97d7078c6716a8d6f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb201440d2d4b97d7078c6716a8d6f49">&#9670;&nbsp;</a></span>ProbingMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49">DGtal::ProbingMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Probing mode for plane-probing estimators. This mode allows to select the good <a class="el" href="classDGtal_1_1PlaneProbingNeighborhood.html">PlaneProbingNeighborhood</a> subclass when constructing a <a class="el" href="classDGtal_1_1PlaneProbingTetrahedronEstimator.html">PlaneProbingTetrahedronEstimator</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abb201440d2d4b97d7078c6716a8d6f49ac1d9f50f86825a1a2302ec2449c17196"></a>H&#160;</td><td class="fielddoc"><p>The H-neighborhood composed of 6 points on an hexagon, see <a class="el" href="classDGtal_1_1PlaneProbingHNeighborhood.html">PlaneProbingHNeighborhood</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="abb201440d2d4b97d7078c6716a8d6f49ae1e1d3d40573127e9ee0480caf1283d6"></a>R&#160;</td><td class="fielddoc"><p>The R-neighborhood composed of 6 rays, see <a class="el" href="classDGtal_1_1PlaneProbingRNeighborhood.html">PlaneProbingRNeighborhood</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="abb201440d2d4b97d7078c6716a8d6f49acda522d4353b166cc2dee84673307b4e"></a>R1&#160;</td><td class="fielddoc"><p>The R-neighborhood but with an optimization to reduce the number of calls to the predicate, see <a class="el" href="classDGtal_1_1PlaneProbingR1Neighborhood.html">PlaneProbingR1Neighborhood</a>. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="PlaneProbingTetrahedronEstimator_8h_source.html#l00058">58</a> of file <a class="el" href="PlaneProbingTetrahedronEstimator_8h_source.html">PlaneProbingTetrahedronEstimator.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    {</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        <a class="code" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ac1d9f50f86825a1a2302ec2449c17196">H</a>, </div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        <a class="code" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ae1e1d3d40573127e9ee0480caf1283d6">R</a>, </div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        <a class="code" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49acda522d4353b166cc2dee84673307b4e">R1</a>, </div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    };</div>
<div class="ttc" id="anamespaceDGtal_html_abb201440d2d4b97d7078c6716a8d6f49ac1d9f50f86825a1a2302ec2449c17196"><div class="ttname"><a href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ac1d9f50f86825a1a2302ec2449c17196">DGtal::ProbingMode::H</a></div><div class="ttdeci">@ H</div></div>
<div class="ttc" id="anamespaceDGtal_html_abb201440d2d4b97d7078c6716a8d6f49acda522d4353b166cc2dee84673307b4e"><div class="ttname"><a href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49acda522d4353b166cc2dee84673307b4e">DGtal::ProbingMode::R1</a></div><div class="ttdeci">@ R1</div></div>
<div class="ttc" id="anamespaceDGtal_html_abb201440d2d4b97d7078c6716a8d6f49ae1e1d3d40573127e9ee0480caf1283d6"><div class="ttname"><a href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ae1e1d3d40573127e9ee0480caf1283d6">DGtal::ProbingMode::R</a></div><div class="ttdeci">@ R</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a679e16b34aad98ff340decf89d1c86db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679e16b34aad98ff340decf89d1c86db">&#9670;&nbsp;</a></span>SignEnum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86db">DGtal::SignEnum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sign type of a number. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a679e16b34aad98ff340decf89d1c86dbae3e0717ad611faed845dd64931b1f99c"></a>SIGNED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a679e16b34aad98ff340decf89d1c86dba4e5cd9a9d62617341034f3f1c0f79b32"></a>UNSIGNED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a679e16b34aad98ff340decf89d1c86dba23888a413fb400a53deeb0b0e17d3100"></a>SIGN_UNKNOWN&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="NumberTraits_8h_source.html#l00057">57</a> of file <a class="el" href="NumberTraits_8h_source.html">NumberTraits.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;{<a class="code" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dbae3e0717ad611faed845dd64931b1f99c">SIGNED</a> = 0, <a class="code" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dba4e5cd9a9d62617341034f3f1c0f79b32">UNSIGNED</a> = 1, <a class="code" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dba23888a413fb400a53deeb0b0e17d3100">SIGN_UNKNOWN</a> = 2};</div>
<div class="ttc" id="anamespaceDGtal_html_a679e16b34aad98ff340decf89d1c86dba23888a413fb400a53deeb0b0e17d3100"><div class="ttname"><a href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dba23888a413fb400a53deeb0b0e17d3100">DGtal::SIGN_UNKNOWN</a></div><div class="ttdeci">@ SIGN_UNKNOWN</div><div class="ttdef"><b>Definition:</b> <a href="NumberTraits_8h_source.html#l00057">NumberTraits.h:57</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a679e16b34aad98ff340decf89d1c86dba4e5cd9a9d62617341034f3f1c0f79b32"><div class="ttname"><a href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dba4e5cd9a9d62617341034f3f1c0f79b32">DGtal::UNSIGNED</a></div><div class="ttdeci">@ UNSIGNED</div><div class="ttdef"><b>Definition:</b> <a href="NumberTraits_8h_source.html#l00057">NumberTraits.h:57</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a679e16b34aad98ff340decf89d1c86dbae3e0717ad611faed845dd64931b1f99c"><div class="ttname"><a href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dbae3e0717ad611faed845dd64931b1f99c">DGtal::SIGNED</a></div><div class="ttdeci">@ SIGNED</div><div class="ttdef"><b>Definition:</b> <a href="NumberTraits_8h_source.html#l00057">NumberTraits.h:57</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aaad242ffef715835e8928579a506b2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad242ffef715835e8928579a506b2d5">&#9670;&nbsp;</a></span>Surfel2PointEmbedding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#aaad242ffef715835e8928579a506b2d5">DGtal::Surfel2PointEmbedding</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Possible embeddings for surfel as point(s) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aaad242ffef715835e8928579a506b2d5ac0a8bc5774ff6530ee71a7cacd6ca6f4"></a>Pointels&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aaad242ffef715835e8928579a506b2d5a800e26ee60cfa63833cffca955ae401f"></a>InnerSpel&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aaad242ffef715835e8928579a506b2d5a0630efc9b8129aa1ad3233bba9f08423"></a>OuterSpel&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="VoronoiCovarianceMeasureOnDigitalSurface_8h_source.html#l00058">58</a> of file <a class="el" href="VoronoiCovarianceMeasureOnDigitalSurface_8h_source.html">VoronoiCovarianceMeasureOnDigitalSurface.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;{ <a class="code" href="namespaceDGtal.html#aaad242ffef715835e8928579a506b2d5ac0a8bc5774ff6530ee71a7cacd6ca6f4">Pointels</a> = 0, <a class="code" href="namespaceDGtal.html#aaad242ffef715835e8928579a506b2d5a800e26ee60cfa63833cffca955ae401f">InnerSpel</a> = 1, <a class="code" href="namespaceDGtal.html#aaad242ffef715835e8928579a506b2d5a0630efc9b8129aa1ad3233bba9f08423">OuterSpel</a> = 2 };</div>
<div class="ttc" id="anamespaceDGtal_html_aaad242ffef715835e8928579a506b2d5a0630efc9b8129aa1ad3233bba9f08423"><div class="ttname"><a href="namespaceDGtal.html#aaad242ffef715835e8928579a506b2d5a0630efc9b8129aa1ad3233bba9f08423">DGtal::OuterSpel</a></div><div class="ttdeci">@ OuterSpel</div><div class="ttdef"><b>Definition:</b> <a href="VoronoiCovarianceMeasureOnDigitalSurface_8h_source.html#l00058">VoronoiCovarianceMeasureOnDigitalSurface.h:58</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_aaad242ffef715835e8928579a506b2d5a800e26ee60cfa63833cffca955ae401f"><div class="ttname"><a href="namespaceDGtal.html#aaad242ffef715835e8928579a506b2d5a800e26ee60cfa63833cffca955ae401f">DGtal::InnerSpel</a></div><div class="ttdeci">@ InnerSpel</div><div class="ttdef"><b>Definition:</b> <a href="VoronoiCovarianceMeasureOnDigitalSurface_8h_source.html#l00058">VoronoiCovarianceMeasureOnDigitalSurface.h:58</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_aaad242ffef715835e8928579a506b2d5ac0a8bc5774ff6530ee71a7cacd6ca6f4"><div class="ttname"><a href="namespaceDGtal.html#aaad242ffef715835e8928579a506b2d5ac0a8bc5774ff6530ee71a7cacd6ca6f4">DGtal::Pointels</a></div><div class="ttdeci">@ Pointels</div><div class="ttdef"><b>Definition:</b> <a href="VoronoiCovarianceMeasureOnDigitalSurface_8h_source.html#l00058">VoronoiCovarianceMeasureOnDigitalSurface.h:58</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac30d89880d1c9d74deadc8f199e4051b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30d89880d1c9d74deadc8f199e4051b">&#9670;&nbsp;</a></span>advanceIterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::advanceIterator </td>
          <td>(</td>
          <td class="paramtype">IC &amp;&#160;</td>
          <td class="paramname"><em>ic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structDGtal_1_1IteratorCirculatorTraits.html">IteratorCirculatorTraits</a>&lt; IC &gt;::Difference&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Moves <em>ic</em> at position @ it + <em>n</em> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ic</td><td>any (circular)iterator </td></tr>
    <tr><td class="paramname">n</td><td>any positive distance </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IC</td><td>any model o fiterator or circulator </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="testIteratorFunctions_8cpp_source.html#l00072">testAdvance()</a>.</p>

</div>
</div>
<a id="a8bfda2e911a663b2b6a0d53d34a67838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfda2e911a663b2b6a0d53d34a67838">&#9670;&nbsp;</a></span>assert_failed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::assert_failed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Assert_8h_source.html#l00065">65</a> of file <a class="el" href="Assert_8h_source.html">Assert.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  {</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;      <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a1e786a1f3b1047e92b73c82f67e3c295">error</a>()</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;          &lt;&lt; <span class="stringliteral">&quot; Assertion Error - assertion (&quot;</span> &lt;&lt; expr &lt;&lt; <span class="stringliteral">&quot;) failed in &quot;</span> &lt;&lt; <span class="keyword">function</span> &lt;&lt; <span class="stringliteral">&quot;: &quot;</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;          &lt;&lt; file &lt;&lt; <span class="charliteral">&#39;(&#39;</span> &lt;&lt; line &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;      std::abort();</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  }</div>
<div class="ttc" id="aclassDGtal_1_1Trace_html_a1e786a1f3b1047e92b73c82f67e3c295"><div class="ttname"><a href="classDGtal_1_1Trace.html#a1e786a1f3b1047e92b73c82f67e3c295">DGtal::Trace::error</a></div><div class="ttdeci">std::ostream &amp; error()</div></div>
<div class="ttc" id="anamespaceDGtal_html_a8fc7012708b0416880a5c8b12dfdf9dd"><div class="ttname"><a href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">DGtal::trace</a></div><div class="ttdeci">Trace trace</div><div class="ttdef"><b>Definition:</b> <a href="Common_8h_source.html#l00154">Common.h:154</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classDGtal_1_1Trace.html#a1e786a1f3b1047e92b73c82f67e3c295">DGtal::Trace::error()</a>, and <a class="el" href="Common_8h_source.html#l00154">trace</a>.</p>

</div>
</div>
<a id="ae46480d3544b6298c5c3999a3bec9405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46480d3544b6298c5c3999a3bec9405">&#9670;&nbsp;</a></span>assert_failed_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::assert_failed_message </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Assert_8h_source.html#l00081">81</a> of file <a class="el" href="Assert_8h_source.html">Assert.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  {</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;      <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a1e786a1f3b1047e92b73c82f67e3c295">error</a>()</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;          &lt;&lt; <span class="stringliteral">&quot; Assertion Error - assertion (&quot;</span> &lt;&lt; expr &lt;&lt; <span class="stringliteral">&quot;) failed in &quot;</span> &lt;&lt; <span class="keyword">function</span> &lt;&lt; <span class="stringliteral">&quot;: &quot;</span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;          &lt;&lt; file &lt;&lt; <span class="charliteral">&#39;(&#39;</span> &lt;&lt; line &lt;&lt; <span class="stringliteral">&quot;): &quot;</span> &lt;&lt; std::endl &lt;&lt; message &lt;&lt; std::endl;</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;      std::abort();</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classDGtal_1_1Trace.html#a1e786a1f3b1047e92b73c82f67e3c295">DGtal::Trace::error()</a>, and <a class="el" href="Common_8h_source.html#l00154">trace</a>.</p>

</div>
</div>
<a id="abdc15c973e5c46488ab60f46da9efb71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc15c973e5c46488ab60f46da9efb71">&#9670;&nbsp;</a></span>backStack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1BackInsertionSequenceToStackAdapter.html">BackInsertionSequenceToStackAdapter</a>&lt;TSequence&gt; DGtal::backStack </td>
          <td>(</td>
          <td class="paramtype">TSequence &amp;&#160;</td>
          <td class="paramname"><em>aSequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function returning an object of class '<a class="el" href="classDGtal_1_1BackInsertionSequenceToStackAdapter.html" title="Aim: This class implements a dynamic adapter to an instance of a model of back insertion sequence in ...">BackInsertionSequenceToStackAdapter</a>' </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aSequence</td><td>container to adapt. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSequence</td><td>a model of back insertion sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the adapter. </dd></dl>

</div>
</div>
<a id="abc6d219dcad7382fbe63f8b98941d0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6d219dcad7382fbe63f8b98941d0d8">&#9670;&nbsp;</a></span>constructFromArithmeticConversion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDGtal.html#a55bbc4405f35f8a03161e41068432454">ArithmeticConversionType</a>&lt;LHS, RHS&gt; DGtal::constructFromArithmeticConversion </td>
          <td>(</td>
          <td class="paramtype">LHS const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call constructor for the result type of an arithmetic operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHS</td><td>First operand type. </td></tr>
    <tr><td class="paramname">RHS</td><td>Second operand type. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of the parameters forwarded to the constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First operand (only used for auto-deducing its type). </td></tr>
    <tr><td class="paramname">rhs</td><td>Second operand (only used for auto-deducing its type). </td></tr>
    <tr><td class="paramname">args</td><td><a class="el" href="structDGtal_1_1Parameters.html">Parameters</a> forwarded to the constructor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ArithmeticConversionTraits_8h_source.html#l00182">182</a> of file <a class="el" href="ArithmeticConversionTraits_8h_source.html">ArithmeticConversionTraits.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    {</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;      boost::ignore_unused_variable_warning(lhs);</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;      boost::ignore_unused_variable_warning(rhs);</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160; </div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;      <span class="keywordflow">return</span> ArithmeticConversionType&lt;LHS, RHS&gt;( std::forward&lt;Args&gt;(args)... );</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa3caf900c3807cf27e2b8fca80036bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3caf900c3807cf27e2b8fca80036bcc">&#9670;&nbsp;</a></span>cosineSimilarity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double DGtal::cosineSimilarity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Positive angle between two vectors, deduced from their scalar product. </p>
<dl class="section return"><dt>Returns</dt><dd>the angle between <em>lhs</em> and <em>rhs</em> in [0,pi]. </dd></dl>

<p class="reference">Referenced by <a class="el" href="testPointVector_8cpp_source.html#l00152">TEST_CASE()</a>.</p>

</div>
</div>
<a id="a461bb682654c5626fb3dc09b91a6252e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461bb682654c5626fb3dc09b91a6252e">&#9670;&nbsp;</a></span>crossProduct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt;3, <a class="el" href="namespaceDGtal.html#a55bbc4405f35f8a03161e41068432454">DGtal::ArithmeticConversionType</a>&lt;LeftEuclideanRing, RightEuclideanRing&gt; &gt; DGtal::crossProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; 2, LeftEuclideanRing, LeftContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; 2, RightEuclideanRing, RightContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cross product of two 2D Points/Vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>the 3th component of the cross product of the two points/vectors embedded in 3D. </dd></dl>

</div>
</div>
<a id="a18ceabc071a958546b2e65cedb4ff342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ceabc071a958546b2e65cedb4ff342">&#9670;&nbsp;</a></span>crossProduct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DGtal::crossProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; 3, LeftEuclideanRing, LeftContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; 3, RightEuclideanRing, RightContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cross product of two 3D Points/Vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>a 3D point/vector with best component type accordingly to the C++ conversion rules in arithmetic operations context. </dd></dl>

<p class="reference">Referenced by <a class="el" href="sphereCotangentLaplaceOperator_8cpp_source.html#l00089">laplacian()</a>, and <a class="el" href="testPointVector_8cpp_source.html#l00053">TEST_CASE()</a>.</p>

</div>
</div>
<a id="afd55a2a73cd7b4552dbaf0b62980b323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd55a2a73cd7b4552dbaf0b62980b323">&#9670;&nbsp;</a></span>derivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, int n, typename Ring , typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;n, Ring, Alloc&gt; DGtal::derivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the partial derivative of <em>p</em> with respect to the N-th indeterminate. We assume that 0 &lt;= N &lt; n.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>an arbitrary polynomial.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the variable used for derivation.</td></tr>
    <tr><td class="paramname">n</td><td>the number of variables or indeterminates.</td></tr>
    <tr><td class="paramname">Ring</td><td>the type chosen for the polynomial, defines also the type of the coefficents (generally int, float or double).</td></tr>
    <tr><td class="paramname">Alloc</td><td>is an allocator for Ring, for example std::allocator&lt;Ring&gt;; this is also the default parameter. Usually this parameter does not needs to be changed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MPolynomial_8h_source.html#l01966">1966</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01967"></a><span class="lineno"> 1967</span>&#160;  {</div>
<div class="line"><a name="l01968"></a><span class="lineno"> 1968</span>&#160;    MPolynomial&lt;n, Ring, Alloc&gt; res( p.getAllocator() );</div>
<div class="line"><a name="l01969"></a><span class="lineno"> 1969</span>&#160;    MPolynomialDerivativeComputer&lt;N, n, Ring, Alloc&gt;::computeDerivative(p, res);</div>
<div class="line"><a name="l01970"></a><span class="lineno"> 1970</span>&#160;    <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l01971"></a><span class="lineno"> 1971</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="MPolynomial_8h_source.html#l01901">DGtal::MPolynomialDerivativeComputer&lt; N, n, Ring, Alloc &gt;::computeDerivative()</a>.</p>

</div>
</div>
<a id="a9aedf0fbd5b7c5814911d1299be81cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aedf0fbd5b7c5814911d1299be81cb9">&#9670;&nbsp;</a></span>derivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, int n, typename Ring &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;n, Ring, std::allocator&lt;Ring&gt; &gt; DGtal::derivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, std::allocator&lt; Ring &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the partial derivative of <em>p</em> with respect to the N-th indeterminate. We assume that 0 &lt;= N &lt; n.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>an arbitrary polynomial.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the variable used for derivation.</td></tr>
    <tr><td class="paramname">n</td><td>the number of variables or indeterminates.</td></tr>
    <tr><td class="paramname">Ring</td><td>the type chosen for the polynomial, defines also the type of the coefficents (generally int, float or double). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MPolynomial_8h_source.html#l01989">1989</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01991"></a><span class="lineno"> 1991</span>&#160;   {</div>
<div class="line"><a name="l01992"></a><span class="lineno"> 1992</span>&#160;     MPolynomial&lt;n, Ring, std::allocator&lt;Ring&gt; &gt; res( p.getAllocator() );</div>
<div class="line"><a name="l01993"></a><span class="lineno"> 1993</span>&#160;     MPolynomialDerivativeComputer&lt;N, n, Ring, std::allocator&lt;Ring&gt; &gt;</div>
<div class="line"><a name="l01994"></a><span class="lineno"> 1994</span>&#160;       ::computeDerivative( p, res );</div>
<div class="line"><a name="l01995"></a><span class="lineno"> 1995</span>&#160;     <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l01996"></a><span class="lineno"> 1996</span>&#160;   }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a144dca4ff96493af561a3006d44a8a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144dca4ff96493af561a3006d44a8a78">&#9670;&nbsp;</a></span>dotProduct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDGtal.html#a55bbc4405f35f8a03161e41068432454">DGtal::ArithmeticConversionType</a>&lt;LeftEuclideanRing, RightEuclideanRing&gt; DGtal::dotProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dot product between two points/vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>the dot product in the best Euclidean ring accordingly to the C++ conversion rules in arithmetic operations context. </dd></dl>

<p class="reference">Referenced by <a class="el" href="testPointVector_8cpp_source.html#l00152">TEST_CASE()</a>.</p>

</div>
</div>
<a id="afc4718ecc21bcecf1618414e982b951c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4718ecc21bcecf1618414e982b951c">&#9670;&nbsp;</a></span>euclidDiv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::euclidDiv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes q and r such that f = q g + r and degree(r) &lt; degree(g). </p>

<p class="definition">Definition at line <a class="el" href="MPolynomial_8h_source.html#l02003">2003</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02007"></a><span class="lineno"> 2007</span>&#160;   {</div>
<div class="line"><a name="l02008"></a><span class="lineno"> 2008</span>&#160;     <span class="keywordflow">if</span> (f.degree() &lt; g.degree())</div>
<div class="line"><a name="l02009"></a><span class="lineno"> 2009</span>&#160;       {</div>
<div class="line"><a name="l02010"></a><span class="lineno"> 2010</span>&#160;         <span class="comment">// Ignore the trivial case</span></div>
<div class="line"><a name="l02011"></a><span class="lineno"> 2011</span>&#160;         q = MPolynomial&lt;1, Ring, Alloc&gt;(f.getAllocator());</div>
<div class="line"><a name="l02012"></a><span class="lineno"> 2012</span>&#160;         r = f;</div>
<div class="line"><a name="l02013"></a><span class="lineno"> 2013</span>&#160;         <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l02014"></a><span class="lineno"> 2014</span>&#160;       }</div>
<div class="line"><a name="l02015"></a><span class="lineno"> 2015</span>&#160;    q = MPolynomial&lt;1, Ring, Alloc&gt;( <span class="keyword">true</span>, f.degree() - g.degree() + 1, </div>
<div class="line"><a name="l02016"></a><span class="lineno"> 2016</span>&#160;                                     f.getAllocator() );</div>
<div class="line"><a name="l02017"></a><span class="lineno"> 2017</span>&#160;    r = f;</div>
<div class="line"><a name="l02018"></a><span class="lineno"> 2018</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = q.degree(); i &gt;= 0; --i)</div>
<div class="line"><a name="l02019"></a><span class="lineno"> 2019</span>&#160;      {</div>
<div class="line"><a name="l02020"></a><span class="lineno"> 2020</span>&#160;        q[i] = r[i + g.degree()] / g.leading();</div>
<div class="line"><a name="l02021"></a><span class="lineno"> 2021</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = g.degree(); j &gt;= 0; --j)</div>
<div class="line"><a name="l02022"></a><span class="lineno"> 2022</span>&#160;          r[i + j] -= q[i] * g[j];</div>
<div class="line"><a name="l02023"></a><span class="lineno"> 2023</span>&#160;      }</div>
<div class="line"><a name="l02024"></a><span class="lineno"> 2024</span>&#160;    r.normalize();</div>
<div class="line"><a name="l02025"></a><span class="lineno"> 2025</span>&#160;    <span class="comment">// Note that the degree of q is already correct.</span></div>
<div class="line"><a name="l02026"></a><span class="lineno"> 2026</span>&#160;   }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a57e756b9529892b5019066b6d4a4310c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e756b9529892b5019066b6d4a4310c">&#9670;&nbsp;</a></span>euclidDiv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::euclidDiv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes q and r such that f = q g + r and degree(r) &lt; degree(g). </p>

<p class="definition">Definition at line <a class="el" href="MPolynomial_8h_source.html#l02033">2033</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02037"></a><span class="lineno"> 2037</span>&#160;   {</div>
<div class="line"><a name="l02038"></a><span class="lineno"> 2038</span>&#160;     euclidDiv&lt;Ring, std::allocator&lt;Ring&gt; &gt;(f, g, q, r);</div>
<div class="line"><a name="l02039"></a><span class="lineno"> 2039</span>&#160;   }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2bbdffe7efc4f8af031964cecfe477a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bbdffe7efc4f8af031964cecfe477a7">&#9670;&nbsp;</a></span>euclidDiv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRing , typename TAlloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::euclidDiv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forward declaration, to be able to declare this as a friend. </p>

<p class="reference">Referenced by <a class="el" href="MPolynomial_8h_source.html#l02047">gcd()</a>.</p>

</div>
</div>
<a id="a5c8219e7b58c9b98239c5e0ac2feeb4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8219e7b58c9b98239c5e0ac2feeb4f">&#9670;&nbsp;</a></span>fatal_error_failed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::fatal_error_failed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Assert_8h_source.html#l00093">93</a> of file <a class="el" href="Assert_8h_source.html">Assert.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;  {</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;      <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a1e786a1f3b1047e92b73c82f67e3c295">error</a>()</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;          &lt;&lt; <span class="stringliteral">&quot; Fatal Error - assertion (&quot;</span> &lt;&lt; expr &lt;&lt; <span class="stringliteral">&quot;) failed in &quot;</span> &lt;&lt; <span class="keyword">function</span> &lt;&lt; <span class="stringliteral">&quot;: &quot;</span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;          &lt;&lt; file &lt;&lt; <span class="charliteral">&#39;(&#39;</span> &lt;&lt; line &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;      std::abort();</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classDGtal_1_1Trace.html#a1e786a1f3b1047e92b73c82f67e3c295">DGtal::Trace::error()</a>, and <a class="el" href="Common_8h_source.html#l00154">trace</a>.</p>

</div>
</div>
<a id="a250f6ee7761ac4632236f5482238ea02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250f6ee7761ac4632236f5482238ea02">&#9670;&nbsp;</a></span>fatal_error_failed_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::fatal_error_failed_message </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Assert_8h_source.html#l00104">104</a> of file <a class="el" href="Assert_8h_source.html">Assert.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;  {</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;      <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a1e786a1f3b1047e92b73c82f67e3c295">error</a>()</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;          &lt;&lt; <span class="stringliteral">&quot; Fatal Error - assertion (&quot;</span> &lt;&lt; expr &lt;&lt; <span class="stringliteral">&quot;) failed in &quot;</span> &lt;&lt; <span class="keyword">function</span> &lt;&lt; <span class="stringliteral">&quot;: &quot;</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;          &lt;&lt; file &lt;&lt; <span class="charliteral">&#39;(&#39;</span> &lt;&lt; line &lt;&lt; <span class="stringliteral">&quot;): &quot;</span> &lt;&lt; std::endl &lt;&lt; message &lt;&lt; std::endl;</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;      std::abort();</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classDGtal_1_1Trace.html#a1e786a1f3b1047e92b73c82f67e3c295">DGtal::Trace::error()</a>, and <a class="el" href="Common_8h_source.html#l00154">trace</a>.</p>

</div>
</div>
<a id="a3f73d6217f05eef8225781a523efc077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f73d6217f05eef8225781a523efc077">&#9670;&nbsp;</a></span>findAndGetValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::findAndGetValue </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>aSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="examplePlaneProbingTetrahedronEstimator_8cpp.html#aa735f3a0c2faee42eae6a625d2ae8760">I::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">I::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>aValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the value contained in <em>aImg</em> at <em>aPoint</em> if <em>aPoint</em> belongs to <em>aSet</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aImg</td><td>an image </td></tr>
    <tr><td class="paramname">aSet</td><td>a digital set </td></tr>
    <tr><td class="paramname">aPoint</td><td>a point </td></tr>
    <tr><td class="paramname">aValue</td><td>(returned) value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if a new point is found and the value read but 'false' otherwise</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>any model of CConstImage </td></tr>
    <tr><td class="paramname">S</td><td>any model of CDigitalSet</td></tr>
  </table>
  </dd>
</dl>
<p>The general behavior is like: </p><div class="fragment"></div><!-- fragment --><p>However, this code is specialized if I is an <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> and S is a <a class="el" href="classDGtal_1_1DigitalSetFromMap.html">DigitalSetFromMap&lt;I&gt;</a> as follows: </p><div class="fragment"></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> <a class="el" href="classDGtal_1_1DigitalSetFromMap.html" title="Aim: An adapter for viewing an associative image container like ImageContainerBySTLMap as a simple di...">DigitalSetFromMap</a> </dd>
<dd>
<a class="el" href="namespaceDGtal.html#a5f01a70f2cf84e9c08d1308e77911a08">insertAndSetValue</a> </dd></dl>

</div>
</div>
<a id="a18c5282eb177f64a2957c29bf51b0e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c5282eb177f64a2957c29bf51b0e1c">&#9670;&nbsp;</a></span>firstMaximalSegment() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::firstMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the first maximal segment passing through i </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin</td><td>any begin ConstIterator bounding a range </td></tr>
    <tr><td class="paramname">end</td><td>any end ConstIterator bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00508">508</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;{</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;  firstMaximalSegment&lt;SC&gt;(s, i, begin, end, </div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;<span class="keyword">typename</span> <a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::SegmentComputerTraits&lt;SC&gt;::Category</a>() );</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;}</div>
<div class="ttc" id="astructDGtal_1_1ForwardSegmentComputer_html"><div class="ttname"><a href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a></div><div class="ttdef"><b>Definition:</b> <a href="SegmentComputerUtils_8h_source.html#l00052">SegmentComputerUtils.h:52</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae37d5f56ebcd83255b9c93038deff781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37d5f56ebcd83255b9c93038deff781">&#9670;&nbsp;</a></span>firstMaximalSegment() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::firstMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the first maximal segment passing through i </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin</td><td>any begin ConstIterator bounding a range </td></tr>
    <tr><td class="paramname">end</td><td>any end ConstIterator bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of CBidirectionalSegmentComputer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00449">449</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;{</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;  s.init(i);</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160; </div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;  <a class="code" href="namespaceDGtal.html#a462eaaf587bc04ebd2e6141bed3fc21e">oppositeEndMaximalExtension</a>(s, begin);</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;  <a class="code" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a>(s, end);</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;}</div>
<div class="ttc" id="anamespaceDGtal_html_a462eaaf587bc04ebd2e6141bed3fc21e"><div class="ttname"><a href="namespaceDGtal.html#a462eaaf587bc04ebd2e6141bed3fc21e">DGtal::oppositeEndMaximalExtension</a></div><div class="ttdeci">void oppositeEndMaximalExtension(SC &amp;s, const typename SC::ConstIterator &amp;begin, IteratorType)</div><div class="ttdef"><b>Definition:</b> <a href="SegmentComputerUtils_8h_source.html#l00198">SegmentComputerUtils.h:198</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a4718031e09102bb8f73a874c47e10aaf"><div class="ttname"><a href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">DGtal::maximalExtension</a></div><div class="ttdeci">void maximalExtension(SC &amp;s, const typename SC::ConstIterator &amp;end, IteratorType)</div><div class="ttdef"><b>Definition:</b> <a href="SegmentComputerUtils_8h_source.html#l00164">SegmentComputerUtils.h:164</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00164">maximalExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00198">oppositeEndMaximalExtension()</a>.</p>

</div>
</div>
<a id="aae8ba2a7a4a42e59741df4afed37f449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8ba2a7a4a42e59741df4afed37f449">&#9670;&nbsp;</a></span>firstMaximalSegment() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::firstMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the first maximal segment passing through i </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin</td><td>any begin ConstIterator bounding a range </td></tr>
    <tr><td class="paramname">end</td><td>any end ConstIterator bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of CDynamicBidirectionalSegmentComputer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00490">490</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;{</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;  <a class="code" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">firstMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>() );</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;}</div>
<div class="ttc" id="anamespaceDGtal_html_ae6d3175b6c7d86845a0c259f566bd7ea"><div class="ttname"><a href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">DGtal::firstMaximalSegment</a></div><div class="ttdeci">void firstMaximalSegment(SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, DGtal::ForwardSegmentComputer)</div><div class="ttdef"><b>Definition:</b> <a href="SegmentComputerUtils_8h_source.html#l00412">SegmentComputerUtils.h:412</a></div></div>
<div class="ttc" id="astructDGtal_1_1BidirectionalSegmentComputer_html"><div class="ttname"><a href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a></div><div class="ttdef"><b>Definition:</b> <a href="SegmentComputerUtils_8h_source.html#l00053">SegmentComputerUtils.h:53</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00412">firstMaximalSegment()</a>.</p>

</div>
</div>
<a id="a8b81102d807d1ec5629d25c6e13ddae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b81102d807d1ec5629d25c6e13ddae7">&#9670;&nbsp;</a></span>firstMaximalSegment() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::firstMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the first maximal segment passing through i </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin</td><td>any begin ConstIterator bounding a range </td></tr>
    <tr><td class="paramname">end</td><td>any end ConstIterator bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of CDynamicSegmentComputer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">ForwardSegmentComputer</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00471">471</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;{</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;  <a class="code" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">firstMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>() );</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00412">firstMaximalSegment()</a>.</p>

</div>
</div>
<a id="ae6d3175b6c7d86845a0c259f566bd7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d3175b6c7d86845a0c259f566bd7ea">&#9670;&nbsp;</a></span>firstMaximalSegment() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::firstMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the first maximal segment passing through i </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin</td><td>any begin ConstIterator bounding a range </td></tr>
    <tr><td class="paramname">end</td><td>any end ConstIterator bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of CForwardSegmentComputer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00412">412</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;{</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160; </div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a>; </div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::Reverse ReverseSegmentComputer; </div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ReverseSegmentComputer::ConstIterator</a> ConstReverseIterator; </div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160; </div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;  <span class="keywordflow">if</span> ( isNotEmpty&lt;ConstIterator&gt;(i,end) ) {</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160; </div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;    <span class="comment">//backward extension</span></div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a> it( i ); ++it; </div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    ConstReverseIterator rit( it );</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    ConstReverseIterator rend( begin );</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    ReverseSegmentComputer r( s.getReverse() ); </div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;    <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>(r, rit, rend);</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160; </div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;    <span class="comment">//forward extension</span></div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a> it2( r.end().base() );</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>(s, it2, end);</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160; </div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;  }</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160; </div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;}</div>
<div class="ttc" id="anamespaceDGtal_html_a2034305fadb5376a987519daba4c982a"><div class="ttname"><a href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">DGtal::longestSegment</a></div><div class="ttdeci">void longestSegment(SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;end, IteratorType)</div><div class="ttdef"><b>Definition:</b> <a href="SegmentComputerUtils_8h_source.html#l00359">SegmentComputerUtils.h:359</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00359">longestSegment()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00471">firstMaximalSegment()</a>, <a class="el" href="exampleAlphaThickSegmentTgtCover_8cpp_source.html#l00067">main()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00529">mostCenteredMaximalSegment()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00797">nextMaximalSegment()</a>.</p>

</div>
</div>
<a id="a93025ccea6a783aac046740d9649edaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93025ccea6a783aac046740d9649edaa">&#9670;&nbsp;</a></span>frontStack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1FrontInsertionSequenceToStackAdapter.html">FrontInsertionSequenceToStackAdapter</a>&lt;TSequence&gt; DGtal::frontStack </td>
          <td>(</td>
          <td class="paramtype">TSequence &amp;&#160;</td>
          <td class="paramname"><em>aSequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function returning an object of class '<a class="el" href="classDGtal_1_1FrontInsertionSequenceToStackAdapter.html" title="Aim: This class implements a dynamic adapter to an instance of a model of front insertion sequence in...">FrontInsertionSequenceToStackAdapter</a>' </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aSequence</td><td>container to adapt. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSequence</td><td>a model of back insertion sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the adapter. </dd></dl>

</div>
</div>
<a id="a38fc7e3a7ad4420d8b0b5950ae21c32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38fc7e3a7ad4420d8b0b5950ae21c32e">&#9670;&nbsp;</a></span>gcd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;1, Ring, Alloc&gt; DGtal::gcd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the monic greatest common divisor of f and g using the Euclidean Algorithm. </p>

<p class="definition">Definition at line <a class="el" href="MPolynomial_8h_source.html#l02047">2047</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02049"></a><span class="lineno"> 2049</span>&#160;   {</div>
<div class="line"><a name="l02050"></a><span class="lineno"> 2050</span>&#160;     <span class="keywordflow">if</span> (f.isZero())</div>
<div class="line"><a name="l02051"></a><span class="lineno"> 2051</span>&#160;       {</div>
<div class="line"><a name="l02052"></a><span class="lineno"> 2052</span>&#160;         <span class="keywordflow">if</span> (g.isZero()) <span class="keywordflow">return</span> f; <span class="comment">// both are zero</span></div>
<div class="line"><a name="l02053"></a><span class="lineno"> 2053</span>&#160;         <span class="keywordflow">else</span>            <span class="keywordflow">return</span> g / g.leading(); <span class="comment">// make g monic</span></div>
<div class="line"><a name="l02054"></a><span class="lineno"> 2054</span>&#160;       }</div>
<div class="line"><a name="l02055"></a><span class="lineno"> 2055</span>&#160;     MPolynomial&lt;1, Ring, Alloc&gt; </div>
<div class="line"><a name="l02056"></a><span class="lineno"> 2056</span>&#160;       d1(f / f.leading()), </div>
<div class="line"><a name="l02057"></a><span class="lineno"> 2057</span>&#160;       d2(g / g.leading()), </div>
<div class="line"><a name="l02058"></a><span class="lineno"> 2058</span>&#160;       q(f.getAllocator()), </div>
<div class="line"><a name="l02059"></a><span class="lineno"> 2059</span>&#160;       r(f.getAllocator());</div>
<div class="line"><a name="l02060"></a><span class="lineno"> 2060</span>&#160;     <span class="keywordflow">while</span> (!d2.isZero())</div>
<div class="line"><a name="l02061"></a><span class="lineno"> 2061</span>&#160;       {</div>
<div class="line"><a name="l02062"></a><span class="lineno"> 2062</span>&#160;         <a class="code" href="namespaceDGtal.html#a2bbdffe7efc4f8af031964cecfe477a7">euclidDiv</a>(d1, d2, q, r);</div>
<div class="line"><a name="l02063"></a><span class="lineno"> 2063</span>&#160;         d1.swap(d2);</div>
<div class="line"><a name="l02064"></a><span class="lineno"> 2064</span>&#160;         d2 = r;</div>
<div class="line"><a name="l02065"></a><span class="lineno"> 2065</span>&#160;         d2 /= r.leading(); <span class="comment">// make r monic</span></div>
<div class="line"><a name="l02066"></a><span class="lineno"> 2066</span>&#160;       }</div>
<div class="line"><a name="l02067"></a><span class="lineno"> 2067</span>&#160;     <span class="keywordflow">return</span> d1;</div>
<div class="line"><a name="l02068"></a><span class="lineno"> 2068</span>&#160;   }</div>
<div class="ttc" id="anamespaceDGtal_html_a2bbdffe7efc4f8af031964cecfe477a7"><div class="ttname"><a href="namespaceDGtal.html#a2bbdffe7efc4f8af031964cecfe477a7">DGtal::euclidDiv</a></div><div class="ttdeci">void euclidDiv(const MPolynomial&lt; 1, TRing, TAlloc &gt; &amp;f, const MPolynomial&lt; 1, TRing, TAlloc &gt; &amp;g, MPolynomial&lt; 1, TRing, TAlloc &gt; &amp;q, MPolynomial&lt; 1, TRing, TAlloc &gt; &amp;r)</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="namespaceDGtal.html#a2bbdffe7efc4f8af031964cecfe477a7">euclidDiv()</a>.</p>

<p class="reference">Referenced by <a class="el" href="testMPolynomial_8cpp_source.html#l00138">testMPolynomial()</a>.</p>

</div>
</div>
<a id="ab28649140d0b09a9b25515660a3e6f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28649140d0b09a9b25515660a3e6f12">&#9670;&nbsp;</a></span>gcd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;1, Ring, std::allocator&lt;Ring&gt; &gt; DGtal::gcd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the monic greatest common divisor of f and g using the Euclidean Algorithm. </p>

<p class="definition">Definition at line <a class="el" href="MPolynomial_8h_source.html#l02076">2076</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02078"></a><span class="lineno"> 2078</span>&#160;  {</div>
<div class="line"><a name="l02079"></a><span class="lineno"> 2079</span>&#160;    <span class="keywordflow">return</span> gcd&lt;Ring, std::allocator&lt;Ring&gt; &gt;(f, g);</div>
<div class="line"><a name="l02080"></a><span class="lineno"> 2080</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a318f9e3e73cd0988af98b3a66a543334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318f9e3e73cd0988af98b3a66a543334">&#9670;&nbsp;</a></span>getMiddleIterator() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IC DGtal::getMiddleIterator </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the middle iterator of a given range, i.e. itb + (ite-itb)/2) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator of a range </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator of a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the middle iterator of the range [itb,ite) </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IC</td><td>iterator or circulator </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00151">151</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;                                                   {</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;  <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorCirculatorTraits&lt;IC&gt;::Category Category; </div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespaceDGtal.html#a8c4fb1b2976e5fc35dc1b4073149408e">getMiddleIterator</a>(itb, ite, Category() ); </div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;} </div>
<div class="ttc" id="anamespaceDGtal_html_a8c4fb1b2976e5fc35dc1b4073149408e"><div class="ttname"><a href="namespaceDGtal.html#a8c4fb1b2976e5fc35dc1b4073149408e">DGtal::getMiddleIterator</a></div><div class="ttdeci">IC getMiddleIterator(const IC &amp;itb, const IC &amp;ite, RandomAccessCategory)</div><div class="ttdef"><b>Definition:</b> <a href="SegmentComputerUtils_8h_source.html#l00087">SegmentComputerUtils.h:87</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00087">getMiddleIterator()</a>.</p>

</div>
</div>
<a id="a9cf4e9405b276ba5b8b931f72d180d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf4e9405b276ba5b8b931f72d180d9d">&#9670;&nbsp;</a></span>getMiddleIterator() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IC DGtal::getMiddleIterator </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1BidirectionalCategory.html">BidirectionalCategory</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for bidirectional category NB: in O(ite-itb) </p>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00100">100</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;{</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  IC b( itb ); </div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;  IC f( ite ); </div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  <span class="keywordtype">bool</span> flag = <span class="keyword">true</span>; </div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;  <span class="keywordflow">while</span> (b != f) {</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    <span class="keywordflow">if</span> (flag) {</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;      --f;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;      flag = <span class="keyword">false</span>; </div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;      ++b; </div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;      flag = <span class="keyword">true</span>; </div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    } </div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  }</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  <span class="keywordflow">return</span> b;   </div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8f53c482fe83e31093accf95ec7190d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f53c482fe83e31093accf95ec7190d9">&#9670;&nbsp;</a></span>getMiddleIterator() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IC DGtal::getMiddleIterator </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ForwardCategory.html">ForwardCategory</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for forward category NB: in O(ite-itb) </p>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00122">122</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;{</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;  IC i( itb ); </div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160; </div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; </div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;  <span class="keywordflow">while</span> (i != ite) {</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    ++i; </div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    ++c;</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  } </div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = c/2;</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160; </div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;  c = 0; </div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;  i = itb; </div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;  <span class="keywordflow">while</span> (c != k) {</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    ++i; </div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    ++c;</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;  } </div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160; </div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  <span class="keywordflow">return</span> i;   </div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8c4fb1b2976e5fc35dc1b4073149408e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c4fb1b2976e5fc35dc1b4073149408e">&#9670;&nbsp;</a></span>getMiddleIterator() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IC DGtal::getMiddleIterator </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1RandomAccessCategory.html">RandomAccessCategory</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for random access category </p>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00087">87</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;{</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;<span class="comment">//how to compute this with circulators ?</span></div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="comment">//return itb + ((ite-itb)/2);  </span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="comment">//does not work  </span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespaceDGtal.html#a8c4fb1b2976e5fc35dc1b4073149408e">getMiddleIterator</a>(itb, ite, BidirectionalCategory() ); </div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00151">getMiddleIterator()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00529">mostCenteredMaximalSegment()</a>.</p>

</div>
</div>
<a id="a7adead813e8d0e92752ff8e086bbbad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7adead813e8d0e92752ff8e086bbbad1">&#9670;&nbsp;</a></span>hash_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t DGtal::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1KhalimskyCell.html">KhalimskyCell</a>&lt; <a class="el" href="viewDualSurface_8cpp.html#a1a254aa17418553bc21790001a69262a">dim</a>, TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hash function for Khalimsky unsigned cells. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>input signed cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hash value. </dd></dl>

</div>
</div>
<a id="a46234d3693677caa52b0ffb6db059d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46234d3693677caa52b0ffb6db059d5d">&#9670;&nbsp;</a></span>imageFromFunctor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::imageFromFunctor </td>
          <td>(</td>
          <td class="paramtype">I &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>aFun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In a window corresponding to the domain of <em>aImg</em>, copy the values of <em>aFun</em> into <em>aImg</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aImg</td><td>(returned) image </td></tr>
    <tr><td class="paramname">aFun</td><td>a unary functor</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>any model of CImage </td></tr>
    <tr><td class="paramname">F</td><td>any model of CPointFunctor </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="testImagesSetsUtilities_8cpp_source.html#l00079">testImageFromSet()</a>.</p>

</div>
</div>
<a id="a9e8c71069e10fc24d2a0e0ae927635ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8c71069e10fc24d2a0e0ae927635ac">&#9670;&nbsp;</a></span>imageFromImage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename I2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::imageFromImage </td>
          <td>(</td>
          <td class="paramtype">I1 &amp;&#160;</td>
          <td class="paramname"><em>aImg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I2 &amp;&#160;</td>
          <td class="paramname"><em>aImg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the values of <em>aImg2</em> into <em>aImg1</em> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aImg1</td><td>the image to fill </td></tr>
    <tr><td class="paramname">aImg2</td><td>the image to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I1</td><td>any model of CImage </td></tr>
    <tr><td class="paramname">I2</td><td>any model of CConstImage </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="testImagesSetsUtilities_8cpp_source.html#l00079">testImageFromSet()</a>.</p>

</div>
</div>
<a id="ac1511d84bd2b82df82bea3aefc3af2dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1511d84bd2b82df82bea3aefc3af2dd">&#9670;&nbsp;</a></span>imageFromRangeAndValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It , typename Im &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::imageFromRangeAndValue </td>
          <td>(</td>
          <td class="paramtype">const It &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const It &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Im &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Im::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>aValue</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the values of <em>aImg</em> at <em>aValue</em> for each points of the range [ <em>itb</em> , <em>ite</em> )</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator on points </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator on points </td></tr>
    <tr><td class="paramname">aImg</td><td>(returned) image </td></tr>
    <tr><td class="paramname">aValue</td><td>any value (default: 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>any model of forward iterator </td></tr>
    <tr><td class="paramname">Im</td><td>any model of CImage </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="exampleIntegralInvariantCurvature2D_8cpp_source.html#l00058">main()</a>, and <a class="el" href="testImagesSetsUtilities_8cpp_source.html#l00079">testImageFromSet()</a>.</p>

</div>
</div>
<a id="aff03c6c44f0ec8ad182440aad1b4e86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff03c6c44f0ec8ad182440aad1b4e86a">&#9670;&nbsp;</a></span>imageFromRangeAndValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::imageFromRangeAndValue </td>
          <td>(</td>
          <td class="paramtype">const R &amp;&#160;</td>
          <td class="paramname"><em>aRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">I::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>aValue</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the values of <em>aImg</em> at <em>aValue</em> for each points of the range <em>aRange</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aRange</td><td>any range </td></tr>
    <tr><td class="paramname">aImg</td><td>(returned) image </td></tr>
    <tr><td class="paramname">aValue</td><td>any value (default: 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>any model of CConstSinglePassRange </td></tr>
    <tr><td class="paramname">I</td><td>any model of CImage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab19f06bbc70ca7f69e088fd15e16298d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19f06bbc70ca7f69e088fd15e16298d">&#9670;&nbsp;</a></span>inf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DGtal::inf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the infimum (or greatest lower bound). </p>
<p>It means the point whose coordinates are exactly the minimum of the two points coordinate by coordinate.</p>
<dl class="section return"><dt>Returns</dt><dd>a new point (with best Euclidean ring type accordingly to the C++ conversion rules) being the inf between <em>lhs</em> and <em>rhs</em>; </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceDGtal.html#afddb6191e2ccc45985a5ecff1989b87e" title="Return true if the first point is below the second point.">isLower</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="testPointVector_8cpp_source.html#l00152">TEST_CASE()</a>.</p>

</div>
</div>
<a id="ac920bc98f866a2e17ee53faddc67ff80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac920bc98f866a2e17ee53faddc67ff80">&#9670;&nbsp;</a></span>insertAndAlwaysSetValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::insertAndAlwaysSetValue </td>
          <td>(</td>
          <td class="paramtype">I &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>aSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="examplePlaneProbingTetrahedronEstimator_8cpp.html#aa735f3a0c2faee42eae6a625d2ae8760">I::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">I::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>aValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert <em>aPoint</em> in <em>aSet</em> and set <em>aValue</em> at <em>aPoint</em> in <em>aImg</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aImg</td><td>an image </td></tr>
    <tr><td class="paramname">aSet</td><td>a digital set </td></tr>
    <tr><td class="paramname">aPoint</td><td>a point </td></tr>
    <tr><td class="paramname">aValue</td><td>a value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if a new point was inserted in <em>aSet</em> but 'false' if the same point already exist in <em>aSet</em> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>any model of CImage </td></tr>
    <tr><td class="paramname">S</td><td>any model of CDigitalSet</td></tr>
  </table>
  </dd>
</dl>
<p>The general behavior is like: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> found = <span class="keyword">false</span>; </div>
<div class="line"><span class="keywordflow">if</span> ( aSet.find( <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a9ae40316aa447d5a39eb6f76dba59444">aPoint</a> ) != aSet.end() )</div>
<div class="line">  found = <span class="keyword">true</span>;       </div>
<div class="line"><span class="comment">//always set value</span></div>
<div class="line">aSet.insert( <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a9ae40316aa447d5a39eb6f76dba59444">aPoint</a> );</div>
<div class="line">aImg.setValue( <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a9ae40316aa447d5a39eb6f76dba59444">aPoint</a>, aValue ); </div>
<div class="line"><span class="keywordflow">return</span> !found; </div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_a9ae40316aa447d5a39eb6f76dba59444"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a9ae40316aa447d5a39eb6f76dba59444">aPoint</a></div><div class="ttdeci">const Point aPoint(3, 4)</div></div>
</div><!-- fragment --><p>However, this code is specialized if I is an <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> and S is a <a class="el" href="classDGtal_1_1DigitalSetFromMap.html">DigitalSetFromMap&lt;I&gt;</a> as follows: </p><div class="fragment"><div class="line">std::pair&lt;P, V&gt; </div>
<div class="line">pair( <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a9ae40316aa447d5a39eb6f76dba59444">aPoint</a>, aValue );  </div>
<div class="line">std::pair&lt;Iterator, bool&gt; res </div>
<div class="line">= aImg.insert( pair );</div>
<div class="line"><span class="keywordtype">bool</span> flag = res.second; </div>
<div class="line"><span class="keywordflow">if</span> (flag == <span class="keyword">false</span>) <span class="comment">//set value even in this case</span></div>
<div class="line">res.first-&gt;second = aValue;</div>
<div class="line"><span class="keywordflow">return</span> flag; </div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> <a class="el" href="classDGtal_1_1DigitalSetFromMap.html" title="Aim: An adapter for viewing an associative image container like ImageContainerBySTLMap as a simple di...">DigitalSetFromMap</a> </dd>
<dd>
<a class="el" href="namespaceDGtal.html#a5f01a70f2cf84e9c08d1308e77911a08">insertAndSetValue</a> </dd></dl>

</div>
</div>
<a id="a5f01a70f2cf84e9c08d1308e77911a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f01a70f2cf84e9c08d1308e77911a08">&#9670;&nbsp;</a></span>insertAndSetValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::insertAndSetValue </td>
          <td>(</td>
          <td class="paramtype">I &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>aSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="examplePlaneProbingTetrahedronEstimator_8cpp.html#aa735f3a0c2faee42eae6a625d2ae8760">I::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">I::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>aValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert <em>aPoint</em> in <em>aSet</em> and if (and only if) <em>aPoint</em> is a newly inserted point. Then set <em>aValue</em> at <em>aPoint</em> in <em>aImg</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aImg</td><td>an image </td></tr>
    <tr><td class="paramname">aSet</td><td>a digital set </td></tr>
    <tr><td class="paramname">aPoint</td><td>a point </td></tr>
    <tr><td class="paramname">aValue</td><td>a value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if a new point was inserted in <em>aSet</em> but 'false' if the same point already exist in <em>aSet</em> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>any model of CImage </td></tr>
    <tr><td class="paramname">S</td><td>any model of CDigitalSet</td></tr>
  </table>
  </dd>
</dl>
<p>The general behavior is like: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> found = <span class="keyword">true</span>; </div>
<div class="line"><span class="keywordflow">if</span> ( aSet.find( <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a9ae40316aa447d5a39eb6f76dba59444">aPoint</a> ) == aSet.end() )</div>
<div class="line">  { <span class="comment">//if not found</span></div>
<div class="line">    found = <span class="keyword">false</span>; </div>
<div class="line">    aSet.insert( <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a9ae40316aa447d5a39eb6f76dba59444">aPoint</a> );</div>
<div class="line">    aImg.setValue( <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a9ae40316aa447d5a39eb6f76dba59444">aPoint</a>, aValue ); </div>
<div class="line">  }      </div>
<div class="line"><span class="keywordflow">return</span> !found; </div>
</div><!-- fragment --><p>However, this code is specialized if I is an <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> and S is a <a class="el" href="classDGtal_1_1DigitalSetFromMap.html">DigitalSetFromMap&lt;I&gt;</a> as follows: </p><div class="fragment"><div class="line">std::pair&lt;P, V&gt; </div>
<div class="line">pair( <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a9ae40316aa447d5a39eb6f76dba59444">aPoint</a>, aValue );  </div>
<div class="line">std::pair&lt;Iterator, bool&gt; res </div>
<div class="line">= aImg.insert( pair ); </div>
<div class="line"><span class="keywordflow">return</span> res.second;  </div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> <a class="el" href="classDGtal_1_1DigitalSetFromMap.html" title="Aim: An adapter for viewing an associative image container like ImageContainerBySTLMap as a simple di...">DigitalSetFromMap</a> </dd>
<dd>
<a class="el" href="namespaceDGtal.html#ac920bc98f866a2e17ee53faddc67ff80">insertAndAlwaysSetValue</a> </dd></dl>

</div>
</div>
<a id="a6b49e997d09ccb163eb82529e8970996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b49e997d09ccb163eb82529e8970996">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::isEmpty </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the range [ <em>itb</em> , <em>ite</em> ) is empty </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator of the range </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IC</td><td>model of iterator or circulator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afddb6191e2ccc45985a5ecff1989b87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afddb6191e2ccc45985a5ecff1989b87e">&#9670;&nbsp;</a></span>isLower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::isLower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the first point is below the second point. </p>
<dl class="section return"><dt>Returns</dt><dd>true if <em>lhs</em> is below <em>rhs</em> (ie. lhs == inf(lhs,rhs)) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>faster than computing the infimum and compare it afterwards. </dd></dl>

<p class="reference">Referenced by <a class="el" href="testPointVector_8cpp_source.html#l00152">TEST_CASE()</a>.</p>

</div>
</div>
<a id="a6f1b22211474c60437654c3a0decb8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1b22211474c60437654c3a0decb8ef">&#9670;&nbsp;</a></span>isNotEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::isNotEmpty </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the range [ <em>itb</em> , <em>ite</em> ) is not empty </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator of the range </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IC</td><td>model of iterator or circulator </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00587">mostCenteredMaximalSegment()</a>, and <a class="el" href="testMostCenteredMSEstimator_8cpp_source.html#l00071">test()</a>.</p>

</div>
</div>
<a id="a7f9e179d700c18214b8be7752c7c2d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f9e179d700c18214b8be7752c7c2d2b">&#9670;&nbsp;</a></span>isUpper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::isUpper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the first point is upper the second point. </p>
<dl class="section return"><dt>Returns</dt><dd>true if <em>lhs</em> is upper <em>rhs</em> (ie. lhs == sup(lhs,rhs)) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>faster than computing the supremum and compare it afterwards. </dd></dl>

<p class="reference">Referenced by <a class="el" href="testPointVector_8cpp_source.html#l00152">TEST_CASE()</a>.</p>

</div>
</div>
<a id="afa3e824f983193de48aaf18590edaa52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3e824f983193de48aaf18590edaa52">&#9670;&nbsp;</a></span>lastMaximalSegment() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::lastMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the last maximal segment passing through i </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin</td><td>any begin ConstIterator bounding a range </td></tr>
    <tr><td class="paramname">end</td><td>any end ConstIterator bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00776">776</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;{</div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;   lastMaximalSegment&lt;SC&gt;(s, i, begin, end, </div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;<span class="keyword">typename</span> <a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::SegmentComputerTraits&lt;SC&gt;::Category</a>() );</div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8c5dc0554703f63c1ec705f764f2ba3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5dc0554703f63c1ec705f764f2ba3a">&#9670;&nbsp;</a></span>lastMaximalSegment() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::lastMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the last maximal segment passing through i </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin</td><td>any begin ConstIterator bounding a range </td></tr>
    <tr><td class="paramname">end</td><td>any end ConstIterator bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of CBidirectionalSegmentComputer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00717">717</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;{</div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;  s.init(i);</div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160; </div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;  <a class="code" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a>(s, end);</div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;  <a class="code" href="namespaceDGtal.html#a462eaaf587bc04ebd2e6141bed3fc21e">oppositeEndMaximalExtension</a>(s, begin);</div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00164">maximalExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00198">oppositeEndMaximalExtension()</a>.</p>

</div>
</div>
<a id="a47282aa7c7fc28d49e7a52a3f8eeee3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47282aa7c7fc28d49e7a52a3f8eeee3c">&#9670;&nbsp;</a></span>lastMaximalSegment() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::lastMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the last maximal segment passing through i </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin</td><td>any begin ConstIterator bounding a range </td></tr>
    <tr><td class="paramname">end</td><td>any end ConstIterator bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of CDynamicBidirectionalSegmentComputer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00758">758</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;{</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;  <a class="code" href="namespaceDGtal.html#a19f04b5f095862ee00e620f8246df2f8">lastMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>() );</div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;}</div>
<div class="ttc" id="anamespaceDGtal_html_a19f04b5f095862ee00e620f8246df2f8"><div class="ttname"><a href="namespaceDGtal.html#a19f04b5f095862ee00e620f8246df2f8">DGtal::lastMaximalSegment</a></div><div class="ttdeci">void lastMaximalSegment(SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, DGtal::ForwardSegmentComputer)</div><div class="ttdef"><b>Definition:</b> <a href="SegmentComputerUtils_8h_source.html#l00681">SegmentComputerUtils.h:681</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00681">lastMaximalSegment()</a>.</p>

</div>
</div>
<a id="a652ebafea1d9e8891f40d9b0af8fcb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652ebafea1d9e8891f40d9b0af8fcb02">&#9670;&nbsp;</a></span>lastMaximalSegment() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::lastMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the last maximal segment passing through i </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin</td><td>any begin ConstIterator bounding a range </td></tr>
    <tr><td class="paramname">end</td><td>any end ConstIterator bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of CDynamicSegmentComputer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">ForwardSegmentComputer</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00739">739</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;{</div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;  <a class="code" href="namespaceDGtal.html#a19f04b5f095862ee00e620f8246df2f8">lastMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>() );</div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00681">lastMaximalSegment()</a>.</p>

</div>
</div>
<a id="a19f04b5f095862ee00e620f8246df2f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f04b5f095862ee00e620f8246df2f8">&#9670;&nbsp;</a></span>lastMaximalSegment() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::lastMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the last maximal segment passing through i </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin</td><td>any begin ConstIterator bounding a range </td></tr>
    <tr><td class="paramname">end</td><td>any end ConstIterator bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of CForwardSegmentComputer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00681">681</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;{</div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160; </div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a>; </div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::Reverse ReverseSegmentComputer; </div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ReverseSegmentComputer::ConstIterator</a> ConstReverseIterator; </div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160; </div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;  <span class="comment">//forward extension</span></div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;  <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a> j( i );</div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;  <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>(s, j, end);</div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160; </div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;  <span class="comment">//backward extension</span></div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;  <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a> it( s.end() );</div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;  ConstReverseIterator rit( it );</div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;  ConstReverseIterator rend( begin );</div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;  ReverseSegmentComputer r( s.getReverse() ); </div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;  <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>(r, rit, rend);</div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160; </div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;  <span class="comment">//forward extension</span></div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;  <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a> it2( r.end().base() );</div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;  <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>(s, it2, end);</div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00359">longestSegment()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00739">lastMaximalSegment()</a>, <a class="el" href="exampleAlphaThickSegmentTgtCover_8cpp_source.html#l00067">main()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00895">previousMaximalSegment()</a>.</p>

</div>
</div>
<a id="a464c32dc87cc7ded90f601f4657664a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464c32dc87cc7ded90f601f4657664a1">&#9670;&nbsp;</a></span>longestSegment() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::longestSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the longest possible segment from [i] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">i</td><td>a given ConstIterator </td></tr>
    <tr><td class="paramname">end</td><td>any end ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00391">391</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;{</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;  <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorCirculatorTraits&lt;typename SC::ConstIterator&gt;::Type Type; </div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;  <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>( s, i, end, Type() ); </div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00359">longestSegment()</a>.</p>

</div>
</div>
<a id="a67994f04a54230cdb524e46dba46a127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67994f04a54230cdb524e46dba46a127">&#9670;&nbsp;</a></span>longestSegment() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::longestSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for <a class="el" href="classDGtal_1_1Circulator.html" title="Aim: Provides an adapter for classical iterators that can iterate through the underlying data structu...">Circulator</a> type </p>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00374">374</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;{</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;  s.init(i);</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;  <a class="code" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a>(s, end, CirculatorType() );</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00164">maximalExtension()</a>.</p>

</div>
</div>
<a id="a2034305fadb5376a987519daba4c982a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2034305fadb5376a987519daba4c982a">&#9670;&nbsp;</a></span>longestSegment() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::longestSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for Iterator type </p>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00359">359</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160; {</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;  <span class="keywordflow">if</span> (i != end) {</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    s.init(i);</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    <a class="code" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a>(s, end, IteratorType() );</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;  }</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00164">maximalExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="testStabbingCircleComputer_8cpp_source.html#l00149">drawingTestStabbingCircleComputer()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00412">firstMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00681">lastMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00391">longestSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00529">mostCenteredMaximalSegment()</a>, <a class="el" href="testStabbingCircleComputer_8cpp_source.html#l00278">testRecognition()</a>, and <a class="el" href="testStabbingCircleComputer_8cpp_source.html#l00186">testStabbingCircleComputer()</a>.</p>

</div>
</div>
<a id="ac39878d0bfd6ec38b7dfee7bb095ffb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39878d0bfd6ec38b7dfee7bb095ffb4">&#9670;&nbsp;</a></span>makeArrayImageAdapterFromImage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TDomain  = typename TImage::Domain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ArrayImageAdapter&lt; decltype( ((TImage*)nullptr)-&gt;begin() ), TDomain &gt; DGtal::makeArrayImageAdapterFromImage </td>
          <td>(</td>
          <td class="paramtype">TImage &amp;&#160;</td>
          <td class="paramname"><em>anImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an ArrayImageAdapter from an image.</p>
<p>The viewable domain will be the same as the given image domain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">anImage</td><td>The image that models the CConstImage concept. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ArrayImageAdapter_8h_source.html#l00521">521</a> of file <a class="el" href="ArrayImageAdapter_8h_source.html">ArrayImageAdapter.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;    {</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;      <span class="comment">// Remove constness because CConstImage requires assignability.</span></div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;      BOOST_CONCEPT_ASSERT( (<a class="code" href="structDGtal_1_1concepts_1_1CConstImage.html">DGtal::concepts::CConstImage</a>&lt; <span class="keyword">typename</span> std::remove_const&lt;TImage&gt;::type &gt;) );</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160; </div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;      <span class="keywordflow">return</span> { anImage.begin(), anImage.domain(), anImage.domain() };</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;    }</div>
<div class="ttc" id="astructDGtal_1_1concepts_1_1CConstImage_html"><div class="ttname"><a href="structDGtal_1_1concepts_1_1CConstImage.html">DGtal::concepts::CConstImage</a></div><div class="ttdoc">Aim: Defines the concept describing a read-only image, which is a refinement of CPointFunctor.</div><div class="ttdef"><b>Definition:</b> <a href="CConstImage_8h_source.html#l00094">CConstImage.h:95</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5d8f2b0c05fa81f94692c1c48bb44c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8f2b0c05fa81f94692c1c48bb44c6b">&#9670;&nbsp;</a></span>makeArrayImageAdapterFromImage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TDomain  = typename TImage::Domain&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ArrayImageAdapter&lt; decltype( ((TImage*)nullptr)-&gt;begin() ), TDomain &gt; DGtal::makeArrayImageAdapterFromImage </td>
          <td>(</td>
          <td class="paramtype">TImage &amp;&#160;</td>
          <td class="paramname"><em>anImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TDomain const &amp;&#160;</td>
          <td class="paramname"><em>aViewDomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an ArrayImageAdapter from an image and a viewable domain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">anImage</td><td>The image that models the CConstImage concept. </td></tr>
    <tr><td class="paramname">aViewDomain</td><td>The viewable domain of this image. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ArrayImageAdapter_8h_source.html#l00500">500</a> of file <a class="el" href="ArrayImageAdapter_8h_source.html">ArrayImageAdapter.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;    {</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;      <span class="comment">// Remove constness because CConstImage requires assignability.</span></div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;      BOOST_CONCEPT_ASSERT( (<a class="code" href="structDGtal_1_1concepts_1_1CConstImage.html">DGtal::concepts::CConstImage</a>&lt; <span class="keyword">typename</span> std::remove_const&lt;TImage&gt;::type &gt;) );</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160; </div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;      <span class="keywordflow">return</span> { anImage.begin(), anImage.domain(), aViewDomain };</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="exampleArrayImageAdapter_8cpp_source.html#l00091">moduleImages_example()</a>.</p>

</div>
</div>
<a id="ae2a5010ce777b848a0978e57b93a42bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a5010ce777b848a0978e57b93a42bc">&#9670;&nbsp;</a></span>makeArrayImageAdapterFromIterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TArrayIterator , typename TDomain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ArrayImageAdapter&lt; TArrayIterator, TDomain &gt; DGtal::makeArrayImageAdapterFromIterator </td>
          <td>(</td>
          <td class="paramtype">TArrayIterator&#160;</td>
          <td class="paramname"><em>anArrayIterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TDomain const &amp;&#160;</td>
          <td class="paramname"><em>aFullDomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an ArrayImageAdapter from an iterator and a full domain.</p>
<p>The viewable domain will be the same as the full domain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">anArrayIterator</td><td>A random-access iterator on the datas. </td></tr>
    <tr><td class="paramname">aFullDomain</td><td>The domain span by the given iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an ArrayImageAdapter instance. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ArrayImageAdapter_8h_source.html#l00483">483</a> of file <a class="el" href="ArrayImageAdapter_8h_source.html">ArrayImageAdapter.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    {</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;      <span class="keywordflow">return</span> { anArrayIterator, aFullDomain, aFullDomain };</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4d7cc85d6072793cb8f15694be4d0d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7cc85d6072793cb8f15694be4d0d44">&#9670;&nbsp;</a></span>makeArrayImageAdapterFromIterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TArrayIterator , typename TDomain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ArrayImageAdapter&lt; TArrayIterator, TDomain &gt; DGtal::makeArrayImageAdapterFromIterator </td>
          <td>(</td>
          <td class="paramtype">TArrayIterator&#160;</td>
          <td class="paramname"><em>anArrayIterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TDomain const &amp;&#160;</td>
          <td class="paramname"><em>aFullDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TDomain const &amp;&#160;</td>
          <td class="paramname"><em>aViewDomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an ArrayImageAdapter from an iterator, a full domain and a viewable domain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">anArrayIterator</td><td>A random-access iterator on the datas. </td></tr>
    <tr><td class="paramname">aFullDomain</td><td>The domain span by the given iterator. </td></tr>
    <tr><td class="paramname">aViewDomain</td><td>The viewable domain of this image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an ArrayImageAdapter instance. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ArrayImageAdapter_8h_source.html#l00465">465</a> of file <a class="el" href="ArrayImageAdapter_8h_source.html">ArrayImageAdapter.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;    {</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;      <span class="keywordflow">return</span> { anArrayIterator, aFullDomain, aViewDomain };</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="exampleArrayImageAdapter_8cpp_source.html#l00091">moduleImages_example()</a>.</p>

</div>
</div>
<a id="ad0d8c1b64f3a1ecebc8132001fecd7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d8c1b64f3a1ecebc8132001fecd7f6">&#9670;&nbsp;</a></span>makeShroudsRegularization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalSurfaceContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1ShroudsRegularization.html">ShroudsRegularization</a>&lt;TDigitalSurfaceContainer&gt; DGtal::makeShroudsRegularization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1CountedPtr.html">CountedPtr</a>&lt; <a class="el" href="classDGtal_1_1IndexedDigitalSurface.html">IndexedDigitalSurface</a>&lt; TDigitalSurfaceContainer &gt; &gt;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0.00001</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function for constructing a <a class="el" href="classDGtal_1_1ShroudsRegularization.html" title="Aim: Implements the Shrouds Regularization algorithm of Nielson et al .">ShroudsRegularization</a> from a (closed) <em>surface</em>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDigitalSurfaceContainer</td><td>any digital surface container (a model <a class="el" href="structDGtal_1_1concepts_1_1CDigitalSurfaceContainer.html" title="Aim: The digital surface container concept describes a minimal set of inner types and methods so as t...">concepts::CDigitalSurfaceContainer</a>), for instance a <a class="el" href="classDGtal_1_1SetOfSurfels.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels....">SetOfSurfels</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>a counted pointer on an indexed digital surface. </td></tr>
    <tr><td class="paramname">eps</td><td>the bounds for varying the positions of vertices in ]0,1[</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Complexity is linear in the number of surfels of <em>surface</em>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="testShroudsRegularization_8cpp.html">testShroudsRegularization.cpp</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="ShroudsRegularization_8h_source.html#l00585">585</a> of file <a class="el" href="ShroudsRegularization_8h_source.html">ShroudsRegularization.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;  {</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;    <span class="keywordflow">return</span> ShroudsRegularization&lt;TDigitalSurfaceContainer&gt;( surface, eps );</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a367841808f36fa49eceaa1671718f3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367841808f36fa49eceaa1671718f3ee">&#9670;&nbsp;</a></span>maximalExtension() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::maximalExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for <a class="el" href="classDGtal_1_1Circulator.html" title="Aim: Provides an adapter for classical iterators that can iterate through the underlying data structu...">Circulator</a> type </p>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00174">174</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;{</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  <span class="comment">//stop if the segment is the whole range</span></div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> newEnd( s.begin() ); </div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;  <span class="keywordflow">while</span> ( (s.extendFront())</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    &amp;&amp; (s.end() != newEnd) ) {}</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a21c7d5ea8b24456694c6fa5f6a25f4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c7d5ea8b24456694c6fa5f6a25f4cc">&#9670;&nbsp;</a></span>maximalExtension() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::maximalExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls s.extendFront() while possible </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">end</td><td>any ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00188">188</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;                                                                  {</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;  <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorCirculatorTraits&lt;typename SC::ConstIterator&gt;::Type Type; </div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;  <a class="code" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a>( s, end, Type() ); </div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00164">maximalExtension()</a>.</p>

</div>
</div>
<a id="a4718031e09102bb8f73a874c47e10aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4718031e09102bb8f73a874c47e10aaf">&#9670;&nbsp;</a></span>maximalExtension() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::maximalExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for Iterator type </p>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00164">164</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;                                                                                 {</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;  <span class="comment">//stop if s.end() == end</span></div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;  <span class="keywordflow">while</span> ( (s.end() != end)</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;       &amp;&amp; (s.extendFront()) ) {}</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00449">firstMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00717">lastMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00359">longestSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00188">maximalExtension()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00587">mostCenteredMaximalSegment()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00828">nextMaximalSegment()</a>.</p>

</div>
</div>
<a id="ad4831d5ff3c1c70bd1c6a26403297a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4831d5ff3c1c70bd1c6a26403297a9a">&#9670;&nbsp;</a></span>maximalRetraction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::maximalRetraction </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls s.retractBack() while s.isExtendableFront() returns false </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">end</td><td>any ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00323">323</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;{</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;  <span class="keywordflow">if</span> ( isNotEmpty&lt;typename SC::ConstIterator&gt;(s.end(),end) ) {</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;    <span class="keywordflow">while</span> ( (! s.isExtendableFront() ) </div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;          &amp;&amp;(s.retractBack() ) )  {}  </div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;  } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    <span class="keywordflow">while</span> ( s.retractBack() ) {} </div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;  }</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00828">nextMaximalSegment()</a>.</p>

</div>
</div>
<a id="ad09a396e60a1ff248a246cc2f365fb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09a396e60a1ff248a246cc2f365fb31">&#9670;&nbsp;</a></span>maximalSymmetricExtension() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::maximalSymmetricExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls alternatively s.extendFront() and s.extendBack() while it is possible </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of (bidirectional)segment computer </td></tr>
    <tr><td class="paramname">begin</td><td>begin iterator of a range </td></tr>
    <tr><td class="paramname">end</td><td>end iterator of a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the extension at the front fails first and 'false' if the extension at the back fails first </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of CBidirectionalSegmentComputer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00305">305</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;                                       {</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160; </div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;  <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorCirculatorTraits&lt;typename SC::ConstIterator&gt;::Type Type; </div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespaceDGtal.html#ad8d73948fddeeb1f2e0fa94c4c9b03a9">maximalSymmetricExtension</a>( s, begin, end, Type() ); </div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160; </div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;}</div>
<div class="ttc" id="anamespaceDGtal_html_ad8d73948fddeeb1f2e0fa94c4c9b03a9"><div class="ttname"><a href="namespaceDGtal.html#ad8d73948fddeeb1f2e0fa94c4c9b03a9">DGtal::maximalSymmetricExtension</a></div><div class="ttdeci">bool maximalSymmetricExtension(SC &amp;s, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, IteratorType)</div><div class="ttdef"><b>Definition:</b> <a href="SegmentComputerUtils_8h_source.html#l00236">SegmentComputerUtils.h:236</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00236">maximalSymmetricExtension()</a>.</p>

</div>
</div>
<a id="a04bd5266c4907488dc943c3fd18b72a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04bd5266c4907488dc943c3fd18b72a0">&#9670;&nbsp;</a></span>maximalSymmetricExtension() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::maximalSymmetricExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for <a class="el" href="classDGtal_1_1Circulator.html" title="Aim: Provides an adapter for classical iterators that can iterate through the underlying data structu...">Circulator</a> type </p>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00270">270</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;{</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;  boost::ignore_unused_variable_warning( begin );</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;  boost::ignore_unused_variable_warning( end );</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160; </div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;  <span class="keywordtype">bool</span> flagOk = <span class="keyword">true</span>; </div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;  <span class="keywordtype">bool</span> flagForward = <span class="keyword">true</span>; </div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;  <span class="comment">//while the extensions are possible and</span></div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;  <span class="comment">//the segment does not correspond to the whole range</span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;  <span class="keywordflow">while</span> ( (flagOk) &amp;&amp; ( s.end() != s.begin() ) )  {</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    <span class="keywordflow">if</span> (flagForward) {</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;      flagForward = <span class="keyword">false</span>; </div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;      flagOk = s.extendFront(); </div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;      flagForward = <span class="keyword">true</span>; </div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;      flagOk = s.extendBack(); </div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    } </div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;  }</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;  <span class="keywordflow">return</span> !flagForward; </div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad8d73948fddeeb1f2e0fa94c4c9b03a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d73948fddeeb1f2e0fa94c4c9b03a9">&#9670;&nbsp;</a></span>maximalSymmetricExtension() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::maximalSymmetricExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for Iterator type </p>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00236">236</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;                 {</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160; </div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;  <span class="keywordtype">bool</span> flagOk = <span class="keyword">true</span>; </div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;  <span class="keywordtype">bool</span> flagForward = <span class="keyword">true</span>; </div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;  <span class="comment">//while the extension is possible </span></div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;  <span class="comment">//at the front and (then) at the back</span></div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;  <span class="keywordflow">while</span> (flagOk)  {</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    <span class="keywordflow">if</span> (flagForward) {</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;      flagForward = <span class="keyword">false</span>; </div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;      <span class="keywordflow">if</span> ( s.end() != end ) flagOk = s.extendFront();</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;      <span class="keywordflow">else</span> flagOk = <span class="keyword">false</span>; </div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;      flagForward = <span class="keyword">true</span>; </div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;      <span class="keywordflow">if</span> ( s.begin() != begin ) flagOk = s.extendBack();</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;      <span class="keywordflow">else</span> flagOk = <span class="keyword">false</span>; </div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;    } </div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;  }</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;  <span class="comment">//extend one more time if s.begin() == begin</span></div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;  <span class="keywordflow">if</span> (s.begin() != begin ) {</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;    <span class="keywordflow">if</span> (s.extendBack()) <span class="keywordflow">return</span> !s.extendFront(); </div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>; </div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;  } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    <span class="keywordflow">return</span> !flagForward; </div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;  }</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160; </div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00305">maximalSymmetricExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00587">mostCenteredMaximalSegment()</a>.</p>

</div>
</div>
<a id="a770659cf50cd49c0ce6c3d4ab08abb46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770659cf50cd49c0ce6c3d4ab08abb46">&#9670;&nbsp;</a></span>mmonomial() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring , typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;1, Ring, Alloc&gt; DGtal::mmonomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a monomial in one indeterminate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 1-variable polynomial X_0^e </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
    <tr><td class="paramname">Alloc</td><td>the type of allocator. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MPolynomial_8h_source.html#l01686">1686</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01687"></a><span class="lineno"> 1687</span>&#160;  {</div>
<div class="line"><a name="l01688"></a><span class="lineno"> 1688</span>&#160;    MPolynomial&lt;1, Ring, Alloc&gt; p;</div>
<div class="line"><a name="l01689"></a><span class="lineno"> 1689</span>&#160;    p[e] = 1;</div>
<div class="line"><a name="l01690"></a><span class="lineno"> 1690</span>&#160;    <span class="keywordflow">return</span> p;</div>
<div class="line"><a name="l01691"></a><span class="lineno"> 1691</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9ef248272fbf9b379c272e0ec632289c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef248272fbf9b379c272e0ec632289c">&#9670;&nbsp;</a></span>mmonomial() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;1, Ring, std::allocator&lt;Ring&gt; &gt; DGtal::mmonomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a monomial in one indeterminate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 1-variable polynomial X_0^e </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MPolynomial_8h_source.html#l01758">1758</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01759"></a><span class="lineno"> 1759</span>&#160;  {</div>
<div class="line"><a name="l01760"></a><span class="lineno"> 1760</span>&#160;    MPolynomial&lt;1, Ring, std::allocator&lt;Ring&gt; &gt; p;</div>
<div class="line"><a name="l01761"></a><span class="lineno"> 1761</span>&#160;    p[e] = 1;</div>
<div class="line"><a name="l01762"></a><span class="lineno"> 1762</span>&#160;    <span class="keywordflow">return</span> p;</div>
<div class="line"><a name="l01763"></a><span class="lineno"> 1763</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad04b582eb75ae0cfc14dfc40d57c03f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04b582eb75ae0cfc14dfc40d57c03f2">&#9670;&nbsp;</a></span>mmonomial() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring , typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;2, Ring, Alloc&gt; DGtal::mmonomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a monomial in two indeterminates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
    <tr><td class="paramname">f</td><td>the exponent for X_1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 2-variables polynomial X_0^e X_1^f </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
    <tr><td class="paramname">Alloc</td><td>the type of allocator. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MPolynomial_8h_source.html#l01704">1704</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01705"></a><span class="lineno"> 1705</span>&#160;  {</div>
<div class="line"><a name="l01706"></a><span class="lineno"> 1706</span>&#160;    MPolynomial&lt;2, Ring, Alloc&gt; p;</div>
<div class="line"><a name="l01707"></a><span class="lineno"> 1707</span>&#160;    p[e][f] = 1;</div>
<div class="line"><a name="l01708"></a><span class="lineno"> 1708</span>&#160;    <span class="keywordflow">return</span> p;</div>
<div class="line"><a name="l01709"></a><span class="lineno"> 1709</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9ac70e986a68541f5a9e2b9a4035da2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac70e986a68541f5a9e2b9a4035da2c">&#9670;&nbsp;</a></span>mmonomial() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;2, Ring, std::allocator&lt;Ring&gt; &gt; DGtal::mmonomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a monomial in two indeterminates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
    <tr><td class="paramname">f</td><td>the exponent for X_1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 2-variables polynomial X_0^e X_1^f </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MPolynomial_8h_source.html#l01775">1775</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01776"></a><span class="lineno"> 1776</span>&#160;  {</div>
<div class="line"><a name="l01777"></a><span class="lineno"> 1777</span>&#160;    MPolynomial&lt;2, Ring, std::allocator&lt;Ring&gt; &gt; p;</div>
<div class="line"><a name="l01778"></a><span class="lineno"> 1778</span>&#160;    p[e][f] = 1;</div>
<div class="line"><a name="l01779"></a><span class="lineno"> 1779</span>&#160;    <span class="keywordflow">return</span> p;</div>
<div class="line"><a name="l01780"></a><span class="lineno"> 1780</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a46b41f1ac0f88d213c7fb8bee8931799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b41f1ac0f88d213c7fb8bee8931799">&#9670;&nbsp;</a></span>mmonomial() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring , typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;3, Ring, Alloc&gt; DGtal::mmonomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a monomial in three indeterminates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
    <tr><td class="paramname">f</td><td>the exponent for X_1 </td></tr>
    <tr><td class="paramname">g</td><td>the exponent for X_2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 3-variables polynomial X_0^e X_1^f X_2^g </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
    <tr><td class="paramname">Alloc</td><td>the type of allocator. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MPolynomial_8h_source.html#l01722">1722</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01723"></a><span class="lineno"> 1723</span>&#160;  {</div>
<div class="line"><a name="l01724"></a><span class="lineno"> 1724</span>&#160;    MPolynomial&lt;3, Ring, Alloc&gt; p;</div>
<div class="line"><a name="l01725"></a><span class="lineno"> 1725</span>&#160;    p[e][f][g] = 1;</div>
<div class="line"><a name="l01726"></a><span class="lineno"> 1726</span>&#160;    <span class="keywordflow">return</span> p;</div>
<div class="line"><a name="l01727"></a><span class="lineno"> 1727</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4f44e0a9fc1e30d29e52646daeca211d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f44e0a9fc1e30d29e52646daeca211d">&#9670;&nbsp;</a></span>mmonomial() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;3, Ring, std::allocator&lt;Ring&gt; &gt; DGtal::mmonomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a monomial in three indeterminates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
    <tr><td class="paramname">f</td><td>the exponent for X_1 </td></tr>
    <tr><td class="paramname">g</td><td>the exponent for X_2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 3-variables polynomial X_0^e X_1^f X_2^g </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MPolynomial_8h_source.html#l01793">1793</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01794"></a><span class="lineno"> 1794</span>&#160;  {</div>
<div class="line"><a name="l01795"></a><span class="lineno"> 1795</span>&#160;    MPolynomial&lt;3, Ring, std::allocator&lt;Ring&gt; &gt; p;</div>
<div class="line"><a name="l01796"></a><span class="lineno"> 1796</span>&#160;    p[e][f][g] = 1;</div>
<div class="line"><a name="l01797"></a><span class="lineno"> 1797</span>&#160;    <span class="keywordflow">return</span> p;</div>
<div class="line"><a name="l01798"></a><span class="lineno"> 1798</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae6ba6c1f73137c9da0365c16635c92e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ba6c1f73137c9da0365c16635c92e9">&#9670;&nbsp;</a></span>mmonomial() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring , typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;4, Ring, Alloc&gt; DGtal::mmonomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a monomial in four indeterminates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
    <tr><td class="paramname">f</td><td>the exponent for X_1 </td></tr>
    <tr><td class="paramname">g</td><td>the exponent for X_2 </td></tr>
    <tr><td class="paramname">h</td><td>the exponent for X_3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 3-variables polynomial X_0^e X_1^f X_2^g X_3^h </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
    <tr><td class="paramname">Alloc</td><td>the type of allocator. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MPolynomial_8h_source.html#l01742">1742</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01743"></a><span class="lineno"> 1743</span>&#160;  {</div>
<div class="line"><a name="l01744"></a><span class="lineno"> 1744</span>&#160;    MPolynomial&lt;4, Ring, Alloc&gt; p;</div>
<div class="line"><a name="l01745"></a><span class="lineno"> 1745</span>&#160;    p[e][f][g][h] = 1;</div>
<div class="line"><a name="l01746"></a><span class="lineno"> 1746</span>&#160;    <span class="keywordflow">return</span> p;</div>
<div class="line"><a name="l01747"></a><span class="lineno"> 1747</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4a679186eed201b0844c7bf6f83e76c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a679186eed201b0844c7bf6f83e76c8">&#9670;&nbsp;</a></span>mmonomial() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;4, Ring, std::allocator&lt;Ring&gt; &gt; DGtal::mmonomial </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a monomial in four indeterminates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
    <tr><td class="paramname">f</td><td>the exponent for X_1 </td></tr>
    <tr><td class="paramname">g</td><td>the exponent for X_2 </td></tr>
    <tr><td class="paramname">h</td><td>the exponent for X_3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 3-variables polynomial X_0^e X_1^f X_2^g X_3^h </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MPolynomial_8h_source.html#l01812">1812</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01814"></a><span class="lineno"> 1814</span>&#160;  {</div>
<div class="line"><a name="l01815"></a><span class="lineno"> 1815</span>&#160;    MPolynomial&lt;4, Ring, std::allocator&lt;Ring&gt; &gt; p;</div>
<div class="line"><a name="l01816"></a><span class="lineno"> 1816</span>&#160;    p[e][f][g][h] = 1;</div>
<div class="line"><a name="l01817"></a><span class="lineno"> 1817</span>&#160;    <span class="keywordflow">return</span> p;</div>
<div class="line"><a name="l01818"></a><span class="lineno"> 1818</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="adb7b7f5908ea811a44f41186c7a01e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7b7f5908ea811a44f41186c7a01e8e">&#9670;&nbsp;</a></span>mostCenteredMaximalSegment() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::mostCenteredMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the most centered maximal segment passing through i </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin</td><td>any begin ConstIterator bounding a range </td></tr>
    <tr><td class="paramname">end</td><td>any end ConstIterator bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00660">660</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;{</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;   mostCenteredMaximalSegment&lt;SC&gt;(s, i, begin, end, </div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;<span class="keyword">typename</span> <a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::SegmentComputerTraits&lt;SC&gt;::Category</a>() );</div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad153558eaa4afb851f884b64680f4631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad153558eaa4afb851f884b64680f4631">&#9670;&nbsp;</a></span>mostCenteredMaximalSegment() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::mostCenteredMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the most centered maximal segment passing through i </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin</td><td>any begin ConstIterator bounding a range </td></tr>
    <tr><td class="paramname">end</td><td>any end ConstIterator bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of CBidirectionalSegmentComputer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00587">587</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;{</div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;  </div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;  <span class="keywordflow">if</span> ( (<a class="code" href="namespaceDGtal_1_1detail.html#a58243ebf587bb6ca6eafd9184dae75c4">isNotEmpty</a>(i,end)) || (<a class="code" href="namespaceDGtal_1_1detail.html#a58243ebf587bb6ca6eafd9184dae75c4">isNotEmpty</a>(i,begin)) ) { </div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160; </div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;    s.init(i);</div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160; </div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;    <span class="comment">//symmetric extension</span></div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;    <span class="keywordflow">if</span> ( (<a class="code" href="namespaceDGtal_1_1detail.html#a58243ebf587bb6ca6eafd9184dae75c4">isNotEmpty</a>(i,end)) &amp;&amp; (<a class="code" href="namespaceDGtal_1_1detail.html#a58243ebf587bb6ca6eafd9184dae75c4">isNotEmpty</a>(i,begin)) ) { </div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;      <a class="code" href="namespaceDGtal.html#ad8d73948fddeeb1f2e0fa94c4c9b03a9">maximalSymmetricExtension</a>(s, begin, end); </div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;    }</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160; </div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;  <span class="comment">//forward extension</span></div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;  <a class="code" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a>(s, end);</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;      </div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;  <span class="comment">//backward extension</span></div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;  <a class="code" href="namespaceDGtal.html#a462eaaf587bc04ebd2e6141bed3fc21e">oppositeEndMaximalExtension</a>(s, begin);</div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160; </div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;  }</div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160; </div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;}</div>
<div class="ttc" id="anamespaceDGtal_1_1detail_html_a58243ebf587bb6ca6eafd9184dae75c4"><div class="ttname"><a href="namespaceDGtal_1_1detail.html#a58243ebf587bb6ca6eafd9184dae75c4">DGtal::detail::isNotEmpty</a></div><div class="ttdeci">bool isNotEmpty(const IC &amp;itb, const IC &amp;ite, IteratorType)</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="namespaceDGtal.html#a6f1b22211474c60437654c3a0decb8ef">isNotEmpty()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00164">maximalExtension()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00236">maximalSymmetricExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00198">oppositeEndMaximalExtension()</a>.</p>

</div>
</div>
<a id="aa43392e8f5aeba868858b9b2c1e52cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43392e8f5aeba868858b9b2c1e52cf7">&#9670;&nbsp;</a></span>mostCenteredMaximalSegment() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::mostCenteredMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the most centered maximal segment passing through i </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin</td><td>any begin ConstIterator bounding a range </td></tr>
    <tr><td class="paramname">end</td><td>any end ConstIterator bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of CDynamicBidirectionalSegmentComputer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00642">642</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;{</div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;  <a class="code" href="namespaceDGtal.html#a1b3f25b1f654c74c78819624604e4950">mostCenteredMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>() );</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;}</div>
<div class="ttc" id="anamespaceDGtal_html_a1b3f25b1f654c74c78819624604e4950"><div class="ttname"><a href="namespaceDGtal.html#a1b3f25b1f654c74c78819624604e4950">DGtal::mostCenteredMaximalSegment</a></div><div class="ttdeci">void mostCenteredMaximalSegment(SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, DGtal::ForwardSegmentComputer)</div><div class="ttdef"><b>Definition:</b> <a href="SegmentComputerUtils_8h_source.html#l00529">SegmentComputerUtils.h:529</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00529">mostCenteredMaximalSegment()</a>.</p>

</div>
</div>
<a id="a07a2cb535d2b0befce8f080d9d1a2414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a2cb535d2b0befce8f080d9d1a2414">&#9670;&nbsp;</a></span>mostCenteredMaximalSegment() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::mostCenteredMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the most centered maximal segment passing through i </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin</td><td>any begin ConstIterator bounding a range </td></tr>
    <tr><td class="paramname">end</td><td>any end ConstIterator bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of CDynamicSegmentComputer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">ForwardSegmentComputer</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00623">623</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;{</div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;  <a class="code" href="namespaceDGtal.html#a1b3f25b1f654c74c78819624604e4950">mostCenteredMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>() );</div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00529">mostCenteredMaximalSegment()</a>.</p>

</div>
</div>
<a id="a1b3f25b1f654c74c78819624604e4950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3f25b1f654c74c78819624604e4950">&#9670;&nbsp;</a></span>mostCenteredMaximalSegment() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::mostCenteredMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the most centered maximal segment passing through i </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin</td><td>any begin ConstIterator bounding a range </td></tr>
    <tr><td class="paramname">end</td><td>any end ConstIterator bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of CForwardSegmentComputer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00529">529</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;{</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160; </div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a>; </div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::Reverse ReverseSegmentComputer; </div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ReverseSegmentComputer::ConstIterator</a> ConstReverseIterator; </div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160; </div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160; <span class="comment">//get the first maximal segment passing through i</span></div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160; </div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;  <a class="code" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">firstMaximalSegment</a>( s, i, begin, end, <a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>() );</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160; </div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160; <span class="comment">//get the next maximal segment while i is not at the middle of </span></div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160; <span class="comment">//the current maximal segment. </span></div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160; </div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;  <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a> k( s.begin() ); </div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;  <span class="keywordflow">while</span> ( k != i ) {</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160; </div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;    <span class="keywordflow">if</span> ( isNotEmpty&lt;ConstIterator&gt;(s.end(),end) ) {</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160; </div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;      <span class="comment">//backward extension</span></div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;      <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a> it( s.end() ); ++it; </div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;      ConstReverseIterator rit( it );</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;      ConstReverseIterator rend( s.begin() );</div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;      ReverseSegmentComputer r( s.getReverse() ); </div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;      <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>(r, rit, rend);</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;      <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a> newBegin = r.end().base(); </div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;      ASSERT( newBegin != s.begin() );</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160; </div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;      <span class="keywordflow">while</span> ( ( k != <a class="code" href="namespaceDGtal.html#a8c4fb1b2976e5fc35dc1b4073149408e">getMiddleIterator</a>(newBegin, s.end() ) )</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;            &amp;&amp;( k != i ) ) {</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;        ++k; </div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;      }</div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;      <span class="keywordflow">if</span> ( k != i ) {</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;   </div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;        <span class="comment">//get the next maximal segment</span></div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;        <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>(s, newBegin, end);  </div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160; </div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;      }</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160; </div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;      k = i; </div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;    }</div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;  }</div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00412">firstMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00087">getMiddleIterator()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00359">longestSegment()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00623">mostCenteredMaximalSegment()</a>.</p>

</div>
</div>
<a id="a325d2a962cd3410424a45f83c1b32b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325d2a962cd3410424a45f83c1b32b7a">&#9670;&nbsp;</a></span>nextMaximalSegment() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::nextMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the next maximal segment of s (s is assumed to be maximal) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">end</td><td>any end ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00876">876</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;{</div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;   nextMaximalSegment&lt;SC&gt;(s, end, </div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;<span class="keyword">typename</span> <a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::SegmentComputerTraits&lt;SC&gt;::Category</a>() );</div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0f4fc5b05689abd850faa6637a64505c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4fc5b05689abd850faa6637a64505c">&#9670;&nbsp;</a></span>nextMaximalSegment() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::nextMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the next maximal segment of s (s is assumed to be maximal) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">end</td><td>end ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of CBidirectionalSegmentComputer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>firstMaximalSegment of s.end() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00813">813</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;{</div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;  <a class="code" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">firstMaximalSegment</a>(s, s.end(), s.begin(), end, <a class="code" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>() );</div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00412">firstMaximalSegment()</a>.</p>

</div>
</div>
<a id="ae9e6d98ecc15fc5062f30060d4452706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e6d98ecc15fc5062f30060d4452706">&#9670;&nbsp;</a></span>nextMaximalSegment() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::nextMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the next maximal segment of s (s is assumed to be maximal) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">end</td><td>end ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of CDynamicBidirectionalSegmentComputer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DynamicSegmentComputer</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00861">861</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;{ </div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;  <a class="code" href="namespaceDGtal.html#a91c1293187f38e931f5f353d1a38f71c">nextMaximalSegment</a>(s, end, <a class="code" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>() ); </div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;}</div>
<div class="ttc" id="anamespaceDGtal_html_a91c1293187f38e931f5f353d1a38f71c"><div class="ttname"><a href="namespaceDGtal.html#a91c1293187f38e931f5f353d1a38f71c">DGtal::nextMaximalSegment</a></div><div class="ttdeci">void nextMaximalSegment(SC &amp;s, const typename SC::ConstIterator &amp;end, DGtal::ForwardSegmentComputer)</div><div class="ttdef"><b>Definition:</b> <a href="SegmentComputerUtils_8h_source.html#l00797">SegmentComputerUtils.h:797</a></div></div>
<div class="ttc" id="astructDGtal_1_1DynamicSegmentComputer_html"><div class="ttname"><a href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a></div><div class="ttdef"><b>Definition:</b> <a href="SegmentComputerUtils_8h_source.html#l00054">SegmentComputerUtils.h:54</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00797">nextMaximalSegment()</a>.</p>

</div>
</div>
<a id="a6ee548c7f570f6bdb18ce2cc592cb009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee548c7f570f6bdb18ce2cc592cb009">&#9670;&nbsp;</a></span>nextMaximalSegment() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::nextMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the next maximal segment of s (s is assumed to be maximal) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">end</td><td>end ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of CDynamicSegmentComputer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00828">828</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;{</div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a>; </div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160; </div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;  <span class="comment">//rectract</span></div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;  <a class="code" href="namespaceDGtal.html#ad4831d5ff3c1c70bd1c6a26403297a9a">maximalRetraction</a>(s, end); </div>
<div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160; </div>
<div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;  <span class="comment">//intersection test</span></div>
<div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;  <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a> i( s.begin() ); ++i; </div>
<div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;  <span class="comment">//if the intersection between the two </span></div>
<div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;  <span class="comment">// consecutive maximal segments is empty </span></div>
<div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;  <span class="keywordflow">if</span> ( i == s.end() ) {</div>
<div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;    <span class="keywordflow">if</span> ( isNotEmpty&lt;ConstIterator&gt;(i, end) ) {</div>
<div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;      ++i; </div>
<div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;      s.init(i);  </div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;    }</div>
<div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;  }</div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160; </div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;  <span class="comment">//extend</span></div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;  <a class="code" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a>(s, end);</div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;}</div>
<div class="ttc" id="anamespaceDGtal_html_ad4831d5ff3c1c70bd1c6a26403297a9a"><div class="ttname"><a href="namespaceDGtal.html#ad4831d5ff3c1c70bd1c6a26403297a9a">DGtal::maximalRetraction</a></div><div class="ttdeci">void maximalRetraction(SC &amp;s, const typename SC::ConstIterator &amp;end)</div><div class="ttdef"><b>Definition:</b> <a href="SegmentComputerUtils_8h_source.html#l00323">SegmentComputerUtils.h:323</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00164">maximalExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00323">maximalRetraction()</a>.</p>

</div>
</div>
<a id="a91c1293187f38e931f5f353d1a38f71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c1293187f38e931f5f353d1a38f71c">&#9670;&nbsp;</a></span>nextMaximalSegment() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::nextMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the next maximal segment of s (s is assumed to be maximal) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">end</td><td>any end ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of CForwardSegmentComputer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>firstMaximalSegment of s.end() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00797">797</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;{</div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;  <a class="code" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">firstMaximalSegment</a>(s, s.end(), s.begin(), end, ForwardSegmentComputer() );</div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00412">firstMaximalSegment()</a>.</p>

<p class="reference">Referenced by <a class="el" href="exampleAlphaThickSegmentTgtCover_8cpp_source.html#l00067">main()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00861">nextMaximalSegment()</a>.</p>

</div>
</div>
<a id="a9670198dd8ca22231fd61fa042750b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9670198dd8ca22231fd61fa042750b02">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Difference test.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input cubical complex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff <em>S1</em> is not equal to <em>S2</em> (i.e. either <em>S1</em> is not a subcomplex of <em>S2</em> or <em>S2</em> is not a subcomplex of <em>S1</em>). </dd></dl>

<p class="definition">Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00293">293</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;  {</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="testCubicalComplex_8cpp.html#a9f6eee55782bbac774730b7688010a1e">CC</a>;</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    ASSERT( &amp;(S1.space()) == &amp;(S2.space()) );</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= CC::dimension; ++i )</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;      <span class="keywordflow">if</span> ( ! <a class="code" href="testIndexedListWithBlocks_8cpp.html#a8094f96118b5321654e1671f513371f8">functions::isEqual</a>( S1.myCells[ i ], S2.myCells[ i ] ) )</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;  }</div>
<div class="ttc" id="atestCubicalComplex_8cpp_html_a9f6eee55782bbac774730b7688010a1e"><div class="ttname"><a href="testCubicalComplex_8cpp.html#a9f6eee55782bbac774730b7688010a1e">CC</a></div><div class="ttdeci">CubicalComplex&lt; KSpace, Map &gt; CC</div><div class="ttdef"><b>Definition:</b> <a href="testCubicalComplex_8cpp_source.html#l00058">testCubicalComplex.cpp:58</a></div></div>
<div class="ttc" id="atestIndexedListWithBlocks_8cpp_html_a8094f96118b5321654e1671f513371f8"><div class="ttname"><a href="testIndexedListWithBlocks_8cpp.html#a8094f96118b5321654e1671f513371f8">isEqual</a></div><div class="ttdeci">bool isEqual(Container1 &amp;c1, Container2 &amp;c2)</div><div class="ttdef"><b>Definition:</b> <a href="testIndexedListWithBlocks_8cpp_source.html#l00045">testIndexedListWithBlocks.cpp:45</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l00789">DGtal::functions::isEqual()</a>, <a class="el" href="CubicalComplex_8h_source.html#l01301">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>, and <a class="el" href="classDGtal_1_1CubicalComplex.html#a32db9584d04e62cd205002dd7279b36a">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::space()</a>.</p>

</div>
</div>
<a id="a5239018e29ed723fad811621f0ec0432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5239018e29ed723fad811621f0ec0432">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Difference operator on Points/Vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>true iff the two points differ, false otherwise. </dd></dl>

</div>
</div>
<a id="ae23b9018e5c7429c4585bba3f2fdc60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23b9018e5c7429c4585bba3f2fdc60b">&#9670;&nbsp;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; DGtal::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cubical Complex intersection operation. Returns the cubical complex \( S1 \cap S2 \). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input cubical complex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the cubical complex \( S1 \cap S2 \). </dd></dl>

<p class="definition">Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00180">180</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;  {</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="testCubicalComplex_8cpp.html#a9f6eee55782bbac774730b7688010a1e">CC</a>;</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    <a class="code" href="testCubicalComplex_8cpp.html#a9f6eee55782bbac774730b7688010a1e">CC</a> S( S1 );</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= CC::dimension; ++i )</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;      functions::setops::operator&amp;=( S.myCells[ i ], S2.myCells[ i ] );</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    <span class="keywordflow">return</span> S;</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="CubicalComplex_8h_source.html#l01301">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>.</p>

</div>
</div>
<a id="a397f22d0915165d3a2f0b7f273d8302c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397f22d0915165d3a2f0b7f273d8302c">&#9670;&nbsp;</a></span>operator&amp;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp; DGtal::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cubical Complex intersection operation. Updates the cubical complex <em>S1</em> as \( S1 \cap S2 \). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input cubical complex, \( S1 \cap S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the modified cubical complex S1. </dd></dl>

<p class="definition">Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00201">201</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;  {</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="testCubicalComplex_8cpp.html#a9f6eee55782bbac774730b7688010a1e">CC</a>;</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= CC::dimension; ++i )</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;      functions::setops::operator&amp;=( S1.myCells[ i ], S2.myCells[ i ] );</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    <span class="keywordflow">return</span> S1;</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="CubicalComplex_8h_source.html#l01301">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>.</p>

</div>
</div>
<a id="a1cb82504c40b5578aacd454b70190116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb82504c40b5578aacd454b70190116">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; DGtal::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cubical Complex open operation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input cubical complex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new cubical complex that is the opening of S1. </dd></dl>

<p class="definition">Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00078">78</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;  {</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    CubicalComplex&lt; TKSpace, TCellContainer &gt; S( S1 );</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    S.open();</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    <span class="keywordflow">return</span> S;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classDGtal_1_1CubicalComplex.html#aaf566fbbd9e2e68c631b7ff826770eb5">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::open()</a>.</p>

</div>
</div>
<a id="aea63233a5efe92ca5048ea4e965155cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea63233a5efe92ca5048ea4e965155cd">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Color.html">Color</a> DGtal::operator* </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>aColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>External multiplication operator with a scalar number</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coeff</td><td>is the factor <em><a class="el" href="classDGtal_1_1Color.html" title="Structure representing an RGB triple with alpha component.">Color</a></em> is multiplied by. </td></tr>
    <tr><td class="paramname">aColor</td><td>is the vector that is multiplied by the factor <em>coef</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new Vector that is the multiplication of <em>aVector</em> by <em>coeff</em>. </dd></dl>

</div>
</div>
<a id="aa434f809abed79a881725bafd3656089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa434f809abed79a881725bafd3656089">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Calculus , Order order_in, Duality duality_in, Order order_fold, Duality duality_fold, Order order_out, Duality duality_out&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt;Calculus, order_in, duality_in, order_out, duality_out&gt; DGtal::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_fold, duality_fold, order_out, duality_out &gt; &amp;&#160;</td>
          <td class="paramname"><em>operator_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_in, duality_in, order_fold, duality_fold &gt; &amp;&#160;</td>
          <td class="paramname"><em>operator_right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator*' for internal multiplication of objects of class '<a class="el" href="classDGtal_1_1LinearOperator.html" title="Aim: LinearOperator represents discrete linear operator between discrete kforms in the DEC package.">LinearOperator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operator_left</td><td>left operant </td></tr>
    <tr><td class="paramname">operator_right</td><td>right operant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>operator_left * operator_right. </dd></dl>

</div>
</div>
<a id="a6171236ccfadbd59609e1b43ae1ece3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6171236ccfadbd59609e1b43ae1ece3e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Calculus , Order order_in, Duality duality_in, Order order_out, Duality duality_out&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt;Calculus, order_out, duality_out&gt; DGtal::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_in, duality_in, order_out, duality_out &gt; &amp;&#160;</td>
          <td class="paramname"><em>linear_operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt; Calculus, order_in, duality_in &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_form</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator*' for application of objects of class '<a class="el" href="classDGtal_1_1LinearOperator.html" title="Aim: LinearOperator represents discrete linear operator between discrete kforms in the DEC package.">LinearOperator</a>' on objects of class '<a class="el" href="classDGtal_1_1KForm.html" title="Aim: KForm represents discrete kforms in the dec package.">KForm</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linear_operator</td><td>left operant </td></tr>
    <tr><td class="paramname">input_form</td><td>right operant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>linear_operator * input_form. </dd></dl>

</div>
</div>
<a id="aa74eb3d39b9b5e8d9fd8700d508a6466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74eb3d39b9b5e8d9fd8700d508a6466">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComponent , DGtal::Dimension TM, DGtal::Dimension TN&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1SimpleMatrix.html">SimpleMatrix</a>&lt;TComponent, TM, TN&gt; DGtal::operator* </td>
          <td>(</td>
          <td class="paramtype">const TComponent &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SimpleMatrix.html">SimpleMatrix</a>&lt; TComponent, TM, TN &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>External scalar multiplication </p>

</div>
</div>
<a id="aa70c40c0349f5404672003567a189506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70c40c0349f5404672003567a189506">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Calculus , Order order, Duality duality&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt;Calculus, order, duality&gt; DGtal::operator* </td>
          <td>(</td>
          <td class="paramtype">const typename Calculus::Scalar &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt; Calculus, order, duality &gt; &amp;&#160;</td>
          <td class="paramname"><em>form</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator*' for scalar multiplication of objects of class '<a class="el" href="classDGtal_1_1KForm.html" title="Aim: KForm represents discrete kforms in the dec package.">KForm</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>left operant </td></tr>
    <tr><td class="paramname">form</td><td>right operant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scalar * form. </dd></dl>

</div>
</div>
<a id="a5276ede383635a215f61ac918dc2d185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5276ede383635a215f61ac918dc2d185">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Calculus , Order order_in, Duality duality_in, Order order_out, Duality duality_out&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt;Calculus, order_in, duality_in, order_out, duality_out&gt; DGtal::operator* </td>
          <td>(</td>
          <td class="paramtype">const typename Calculus::Scalar &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_in, duality_in, order_out, duality_out &gt; &amp;&#160;</td>
          <td class="paramname"><em>linear_operator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator*' for scalar multiplication of objects of class '<a class="el" href="classDGtal_1_1LinearOperator.html" title="Aim: LinearOperator represents discrete linear operator between discrete kforms in the DEC package.">LinearOperator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>left operant </td></tr>
    <tr><td class="paramname">linear_operator</td><td>right operant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scalar * linear_operator. </dd></dl>

</div>
</div>
<a id="a124e3c51465f61a87c1c37d667aa9e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124e3c51465f61a87c1c37d667aa9e38">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Calculus , Duality duality&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1VectorField.html">VectorField</a>&lt;Calculus, duality&gt; DGtal::operator* </td>
          <td>(</td>
          <td class="paramtype">const typename Calculus::Scalar &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1VectorField.html">VectorField</a>&lt; Calculus, duality &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator*' for scalar multiplication of objects of class '<a class="el" href="classDGtal_1_1VectorField.html" title="Aim: VectorField represents a discrete vector field in the dec package. Vector field values are attac...">VectorField</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>left operant </td></tr>
    <tr><td class="paramname">vector_field</td><td>right operant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scalar * vector_field. </dd></dl>

</div>
</div>
<a id="a15f23c185684bf04a88db79a08999be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f23c185684bf04a88db79a08999be4">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftScalar , typename RightEuclideanRing , typename RightContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DGtal::operator* </td>
          <td>(</td>
          <td class="paramtype">LeftScalar const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator between a scalar and a Point/Vector. </p>
<dl class="section return"><dt>Returns</dt><dd>a point/vector with best component type accordingly to the C++ conversion rules in arithmetic operations context. </dd></dl>

</div>
</div>
<a id="a40fd09c1e06ec1263fe83cba764b54c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40fd09c1e06ec1263fe83cba764b54c7">&#9670;&nbsp;</a></span>operator*() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DGtal::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator between two Points/Vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>a point/vector with best component type accordingly to the C++ conversion rules in arithmetic operations context. </dd></dl>

</div>
</div>
<a id="a33d6a8275616ead7a8ed793de952eb46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d6a8275616ead7a8ed793de952eb46">&#9670;&nbsp;</a></span>operator*() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightScalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DGtal::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RightScalar const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator between a Point/Vector and a scalar. </p>
<dl class="section return"><dt>Returns</dt><dd>a point/vector with best component type accordingly to the C++ conversion rules in arithmetic operations context. </dd></dl>

</div>
</div>
<a id="a66bb2fc09d5940620aa4bb6b3246cf50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66bb2fc09d5940620aa4bb6b3246cf50">&#9670;&nbsp;</a></span>operator*() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt;TSpace&gt; DGtal::operator* </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt;::<a class="el" href="examplePlaneProbingParallelepipedEstimator_8cpp.html#ad31c3eca44cf6770809bc47f2b456212">Integer</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>any integer. </td></tr>
    <tr><td class="paramname">P</td><td>any polytope. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the polytope tP. </dd></dl>

</div>
</div>
<a id="a8b89d5d3bfe2fc1b44f147e5ae811f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b89d5d3bfe2fc1b44f147e5ae811f31">&#9670;&nbsp;</a></span>operator*() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt;TSpace&gt; DGtal::operator* </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; TSpace &gt;::<a class="el" href="examplePlaneProbingParallelepipedEstimator_8cpp.html#ad31c3eca44cf6770809bc47f2b456212">Integer</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>any integer. </td></tr>
    <tr><td class="paramname">P</td><td>any polytope. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the polytope tP. </dd></dl>

</div>
</div>
<a id="af3ad7b4c24afbe69907e4c6b4e9708b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ad7b4c24afbe69907e4c6b4e9708b0">&#9670;&nbsp;</a></span>operator*() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt;TSpace&gt; DGtal::operator* </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; TSpace &gt;::Rational&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>any rational. </td></tr>
    <tr><td class="paramname">P</td><td>any polytope. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rational polytope rP. </dd></dl>

</div>
</div>
<a id="a0bc7f826e62dbeaca125517a82a5b098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc7f826e62dbeaca125517a82a5b098">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt;TSpace&gt; DGtal::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt;::LeftStrictUnitCell&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Minkowski sum of polytope <em>P</em> with an axis-aligned strict unit cell <em>c</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>any polytope. </td></tr>
    <tr><td class="paramname">c</td><td>any strict unit cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Polytope P + c. </dd></dl>

</div>
</div>
<a id="a7df255b5e94781f1f3607c8df815ac66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df255b5e94781f1f3607c8df815ac66">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt;TSpace&gt; DGtal::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt;::LeftStrictUnitSegment&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Minkowski sum of polytope <em>P</em> with strict unit segment <em>s</em> aligned with some axis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>any polytope. </td></tr>
    <tr><td class="paramname">s</td><td>any strict unit segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Polytope P + s. </dd></dl>

</div>
</div>
<a id="a678c2d53aa522c5088c77139388a5ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678c2d53aa522c5088c77139388a5ccb">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt;TSpace&gt; DGtal::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt;::RightStrictUnitCell&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Minkowski sum of polytope <em>P</em> with an axis-aligned strict unit cell <em>c</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>any polytope. </td></tr>
    <tr><td class="paramname">c</td><td>any strict unit cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Polytope P + c. </dd></dl>

</div>
</div>
<a id="a5abb6cb52e4cbb2515a9ba6af7d386da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5abb6cb52e4cbb2515a9ba6af7d386da">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt;TSpace&gt; DGtal::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt;::RightStrictUnitSegment&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Minkowski sum of polytope <em>P</em> with strict unit segment <em>s</em> aligned with some axis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>any polytope. </td></tr>
    <tr><td class="paramname">s</td><td>any strict unit segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Polytope P + s. </dd></dl>

</div>
</div>
<a id="a2989aae399cb671d978428ffd4fbe325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2989aae399cb671d978428ffd4fbe325">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt;TSpace&gt; DGtal::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt;::UnitCell&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Minkowski sum of polytope <em>P</em> with an axis-aligned unit cell <em>c</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>any polytope. </td></tr>
    <tr><td class="paramname">c</td><td>any unit cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Polytope P + c. </dd></dl>

</div>
</div>
<a id="a6d4f5b9f5ff70e32fc8dcf70cb98bb5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d4f5b9f5ff70e32fc8dcf70cb98bb5f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt;TSpace&gt; DGtal::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt;::UnitSegment&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Minkowski sum of polytope <em>P</em> with unit segment <em>s</em> aligned with some axis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>any polytope. </td></tr>
    <tr><td class="paramname">s</td><td>any unit segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Polytope P + s. </dd></dl>

</div>
</div>
<a id="a0fc6de5ffec7b9bd8eaf029b9b44ff0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc6de5ffec7b9bd8eaf029b9b44ff0c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt;TSpace&gt; DGtal::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; TSpace &gt;::UnitCell&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Minkowski sum of polytope <em>P</em> with an axis-aligned unit cell <em>c</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>any polytope. </td></tr>
    <tr><td class="paramname">c</td><td>any unit cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Polytope P + c. </dd></dl>

</div>
</div>
<a id="ab4771f3aa833a58345269e424b25bd67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4771f3aa833a58345269e424b25bd67">&#9670;&nbsp;</a></span>operator+() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt;TSpace&gt; DGtal::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; TSpace &gt;::UnitSegment&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Minkowski sum of polytope <em>P</em> with unit segment <em>s</em> aligned with some axis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>any polytope. </td></tr>
    <tr><td class="paramname">s</td><td>any unit segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Polytope P + s. </dd></dl>

</div>
</div>
<a id="ac49620ee5f3ed8761257b992c5f8e407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49620ee5f3ed8761257b992c5f8e407">&#9670;&nbsp;</a></span>operator+() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Calculus , Order order, Duality duality&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt;Calculus, order, duality&gt; DGtal::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt; Calculus, order, duality &gt; &amp;&#160;</td>
          <td class="paramname"><em>form_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt; Calculus, order, duality &gt; &amp;&#160;</td>
          <td class="paramname"><em>form_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator+' for adding objects of class '<a class="el" href="classDGtal_1_1KForm.html" title="Aim: KForm represents discrete kforms in the dec package.">KForm</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">form_a</td><td>left operant </td></tr>
    <tr><td class="paramname">form_b</td><td>right operant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>form_a + form_b. </dd></dl>

</div>
</div>
<a id="a157fb77aee59a66348106f1fd39067b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a157fb77aee59a66348106f1fd39067b5">&#9670;&nbsp;</a></span>operator+() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Calculus , Order order_in, Duality duality_in, Order order_out, Duality duality_out&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt;Calculus, order_in, duality_in, order_out, duality_out&gt; DGtal::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_in, duality_in, order_out, duality_out &gt; &amp;&#160;</td>
          <td class="paramname"><em>linear_operator_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_in, duality_in, order_out, duality_out &gt; &amp;&#160;</td>
          <td class="paramname"><em>linear_operator_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator+' for adding objects of class '<a class="el" href="classDGtal_1_1LinearOperator.html" title="Aim: LinearOperator represents discrete linear operator between discrete kforms in the DEC package.">LinearOperator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linear_operator_a</td><td>left operant </td></tr>
    <tr><td class="paramname">linear_operator_b</td><td>right operant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>linear_operator_a + linear_operator_b. </dd></dl>

</div>
</div>
<a id="a8f1ef43ca7a715577e740ad49d4da0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1ef43ca7a715577e740ad49d4da0ca">&#9670;&nbsp;</a></span>operator+() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Calculus , Duality duality&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1VectorField.html">VectorField</a>&lt;Calculus, duality&gt; DGtal::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1VectorField.html">VectorField</a>&lt; Calculus, duality &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_field_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1VectorField.html">VectorField</a>&lt; Calculus, duality &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_field_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator+' for adding objects of class '<a class="el" href="classDGtal_1_1VectorField.html" title="Aim: VectorField represents a discrete vector field in the dec package. Vector field values are attac...">VectorField</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector_field_a</td><td>left operant </td></tr>
    <tr><td class="paramname">vector_field_b</td><td>right operant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector_field_a + vector_field_b. </dd></dl>

</div>
</div>
<a id="ac0269f9a89baa463f71fec06c5487fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0269f9a89baa463f71fec06c5487fd6">&#9670;&nbsp;</a></span>operator+() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftScalar , typename RightEuclideanRing , typename RightContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DGtal::operator+ </td>
          <td>(</td>
          <td class="paramtype">LeftScalar const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator between a scalar and a Point/Vector. </p>
<dl class="section return"><dt>Returns</dt><dd>a point/vector with best component type accordingly to the C++ conversion rules in arithmetic operations context. </dd></dl>

</div>
</div>
<a id="a86626d443cf72fd15d58a94d709d566f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86626d443cf72fd15d58a94d709d566f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DGtal::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator between two Points/Vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>a point/vector with best component type accordingly to the C++ conversion rules in arithmetic operations context. </dd></dl>

</div>
</div>
<a id="aa91983378c10b6d909535e581661daae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91983378c10b6d909535e581661daae">&#9670;&nbsp;</a></span>operator+() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightScalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DGtal::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RightScalar const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator between a Point/Vector and a scalar. </p>
<dl class="section return"><dt>Returns</dt><dd>a point/vector with best component type accordingly to the C++ conversion rules in arithmetic operations context. </dd></dl>

</div>
</div>
<a id="ae2b8f8cfdace54a784220c80b36ea651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b8f8cfdace54a784220c80b36ea651">&#9670;&nbsp;</a></span>operator+() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Circulator.html">Circulator</a>&lt;TIterator&gt; DGtal::operator+ </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structDGtal_1_1IteratorCirculatorTraits.html">IteratorCirculatorTraits</a>&lt; TIterator &gt;::Difference&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1Circulator.html">Circulator</a>&lt; TIterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Circulator_8h_source.html#l00453">453</a> of file <a class="el" href="Circulator_8h_source.html">Circulator.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;  {</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;    Circulator&lt;TIterator&gt; tmp = object;</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;    <span class="keywordflow">return</span> tmp += d;</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a46d8848c1b6c272844824c892fdb47fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d8848c1b6c272844824c892fdb47fa">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; DGtal::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cubical Complex difference operation. Returns the difference of <em>S1</em> - <em>S2</em>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input cubical complex </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the cubical complex <em>S1</em> - <em>S2</em>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00118">118</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  {</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="testCubicalComplex_8cpp.html#a9f6eee55782bbac774730b7688010a1e">CC</a>;</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    <a class="code" href="testCubicalComplex_8cpp.html#a9f6eee55782bbac774730b7688010a1e">CC</a> S( S1 );</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= CC::dimension; ++i )</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;      functions::setops::operator-=( S.myCells[ i ],S2.myCells[ i ] );</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <span class="keywordflow">return</span> S;</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="CubicalComplex_8h_source.html#l01301">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>.</p>

</div>
</div>
<a id="a68a350eb811553a00e8696dca7638eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a350eb811553a00e8696dca7638eef">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Calculus , Order order, Duality duality&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt;Calculus, order, duality&gt; DGtal::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt; Calculus, order, duality &gt; &amp;&#160;</td>
          <td class="paramname"><em>form</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator-' for unary additive inverse of objects of class '<a class="el" href="classDGtal_1_1KForm.html" title="Aim: KForm represents discrete kforms in the dec package.">KForm</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">form</td><td>operant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-form. </dd></dl>

</div>
</div>
<a id="adec6f2f58473756f2ba913ebda2a5d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec6f2f58473756f2ba913ebda2a5d1a">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Calculus , Order order, Duality duality&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt;Calculus, order, duality&gt; DGtal::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt; Calculus, order, duality &gt; &amp;&#160;</td>
          <td class="paramname"><em>form_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt; Calculus, order, duality &gt; &amp;&#160;</td>
          <td class="paramname"><em>form_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator-' for substracting objects of class '<a class="el" href="classDGtal_1_1KForm.html" title="Aim: KForm represents discrete kforms in the dec package.">KForm</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">form_a</td><td>left operant </td></tr>
    <tr><td class="paramname">form_b</td><td>right operant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>form_a - form_b. </dd></dl>

</div>
</div>
<a id="ac8d1c40f41aa395c8c020538f27b3d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d1c40f41aa395c8c020538f27b3d6d">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Calculus , Order order_in, Duality duality_in, Order order_out, Duality duality_out&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt;Calculus, order_in, duality_in, order_out, duality_out&gt; DGtal::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_in, duality_in, order_out, duality_out &gt; &amp;&#160;</td>
          <td class="paramname"><em>linear_operator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator-' for unary additive inverse of objects of class '<a class="el" href="classDGtal_1_1LinearOperator.html" title="Aim: LinearOperator represents discrete linear operator between discrete kforms in the DEC package.">LinearOperator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linear_operator</td><td>operant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-linear_operator. </dd></dl>

</div>
</div>
<a id="ad1af6b3e28a9f1298422b89588efecfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1af6b3e28a9f1298422b89588efecfb">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Calculus , Order order_in, Duality duality_in, Order order_out, Duality duality_out&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt;Calculus, order_in, duality_in, order_out, duality_out&gt; DGtal::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_in, duality_in, order_out, duality_out &gt; &amp;&#160;</td>
          <td class="paramname"><em>linear_operator_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_in, duality_in, order_out, duality_out &gt; &amp;&#160;</td>
          <td class="paramname"><em>linear_operator_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator-' for substracting objects of class '<a class="el" href="classDGtal_1_1LinearOperator.html" title="Aim: LinearOperator represents discrete linear operator between discrete kforms in the DEC package.">LinearOperator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linear_operator_a</td><td>left operant </td></tr>
    <tr><td class="paramname">linear_operator_b</td><td>right operant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>linear_operator_a - linear_operator_b. </dd></dl>

</div>
</div>
<a id="a12aa22271b3a8943a2e49190ca483e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12aa22271b3a8943a2e49190ca483e2d">&#9670;&nbsp;</a></span>operator-() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Calculus , Duality duality&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1VectorField.html">VectorField</a>&lt;Calculus, duality&gt; DGtal::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1VectorField.html">VectorField</a>&lt; Calculus, duality &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_field</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator-' for unary additive inverse of objects of class '<a class="el" href="classDGtal_1_1VectorField.html" title="Aim: VectorField represents a discrete vector field in the dec package. Vector field values are attac...">VectorField</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector_field</td><td>operant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-vector_field </dd></dl>

</div>
</div>
<a id="a7ef3b60bbf6d8d3847d7b69945454c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef3b60bbf6d8d3847d7b69945454c20">&#9670;&nbsp;</a></span>operator-() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Calculus , Duality duality&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1VectorField.html">VectorField</a>&lt;Calculus, duality&gt; DGtal::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1VectorField.html">VectorField</a>&lt; Calculus, duality &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_field_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1VectorField.html">VectorField</a>&lt; Calculus, duality &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_field_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator-' for substracting objects of class '<a class="el" href="classDGtal_1_1VectorField.html" title="Aim: VectorField represents a discrete vector field in the dec package. Vector field values are attac...">VectorField</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector_field_a</td><td>left operant </td></tr>
    <tr><td class="paramname">vector_field_b</td><td>right operant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector_field_a - vector_field_b. </dd></dl>

</div>
</div>
<a id="a5eccf894da053756ca42d3544bdd7acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eccf894da053756ca42d3544bdd7acf">&#9670;&nbsp;</a></span>operator-() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1VoxelComplex.html">VoxelComplex</a>&lt; TKSpace, TCellContainer &gt; DGtal::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1VoxelComplex.html">VoxelComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1VoxelComplex.html">VoxelComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Voxel Complex difference operation. Returns the difference of <em>S1</em> - <em>S2</em>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the voxel complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the voxel complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input voxel complex </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input voxel complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the voxel complex <em>S1</em> - <em>S2</em>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VoxelComplexFunctions_8h_source.html#l00408">408</a> of file <a class="el" href="VoxelComplexFunctions_8h_source.html">VoxelComplexFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;    {</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;      <span class="keyword">typedef</span> VoxelComplex&lt; TKSpace, TCellContainer &gt; VC;</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;      VC S(S1);</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;      <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= VC::dimension; ++i )</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;        functions::setops::operator-=( S.myCells[ i ],S2.myCells[ i ] );</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;      <span class="keywordflow">return</span> S;</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="CubicalComplex_8h_source.html#l01301">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>.</p>

</div>
</div>
<a id="a25e1a107bc846d1fc6df40d9a7ffa571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e1a107bc846d1fc6df40d9a7ffa571">&#9670;&nbsp;</a></span>operator-() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftScalar , typename RightEuclideanRing , typename RightContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DGtal::operator- </td>
          <td>(</td>
          <td class="paramtype">LeftScalar const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substraction operator between a scalar and a Point/Vector. </p>
<dl class="section return"><dt>Returns</dt><dd>a point/vector with best component type accordingly to the C++ conversion rules in arithmetic operations context. </dd></dl>

</div>
</div>
<a id="a73bc107bf5faa1dfbb4ad23d2dda9099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73bc107bf5faa1dfbb4ad23d2dda9099">&#9670;&nbsp;</a></span>operator-() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DGtal::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator between two Points/Vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>a point/vector with best component type accordingly to the C++ conversion rules in arithmetic operations context. </dd></dl>

</div>
</div>
<a id="abcda92e8bf3c2c9337277fb908b3f258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcda92e8bf3c2c9337277fb908b3f258">&#9670;&nbsp;</a></span>operator-() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightScalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DGtal::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RightScalar const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator between a Point/Vector and a scalar. </p>
<dl class="section return"><dt>Returns</dt><dd>a point/vector with best component type accordingly to the C++ conversion rules in arithmetic operations context. </dd></dl>

</div>
</div>
<a id="af6ca8514c052da8444ab157c10b57add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ca8514c052da8444ab157c10b57add">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp; DGtal::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cubical Complex difference operation. Updates the cubical complex S1 as S1 - S2. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input cubical complex, <em>S1</em> - <em>S2</em> as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the modified cubical complex S1. </dd></dl>

<p class="definition">Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00097">97</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  {</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="testCubicalComplex_8cpp.html#a9f6eee55782bbac774730b7688010a1e">CC</a>;</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= CC::dimension; ++i )</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;      functions::setops::operator-=( S1.myCells[ i ],S2.myCells[ i ] );</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    <span class="keywordflow">return</span> S1;</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="CubicalComplex_8h_source.html#l01301">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>.</p>

</div>
</div>
<a id="ae9453d81f5c0bc9057de2329c799e798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9453d81f5c0bc9057de2329c799e798">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1VoxelComplex.html">VoxelComplex</a>&lt; TKSpace, TCellContainer &gt; &amp; DGtal::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1VoxelComplex.html">VoxelComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1VoxelComplex.html">VoxelComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Voxel Complex difference operation. Updates the voxel complex S1 as S1 - S2. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the voxel complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the voxel complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input voxel complex, <em>S1</em> - <em>S2</em> as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input voxel complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the modified voxel complex S1. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VoxelComplexFunctions_8h_source.html#l00386">386</a> of file <a class="el" href="VoxelComplexFunctions_8h_source.html">VoxelComplexFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    {</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;      <span class="keyword">typedef</span> VoxelComplex&lt; TKSpace, TCellContainer &gt; VC;</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;      <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= VC::dimension; ++i )</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;        functions::setops::operator-=( S1.myCells[ i ],S2.myCells[ i ] );</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;      <span class="keywordflow">return</span> S1;</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="CubicalComplex_8h_source.html#l01301">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>.</p>

</div>
</div>
<a id="a73bff88284b00b08e9aea5aa050b2d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73bff88284b00b08e9aea5aa050b2d20">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftScalar , typename RightEuclideanRing , typename RightContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DGtal::operator/ </td>
          <td>(</td>
          <td class="paramtype">LeftScalar const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division operator between a scalar and a Point/Vector. </p>
<dl class="section return"><dt>Returns</dt><dd>a point/vector with best component type accordingly to the C++ conversion rules in arithmetic operations context. </dd></dl>

</div>
</div>
<a id="aa320999d6387f35c03264c5984355c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa320999d6387f35c03264c5984355c3f">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DGtal::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division operator between two Points/Vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>a point/vector with best component type accordingly to the C++ conversion rules in arithmetic operations context. </dd></dl>

</div>
</div>
<a id="affd3a380a6eb27322cc72b886c290734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd3a380a6eb27322cc72b886c290734">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightScalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DGtal::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RightScalar const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division operator between a Point/Vector and a scalar. </p>
<dl class="section return"><dt>Returns</dt><dd>a point/vector with best component type accordingly to the C++ conversion rules in arithmetic operations context. </dd></dl>

</div>
</div>
<a id="a7aea121a396821797edc0eff58f2cb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aea121a396821797edc0eff58f2cb7a">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator on Points/Vectors (LesserThan). </p>
<dl class="section return"><dt>Returns</dt><dd>true iff lhs &lt; rhs, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It uses the lexicographical order. </dd></dl>

<p class="reference">Referenced by <a class="el" href="Color_8cpp_source.html#l00129">DGtal::Color::operator&lt;=()</a>, and <a class="el" href="Color_8cpp_source.html#l00123">DGtal::Color::operator&gt;()</a>.</p>

</div>
</div>
<a id="a55a3903fa935b85eb3a22de1d383df9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a3903fa935b85eb3a22de1d383df9d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1Mesh.html">Mesh</a>&lt; TPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>'operator&lt;&lt;' for exporting objects of class '<a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces....">Mesh</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>a mesh </td></tr>
    <tr><td class="paramname">filename</td><td>a filename </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the mesh has been exported correctly. </dd></dl>

</div>
</div>
<a id="adc9b640720251af967daebe4feec737e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9b640720251af967daebe4feec737e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/255]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>aOs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49">ProbingMode</a> const &amp;&#160;</td>
          <td class="paramname"><em>aMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Display a mode on the standard output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aOs</td><td>the output stream. </td></tr>
    <tr><td class="paramname">aMode</td><td>the mode to display. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="PlaneProbingTetrahedronEstimator_8h_source.html#l00073">73</a> of file <a class="el" href="PlaneProbingTetrahedronEstimator_8h_source.html">PlaneProbingTetrahedronEstimator.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    {</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        <span class="keywordflow">switch</span> (aMode)</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        {</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;            <span class="keywordflow">case</span> ProbingMode::H:</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;                aOs &lt;&lt; <span class="stringliteral">&quot;H&quot;</span>;</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160; </div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;            <span class="keywordflow">case</span> ProbingMode::R:</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;                aOs &lt;&lt; <span class="stringliteral">&quot;R&quot;</span>;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160; </div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;            <span class="keywordflow">case</span> ProbingMode::R1:</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;                aOs &lt;&lt; <span class="stringliteral">&quot;R1&quot;</span>;</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        }</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160; </div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        <span class="keywordflow">return</span> aOs;</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ac1d9f50f86825a1a2302ec2449c17196">H</a>, <a class="el" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ae1e1d3d40573127e9ee0480caf1283d6">R</a>, and <a class="el" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49acda522d4353b166cc2dee84673307b4e">R1</a>.</p>

</div>
</div>
<a id="a3767c6329da3b3959bb60341e7ed9adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3767c6329da3b3959bb60341e7ed9adc">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/255]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ComputationInfo &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Eigen::ComputationInfo'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">info</td><td>the object of class 'EigenSupport' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="EigenSupport_8h_source.html#l00123">123</a> of file <a class="el" href="EigenSupport_8h_source.html">EigenSupport.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;{</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    <span class="keywordflow">switch</span> (info)</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    {</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        <span class="keywordflow">case</span> Eigen::Success:</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;success&quot;</span>;</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;        <span class="keywordflow">case</span> Eigen::NumericalIssue:</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;numerical_issue&quot;</span>;</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        <span class="keywordflow">case</span> Eigen::NoConvergence:</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;no_convergence&quot;</span>;</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        <span class="keywordflow">case</span> Eigen::InvalidInput:</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;invalid_input&quot;</span>;</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    }</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160; </div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    <span class="keywordflow">return</span> os;</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2706aab43647ea9f5e8680d198a78058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2706aab43647ea9f5e8680d198a78058">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1AccFlower2D.html">AccFlower2D</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1AccFlower2D.html" title="Aim: Model of the concept StarShaped represents any accelerated flower in the plane.">AccFlower2D</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1AccFlower2D.html" title="Aim: Model of the concept StarShaped represents any accelerated flower in the plane.">AccFlower2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="acdf9c6b4e189ded5d60d22898ad8212e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf9c6b4e189ded5d60d22898ad8212e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputPoint , typename TConstIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1AlphaThickSegmentComputer.html">AlphaThickSegmentComputer</a>&lt; TInputPoint, TConstIterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1AlphaThickSegmentComputer.html" title="Aim: This class is devoted to the recognition of alpha thick segments as described in  ....">AlphaThickSegmentComputer</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1AlphaThickSegmentComputer.html" title="Aim: This class is devoted to the recognition of alpha thick segments as described in  ....">AlphaThickSegmentComputer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="abe792e4bd33613a06d18b3021d580384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe792e4bd33613a06d18b3021d580384">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/255]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1AngleLinearMinimizer.html">AngleLinearMinimizer</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1AngleLinearMinimizer.html" title="Aim: Used to minimize the angle variation between different angles while taking into accounts min and...">AngleLinearMinimizer</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1AngleLinearMinimizer.html" title="Aim: Used to minimize the angle variation between different angles while taking into accounts min and...">AngleLinearMinimizer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a35ba602cd04883e50ce0236387bd2e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ba602cd04883e50ce0236387bd2e9d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ArithmeticalDSL.html">ArithmeticalDSL</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ArithmeticalDSL.html" title="Aim: This class represents a naive (resp. standard) digital straight line (DSL), ie....">ArithmeticalDSL</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ArithmeticalDSL.html" title="Aim: This class represents a naive (resp. standard) digital straight line (DSL), ie....">ArithmeticalDSL</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a2bcd5a800f76e4b4641af33a32f466d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bcd5a800f76e4b4641af33a32f466d5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a3914f7e1bedd3c522b9a40cbdad75a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3914f7e1bedd3c522b9a40cbdad75a15">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[9/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TInteger , unsigned short adjacency&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html">ArithmeticalDSSComputer</a>&lt; TIterator, TInteger, adjacency &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html" title="Aim: This class is a wrapper around ArithmeticalDSS that is devoted to the dynamic recognition of dig...">ArithmeticalDSSComputer</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html" title="Aim: This class is a wrapper around ArithmeticalDSS that is devoted to the dynamic recognition of dig...">ArithmeticalDSSComputer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ArithmeticalDSSComputer_8h_source.html#l00420">420</a> of file <a class="el" href="ArithmeticalDSSComputer_8h_source.html">ArithmeticalDSSComputer.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;{</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;  <span class="keywordtype">object</span>.selfDisplay( out);</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;  <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8b6444c3cd63c5b91e183adffeabf64b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6444c3cd63c5b91e183adffeabf64b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[10/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TIterator , typename TInteger , unsigned short adjacency&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ArithmeticalDSSComputerOnSurfels.html">ArithmeticalDSSComputerOnSurfels</a>&lt; TKSpace, TIterator, TInteger, adjacency &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ArithmeticalDSSComputerOnSurfels.html" title="Aim: This class is a wrapper around ArithmeticalDSS that is devoted to the dynamic recognition of dig...">ArithmeticalDSSComputerOnSurfels</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ArithmeticalDSSComputerOnSurfels.html" title="Aim: This class is a wrapper around ArithmeticalDSS that is devoted to the dynamic recognition of dig...">ArithmeticalDSSComputerOnSurfels</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ArithmeticalDSSComputerOnSurfels_8h_source.html#l00442">442</a> of file <a class="el" href="ArithmeticalDSSComputerOnSurfels_8h_source.html">ArithmeticalDSSComputerOnSurfels.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;{</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;  <span class="keywordtype">object</span>.selfDisplay( out);</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;  <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3290776c6f437b487cca376b72a32364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3290776c6f437b487cca376b72a32364">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[11/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TArrayIterator , typename TDomain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayImageAdapter&lt; TArrayIterator, TDomain &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>[<a class="el" href="classDGtal_1_1IteratorCompletionTraits.html" title="Aim: Traits that must be specialized for each IteratorCompletion derived class.">IteratorCompletionTraits</a>] </p>
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ArrayImageIterator.html" title="Aim: Random access iterator over an image given his definition domain and viewable domain.">ArrayImageIterator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ArrayImageIterator.html" title="Aim: Random access iterator over an image given his definition domain and viewable domain.">ArrayImageIterator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ArrayImageAdapter_8h_source.html#l00443">443</a> of file <a class="el" href="ArrayImageAdapter_8h_source.html">ArrayImageAdapter.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;    {</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;      <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;      <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="acdf1432bfdb1b6298b58a87b7abe81cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf1432bfdb1b6298b58a87b7abe81cf">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[12/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterableClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ArrayImageIterator.html">ArrayImageIterator</a>&lt; TIterableClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ArrayImageIterator.html" title="Aim: Random access iterator over an image given his definition domain and viewable domain.">ArrayImageIterator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ArrayImageIterator.html" title="Aim: Random access iterator over an image given his definition domain and viewable domain.">ArrayImageIterator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a7a89cd5501bdf942f7a188b680a16330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a89cd5501bdf942f7a188b680a16330">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[13/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Astroid2D.html">Astroid2D</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Astroid2D.html" title="Aim: Model of the concept StarShaped represents an astroid.">Astroid2D</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Astroid2D.html" title="Aim: Model of the concept StarShaped represents an astroid.">Astroid2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="add8541826ace2aebbe88c8a08875cf91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8541826ace2aebbe88c8a08875cf91">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[14/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ATSolver2D.html">ATSolver2D</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ATSolver2D.html" title="Aim: This class solves Ambrosio-Tortorelli functional on a two-dimensional digital space (a 2D grid o...">ATSolver2D</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ATSolver2D.html" title="Aim: This class solves Ambrosio-Tortorelli functional on a two-dimensional digital space (a 2D grid o...">ATSolver2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a1ccee26befa27175cfcc96042ae4fc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ccee26befa27175cfcc96042ae4fc79">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[15/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1AvnaimEtAl2x2DetSignComputer.html">AvnaimEtAl2x2DetSignComputer</a>&lt; TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1AvnaimEtAl2x2DetSignComputer.html" title="Aim: Class that provides a way of computing the sign of the determinant of a 2x2 matrix from its four...">AvnaimEtAl2x2DetSignComputer</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1AvnaimEtAl2x2DetSignComputer.html" title="Aim: Class that provides a way of computing the sign of the determinant of a 2x2 matrix from its four...">AvnaimEtAl2x2DetSignComputer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a1add7afbe92aeefa8c1d71165b43dc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1add7afbe92aeefa8c1d71165b43dc9f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[16/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1BackInsertionSequenceToStackAdapter.html">BackInsertionSequenceToStackAdapter</a>&lt; TSequence &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1BackInsertionSequenceToStackAdapter.html" title="Aim: This class implements a dynamic adapter to an instance of a model of back insertion sequence in ...">BackInsertionSequenceToStackAdapter</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1BackInsertionSequenceToStackAdapter.html" title="Aim: This class implements a dynamic adapter to an instance of a model of back insertion sequence in ...">BackInsertionSequenceToStackAdapter</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a6e3122ee382f11142dd99840d9369962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3122ee382f11142dd99840d9369962">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[17/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Ball2D.html">Ball2D</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Ball2D.html" title="Aim: Model of the concept StarShaped represents any circle in the plane.">Ball2D</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Ball2D.html" title="Aim: Model of the concept StarShaped represents any circle in the plane.">Ball2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a1ec957eba9b6bc73034478bdefa0d9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec957eba9b6bc73034478bdefa0d9d1">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[18/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Ball3D.html">Ball3D</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Ball3D.html" title="Aim: Model of the concept StarShaped3D represents any Sphere in the space.">Ball3D</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Ball3D.html" title="Aim: Model of the concept StarShaped3D represents any Sphere in the space.">Ball3D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ac91ddbc6c9aa0527a2bef39c1db5a442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91ddbc6c9aa0527a2bef39c1db5a442">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[19/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TConstIteratorOnPoints , typename TValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1BinomialConvolver.html">BinomialConvolver</a>&lt; TConstIteratorOnPoints, TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1BinomialConvolver.html" title="Aim: This class represents a 2D contour convolved by some binomial. It computes first and second orde...">BinomialConvolver</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1BinomialConvolver.html" title="Aim: This class represents a 2D contour convolved by some binomial. It computes first and second orde...">BinomialConvolver</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a2e60731c3d380a3d904efbf5c088cf07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e60731c3d380a3d904efbf5c088cf07">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[20/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1BLUELocalLengthEstimator.html">BLUELocalLengthEstimator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1BLUELocalLengthEstimator.html" title="Aim: Best Linear Unbiased Two step length estimator.">BLUELocalLengthEstimator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1BLUELocalLengthEstimator.html" title="Aim: Best Linear Unbiased Two step length estimator.">BLUELocalLengthEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a48eda6ac0ad627de337fbf0f380f446a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48eda6ac0ad627de337fbf0f380f446a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[21/255]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Board2D.html">Board2D</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (with &lt;&lt;)....">Board2D</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (with &lt;&lt;)....">Board2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a764912e949cef91dac5e9620e985074e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764912e949cef91dac5e9620e985074e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[22/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Space , typename KSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Board3D.html">Board3D</a>&lt; <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a38dfaf1641eab4d3fb805df4b52ab10d">Space</a>, <a class="el" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Board3D.html" title="The class Board3D is a type of Display3D which export the figures in the format OBJ/MTL when calling ...">Board3D</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Board3D.html" title="The class Board3D is a type of Display3D which export the figures in the format OBJ/MTL when calling ...">Board3D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aa02bb85760b407e96a4e4a3c2159f558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02bb85760b407e96a4e4a3c2159f558">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[23/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Space , typename KSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Board3DTo2D.html">Board3DTo2D</a>&lt; <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a38dfaf1641eab4d3fb805df4b52ab10d">Space</a>, <a class="el" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Board3DTo2D.html" title="Class for PDF, PNG, PS, EPS, SVG export drawings with Cairo with 3D-&gt;2D projection.">Board3DTo2D</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Board3DTo2D.html" title="Class for PDF, PNG, PS, EPS, SVG export drawings with Cairo with 3D-&gt;2D projection.">Board3DTo2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a1f3b6ebf2123436829f58f92ef5a618d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3b6ebf2123436829f58f92ef5a618d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[24/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1BoundedLatticePolytope.html" title="Aim: Represents an nD lattice polytope, i.e. a convex polyhedron bounded with vertices with integer c...">BoundedLatticePolytope</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1BoundedLatticePolytope.html" title="Aim: Represents an nD lattice polytope, i.e. a convex polyhedron bounded with vertices with integer c...">BoundedLatticePolytope</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a80d062a5c7a6c7e1bcf63cf3e0a9fe73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d062a5c7a6c7e1bcf63cf3e0a9fe73">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[25/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1BoundedRationalPolytope.html" title="Aim: Represents an nD rational polytope, i.e. a convex polyhedron bounded by vertices with rational c...">BoundedRationalPolytope</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1BoundedRationalPolytope.html" title="Aim: Represents an nD rational polytope, i.e. a convex polyhedron bounded by vertices with rational c...">BoundedRationalPolytope</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a75f70d0ba908b7e05676658fa82734b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f70d0ba908b7e05676658fa82734b4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[26/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TGraph , typename TMarkSet &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1BreadthFirstVisitor.html">BreadthFirstVisitor</a>&lt; TGraph, TMarkSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1BreadthFirstVisitor.html" title="Aim: This class is useful to perform a breadth-first exploration of a graph given a starting point or...">BreadthFirstVisitor</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1BreadthFirstVisitor.html" title="Aim: This class is useful to perform a breadth-first exploration of a graph given a starting point or...">BreadthFirstVisitor</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a83d94472929eed3723d1405c74e3a0e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d94472929eed3723d1405c74e3a0e9">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[27/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1CanonicCellEmbedder.html">CanonicCellEmbedder</a>&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="structDGtal_1_1CanonicCellEmbedder.html" title="Aim: A trivial embedder for signed and unsigned cell, which corresponds to the canonic injection of c...">CanonicCellEmbedder</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="structDGtal_1_1CanonicCellEmbedder.html" title="Aim: A trivial embedder for signed and unsigned cell, which corresponds to the canonic injection of c...">CanonicCellEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aba90e4a5acd6874d3e462e7a26cb9336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba90e4a5acd6874d3e462e7a26cb9336">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[28/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalSurface &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1CanonicDigitalSurfaceEmbedder.html">CanonicDigitalSurfaceEmbedder</a>&lt; TDigitalSurface &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="structDGtal_1_1CanonicDigitalSurfaceEmbedder.html" title="Aim: A trivial embedder for digital surfaces, which corresponds to the canonic injection of cell cent...">CanonicDigitalSurfaceEmbedder</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="structDGtal_1_1CanonicDigitalSurfaceEmbedder.html" title="Aim: A trivial embedder for digital surfaces, which corresponds to the canonic injection of cell cent...">CanonicDigitalSurfaceEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a09507195f1c90b1e477e54afd0b3365d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09507195f1c90b1e477e54afd0b3365d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[29/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1CanonicEmbedder.html">CanonicEmbedder</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="structDGtal_1_1CanonicEmbedder.html" title="Aim: A trivial embedder for digital points, which corresponds to the canonic injection of Zn into Rn.">CanonicEmbedder</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="structDGtal_1_1CanonicEmbedder.html" title="Aim: A trivial embedder for digital points, which corresponds to the canonic injection of Zn into Rn.">CanonicEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a77ea40386af9fb5ff47a649b3b11e7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ea40386af9fb5ff47a649b3b11e7c7">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[30/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1CanonicSCellEmbedder.html">CanonicSCellEmbedder</a>&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="structDGtal_1_1CanonicSCellEmbedder.html" title="Aim: A trivial embedder for signed cell, which corresponds to the canonic injection of cell centroids...">CanonicSCellEmbedder</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="structDGtal_1_1CanonicSCellEmbedder.html" title="Aim: A trivial embedder for signed cell, which corresponds to the canonic injection of cell centroids...">CanonicSCellEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ae68e77202300ec2a1ebee48ddce0e640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68e77202300ec2a1ebee48ddce0e640">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[31/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CellGeometry.html">CellGeometry</a>&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1CellGeometry.html" title="Aim: Computes and stores sets of cells and provides methods to compute intersections of lattice and r...">CellGeometry</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1CellGeometry.html" title="Aim: Computes and stores sets of cells and provides methods to compute intersections of lattice and r...">CellGeometry</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a6714a7a10d4957d494e7ed098c066ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6714a7a10d4957d494e7ed098c066ee4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[32/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace , typename TInputPoint , typename TInternalScalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ChordGenericNaivePlaneComputer.html">ChordGenericNaivePlaneComputer</a>&lt; TSpace, TInputPoint, TInternalScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ChordGenericNaivePlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1,...">ChordGenericNaivePlaneComputer</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ChordGenericNaivePlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1,...">ChordGenericNaivePlaneComputer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a666f5204280b03b007687a7f24b67bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666f5204280b03b007687a7f24b67bdd">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[33/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace , typename TInputPoint , typename TInternalScalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ChordGenericStandardPlaneComputer.html">ChordGenericStandardPlaneComputer</a>&lt; TSpace, TInputPoint, TInternalScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ChordGenericStandardPlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given diagonal width. When the width is ,...">ChordGenericStandardPlaneComputer</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ChordGenericStandardPlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given diagonal width. When the width is ,...">ChordGenericStandardPlaneComputer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aa00e9304bdefeecac3cc99759225df1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00e9304bdefeecac3cc99759225df1e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[34/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace , typename TInputPoint , typename TInternalScalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ChordNaivePlaneComputer.html">ChordNaivePlaneComputer</a>&lt; TSpace, TInputPoint, TInternalScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ChordNaivePlaneComputer.html" title="Aim: A class that contains the chord-based algorithm for recognizing pieces of digital planes of give...">ChordNaivePlaneComputer</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ChordNaivePlaneComputer.html" title="Aim: A class that contains the chord-based algorithm for recognizing pieces of digital planes of give...">ChordNaivePlaneComputer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a585a463f4055c1df3774c34bc4d1c5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585a463f4055c1df3774c34bc4d1c5fb">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[35/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CircleFrom2Points.html">CircleFrom2Points</a>&lt; TPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1CircleFrom2Points.html" title="Aim: Represents a circle that passes through a given point and that is thus uniquely defined by two o...">CircleFrom2Points</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1CircleFrom2Points.html" title="Aim: Represents a circle that passes through a given point and that is thus uniquely defined by two o...">CircleFrom2Points</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="CircleFrom2Points_8h_source.html#l00225">225</a> of file <a class="el" href="CircleFrom2Points_8h_source.html">CircleFrom2Points.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;  {</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5ee88b42fe08c64c833f2b785139063c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee88b42fe08c64c833f2b785139063c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[36/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CircleFrom3Points.html">CircleFrom3Points</a>&lt; TPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1CircleFrom3Points.html" title="Aim: Represents a circle uniquely defined by three 2D points and that is able to return for any given...">CircleFrom3Points</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1CircleFrom3Points.html" title="Aim: Represents a circle uniquely defined by three 2D points and that is able to return for any given...">CircleFrom3Points</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="CircleFrom3Points_8h_source.html#l00235">235</a> of file <a class="el" href="CircleFrom3Points_8h_source.html">CircleFrom3Points.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;  {</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac4d5198d8a044649b47cf6ccecf43549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d5198d8a044649b47cf6ccecf43549">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[37/255]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Clock.html">Clock</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Clock.html">Clock</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Clock.html">Clock</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Clock_8h_source.html#l00163">163</a> of file <a class="el" href="Clock_8h_source.html">Clock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    {</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;      <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;      <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6c5c11e869e737331dc7555ccd76fd6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5c11e869e737331dc7555ccd76fd6d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[38/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1ClosedIntegerHalfPlane.html">ClosedIntegerHalfPlane</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="structDGtal_1_1ClosedIntegerHalfPlane.html" title="Aim: A half-space specified by a vector N and a constant c. The half-space is the set .">ClosedIntegerHalfPlane</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="structDGtal_1_1ClosedIntegerHalfPlane.html" title="Aim: A half-space specified by a vector N and a constant c. The half-space is the set .">ClosedIntegerHalfPlane</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a64bed9b65298e34bd47518694b8890f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bed9b65298e34bd47518694b8890f3">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[39/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace , typename TInternalInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html">COBAGenericNaivePlaneComputer</a>&lt; TSpace, TInternalInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1,...">COBAGenericNaivePlaneComputer</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1,...">COBAGenericNaivePlaneComputer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a3ffdff71c4a212bf79860d4205fdf973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffdff71c4a212bf79860d4205fdf973">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[40/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace , typename TInternalInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1COBAGenericStandardPlaneComputer.html">COBAGenericStandardPlaneComputer</a>&lt; TSpace, TInternalInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1COBAGenericStandardPlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the diagonal width is...">COBAGenericStandardPlaneComputer</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1COBAGenericStandardPlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the diagonal width is...">COBAGenericStandardPlaneComputer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a7186d0986fa94a9082a554decc7778ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7186d0986fa94a9082a554decc7778ef">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[41/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace , typename TInternalInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html">COBANaivePlaneComputer</a>&lt; TSpace, TInternalInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="af044fcd2d297fa25c9000469042edbe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af044fcd2d297fa25c9000469042edbe0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[42/255]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>aColor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Color.html" title="Structure representing an RGB triple with alpha component.">Color</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">aColor</td><td>the object of class '<a class="el" href="classDGtal_1_1Color.html" title="Structure representing an RGB triple with alpha component.">Color</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a1f741db2aff5b278688197ead61fbf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f741db2aff5b278688197ead61fbf84">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[43/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PValue , int PDefaultColor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ColorBrightnessColorMap.html">ColorBrightnessColorMap</a>&lt; PValue, PDefaultColor &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ColorBrightnessColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">ColorBrightnessColorMap</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ColorBrightnessColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">ColorBrightnessColorMap</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a44d89ceb668c40a2e86d1ff5b41fbf59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d89ceb668c40a2e86d1ff5b41fbf59">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[44/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImageContainer , typename TNewDomain , typename TFunctorD , typename TNewValue , typename TFunctorV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ConstImageAdapter.html">ConstImageAdapter</a>&lt; TImageContainer, TNewDomain, TFunctorD, TNewValue, TFunctorV &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a0e7ca3a483107d4b69dfa47cf7919663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7ca3a483107d4b69dfa47cf7919663">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[45/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TFunctor , typename TReturnType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ConstRangeAdapter.html">ConstRangeAdapter</a>&lt; TIterator, TFunctor, TReturnType &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ConstRangeAdapter.html" title="Aim: model of CConstBidirectionalRange that adapts any range of elements bounded by two iterators [it...">ConstRangeAdapter</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ConstRangeAdapter.html" title="Aim: model of CConstBidirectionalRange that adapts any range of elements bounded by two iterators [it...">ConstRangeAdapter</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ConstRangeAdapter_8h_source.html#l00315">315</a> of file <a class="el" href="ConstRangeAdapter_8h_source.html">ConstRangeAdapter.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;   {</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;     <span class="keywordtype">object</span>.selfDisplay( out ); </div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;     <span class="keywordflow">return</span> out; </div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;   } </div>
</div><!-- fragment -->
</div>
</div>
<a id="acf090f2b7c0b27c606e73a5a83a558b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf090f2b7c0b27c606e73a5a83a558b7">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[46/255]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ContourHelper.html">ContourHelper</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ContourHelper.html" title="Aim: a helper class to process sequences of points.">ContourHelper</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ContourHelper.html" title="Aim: a helper class to process sequences of points.">ContourHelper</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="acaf4801901b7957941d7f14f370f1cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf4801901b7957941d7f14f370f1cbf">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[47/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1ConvexCellComplex.html">ConvexCellComplex</a>&lt; TPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="structDGtal_1_1ConvexCellComplex.html" title="Aim: represents a d-dimensional complex in a d-dimensional space with the following properties and re...">ConvexCellComplex</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="structDGtal_1_1ConvexCellComplex.html" title="Aim: represents a d-dimensional complex in a d-dimensional space with the following properties and re...">ConvexCellComplex</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ConvexCellComplex_8h_source.html#l00537">537</a> of file <a class="el" href="ConvexCellComplex_8h_source.html">ConvexCellComplex.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;  {</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;    <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;    <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aeefaa36d38a78e24915bdcd617e92945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeefaa36d38a78e24915bdcd617e92945">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[48/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CountedConstPtrOrConstPtr.html">CountedConstPtrOrConstPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1CountedConstPtrOrConstPtr.html" title="Aim: Smart or simple const pointer on T. It can be a smart pointer based on reference counts or a sim...">CountedConstPtrOrConstPtr</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1CountedConstPtrOrConstPtr.html" title="Aim: Smart or simple const pointer on T. It can be a smart pointer based on reference counts or a sim...">CountedConstPtrOrConstPtr</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a3a29027f9af032254ecd7af503707d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a29027f9af032254ecd7af503707d88">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[49/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CountedPtr.html">CountedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1CountedPtr.html" title="Aim: Smart pointer based on reference counts.">CountedPtr</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1CountedPtr.html" title="Aim: Smart pointer based on reference counts.">CountedPtr</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a1cd957666821fd029d79e63cb9f6f7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd957666821fd029d79e63cb9f6f7ae">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[50/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CountedPtrOrPtr.html">CountedPtrOrPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1CountedPtrOrPtr.html" title="Aim: Smart or simple pointer on T. It can be a smart pointer based on reference counts or a simple po...">CountedPtrOrPtr</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1CountedPtrOrPtr.html" title="Aim: Smart or simple pointer on T. It can be a smart pointer based on reference counts or a simple po...">CountedPtrOrPtr</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a50dc282001d37fbfd29aead60ac3d110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50dc282001d37fbfd29aead60ac3d110">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[51/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CowPtr.html">CowPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1CowPtr.html" title="Aim: Copy on write shared pointer.">CowPtr</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1CowPtr.html" title="Aim: Copy on write shared pointer.">CowPtr</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="abfa4cf951c1e0d56b28f5112a777c558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa4cf951c1e0d56b28f5112a777c558">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[52/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1CubicalComplex.html" title="Aim: This class represents an arbitrary cubical complex living in some Khalimsky space....">CubicalComplex</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1CubicalComplex.html" title="Aim: This class represents an arbitrary cubical complex living in some Khalimsky space....">CubicalComplex</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ad1daa4a8453a4bf2325c1b208fd34c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1daa4a8453a4bf2325c1b208fd34c07">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[53/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCurve , typename TTransfromation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DecoratorParametricCurveTransformation.html">DecoratorParametricCurveTransformation</a>&lt; TCurve, TTransfromation &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DecoratorParametricCurveTransformation.html" title="Aim: Implements a decorator for applying transformations to parametric curves.">DecoratorParametricCurveTransformation</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DecoratorParametricCurveTransformation.html" title="Aim: Implements a decorator for applying transformations to parametric curves.">DecoratorParametricCurveTransformation</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="af2692bfafe78e4a45477e7fca4d57d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2692bfafe78e4a45477e7fca4d57d64">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[54/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ShapeA , typename ShapeB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1deprecated_1_1DigitalShapesIntersection.html">deprecated::DigitalShapesIntersection</a>&lt; ShapeA, ShapeB &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b1a7b9fb65df86c693ec23cf429b7bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1a7b9fb65df86c693ec23cf429b7bf">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[55/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ShapeA , typename ShapeB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1deprecated_1_1DigitalShapesMinus.html">deprecated::DigitalShapesMinus</a>&lt; ShapeA, ShapeB &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2094d74ad8874607e4f63fdc3a268332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2094d74ad8874607e4f63fdc3a268332">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[56/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ShapeA , typename ShapeB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1deprecated_1_1DigitalShapesUnion.html">deprecated::DigitalShapesUnion</a>&lt; ShapeA, ShapeB &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'DigitalShapesDecorator'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'DigitalShapesDecorator' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a522943b7af0902564a6c11c604d0e7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522943b7af0902564a6c11c604d0e7a4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[57/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ShapeA , typename ShapeB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1deprecated_1_1EuclideanShapesIntersection.html">deprecated::EuclideanShapesIntersection</a>&lt; ShapeA, ShapeB &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a69b800670c124959363ed6f19e5efcce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b800670c124959363ed6f19e5efcce">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[58/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ShapeA , typename ShapeB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1deprecated_1_1EuclideanShapesMinus.html">deprecated::EuclideanShapesMinus</a>&lt; ShapeA, ShapeB &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a10f80249972e1a999a12224db8ac1fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f80249972e1a999a12224db8ac1fbc">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[59/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ShapeA , typename ShapeB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1deprecated_1_1EuclideanShapesUnion.html">deprecated::EuclideanShapesUnion</a>&lt; ShapeA, ShapeB &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'EuclideanShapesDecorator'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'EuclideanShapesDecorator' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ae26df83c104fdb5fe631aebda8f31d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26df83c104fdb5fe631aebda8f31d3b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[60/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TGraph , typename TMarkSet &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DepthFirstVisitor.html">DepthFirstVisitor</a>&lt; TGraph, TMarkSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DepthFirstVisitor.html" title="Aim: This class is useful to perform a depth-first exploration of a graph given a starting point or s...">DepthFirstVisitor</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DepthFirstVisitor.html" title="Aim: This class is useful to perform a depth-first exploration of a graph given a starting point or s...">DepthFirstVisitor</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a6cd595721147b6f13350271e1916f163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd595721147b6f13350271e1916f163">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[61/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TPointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1deprecated_1_1IntegralInvariantNormalVectorEstimator.html">DGtal::deprecated::IntegralInvariantNormalVectorEstimator</a>&lt; TKSpace, TPointPredicate &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'IntegralInvariantNormalVectorEstimator'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'IntegralInvariantNormalVectorEstimator' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aea206d459862d088c8f84b87e3ae35f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea206d459862d088c8f84b87e3ae35f6">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[62/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TF , typename TKF , typename TKS , typename TDK &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalSurfaceConvolver.html">DGtal::DigitalSurfaceConvolver</a>&lt; TF, TKF, TKS, TDK, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d6b3b9050f323b4bc23e4d6d86fb028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6b3b9050f323b4bc23e4d6d86fb028">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[63/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TF , typename TKF , typename TKS , typename TDK &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalSurfaceConvolver.html">DGtal::DigitalSurfaceConvolver</a>&lt; TF, TKF, TKS, TDK, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a63db51cb0f46e9f2dc553c760be867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a63db51cb0f46e9f2dc553c760be867">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[64/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TF , typename TKF , typename TKS , typename TDK , Dimension dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalSurfaceConvolver.html">DGtal::DigitalSurfaceConvolver</a>&lt; TF, TKF, TKS, TDK, dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSurfaceConvolver.html">DigitalSurfaceConvolver</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSurfaceConvolver.html">DigitalSurfaceConvolver</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a0736f0d4cdf97e4590b4b9ca7fb7f46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0736f0d4cdf97e4590b4b9ca7fb7f46a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[65/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Space , typename KSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Display3D.html">DGtal::Display3D</a>&lt; <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a38dfaf1641eab4d3fb805df4b52ab10d">Space</a>, <a class="el" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like BallVector,...">Display3D</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like BallVector,...">Display3D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="af1da1d6ecb338834767c80d57338d4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1da1d6ecb338834767c80d57338d4fc">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[66/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TImage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1functors_1_1BoundaryPredicate.html">DGtal::functors::BoundaryPredicate</a>&lt; TKSpace, TImage &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'BoundaryPredicate'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'BoundaryPredicate' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ac1aa44568f4b2968af009d441cc80a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1aa44568f4b2968af009d441cc80a4f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[67/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TImage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1functors_1_1FrontierPredicate.html">DGtal::functors::FrontierPredicate</a>&lt; TKSpace, TImage &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'FrontierPredicate'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'FrontierPredicate' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ab459bc9dd22f00b399b6d8847d6ed92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab459bc9dd22f00b399b6d8847d6ed92e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[68/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSurface , bool isUpward, bool isClosed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1functors_1_1Point2ShapePredicate.html">DGtal::functors::Point2ShapePredicate</a>&lt; TSurface, isUpward, isClosed &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Point2ShapePredicate'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'Point2ShapePredicate' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a763c7c06f6d313a99d43a33f62d766b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763c7c06f6d313a99d43a33f62d766b1">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[69/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalConvexity.html">DigitalConvexity</a>&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalConvexity.html" title="Aim: A helper class to build polytopes from digital sets and to check digital k-convexity.">DigitalConvexity</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalConvexity.html" title="Aim: A helper class to build polytopes from digital sets and to check digital k-convexity.">DigitalConvexity</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ab04f1bbd3a9fbe61dd9dd02aea02d982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab04f1bbd3a9fbe61dd9dd02aea02d982">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[70/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalMetricAdapter.html">DigitalMetricAdapter</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalMetricAdapter.html" title="Aim: simple adapter class which adapts any models of concepts::CMetricSpace to a model of concepts::C...">DigitalMetricAdapter</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalMetricAdapter.html" title="Aim: simple adapter class which adapts any models of concepts::CMetricSpace to a model of concepts::C...">DigitalMetricAdapter</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a59c45b5dc20ec7451c7a12c524bc32f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c45b5dc20ec7451c7a12c524bc32f6">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[71/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalPlanePredicate.html">DigitalPlanePredicate</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalPlanePredicate.html" title="Aim: Representing digital planes, which are digitizations of Euclidean planes, as point predicates.">DigitalPlanePredicate</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalPlanePredicate.html" title="Aim: Representing digital planes, which are digitizations of Euclidean planes, as point predicates.">DigitalPlanePredicate</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a9a808836f9b5bef26687f2fad255818d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a808836f9b5bef26687f2fad255818d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[72/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TDigitalSet &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalSetBoundary.html">DigitalSetBoundary</a>&lt; TKSpace, TDigitalSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSetBoundary.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of a given...">DigitalSetBoundary</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSetBoundary.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of a given...">DigitalSetBoundary</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>a model of CCellularGridSpaceND: the type chosen for the cellular grid space.</td></tr>
    <tr><td class="paramname">TDigitalSet</td><td>a model of CDigitalSet: the type chosen for the set of digital points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addb8d3b558694e4b99b9955af0d38b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb8d3b558694e4b99b9955af0d38b18">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[73/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Domain , typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalSetByAssociativeContainer.html">DigitalSetByAssociativeContainer</a>&lt; <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a>, Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSetByAssociativeContainer.html" title="Aim: A wrapper class around a STL associative container for storing sets of digital points within som...">DigitalSetByAssociativeContainer</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSetByAssociativeContainer.html" title="Aim: A wrapper class around a STL associative container for storing sets of digital points within som...">DigitalSetByAssociativeContainer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="adb588f6147711cedb29da5c595c915cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb588f6147711cedb29da5c595c915cd">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[74/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Domain , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html">DigitalSetBySTLSet</a>&lt; <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a>, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim: A container class for storing sets of digital points within some given domain.">DigitalSetBySTLSet</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim: A container class for storing sets of digital points within some given domain.">DigitalSetBySTLSet</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a355c26edc3c9eaed443df491553bd12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355c26edc3c9eaed443df491553bd12a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[75/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalSetBySTLVector.html">DigitalSetBySTLVector</a>&lt; <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSetBySTLVector.html" title="Aim: Realizes the concept CDigitalSet by using the STL container std::vector.">DigitalSetBySTLVector</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSetBySTLVector.html" title="Aim: Realizes the concept CDigitalSet by using the STL container std::vector.">DigitalSetBySTLVector</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a64c1c0996bfe10bd42952cad2d72ecdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c1c0996bfe10bd42952cad2d72ecdb">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[76/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalSetDomain.html">DigitalSetDomain</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSetDomain.html" title="Aim: Constructs a domain limited to the given digital set.">DigitalSetDomain</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSetDomain.html" title="Aim: Constructs a domain limited to the given digital set.">DigitalSetDomain</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a49b6251ea39e4165f4aff000e4131f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b6251ea39e4165f4aff000e4131f92">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[77/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMapImage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalSetFromMap.html">DigitalSetFromMap</a>&lt; TMapImage &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSetFromMap.html" title="Aim: An adapter for viewing an associative image container like ImageContainerBySTLMap as a simple di...">DigitalSetFromMap</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSetFromMap.html" title="Aim: An adapter for viewing an associative image container like ImageContainerBySTLMap as a simple di...">DigitalSetFromMap</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a6db2f56807d13a3301f7368ce7246f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db2f56807d13a3301f7368ce7246f58">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[78/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalSurfaceTracker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalSurface2DSlice.html">DigitalSurface2DSlice</a>&lt; TDigitalSurfaceTracker &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSurface2DSlice.html" title="Aim: Represents a 2-dimensional slice in a DigitalSurface. In a sense, it is a 4-connected contour,...">DigitalSurface2DSlice</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSurface2DSlice.html" title="Aim: Represents a 2-dimensional slice in a DigitalSurface. In a sense, it is a 4-connected contour,...">DigitalSurface2DSlice</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aa573134cae2a8658a3c6d3da36524cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa573134cae2a8658a3c6d3da36524cc6">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[79/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalSurfaceContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalSurface.html">DigitalSurface</a>&lt; TDigitalSurfaceContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aa49ad0ee550d45074f0aa5179808eb51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49ad0ee550d45074f0aa5179808eb51">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[80/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalSurfaceEmbedder , typename TNormalVectorEstimator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalSurfaceEmbedderWithNormalVectorEstimator.html">DigitalSurfaceEmbedderWithNormalVectorEstimator</a>&lt; TDigitalSurfaceEmbedder, TNormalVectorEstimator &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSurfaceEmbedderWithNormalVectorEstimator.html" title="Aim: Combines a digital surface embedder with a normal vector estimator to get a model of CDigitalSur...">DigitalSurfaceEmbedderWithNormalVectorEstimator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSurfaceEmbedderWithNormalVectorEstimator.html" title="Aim: Combines a digital surface embedder with a normal vector estimator to get a model of CDigitalSur...">DigitalSurfaceEmbedderWithNormalVectorEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a1572c3e1a45017935344cb6abb02ecfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1572c3e1a45017935344cb6abb02ecfb">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[81/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSurface &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalSurfacePredicate.html">DigitalSurfacePredicate</a>&lt; TSurface &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSurfacePredicate.html" title="Aim: A point predicate which tells whether a point belongs to the set of pointels of a given digital ...">DigitalSurfacePredicate</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSurfacePredicate.html" title="Aim: A point predicate which tells whether a point belongs to the set of pointels of a given digital ...">DigitalSurfacePredicate</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a449b924dd8e63c9ae2ebcdc4502c858f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449b924dd8e63c9ae2ebcdc4502c858f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[82/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalSurfaceRegularization.html">DigitalSurfaceRegularization</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSurfaceRegularization.html" title="Aim: Implements Digital Surface Regularization as described in .">DigitalSurfaceRegularization</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSurfaceRegularization.html" title="Aim: Implements Digital Surface Regularization as described in .">DigitalSurfaceRegularization</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a7fbb6c219f9f726cfedde0631fe2f7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fbb6c219f9f726cfedde0631fe2f7a9">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[83/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TForegroundAdjacency , typename TBackgroundAdjacency &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalTopology.html">DigitalTopology</a>&lt; TForegroundAdjacency, TBackgroundAdjacency &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalTopology.html" title="Aim: Represents a digital topology as a couple of adjacency relations.">DigitalTopology</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalTopology.html" title="Aim: Represents a digital topology as a couple of adjacency relations.">DigitalTopology</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a99e2087ab5ab59ae97290712aa847f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e2087ab5ab59ae97290712aa847f3b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[84/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dimEmbedded, Dimension dimAmbient, typename TLinearAlgebraBackend , typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DiscreteExteriorCalculus.html">DiscreteExteriorCalculus</a>&lt; dimEmbedded, dimAmbient, TLinearAlgebraBackend, TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DiscreteExteriorCalculus.html" title="Aim: DiscreteExteriorCalculus represents a calculus in the dec package. This is the main structure in...">DiscreteExteriorCalculus</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DiscreteExteriorCalculus.html" title="Aim: DiscreteExteriorCalculus represents a calculus in the dec package. This is the main structure in...">DiscreteExteriorCalculus</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a60ef2b4a196c4e948d4af4d9c912d31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ef2b4a196c4e948d4af4d9c912d31e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[85/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename S , Order order_in, Duality duality_in, Order order_out, Duality duality_out&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DiscreteExteriorCalculusSolver.html">DiscreteExteriorCalculusSolver</a>&lt; C, S, order_in, duality_in, order_out, duality_out &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DiscreteExteriorCalculusSolver.html" title="Aim: This wraps a linear algebra solver around a discrete exterior calculus.">DiscreteExteriorCalculusSolver</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DiscreteExteriorCalculusSolver.html" title="Aim: This wraps a linear algebra solver around a discrete exterior calculus.">DiscreteExteriorCalculusSolver</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a49730b5a6af3e6dacff53ec86a215a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49730b5a6af3e6dacff53ec86a215a06">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[86/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TGraph , typename TVertexFunctor , typename TMarkSet &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DistanceBreadthFirstVisitor.html">DistanceBreadthFirstVisitor</a>&lt; TGraph, TVertexFunctor, TMarkSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DistanceBreadthFirstVisitor.html" title="Aim: This class is useful to perform an exploration of a graph given a starting point or set (called ...">DistanceBreadthFirstVisitor</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DistanceBreadthFirstVisitor.html" title="Aim: This class is useful to perform an exploration of a graph given a starting point or set (called ...">DistanceBreadthFirstVisitor</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a0d6fd271d4780ea13d45a7b0a62849e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d6fd271d4780ea13d45a7b0a62849e9">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[87/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename P , typename TSep &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DistanceTransformation.html">DistanceTransformation</a>&lt; S, P, TSep &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DistanceTransformation_8h_source.html#l00258">258</a> of file <a class="el" href="DistanceTransformation_8h_source.html">DistanceTransformation.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;  {</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;    <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;    <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3c93240481c27affe2f4d04791c14f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c93240481c27affe2f4d04791c14f08">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[88/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDomain , typename TAdjacency &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DomainAdjacency.html">DomainAdjacency</a>&lt; TDomain, TAdjacency &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DomainAdjacency.html" title="Aim: Given a domain and an adjacency, limits the given adjacency to the specified domain for all adja...">DomainAdjacency</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DomainAdjacency.html" title="Aim: Given a domain and an adjacency, limits the given adjacency to the specified domain for all adja...">DomainAdjacency</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a04e75d59933161af0498eda25de007ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e75d59933161af0498eda25de007ba">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[89/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DSSLengthEstimator.html">DSSLengthEstimator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DSSLengthEstimator.html" title="Aim: a model of CGlobalCurveEstimator that segments the digital curve into DSS and computes the lengt...">DSSLengthEstimator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DSSLengthEstimator.html" title="Aim: a model of CGlobalCurveEstimator that segments the digital curve into DSS and computes the lengt...">DSSLengthEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a57c7d9a956b5cff0d4d26c3d44ea890e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c7d9a956b5cff0d4d26c3d44ea890e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[90/255]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDGtal.html#ab8007ddbb5627666913e18c3b951745d">Duality</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Duality'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'Duality' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aa6d10b79644958ed25bff3bb3909edbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d10b79644958ed25bff3bb3909edbd">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[91/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Ellipse2D.html">Ellipse2D</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Ellipse2D.html" title="Aim: Model of the concept StarShaped represents any ellipse in the plane.">Ellipse2D</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Ellipse2D.html" title="Aim: Model of the concept StarShaped represents any ellipse in the plane.">Ellipse2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a3ae7db27a17af200544f21c515fdae1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae7db27a17af200544f21c515fdae1a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[92/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1EllipticHelix.html">EllipticHelix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1EllipticHelix.html" title="Aim: Implement a parametric curve – elliptic helix.">EllipticHelix</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1EllipticHelix.html" title="Aim: Implement a parametric curve – elliptic helix.">EllipticHelix</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a3d9c279c4bb21a43828810300d1206eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9c279c4bb21a43828810300d1206eb">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[93/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1EstimatorCache.html">EstimatorCache</a>&lt; T, TC &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1EstimatorCache.html" title="Aim: this class adapts any local surface estimator to cache the estimated values in a associative con...">EstimatorCache</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1EstimatorCache.html" title="Aim: this class adapts any local surface estimator to cache the estimated values in a associative con...">EstimatorCache</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="EstimatorCache_8h_source.html#l00300">300</a> of file <a class="el" href="EstimatorCache_8h_source.html">EstimatorCache.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;  {</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="afa6e278dc3833c3664cdd0cd9a20898a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6e278dc3833c3664cdd0cd9a20898a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[94/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , DGtal::uint32_t p, typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ExactPredicateLpPowerSeparableMetric.html">ExactPredicateLpPowerSeparableMetric</a>&lt; T, p, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ExactPredicateLpPowerSeparableMetric.html" title="Aim: implements weighted separable l_p metrics with exact predicates.">ExactPredicateLpPowerSeparableMetric</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ExactPredicateLpPowerSeparableMetric.html" title="Aim: implements weighted separable l_p metrics with exact predicates.">ExactPredicateLpPowerSeparableMetric</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a8b6b29dfb8da033f13dc6afc0728d1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6b29dfb8da033f13dc6afc0728d1c4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[95/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , DGtal::uint32_t p, typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ExactPredicateLpSeparableMetric.html">ExactPredicateLpSeparableMetric</a>&lt; T, p, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ExactPredicateLpSeparableMetric.html" title="Aim: implements separable l_p metrics with exact predicates.">ExactPredicateLpSeparableMetric</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ExactPredicateLpSeparableMetric.html" title="Aim: implements separable l_p metrics with exact predicates.">ExactPredicateLpSeparableMetric</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aa92bbcb0c90cddb06c7f84134c1e4a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa92bbcb0c90cddb06c7f84134c1e4a5f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[96/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Expander.html">Expander</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Expander.html" title="Aim: This class is useful to visit an object by adjacencies, layer by layer.">Expander</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Expander.html" title="Aim: This class is useful to visit an object by adjacencies, layer by layer.">Expander</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a1b596b7d29143ff8043e4666349b7c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b596b7d29143ff8043e4666349b7c4b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[97/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1experimental_1_1ChamferNorm2D.html">experimental::ChamferNorm2D</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'ChamferNorm2D'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'ChamferNorm2D' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aee00a232b8855f43efadbbc22f4111a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee00a232b8855f43efadbbc22f4111a3">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[98/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TSurfelPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html">ExplicitDigitalSurface</a>&lt; TKSpace, TSurfelPredicate &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels....">ExplicitDigitalSurface</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels....">ExplicitDigitalSurface</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>a model of CCellularGridSpaceND: the type chosen for the cellular grid space.</td></tr>
    <tr><td class="paramname">TSurfelPredicate</td><td>a model of CDigitalSet: the type chosen for the set of digital points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1091b09723068081fb14bcbc8c17c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1091b09723068081fb14bcbc8c17c0b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[99/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Filtered2x2DetComputer.html">Filtered2x2DetComputer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Filtered2x2DetComputer.html" title="Aim: Class that provides a way of computing the sign of the determinant of a 2x2 matrix from its four...">Filtered2x2DetComputer</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Filtered2x2DetComputer.html" title="Aim: Class that provides a way of computing the sign of the determinant of a 2x2 matrix from its four...">Filtered2x2DetComputer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ac5bfcec3a6636adb60531b90ebc1818b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5bfcec3a6636adb60531b90ebc1818b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[100/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Flower2D.html">Flower2D</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Flower2D.html" title="Aim: Model of the concept StarShaped represents any flower with k-petals in the plane.">Flower2D</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Flower2D.html" title="Aim: Model of the concept StarShaped represents any flower with k-petals in the plane.">Flower2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aa84025008f3aed7e1e9f290b1822b711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84025008f3aed7e1e9f290b1822b711">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[101/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TSet , typename TPointPredicate , typename TPointFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1FMM.html">FMM</a>&lt; TImage, TSet, TPointPredicate, TPointFunctor &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1FMM.html" title="Aim: Fast Marching Method (FMM) for nd distance transforms.">FMM</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1FMM.html" title="Aim: Fast Marching Method (FMM) for nd distance transforms.">FMM</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a07229b7f7c8d1bada146c67528c9de96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07229b7f7c8d1bada146c67528c9de96">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[102/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TInteger , int connectivity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1FP.html">FP</a>&lt; TIterator, TInteger, connectivity &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aad35009edbde521ecf9374d1efdad61e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad35009edbde521ecf9374d1efdad61e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[103/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1FPLengthEstimator.html">FPLengthEstimator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1FPLengthEstimator.html" title="Aim: a model of CGlobalCurveEstimator that computes the length of a digital curve using its FP (faith...">FPLengthEstimator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1FPLengthEstimator.html" title="Aim: a model of CGlobalCurveEstimator that computes the length of a digital curve using its FP (faith...">FPLengthEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ae081561d2fa45377630974eff2552f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae081561d2fa45377630974eff2552f56">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[104/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1FrechetShortcut.html">FrechetShortcut</a>&lt; TIterator, TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1FrechetShortcut.html" title="Aim: On-line computation Computation of the longest shortcut according to the Fréchet distance for a ...">FrechetShortcut</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1FrechetShortcut.html" title="Aim: On-line computation Computation of the longest shortcut according to the Fréchet distance for a ...">FrechetShortcut</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="af04f7017782434af4136151691f7a774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04f7017782434af4136151691f7a774">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[105/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a>&lt; TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ae1497ed0b31ec222f4ebc35be862ee16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1497ed0b31ec222f4ebc35be862ee16">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[106/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1FrontInsertionSequenceToStackAdapter.html">FrontInsertionSequenceToStackAdapter</a>&lt; TSequence &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1FrontInsertionSequenceToStackAdapter.html" title="Aim: This class implements a dynamic adapter to an instance of a model of front insertion sequence in...">FrontInsertionSequenceToStackAdapter</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1FrontInsertionSequenceToStackAdapter.html" title="Aim: This class implements a dynamic adapter to an instance of a model of front insertion sequence in...">FrontInsertionSequenceToStackAdapter</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a3fa72caba0ce21c2d9ae0ef622f6ca29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa72caba0ce21c2d9ae0ef622f6ca29">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[107/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TF , typename TKS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1FunctorOnCells.html">FunctorOnCells</a>&lt; TF, TKS &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1FunctorOnCells.html" title="Aim: Convert a functor on Digital Point to a Functor on Khalimsky Cell.">FunctorOnCells</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1FunctorOnCells.html" title="Aim: Convert a functor on Digital Point to a Functor on Khalimsky Cell.">FunctorOnCells</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aa40ca76cd3d190bc9a1bde85e4610786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40ca76cd3d190bc9a1bde85e4610786">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[108/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace , typename TEuclideanShape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1GaussDigitizer.html">GaussDigitizer</a>&lt; TSpace, TEuclideanShape &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1GaussDigitizer.html" title="Aim: A class for computing the Gauss digitization of some Euclidean shape, i.e. its intersection with...">GaussDigitizer</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1GaussDigitizer.html" title="Aim: A class for computing the Gauss digitization of some Euclidean shape, i.e. its intersection with...">GaussDigitizer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a780bffe88dbcc0c1e8d268c165f2730c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780bffe88dbcc0c1e8d268c165f2730c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[109/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PValue , int PDefaultPreset, int PDefaultFirstColor, int PDefaultLastColor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1GradientColorMap.html">GradientColorMap</a>&lt; PValue, PDefaultPreset, PDefaultFirstColor, PDefaultLastColor &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1GradientColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">GradientColorMap</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1GradientColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">GradientColorMap</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a4ff5ef7c415d75ea4c324c23b7f49140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff5ef7c415d75ea4c324c23b7f49140">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[110/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TGraphVisitor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1GraphVisitorRange.html">GraphVisitorRange</a>&lt; TGraphVisitor &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1GraphVisitorRange.html" title="Aim: Transforms a graph visitor into a single pass input range.">GraphVisitorRange</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1GraphVisitorRange.html" title="Aim: Transforms a graph visitor into a single pass input range.">GraphVisitorRange</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a485151b618f71a80d057c3c7d35e84ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485151b618f71a80d057c3c7d35e84ca">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[111/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1GrayscaleColorMap.html">GrayscaleColorMap</a>&lt; PValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1GrayscaleColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into gray l...">GrayscaleColorMap</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1GrayscaleColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into gray l...">GrayscaleColorMap</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a52995248ae36d8cd61977cf8e37c63bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52995248ae36d8cd61977cf8e37c63bc">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[112/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SegmentComputer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1GreedySegmentation.html">GreedySegmentation</a>&lt; <a class="el" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#a51bb21fda3840e1eff0ee53753ebcbc3">SegmentComputer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1GreedySegmentation.html" title="Aim: Computes the greedy segmentation of a range given by a pair of ConstIterators....">GreedySegmentation</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1GreedySegmentation.html" title="Aim: Computes the greedy segmentation of a range given by a pair of ConstIterators....">GreedySegmentation</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a33bee6b2124dccce74416d0cfeef2cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33bee6b2124dccce74416d0cfeef2cc1">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[113/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1GridCurve.html">GridCurve</a>&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1GridCurve.html" title="Aim: describes, in a cellular space of dimension n, a closed or open sequence of signed d-cells (or d...">GridCurve</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1GridCurve.html" title="Aim: describes, in a cellular space of dimension n, a closed or open sequence of signed d-cells (or d...">GridCurve</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="af4d394b77876cb7d9afb5a55bd6dd19b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d394b77876cb7d9afb5a55bd6dd19b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[114/255]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1HalfEdgeDataStructure.html">HalfEdgeDataStructure</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1HalfEdgeDataStructure.html" title="Aim: This class represents an half-edge data structure, which is a structure for representing the top...">HalfEdgeDataStructure</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1HalfEdgeDataStructure.html" title="Aim: This class represents an half-edge data structure, which is a structure for representing the top...">HalfEdgeDataStructure</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aa0e04d0ec7f74b2b1cb5c3b91608814f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e04d0ec7f74b2b1cb5c3b91608814f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[115/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TQuantity , typename TBinner &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Histogram.html">Histogram</a>&lt; TQuantity, TBinner &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Histogram.html" title="Aim: Represents a typical histogram in statistics, which is a discrete estimate of the probability di...">Histogram</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Histogram.html" title="Aim: Represents a typical histogram in statistics, which is a discrete estimate of the probability di...">Histogram</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a69f3490f30f770c8fc9fc6dd445cd93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f3490f30f770c8fc9fc6dd445cd93c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[116/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PValue , int DefaultCycles&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1HueShadeColorMap.html">HueShadeColorMap</a>&lt; PValue, DefaultCycles &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1HueShadeColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">HueShadeColorMap</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1HueShadeColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">HueShadeColorMap</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a2af95afbaeec3e49ad813181f4f2f115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af95afbaeec3e49ad813181f4f2f115">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[117/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1HyperRectDomain.html">HyperRectDomain</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a4801ed1e1263f017f891f2ad81c73beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4801ed1e1263f017f891f2ad81c73beb">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[118/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Image.html">Image</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a6600699772a4cb84168f5df6de7fb9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6600699772a4cb84168f5df6de7fb9fb">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[119/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImageContainer , typename TNewDomain , typename TFunctorD , typename TNewValue , typename TFunctorV , typename TFunctorVm1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImageAdapter.html">ImageAdapter</a>&lt; TImageContainer, TNewDomain, TFunctorD, TNewValue, TFunctorV, TFunctorVm1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImageAdapter.html" title="Aim: implements an image adapter with a given domain (i.e. a subdomain) and 3 functors : g for domain...">ImageAdapter</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImageAdapter.html" title="Aim: implements an image adapter with a given domain (i.e. a subdomain) and 3 functors : g for domain...">ImageAdapter</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a023df84c861e7dd414bae501a62aff19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023df84c861e7dd414bae501a62aff19">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[120/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImageContainer , typename TImageFactory , typename TReadPolicy , typename TWritePolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImageCache.html">ImageCache</a>&lt; TImageContainer, TImageFactory, TReadPolicy, TWritePolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImageCache.html" title="Aim: implements an images cache with &#39;read and write&#39; policies.">ImageCache</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImageCache.html" title="Aim: implements an images cache with &#39;read and write&#39; policies.">ImageCache</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aeaf8e0ddcbbe3ba4780a5c8589c4fc41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf8e0ddcbbe3ba4780a5c8589c4fc41">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[121/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImageContainerByITKImage.html">ImageContainerByITKImage</a>&lt; T, TV &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImageContainerByITKImage.html" title="Aim: implements a model of CImageContainer using a ITK Image.">ImageContainerByITKImage</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImageContainerByITKImage.html" title="Aim: implements a model of CImageContainer using a ITK Image.">ImageContainerByITKImage</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a30d8ad5b6fd2dc5b1a3cff0afc4e3a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d8ad5b6fd2dc5b1a3cff0afc4e3a5c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[122/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDomain , typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a>&lt; TDomain, TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ImageContainerBySTLMap_8h_source.html#l00273">273</a> of file <a class="el" href="ImageContainerBySTLMap_8h_source.html">ImageContainerBySTLMap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;  {</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    <span class="keywordtype">object</span>.selfDisplay ( out );</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="afec460eda081b4dc6922174819cae6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec460eda081b4dc6922174819cae6cc">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[123/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Domain , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>&lt; <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a>, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ImageContainerBySTLVector_8h_source.html#l00544">544</a> of file <a class="el" href="ImageContainerBySTLVector_8h_source.html">ImageContainerBySTLVector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;  {</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;    <span class="keywordtype">object</span>.selfDisplay ( out );</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;    <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a11c7224d39e1bb3537f8c5d6012e1921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c7224d39e1bb3537f8c5d6012e1921">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[124/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImageContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImageFactoryFromHDF5.html">ImageFactoryFromHDF5</a>&lt; TImageContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImageFactoryFromHDF5.html" title="Aim: implements a factory from an HDF5 file.">ImageFactoryFromHDF5</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImageFactoryFromHDF5.html" title="Aim: implements a factory from an HDF5 file.">ImageFactoryFromHDF5</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aa86c21332bf1c7be1c10b6f80939273a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86c21332bf1c7be1c10b6f80939273a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[125/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImageContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImageFactoryFromImage.html">ImageFactoryFromImage</a>&lt; TImageContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImageFactoryFromImage.html" title="Aim: implements a factory to produce images from a &quot;bigger/original&quot; one according to a given domain.">ImageFactoryFromImage</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImageFactoryFromImage.html" title="Aim: implements a factory to produce images from a &quot;bigger/original&quot; one according to a given domain.">ImageFactoryFromImage</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a2ad893514689ceaf38eb331feb0cbb83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad893514689ceaf38eb331feb0cbb83">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[126/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TImage , typename TEmbedder &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImageLinearCellEmbedder.html">ImageLinearCellEmbedder</a>&lt; TKSpace, TImage, TEmbedder &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImageLinearCellEmbedder.html" title="Aim: a cellular embedder for images. (default constructible, copy constructible, assignable)....">ImageLinearCellEmbedder</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImageLinearCellEmbedder.html" title="Aim: a cellular embedder for images. (default constructible, copy constructible, assignable)....">ImageLinearCellEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="af728c4929cf5c46f199d45708df92f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af728c4929cf5c46f199d45708df92f8f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[127/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImplicitBall.html">ImplicitBall</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitBall.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create a ball in nD....">ImplicitBall</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitBall.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create a ball in nD....">ImplicitBall</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="abcbd59ad8a40756a291c741c52dc1712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcbd59ad8a40756a291c741c52dc1712">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[128/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TPointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html">ImplicitDigitalSurface</a>&lt; TKSpace, TPointPredicate &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">ImplicitDigitalSurface</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">ImplicitDigitalSurface</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>a model of CCellularGridSpaceND: the type chosen for the cellular grid space.</td></tr>
    <tr><td class="paramname">TPointPredicate</td><td>a model of CDigitalSet: the type chosen for the set of digital points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc264aee8a9229888ae63aecb0197111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc264aee8a9229888ae63aecb0197111">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[129/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TImplicitFunctionDiff1 , typename TEmbedder &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImplicitFunctionDiff1LinearCellEmbedder.html">ImplicitFunctionDiff1LinearCellEmbedder</a>&lt; TKSpace, TImplicitFunctionDiff1, TEmbedder &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitFunctionDiff1LinearCellEmbedder.html" title="Aim: a cellular embedder for implicit functions, (default constructible, copy constructible,...">ImplicitFunctionDiff1LinearCellEmbedder</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitFunctionDiff1LinearCellEmbedder.html" title="Aim: a cellular embedder for implicit functions, (default constructible, copy constructible,...">ImplicitFunctionDiff1LinearCellEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a4af248a4c1de019c3ed17fe479c1f341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af248a4c1de019c3ed17fe479c1f341">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[130/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TImplicitFunction , typename TEmbedder &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImplicitFunctionLinearCellEmbedder.html">ImplicitFunctionLinearCellEmbedder</a>&lt; TKSpace, TImplicitFunction, TEmbedder &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitFunctionLinearCellEmbedder.html" title="Aim: a cellular embedder for implicit functions, (default constructible, copy constructible,...">ImplicitFunctionLinearCellEmbedder</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitFunctionLinearCellEmbedder.html" title="Aim: a cellular embedder for implicit functions, (default constructible, copy constructible,...">ImplicitFunctionLinearCellEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a05d2b3f53e85f184b3a41a78ffbd8e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d2b3f53e85f184b3a41a78ffbd8e52">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[131/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImplicitHyperCube.html">ImplicitHyperCube</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitHyperCube.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create an hypercube in n...">ImplicitHyperCube</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitHyperCube.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create an hypercube in n...">ImplicitHyperCube</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ac1f3b2e62918e689beb5d66ea49554ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f3b2e62918e689beb5d66ea49554ea">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[132/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImplicitNorm1Ball.html">ImplicitNorm1Ball</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitNorm1Ball.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create a ball for the L_...">ImplicitNorm1Ball</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitNorm1Ball.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create a ball for the L_...">ImplicitNorm1Ball</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a31c3aec34372e12bb2a4b530ebefb1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c3aec34372e12bb2a4b530ebefb1b6">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[133/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImplicitPolynomial3Shape.html">ImplicitPolynomial3Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitPolynomial3Shape.html" title="Aim: model of CEuclideanOrientedShape concepts to create a shape from a polynomial.">ImplicitPolynomial3Shape</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitPolynomial3Shape.html" title="Aim: model of CEuclideanOrientedShape concepts to create a shape from a polynomial.">ImplicitPolynomial3Shape</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a68fb8525ad5cc983a11b2a8a44b70664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68fb8525ad5cc983a11b2a8a44b70664">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[134/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImplicitRoundedHyperCube.html">ImplicitRoundedHyperCube</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitRoundedHyperCube.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create a rounded hypercu...">ImplicitRoundedHyperCube</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitRoundedHyperCube.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create a rounded hypercu...">ImplicitRoundedHyperCube</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a6cb9dc46e99031f7f6d6969480f906b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb9dc46e99031f7f6d6969480f906b3">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[135/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalSurfaceContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1IndexedDigitalSurface.html">IndexedDigitalSurface</a>&lt; TDigitalSurfaceContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1IndexedDigitalSurface.html" title="Aim: Represents a digital surface with the topology of its dual surface. Its aim is to mimick the sta...">IndexedDigitalSurface</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1IndexedDigitalSurface.html" title="Aim: Represents a digital surface with the topology of its dual surface. Its aim is to mimick the sta...">IndexedDigitalSurface</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ac0710d6ab8bf5a49ea5634d8c6675ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0710d6ab8bf5a49ea5634d8c6675ae3">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[136/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TValue , unsigned int N, unsigned int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1IndexedListWithBlocks.html">IndexedListWithBlocks</a>&lt; TValue, N, M &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1IndexedListWithBlocks.html" title="Aim: Represents a mixed list/array structure which is useful in some context. It is essentially a lis...">IndexedListWithBlocks</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1IndexedListWithBlocks.html" title="Aim: Represents a mixed list/array structure which is useful in some context. It is essentially a lis...">IndexedListWithBlocks</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TValue</td><td>the type for the values stored in the list. </td></tr>
    <tr><td class="paramname">N</td><td>the number of value stored in the first block. </td></tr>
    <tr><td class="paramname">M</td><td>the number of value stored in the further blocks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b6ff11f2a468df0c081b71d67268e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6ff11f2a468df0c081b71d67268e96">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[137/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1InexactPredicateLpSeparableMetric.html">InexactPredicateLpSeparableMetric</a>&lt; T, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1InexactPredicateLpSeparableMetric.html" title="Aim: implements separable l_p metrics with approximated predicates.">InexactPredicateLpSeparableMetric</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1InexactPredicateLpSeparableMetric.html" title="Aim: implements separable l_p metrics with approximated predicates.">InexactPredicateLpSeparableMetric</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a2ebae8f75da20280aa574fe408cbb297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebae8f75da20280aa574fe408cbb297">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[138/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint , typename TDetComputer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1InGeneralizedDiskOfGivenRadius.html">InGeneralizedDiskOfGivenRadius</a>&lt; TPoint, TDetComputer &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1InGeneralizedDiskOfGivenRadius.html" title="Aim: This class implements an orientation functor that   provides a way to determine the position of ...">InGeneralizedDiskOfGivenRadius</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1InGeneralizedDiskOfGivenRadius.html" title="Aim: This class implements an orientation functor that   provides a way to determine the position of ...">InGeneralizedDiskOfGivenRadius</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a0731f53e4d71e43de135446d19c83c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0731f53e4d71e43de135446d19c83c5e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[139/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint , typename TDetComputer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1InHalfPlaneBy2x2DetComputer.html">InHalfPlaneBy2x2DetComputer</a>&lt; TPoint, TDetComputer &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1InHalfPlaneBy2x2DetComputer.html" title="Aim: Class that implements an orientation functor, ie. it provides a way to compute the orientation o...">InHalfPlaneBy2x2DetComputer</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1InHalfPlaneBy2x2DetComputer.html" title="Aim: Class that implements an orientation functor, ie. it provides a way to compute the orientation o...">InHalfPlaneBy2x2DetComputer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aa8708acb96a6cc02fd2e7b68e6a7bd94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8708acb96a6cc02fd2e7b68e6a7bd94">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[140/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint , typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1InHalfPlaneBySimple3x3Matrix.html">InHalfPlaneBySimple3x3Matrix</a>&lt; TPoint, TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1InHalfPlaneBySimple3x3Matrix.html" title="Aim: Class that implements an orientation functor, ie. it provides a way to compute the orientation o...">InHalfPlaneBySimple3x3Matrix</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1InHalfPlaneBySimple3x3Matrix.html" title="Aim: Class that implements an orientation functor, ie. it provides a way to compute the orientation o...">InHalfPlaneBySimple3x3Matrix</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ae19ddb54377bb60c5a14e7e9af00c3b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19ddb54377bb60c5a14e7e9af00c3b8">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[141/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSequence , typename TRank &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1InputIteratorWithRankOnSequence.html">InputIteratorWithRankOnSequence</a>&lt; TSequence, TRank &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1InputIteratorWithRankOnSequence.html" title="Aim: Useful to create an iterator that returns a pair (value,rank) when visiting a sequence....">InputIteratorWithRankOnSequence</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1InputIteratorWithRankOnSequence.html" title="Aim: Useful to create an iterator that returns a pair (value,rank) when visiting a sequence....">InputIteratorWithRankOnSequence</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a0fdf109dc892d82f133d5d3ed255e8cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fdf109dc892d82f133d5d3ed255e8cf">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[142/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1IntegerComputer.html">IntegerComputer</a>&lt; TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1IntegerComputer.html" title="Aim: This class gathers several types and methods to make computation with integers.">IntegerComputer</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1IntegerComputer.html" title="Aim: This class gathers several types and methods to make computation with integers.">IntegerComputer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a7679602f19341f9e6de0d3251974e425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7679602f19341f9e6de0d3251974e425">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[143/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TPointPredicate , typename TCovarianceMatrixFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1IntegralInvariantCovarianceEstimator.html">IntegralInvariantCovarianceEstimator</a>&lt; TKSpace, TPointPredicate, TCovarianceMatrixFunctor &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1IntegralInvariantCovarianceEstimator.html" title="Aim: This class implement an Integral Invariant estimator which computes for each surfel the covarian...">IntegralInvariantCovarianceEstimator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1IntegralInvariantCovarianceEstimator.html" title="Aim: This class implement an Integral Invariant estimator which computes for each surfel the covarian...">IntegralInvariantCovarianceEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="af2ea70a7ae784d6d548e9a0f033cfbc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ea70a7ae784d6d548e9a0f033cfbc2">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[144/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TPointPredicate , typename TVolumeFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1IntegralInvariantVolumeEstimator.html">IntegralInvariantVolumeEstimator</a>&lt; TKSpace, TPointPredicate, TVolumeFunctor &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1IntegralInvariantVolumeEstimator.html" title="Aim: This class implement an Integral Invariant estimator which computes for each surfel the volume o...">IntegralInvariantVolumeEstimator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1IntegralInvariantVolumeEstimator.html" title="Aim: This class implement an Integral Invariant estimator which computes for each surfel the volume o...">IntegralInvariantVolumeEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a77ff5382c423736c8d4abc902b00f86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ff5382c423736c8d4abc902b00f86b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[145/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TO , typename TD , typename TS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1KanungoNoise.html">KanungoNoise</a>&lt; TO, TD, TS &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1KanungoNoise.html" title="Aim: From a point predicate (model of concepts::CPointPredicate), this class constructs another point...">KanungoNoise</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1KanungoNoise.html" title="Aim: From a point predicate (model of concepts::CPointPredicate), this class constructs another point...">KanungoNoise</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a9fe554a60d1abe7f9058e3da39bff5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe554a60d1abe7f9058e3da39bff5f2">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[146/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Calculus , Order order, Duality duality&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1KForm.html">KForm</a>&lt; Calculus, order, duality &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1KForm.html" title="Aim: KForm represents discrete kforms in the dec package.">KForm</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1KForm.html" title="Aim: KForm represents discrete kforms in the dec package.">KForm</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a36f9d0220351cf40a44a1430fc7dcb6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f9d0220351cf40a44a1430fc7dcb6b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[147/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1KhalimskyCell.html">KhalimskyCell</a>&lt; <a class="el" href="viewDualSurface_8cpp.html#a1a254aa17418553bc21790001a69262a">dim</a>, TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d9cee3dbb4ab230a228781ea72aee8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9cee3dbb4ab230a228781ea72aee8a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[148/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1KhalimskyPreCell.html">KhalimskyPreCell</a>&lt; <a class="el" href="viewDualSurface_8cpp.html#a1a254aa17418553bc21790001a69262a">dim</a>, TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04c5e0b95cb3bf61322d889850690c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c5e0b95cb3bf61322d889850690c71">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[149/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1KhalimskyPreSpaceND.html">KhalimskyPreSpaceND</a>&lt; <a class="el" href="viewDualSurface_8cpp.html#a1a254aa17418553bc21790001a69262a">dim</a>, TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1KhalimskyPreSpaceND.html" title="Aim: This class is a model of CPreCellularGridSpaceND. It represents the cubical grid as a cell compl...">KhalimskyPreSpaceND</a>'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1KhalimskyPreSpaceND.html" title="Aim: This class is a model of CPreCellularGridSpaceND. It represents the cubical grid as a cell compl...">KhalimskyPreSpaceND</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a690f8c5f9f1d11d71b088ef5141506fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a690f8c5f9f1d11d71b088ef5141506fa">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[150/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1KhalimskySpaceND.html">KhalimskySpaceND</a>&lt; <a class="el" href="viewDualSurface_8cpp.html#a1a254aa17418553bc21790001a69262a">dim</a>, TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex,...">KhalimskySpaceND</a>'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex,...">KhalimskySpaceND</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a5a25bfadf0ecc79a624225fa726eda98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a25bfadf0ecc79a624225fa726eda98">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[151/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Knot__3__1.html">Knot_3_1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Knot__3__1.html" title="Aim: Implement a parametrized knot 3, 1.">Knot_3_1</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Knot__3__1.html" title="Aim: Implement a parametrized knot 3, 1.">Knot_3_1</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a65dc86a5e952018090bb442075f2f3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65dc86a5e952018090bb442075f2f3e5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[152/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Knot__3__2.html">Knot_3_2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Knot__3__2.html" title="Aim: Implement a parametrized knot 3, 2.">Knot_3_2</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Knot__3__2.html" title="Aim: Implement a parametrized knot 3, 2.">Knot_3_2</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a7eca44a4ba4ed42741d260583557212f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eca44a4ba4ed42741d260583557212f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[153/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Knot__4__1.html">Knot_4_1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Knot__4__1.html" title="Aim: Implement a parametrized knot 4, 1.">Knot_4_1</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Knot__4__1.html" title="Aim: Implement a parametrized knot 4, 1.">Knot_4_1</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a733cf1c9b875cd3f8c18c6bbf1841893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733cf1c9b875cd3f8c18c6bbf1841893">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[154/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Knot__4__3.html">Knot_4_3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Knot__4__3.html" title="Aim: Implement a parametrized knot 4, 3.">Knot_4_3</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Knot__4__3.html" title="Aim: Implement a parametrized knot 4, 3.">Knot_4_3</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a1ecadd83849320d83affa80e3c3c852d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ecadd83849320d83affa80e3c3c852d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[155/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Knot__5__1.html">Knot_5_1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Knot__5__1.html" title="Aim: Implement a parametrized knot 5, 1.">Knot_5_1</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Knot__5__1.html" title="Aim: Implement a parametrized knot 5, 1.">Knot_5_1</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ad94e5bad4aaefc658eca711c984a893f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94e5bad4aaefc658eca711c984a893f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[156/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Knot__5__2.html">Knot_5_2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Knot__5__2.html" title="Aim: Implement a parametrized knot 5, 2.">Knot_5_2</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Knot__5__2.html" title="Aim: Implement a parametrized knot 5, 2.">Knot_5_2</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aedbe5917024ddd86e10c8d0ada4d8aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedbe5917024ddd86e10c8d0ada4d8aa7">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[157/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Knot__6__2.html">Knot_6_2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Knot__6__2.html" title="Aim: Implement a parametrized knot 6, 2.">Knot_6_2</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Knot__6__2.html" title="Aim: Implement a parametrized knot 6, 2.">Knot_6_2</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aa1c4d2148956f5217d68919bf2e08aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c4d2148956f5217d68919bf2e08aca">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[158/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Knot__7__4.html">Knot_7_4</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Knot__7__4.html" title="Aim: Implement a parametrized knot 7, 4.">Knot_7_4</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Knot__7__4.html" title="Aim: Implement a parametrized knot 7, 4.">Knot_7_4</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ad3b4d33a9a76cf8cc90f45fcb62eb256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b4d33a9a76cf8cc90f45fcb62eb256">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[159/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1L1LengthEstimator.html">L1LengthEstimator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1L1LengthEstimator.html" title="Aim: a simple model of CGlobalCurveEstimator that compute the length of a curve using the l_1 metric ...">L1LengthEstimator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1L1LengthEstimator.html" title="Aim: a simple model of CGlobalCurveEstimator that compute the length of a curve using the l_1 metric ...">L1LengthEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a5b63a43f6b19a92c34643093e89a3793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b63a43f6b19a92c34643093e89a3793">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[160/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TData , unsigned int L, typename TWord , unsigned int N, unsigned int M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1LabelledMap.html">LabelledMap</a>&lt; TData, L, TWord, N, M &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1LabelledMap.html" title="Aim: Represents a map label -&gt; data, where the label is an integer between 0 and a constant L-1....">LabelledMap</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1LabelledMap.html" title="Aim: Represents a map label -&gt; data, where the label is an integer between 0 and a constant L-1....">LabelledMap</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TData</td><td>the type for the datas stored in the list. </td></tr>
    <tr><td class="paramname">N</td><td>the number of data stored in the first block. </td></tr>
    <tr><td class="paramname">M</td><td>the number of data stored in the further blocks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16183bd6f2ac4e08c138a8cdc6e1bb38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16183bd6f2ac4e08c138a8cdc6e1bb38">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[161/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int L, typename TWord &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Labels.html">Labels</a>&lt; L, TWord &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Labels.html" title="Aim: Stores a set of labels in {O..L-1} as a sequence of bits.">Labels</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Labels.html" title="Aim: Stores a set of labels in {O..L-1} as a sequence of bits.">Labels</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="afdf45b70010000c54be994f9777daa9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf45b70010000c54be994f9777daa9c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[162/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace , typename TSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1LatticePolytope2D.html">LatticePolytope2D</a>&lt; TSpace, TSequence &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1LatticePolytope2D.html" title="Aim: Represents a 2D polytope, i.e. a convex polygon, in the two-dimensional digital plane....">LatticePolytope2D</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1LatticePolytope2D.html" title="Aim: Represents a 2D polytope, i.e. a convex polygon, in the two-dimensional digital plane....">LatticePolytope2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a620f080132158f27407b75993a208254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620f080132158f27407b75993a208254">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[163/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Lemniscate2D.html">Lemniscate2D</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Lemniscate2D.html" title="Aim: Model of the concept StarShaped represents a lemniscate.">Lemniscate2D</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Lemniscate2D.html" title="Aim: Model of the concept StarShaped represents a lemniscate.">Lemniscate2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a15355fc66cdd9267509b7e1820bb849e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15355fc66cdd9267509b7e1820bb849e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[164/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TSurfelPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html">LightExplicitDigitalSurface</a>&lt; TKSpace, TSurfelPredicate &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels....">LightExplicitDigitalSurface</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels....">LightExplicitDigitalSurface</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>a model of CCellularGridSpaceND: the type chosen for the cellular grid space.</td></tr>
    <tr><td class="paramname">TSurfelPredicate</td><td>a model of CDigitalSet: the type chosen for the set of digital points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10dd39d3611456c2f7ed0cfcbaa7607d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10dd39d3611456c2f7ed0cfcbaa7607d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[165/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TPointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html">LightImplicitDigitalSurface</a>&lt; TKSpace, TPointPredicate &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">LightImplicitDigitalSurface</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">LightImplicitDigitalSurface</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>a model of CCellularGridSpaceND: the type chosen for the cellular grid space.</td></tr>
    <tr><td class="paramname">TPointPredicate</td><td>a model of CDigitalSet: the type chosen for the set of digital points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6834567c24d154928475a6b96342a843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6834567c24d154928475a6b96342a843">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[166/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Calculus , Order order_in, Duality duality_in, Order order_out, Duality duality_out&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1LinearOperator.html">LinearOperator</a>&lt; Calculus, order_in, duality_in, order_out, duality_out &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1LinearOperator.html" title="Aim: LinearOperator represents discrete linear operator between discrete kforms in the DEC package.">LinearOperator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1LinearOperator.html" title="Aim: LinearOperator represents discrete linear operator between discrete kforms in the DEC package.">LinearOperator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ace8b645584f9d30e9b1f4d01e378d960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8b645584f9d30e9b1f4d01e378d960">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[167/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TD , typename TV , typename TF , typename TC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1LocalEstimatorFromSurfelFunctorAdapter.html">LocalEstimatorFromSurfelFunctorAdapter</a>&lt; TD, TV, TF, TC &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1LocalEstimatorFromSurfelFunctorAdapter.html" title="Aim: this class adapts any local functor on digital surface element to define a local estimator....">LocalEstimatorFromSurfelFunctorAdapter</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1LocalEstimatorFromSurfelFunctorAdapter.html" title="Aim: this class adapts any local functor on digital surface element to define a local estimator....">LocalEstimatorFromSurfelFunctorAdapter</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a4b42fcfed8d9da681ea8e96f44e3c968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b42fcfed8d9da681ea8e96f44e3c968">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[168/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1LpMetric.html">LpMetric</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1LpMetric.html" title="Aim: implements l_p metrics.">LpMetric</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1LpMetric.html" title="Aim: implements l_p metrics.">LpMetric</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="LpMetric_8h_source.html#l00218">218</a> of file <a class="el" href="LpMetric_8h_source.html">LpMetric.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;  {</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae7832de2b6244193509a272a51cf1b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7832de2b6244193509a272a51cf1b97">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[169/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSurface &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MaximalSegmentSliceEstimation.html">MaximalSegmentSliceEstimation</a>&lt; TSurface &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1MaximalSegmentSliceEstimation.html" title="Aim:">MaximalSegmentSliceEstimation</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1MaximalSegmentSliceEstimation.html" title="Aim:">MaximalSegmentSliceEstimation</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a0028318421129719df74990e535e5333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0028318421129719df74990e535e5333">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[170/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TProfile &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MeaningfulScaleAnalysis.html">MeaningfulScaleAnalysis</a>&lt; TProfile &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1MeaningfulScaleAnalysis.html" title="Aim: This class implements different methods used to define the meaningful scale analysis as proposed...">MeaningfulScaleAnalysis</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1MeaningfulScaleAnalysis.html" title="Aim: This class implements different methods used to define the meaningful scale analysis as proposed...">MeaningfulScaleAnalysis</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a71ebae2f928719f51222d9830f580ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ebae2f928719f51222d9830f580ab6">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[171/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Measure.html">Measure</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Measure.html" title="Aim: Implements a simple measure computation (in the Lesbegue sens) of a set. In dimension 2,...">Measure</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Measure.html" title="Aim: Implements a simple measure computation (in the Lesbegue sens) of a set. In dimension 2,...">Measure</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a4dd9b278acef50a90b1e4bbe9c902812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd9b278acef50a90b1e4bbe9c902812">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[172/255]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MeasureOfStraightLines.html">MeasureOfStraightLines</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1MeasureOfStraightLines.html" title="The aim of this class is to compute the measure in the Lebesgues sense of the set of straight lines a...">MeasureOfStraightLines</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1MeasureOfStraightLines.html" title="The aim of this class is to compute the measure in the Lebesgues sense of the set of straight lines a...">MeasureOfStraightLines</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aa1abd773c091694b461af4dbcce4f2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1abd773c091694b461af4dbcce4f2f0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[173/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint , typename TOrientationFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MelkmanConvexHull.html">MelkmanConvexHull</a>&lt; TPoint, TOrientationFunctor &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1MelkmanConvexHull.html" title="Aim: This class implements the on-line algorithm of Melkman for the computation of the convex hull of...">MelkmanConvexHull</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1MelkmanConvexHull.html" title="Aim: This class implements the on-line algorithm of Melkman for the computation of the convex hull of...">MelkmanConvexHull</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a0abcd22e252a4cb35a43eb765c1c9a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abcd22e252a4cb35a43eb765c1c9a46">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[174/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Mesh.html">Mesh</a>&lt; TPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces....">Mesh</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces....">Mesh</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a6358ae6509cbb7033680e30b29ef66ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6358ae6509cbb7033680e30b29ef66ed">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[175/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace , Dimension maxNorm1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MetricAdjacency.html">MetricAdjacency</a>&lt; TSpace, maxNorm1, TSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1MetricAdjacency.html" title="Aim: Describes digital adjacencies in digital spaces that are defined with the 1-norm and the infinit...">MetricAdjacency</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1MetricAdjacency.html" title="Aim: Describes digital adjacencies in digital spaces that are defined with the 1-norm and the infinit...">MetricAdjacency</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ac13ca2f20ff58b8ad3ca749681226fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac13ca2f20ff58b8ad3ca749681226fa8">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[176/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MLPLengthEstimator.html">MLPLengthEstimator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1MLPLengthEstimator.html" title="Aim: a model of CGlobalCurveEstimator that computes the length of a digital curve using its MLP (give...">MLPLengthEstimator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1MLPLengthEstimator.html" title="Aim: a model of CGlobalCurveEstimator that computes the length of a digital curve using its MLP (give...">MLPLengthEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ae4f0a1e7a73fe21a13f6809e3a47ff0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f0a1e7a73fe21a13f6809e3a47ff0c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[177/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ModuloComputer.html">ModuloComputer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Displays <code>object</code> on the output stream <code>out</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of integer for the modulo computer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream </td></tr>
    <tr><td class="paramname">object</td><td>the object to display. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ModuloComputer_8h_source.html#l00205">205</a> of file <a class="el" href="ModuloComputer_8h_source.html">ModuloComputer.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;  {</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab1843226ad5d68036826cf9c7dc70bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1843226ad5d68036826cf9c7dc70bdd">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[178/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename TRing , class TAlloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; N, TRing, TAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field.">MPolynomial</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field.">MPolynomial</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ab94a183d64e1d3e73261193fb5268ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94a183d64e1d3e73261193fb5268ed6">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[179/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, typename TRing , typename TAlloc , typename TIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomialReader.html">MPolynomialReader</a>&lt; n, TRing, TAlloc, TIterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1MPolynomialReader.html" title="Aim: This class converts a string polynomial expression in a multivariate polynomial.">MPolynomialReader</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1MPolynomialReader.html" title="Aim: This class converts a string polynomial expression in a multivariate polynomial.">MPolynomialReader</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a0d054227f3036a137b394b4b2dca215b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d054227f3036a137b394b4b2dca215b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[180/255]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MultiStatistics.html">MultiStatistics</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1MultiStatistics.html" title="Aim: This class stores a set of sample values for several variables and can then compute different st...">MultiStatistics</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1MultiStatistics.html" title="Aim: This class stores a set of sample values for several variables and can then compute different st...">MultiStatistics</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a6d604a62033fb54ab9e35b77bd9c23a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d604a62033fb54ab9e35b77bd9c23a1">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[181/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1NaiveParametricCurveDigitizer3D.html">NaiveParametricCurveDigitizer3D</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1NaiveParametricCurveDigitizer3D.html" title="Aim: Digitization of 3D parametric curves. This method produces, for good parameters step and k_next,...">NaiveParametricCurveDigitizer3D</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1NaiveParametricCurveDigitizer3D.html" title="Aim: Digitization of 3D parametric curves. This method produces, for good parameters step and k_next,...">NaiveParametricCurveDigitizer3D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ab6df2f54fd5c48116deeb8ffdcd315a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6df2f54fd5c48116deeb8ffdcd315a0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[182/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1NGon2D.html">NGon2D</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1NGon2D.html" title="Aim: Model of the concept StarShaped represents any regular k-gon in the plane.">NGon2D</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1NGon2D.html" title="Aim: Model of the concept StarShaped represents any regular k-gon in the plane.">NGon2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a855e675db4e5e115051b87a6c79c6f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855e675db4e5e115051b87a6c79c6f36">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[183/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalSurface , typename TNormalVectorEstimator , typename TEmbedder &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1NormalVectorEstimatorLinearCellEmbedder.html">NormalVectorEstimatorLinearCellEmbedder</a>&lt; TDigitalSurface, TNormalVectorEstimator, TEmbedder &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1NormalVectorEstimatorLinearCellEmbedder.html" title="Aim: model of cellular embedder for normal vector estimators on digital surface, (default constructib...">NormalVectorEstimatorLinearCellEmbedder</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1NormalVectorEstimatorLinearCellEmbedder.html" title="Aim: model of cellular embedder for normal vector estimators on digital surface, (default constructib...">NormalVectorEstimatorLinearCellEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a2ae75cc7ec1fb5546bc6a2f2f8cd23e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae75cc7ec1fb5546bc6a2f2f8cd23e7">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[184/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalTopology , typename TDigitalSet &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Object.html">Object</a>&lt; TDigitalTopology, TDigitalSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="abf4df6c5ff5ee3dcb5536a58a6e4fb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4df6c5ff5ee3dcb5536a58a6e4fb82">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[185/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TConstIterator , typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1OneBalancedWordComputer.html">OneBalancedWordComputer</a>&lt; TConstIterator, TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'OneBalancedWord'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'OneBalancedWord' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ad177434c374ac178dd25f8e3f3de4d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad177434c374ac178dd25f8e3f3de4d55">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[186/255]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1OrderedAlphabet.html">OrderedAlphabet</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1OrderedAlphabet.html" title="Aim: Describes an alphabet over an interval of (ascii) letters, where the lexicographic order can be ...">OrderedAlphabet</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1OrderedAlphabet.html" title="Aim: Describes an alphabet over an interval of (ascii) letters, where the lexicographic order can be ...">OrderedAlphabet</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a7531e627ab525a3f4a9c46b353fed36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7531e627ab525a3f4a9c46b353fed36c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[187/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1OwningOrAliasingPtr.html">OwningOrAliasingPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1OwningOrAliasingPtr.html" title="Aim: This class describes a smart pointer that is, given the constructor called by the user,...">OwningOrAliasingPtr</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1OwningOrAliasingPtr.html" title="Aim: This class describes a smart pointer that is, given the constructor called by the user,...">OwningOrAliasingPtr</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a0f9f55a1f2ef1516d16626eb5dc1cc3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9f55a1f2ef1516d16626eb5dc1cc3b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[188/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace , bool muIncluded, bool muPlusNuIncluded&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ParallelStrip.html">ParallelStrip</a>&lt; TSpace, muIncluded, muPlusNuIncluded &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ParallelStrip.html" title="Aim: A parallel strip in the space is the intersection of two parallel half-planes such that each hal...">ParallelStrip</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ParallelStrip.html" title="Aim: A parallel strip in the space is the intersection of two parallel half-planes such that each hal...">ParallelStrip</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="abbb639abb32e1e88448c12452b197e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb639abb32e1e88448c12452b197e63">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[189/255]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1Parameters.html">Parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="structDGtal_1_1Parameters.html">Parameters</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="structDGtal_1_1Parameters.html">Parameters</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a1c3092d3b481169e879b1df8ca176dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3092d3b481169e879b1df8ca176dc6">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[190/255]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1ParameterValue.html">ParameterValue</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="structDGtal_1_1ParameterValue.html">ParameterValue</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="structDGtal_1_1ParameterValue.html">ParameterValue</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a5ed0b3f432b36351e8af73cbef27af4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed0b3f432b36351e8af73cbef27af4f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[191/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFraction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Pattern.html">Pattern</a>&lt; TFraction &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Pattern.html" title="Aim: This class represents a pattern, i.e. the path between two consecutive upper leaning points on a...">Pattern</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Pattern.html" title="Aim: This class represents a pattern, i.e. the path between two consecutive upper leaning points on a...">Pattern</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a2d3182e16aadf3b7972b7ab6a0a4cd1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3182e16aadf3b7972b7ab6a0a4cd1c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[192/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSurface , typename TInternalProbingAlgorithm &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PlaneProbingDigitalSurfaceLocalEstimator.html">PlaneProbingDigitalSurfaceLocalEstimator</a>&lt; TSurface, TInternalProbingAlgorithm &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1PlaneProbingDigitalSurfaceLocalEstimator.html" title="Aim: Adapt a plane-probing estimator on a digital surface to estimate normal vectors.">PlaneProbingDigitalSurfaceLocalEstimator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1PlaneProbingDigitalSurfaceLocalEstimator.html" title="Aim: Adapt a plane-probing estimator on a digital surface to estimate normal vectors.">PlaneProbingDigitalSurfaceLocalEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a5c63d0d28a2a1e86e6803f77fcff386c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c63d0d28a2a1e86e6803f77fcff386c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[193/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PlaneProbingHNeighborhood.html">PlaneProbingHNeighborhood</a>&lt; TPredicate &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1PlaneProbingHNeighborhood.html" title="Aim: Represent a way to probe the H-neighborhood.">PlaneProbingHNeighborhood</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1PlaneProbingHNeighborhood.html" title="Aim: Represent a way to probe the H-neighborhood.">PlaneProbingHNeighborhood</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a7f5e1905d819be56862ed900b6ca7f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5e1905d819be56862ed900b6ca7f2e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[194/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PlaneProbingNeighborhood.html">PlaneProbingNeighborhood</a>&lt; TPredicate &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1PlaneProbingNeighborhood.html" title="Aim: A base virtual class that represents a way to probe a neighborhood, used in the plane probing ba...">PlaneProbingNeighborhood</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1PlaneProbingNeighborhood.html" title="Aim: A base virtual class that represents a way to probe a neighborhood, used in the plane probing ba...">PlaneProbingNeighborhood</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="acab44cd427f90bd85108e3a7ca0e37ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab44cd427f90bd85108e3a7ca0e37ca">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[195/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPredicate , ProbingMode mode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PlaneProbingParallelepipedEstimator.html">PlaneProbingParallelepipedEstimator</a>&lt; TPredicate, mode &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1PlaneProbingParallelepipedEstimator.html" title="Aim:">PlaneProbingParallelepipedEstimator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1PlaneProbingParallelepipedEstimator.html" title="Aim:">PlaneProbingParallelepipedEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a13a71d7c536fd74cbcd231c521d1d412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a71d7c536fd74cbcd231c521d1d412">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[196/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PlaneProbingR1Neighborhood.html">PlaneProbingR1Neighborhood</a>&lt; TPredicate &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1PlaneProbingR1Neighborhood.html" title="Aim: Represent a way to probe the R-neighborhood, with the R1 optimization, see  for details.">PlaneProbingR1Neighborhood</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1PlaneProbingR1Neighborhood.html" title="Aim: Represent a way to probe the R-neighborhood, with the R1 optimization, see  for details.">PlaneProbingR1Neighborhood</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a3c5e6dd78ee904d87a2ab3d265bb1039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5e6dd78ee904d87a2ab3d265bb1039">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[197/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PlaneProbingRNeighborhood.html">PlaneProbingRNeighborhood</a>&lt; TPredicate &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1PlaneProbingRNeighborhood.html" title="Aim: Represent a way to probe the R-neighborhood.">PlaneProbingRNeighborhood</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1PlaneProbingRNeighborhood.html" title="Aim: Represent a way to probe the R-neighborhood.">PlaneProbingRNeighborhood</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="af9a09c62703bd3f2595baf3fa6c10223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a09c62703bd3f2595baf3fa6c10223">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[198/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPredicate , ProbingMode mode&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PlaneProbingTetrahedronEstimator.html">PlaneProbingTetrahedronEstimator</a>&lt; TPredicate, mode &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1PlaneProbingTetrahedronEstimator.html" title="Aim: A class that locally estimates a normal on a digital set using only a predicate &quot;does a point x ...">PlaneProbingTetrahedronEstimator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1PlaneProbingTetrahedronEstimator.html" title="Aim: A class that locally estimates a normal on a digital set using only a predicate &quot;does a point x ...">PlaneProbingTetrahedronEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a9d2d7697de6eefcd5500006abfb96cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2d7697de6eefcd5500006abfb96cca">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[199/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename Component , typename TC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; <a class="el" href="viewDualSurface_8cpp.html#a1a254aa17418553bc21790001a69262a">dim</a>, Component, TC &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator &lt;&lt;. </p>

</div>
</div>
<a id="a1c5c58861db3a26964000c06a53a8bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5c58861db3a26964000c06a53a8bcb">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[200/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PolygonalSurface.html">PolygonalSurface</a>&lt; TPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1PolygonalSurface.html" title="Aim: Represents a polygon mesh, i.e. a 2-dimensional combinatorial surface whose faces are (topologic...">PolygonalSurface</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1PolygonalSurface.html" title="Aim: Represents a polygon mesh, i.e. a 2-dimensional combinatorial surface whose faces are (topologic...">PolygonalSurface</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a1daf9f63758c23c887f82362f4375bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1daf9f63758c23c887f82362f4375bca">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[201/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename W , typename Sep , typename Image &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PowerMap.html">PowerMap</a>&lt; W, Sep, <a class="el" href="classDGtal_1_1Image.html">Image</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ExactPredicateLpSeparableMetric.html" title="Aim: implements separable l_p metrics with exact predicates.">ExactPredicateLpSeparableMetric</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ExactPredicateLpSeparableMetric.html" title="Aim: implements separable l_p metrics with exact predicates.">ExactPredicateLpSeparableMetric</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a2e1c2a1e2b1936e56a80d2fd54819fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1c2a1e2b1936e56a80d2fd54819fdc">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[202/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TOrientationFunctor , bool acceptNeg, bool acceptZero&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PredicateFromOrientationFunctor2.html">PredicateFromOrientationFunctor2</a>&lt; TOrientationFunctor, acceptNeg, acceptZero &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1PredicateFromOrientationFunctor2.html" title="Aim: Small adapter to models of COrientationFunctor2. It is a model of concepts::CPointPredicate....">PredicateFromOrientationFunctor2</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1PredicateFromOrientationFunctor2.html" title="Aim: Small adapter to models of COrientationFunctor2. It is a model of concepts::CPointPredicate....">PredicateFromOrientationFunctor2</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="af16925448c97db7223238e00a3babd36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16925448c97db7223238e00a3babd36">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[203/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Shape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Preimage2D.html">Preimage2D</a>&lt; <a class="el" href="testAstroid2D_8cpp.html#a71f4199b023fa1f3b1d8a36a946e7759">Shape</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Preimage2D.html" title="Aim: Computes the preimage of the 2D Euclidean shapes crossing a sequence of n straigth segments in O...">Preimage2D</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Preimage2D.html" title="Aim: Computes the preimage of the 2D Euclidean shapes crossing a sequence of n straigth segments in O...">Preimage2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a726c89af25ffd816f74c79f63551e5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726c89af25ffd816f74c79f63551e5b1">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[204/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TValueFunctor , typename TValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Profile.html">Profile</a>&lt; TValueFunctor, TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Profile.html" title="Aim: This class can be used to represent a profile (PX, PY) defined from an input set of samples (Xi,...">Profile</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Profile.html" title="Aim: This class can be used to represent a profile (PX, PY) defined from an input set of samples (Xi,...">Profile</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ab8287a37f3aa45b30a7b90f62e2aed9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8287a37f3aa45b30a7b90f62e2aed9c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[205/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKernel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1QuickHull.html">QuickHull</a>&lt; TKernel &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="structDGtal_1_1QuickHull.html" title="Aim: Implements the quickhull algorithm by Barber et al. , a famous arbitrary dimensional convex hull...">QuickHull</a>'. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKernel</td><td>any type of <a class="el" href="structDGtal_1_1QuickHull.html" title="Aim: Implements the quickhull algorithm by Barber et al. , a famous arbitrary dimensional convex hull...">QuickHull</a> kernel, like <a class="el" href="structDGtal_1_1ConvexHullIntegralKernel.html" title="Aim: a geometric kernel to compute the convex hull of digital points with integer-only arithmetic.">ConvexHullIntegralKernel</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="structDGtal_1_1QuickHull.html" title="Aim: Implements the quickhull algorithm by Barber et al. , a famous arbitrary dimensional convex hull...">QuickHull</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="QuickHull_8h_source.html#l01557">1557</a> of file <a class="el" href="QuickHull_8h_source.html">QuickHull.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01560"></a><span class="lineno"> 1560</span>&#160;  {</div>
<div class="line"><a name="l01561"></a><span class="lineno"> 1561</span>&#160;    <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line"><a name="l01562"></a><span class="lineno"> 1562</span>&#160;    <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l01563"></a><span class="lineno"> 1563</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a53148a67ad6de6ed49d57c605def778b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53148a67ad6de6ed49d57c605def778b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[206/255]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1RandomColorMap.html">RandomColorMap</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1RandomColorMap.html" title="Aim: access to random color from a gradientColorMap.">RandomColorMap</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1RandomColorMap.html" title="Aim: access to random color from a gradientColorMap.">RandomColorMap</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aea30053ec6e0099310c2d15ef58f988a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea30053ec6e0099310c2d15ef58f988a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[207/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDomain , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealFFT&lt; TDomain, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'RealFFT'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'RealFFT' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="af27245859284b52d3c6234f620b34252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27245859284b52d3c6234f620b34252">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[208/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1RegularPointEmbedder.html">RegularPointEmbedder</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1RegularPointEmbedder.html" title="Aim: A simple point embedder where grid steps are given for each axis. Note that the real point (0,...">RegularPointEmbedder</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1RegularPointEmbedder.html" title="Aim: A simple point embedder where grid steps are given for each axis. Note that the real point (0,...">RegularPointEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a94e0a7004286b0579aa6a27ca6804e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e0a7004286b0579aa6a27ca6804e85">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[209/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename W , typename TSep &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ReverseDistanceTransformation.html">ReverseDistanceTransformation</a>&lt; W, TSep &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ReverseDistanceTransformation_8h_source.html#l00256">256</a> of file <a class="el" href="ReverseDistanceTransformation_8h_source.html">ReverseDistanceTransformation.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;  {</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4b1f11e76731f6b53d58741593de1718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1f11e76731f6b53d58741593de1718">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[210/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1RosenProffittLocalLengthEstimator.html">RosenProffittLocalLengthEstimator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1RosenProffittLocalLengthEstimator.html" title="Aim: Rosen-Proffitt Length Estimator.">RosenProffittLocalLengthEstimator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1RosenProffittLocalLengthEstimator.html" title="Aim: Rosen-Proffitt Length Estimator.">RosenProffittLocalLengthEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a86a932423c11c531c9ecfe4631704aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a932423c11c531c9ecfe4631704aab">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[211/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SegmentComputer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SaturatedSegmentation.html">SaturatedSegmentation</a>&lt; <a class="el" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#a51bb21fda3840e1eff0ee53753ebcbc3">SegmentComputer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1SaturatedSegmentation.html" title="Aim: Computes the saturated segmentation, that is the whole set of maximal segments within a range gi...">SaturatedSegmentation</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1SaturatedSegmentation.html" title="Aim: Computes the saturated segmentation, that is the whole set of maximal segments within a range gi...">SaturatedSegmentation</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aba5335bdab6ea6b638c3143e952a0280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5335bdab6ea6b638c3143e952a0280">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[212/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SeparableMetricAdapter.html">SeparableMetricAdapter</a>&lt; TM &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1SeparableMetricAdapter.html" title="Aim: Adapts any model of CMetric to construct a separable metric (model of CSeparableMetric).">SeparableMetricAdapter</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1SeparableMetricAdapter.html" title="Aim: Adapts any model of CMetric to construct a separable metric (model of CSeparableMetric).">SeparableMetricAdapter</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a0e131923f413c708e1f30e1caf7f502f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e131923f413c708e1f30e1caf7f502f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[213/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TSurfelSet &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SetOfSurfels.html">SetOfSurfels</a>&lt; TKSpace, TSurfelSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1SetOfSurfels.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels....">SetOfSurfels</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1SetOfSurfels.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels....">SetOfSurfels</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>a model of CCellularGridSpaceND: the type chosen for the cellular grid space.</td></tr>
    <tr><td class="paramname">TSurfelSet</td><td>a model of CDigitalSet: the type chosen for the set of digital points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a173a5f39aef469def94b22065f931ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173a5f39aef469def94b22065f931ad0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[214/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDomain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Shapes.html">Shapes</a>&lt; TDomain &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Shapes.html" title="Aim: A utility class for constructing different shapes (balls, diamonds, and others).">Shapes</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Shapes.html" title="Aim: A utility class for constructing different shapes (balls, diamonds, and others).">Shapes</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aeb255b0240525e530d72279416b7db56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb255b0240525e530d72279416b7db56">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[215/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Shortcuts.html">Shortcuts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Shortcuts.html" title="Aim: This class is used to simplify shape and surface creation. With it, you can create new shapes an...">Shortcuts</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Shortcuts.html" title="Aim: This class is used to simplify shape and surface creation. With it, you can create new shapes an...">Shortcuts</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ad81241d0c7fe22c289041e10289a6a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81241d0c7fe22c289041e10289a6a0f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[216/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Signal.html">Signal</a>&lt; TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Signal.html" title="Aim: Represents a discrete signal, periodic or not. The signal can be passed by value since it is onl...">Signal</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Signal.html" title="Aim: Represents a discrete signal, periodic or not. The signal can be passed by value since it is onl...">Signal</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a6851bd6ddd1a7f9164c8f8273ee2727c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6851bd6ddd1a7f9164c8f8273ee2727c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[217/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1SignedKhalimskyCell.html">SignedKhalimskyCell</a>&lt; <a class="el" href="viewDualSurface_8cpp.html#a1a254aa17418553bc21790001a69262a">dim</a>, TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af5fe10bf3d39b724578b076625e81df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5fe10bf3d39b724578b076625e81df3">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[218/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1SignedKhalimskyPreCell.html">SignedKhalimskyPreCell</a>&lt; <a class="el" href="viewDualSurface_8cpp.html#a1a254aa17418553bc21790001a69262a">dim</a>, TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a87f57d0e6ee214b01ef88f829878d7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f57d0e6ee214b01ef88f829878d7fc">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[219/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TI , typename TO &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Simple2x2DetComputer.html">Simple2x2DetComputer</a>&lt; TI, TO &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Simple2x2DetComputer.html" title="Aim: Small class useful to compute the determinant of a 2x2 matrix from its four coefficients,...">Simple2x2DetComputer</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Simple2x2DetComputer.html" title="Aim: Small class useful to compute the determinant of a 2x2 matrix from its four coefficients,...">Simple2x2DetComputer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a70bcaa727229c1493e25beed64213f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70bcaa727229c1493e25beed64213f1f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[220/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TI , typename TO &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SimpleIncremental2x2DetComputer.html">SimpleIncremental2x2DetComputer</a>&lt; TI, TO &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1SimpleIncremental2x2DetComputer.html" title="Aim: Small class useful to compute, in an incremental way, the determinant of a 2x2 matrix from its f...">SimpleIncremental2x2DetComputer</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1SimpleIncremental2x2DetComputer.html" title="Aim: Small class useful to compute, in an incremental way, the determinant of a 2x2 matrix from its f...">SimpleIncremental2x2DetComputer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a4f758bdd2b85477daaba1b42203956d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f758bdd2b85477daaba1b42203956d1">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[221/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , DGtal::Dimension M, DGtal::Dimension N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SimpleMatrix.html">SimpleMatrix</a>&lt; T, M, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1SimpleMatrix.html" title="Aim: implements basic MxN Matrix services (M,N&gt;=1).">SimpleMatrix</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1SimpleMatrix.html" title="Aim: implements basic MxN Matrix services (M,N&gt;=1).">SimpleMatrix</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a6eafb6806e63650dd8bc0f75a3e86dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eafb6806e63650dd8bc0f75a3e86dc3">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[222/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SpatialCubicalSubdivision.html">SpatialCubicalSubdivision</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1SpatialCubicalSubdivision.html" title="Aim: This class is a data structure that subdivides a rectangular domains into cubical domains of siz...">SpatialCubicalSubdivision</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1SpatialCubicalSubdivision.html" title="Aim: This class is a data structure that subdivides a rectangular domains into cubical domains of siz...">SpatialCubicalSubdivision</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a9ed024e0d86a6156e10292c6bee91231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed024e0d86a6156e10292c6bee91231">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[223/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SphericalAccumulator.html">SphericalAccumulator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1SphericalAccumulator.html" title="Aim: implements an accumulator (as histograms for 1D scalars) adapted to spherical point samples.">SphericalAccumulator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1SphericalAccumulator.html" title="Aim: implements an accumulator (as histograms for 1D scalars) adapted to spherical point samples.">SphericalAccumulator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a380ef73ffe8f5104f6782326fc4df10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380ef73ffe8f5104f6782326fc4df10d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[224/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TConstIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1StabbingCircleComputer.html">StabbingCircleComputer</a>&lt; TConstIterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1StabbingCircleComputer.html" title="Aim: On-line recognition of a digital circular arcs (DCA) defined as a sequence of connected grid edg...">StabbingCircleComputer</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1StabbingCircleComputer.html" title="Aim: On-line recognition of a digital circular arcs (DCA) defined as a sequence of connected grid edg...">StabbingCircleComputer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ab8dfae1a3461c126ad5f8deec25cf6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8dfae1a3461c126ad5f8deec25cf6ff">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[225/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TConstIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1StabbingLineComputer.html">StabbingLineComputer</a>&lt; TConstIterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1StabbingLineComputer.html" title="Aim: On-line recognition of a digital straight segment (DSS) defined as a sequence of connected grid ...">StabbingLineComputer</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1StabbingLineComputer.html" title="Aim: On-line recognition of a digital straight segment (DSS) defined as a sequence of connected grid ...">StabbingLineComputer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a17188f111ef6f8f55d2e4e8d08c0a57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17188f111ef6f8f55d2e4e8d08c0a57f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[226/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFraction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1StandardDSLQ0.html">StandardDSLQ0</a>&lt; TFraction &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1StandardDSLQ0.html" title="Aim: Represents a digital straight line with slope in the first quadrant (Q0: x &gt;= 0,...">StandardDSLQ0</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1StandardDSLQ0.html" title="Aim: Represents a digital straight line with slope in the first quadrant (Q0: x &gt;= 0,...">StandardDSLQ0</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aa50c40d2df8aae8bd6ba1fd14e633c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50c40d2df8aae8bd6ba1fd14e633c46">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[227/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TInteger , int connectivity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1StandardDSS6Computer.html">StandardDSS6Computer</a>&lt; TIterator, TInteger, connectivity &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1StandardDSS6Computer.html" title="Aim: Dynamic recognition of a 3d-digital straight segment (DSS)">StandardDSS6Computer</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1StandardDSS6Computer.html" title="Aim: Dynamic recognition of a 3d-digital straight segment (DSS)">StandardDSS6Computer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="StandardDSS6Computer_8h_source.html#l00314">314</a> of file <a class="el" href="StandardDSS6Computer_8h_source.html">StandardDSS6Computer.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;  {</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    <span class="keywordtype">object</span>.selfDisplay( out);</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a372f8751a722045053b7fb40e27acc0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372f8751a722045053b7fb40e27acc0a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[228/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1StarShaped2D.html">StarShaped2D</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1StarShaped2D.html">StarShaped2D</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1StarShaped2D.html">StarShaped2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a143ab94b75f148bd8730c4e6acfcbdbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a143ab94b75f148bd8730c4e6acfcbdbc">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[229/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1StarShaped3D.html">StarShaped3D</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1StarShaped3D.html">StarShaped3D</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1StarShaped2D.html">StarShaped2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aba713edeb51f787070eff9f9edc210c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba713edeb51f787070eff9f9edc210c7">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[230/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>//To move elsewhere ? Overloads 'operator&lt;&lt;' for displaying STL pairs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the STL pair to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ConstRangeAdapter_8h_source.html#l00329">329</a> of file <a class="el" href="ConstRangeAdapter_8h_source.html">ConstRangeAdapter.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;   {</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;     out &lt;&lt; <span class="keywordtype">object</span>.first &lt;&lt; <span class="stringliteral">&quot;|&quot;</span> &lt;&lt; <span class="keywordtype">object</span>.second; </div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;     <span class="keywordflow">return</span> out; </div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;   } </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9c9db375c56d37d5a38a7599c7e02e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9db375c56d37d5a38a7599c7e02e07">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[231/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1StraightLineFrom2Points.html">StraightLineFrom2Points</a>&lt; TPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1StraightLineFrom2Points.html" title="Aim: Represents a straight line uniquely defined by two 2D points and that is able to return for any ...">StraightLineFrom2Points</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1StraightLineFrom2Points.html" title="Aim: Represents a straight line uniquely defined by two 2D points and that is able to return for any ...">StraightLineFrom2Points</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="StraightLineFrom2Points_8h_source.html#l00209">209</a> of file <a class="el" href="StraightLineFrom2Points_8h_source.html">StraightLineFrom2Points.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;  {</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a742bce0b660bee1dc186252d4d130041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742bce0b660bee1dc186252d4d130041">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[232/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRealPoint , typename TRealVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1SurfaceMesh.html">SurfaceMesh</a>&lt; TRealPoint, TRealVector &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aff655e1b0debfe2fbf8ca53c7fe8fa70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff655e1b0debfe2fbf8ca53c7fe8fa70">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[233/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a>&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Surfaces.html" title="Aim: A utility class for constructing surfaces (i.e. set of (n-1)-cells).">Surfaces</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Surfaces.html" title="Aim: A utility class for constructing surfaces (i.e. set of (n-1)-cells).">Surfaces</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ad28cd2ea7afa2aa2dd6bf76e54a9e2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28cd2ea7afa2aa2dd6bf76e54a9e2b0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[234/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; <a class="el" href="viewDualSurface_8cpp.html#a1a254aa17418553bc21790001a69262a">dim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1SurfelAdjacency.html" title="Aim: Represent adjacencies between surfel elements, telling if it follows an interior to exterior ord...">SurfelAdjacency</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1SurfelAdjacency.html" title="Aim: Represent adjacencies between surfel elements, telling if it follows an interior to exterior ord...">SurfelAdjacency</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="acbfc586cb4ecd8bb0b1a787a84cb82d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbfc586cb4ecd8bb0b1a787a84cb82d6">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[235/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1SurfelNeighborhood.html" title="Aim: This helper class is useful to compute the neighboring surfels of a given surfel,...">SurfelNeighborhood</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1SurfelNeighborhood.html" title="Aim: This helper class is useful to compute the neighboring surfels of a given surfel,...">SurfelNeighborhood</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="abfd6d86a7d67dd305921a4cf496fe392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd6d86a7d67dd305921a4cf496fe392">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[236/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TValue , typename CMAP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1TickedColorMap.html">TickedColorMap</a>&lt; TValue, CMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1TickedColorMap.html" title="Aim: This class adapts any colormap to add &quot;ticks&quot; in the colormap colors.">TickedColorMap</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>te output stream after the writing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa0c6e42a58ca70e5d28281050c88574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0c6e42a58ca70e5d28281050c88574">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[237/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImageContainer , typename TImageFactory , typename TImageCacheReadPolicy , typename TImageCacheWritePolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1TiledImage.html">TiledImage</a>&lt; TImageContainer, TImageFactory, TImageCacheReadPolicy, TImageCacheWritePolicy &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1TiledImage.html" title="Aim: implements a tiled image from a &quot;bigger/original&quot; one from an ImageFactory.">TiledImage</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1TiledImage.html" title="Aim: implements a tiled image from a &quot;bigger/original&quot; one from an ImageFactory.">TiledImage</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a4897060261281048cf0bbb18590d5307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4897060261281048cf0bbb18590d5307">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[238/255]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Trace.html">Trace</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Trace.html" title="implementation of basic methods to trace out messages with indentation levels.">Trace</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Trace.html" title="implementation of basic methods to trace out messages with indentation levels.">Trace</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aa1a0c72f3ea963c433d33b86d1fba535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a0c72f3ea963c433d33b86d1fba535">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[239/255]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1TraceWriter.html">TraceWriter</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1TraceWriter.html" title="Virtual Class to implement trace writers.">TraceWriter</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1TraceWriter.html" title="Virtual Class to implement trace writers.">TraceWriter</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="abb0ae3e476260be1ddbbe6c881738e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0ae3e476260be1ddbbe6c881738e81">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[240/255]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1TraceWriterFile.html">TraceWriterFile</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1TraceWriterFile.html">TraceWriterFile</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1TraceWriterFile.html">TraceWriterFile</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aa60540f21dc15c6580824e2e370a7600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60540f21dc15c6580824e2e370a7600">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[241/255]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1TraceWriterTerm.html">TraceWriterTerm</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1TraceWriterTerm.html" title="Implements trace prefix for color terminals.">TraceWriterTerm</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1TraceWriterTerm.html" title="Implements trace prefix for color terminals.">TraceWriterTerm</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a9e1daac4d4761686c19587065eb69989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1daac4d4761686c19587065eb69989">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[242/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1TriangulatedSurface.html">TriangulatedSurface</a>&lt; TPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1TriangulatedSurface.html" title="Aim: Represents a triangulated surface. The topology is stored with a half-edge data structure....">TriangulatedSurface</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1TriangulatedSurface.html" title="Aim: Represents a triangulated surface. The topology is stored with a half-edge data structure....">TriangulatedSurface</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a92007b632b9e7f503b6404c7254efe4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92007b632b9e7f503b6404c7254efe4f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[243/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TShape , typename TGeometricFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1TrueDigitalSurfaceLocalEstimator.html">TrueDigitalSurfaceLocalEstimator</a>&lt; TKSpace, TShape, TGeometricFunctor &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1TrueDigitalSurfaceLocalEstimator.html" title="Aim: An estimator on digital surfaces that returns the reference local geometric quantity....">TrueDigitalSurfaceLocalEstimator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1TrueDigitalSurfaceLocalEstimator.html" title="Aim: An estimator on digital surfaces that returns the reference local geometric quantity....">TrueDigitalSurfaceLocalEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a62ead3771ef37cd4c242dd0da3ba88a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ead3771ef37cd4c242dd0da3ba88a1">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[244/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1TwoStepLocalLengthEstimator.html">TwoStepLocalLengthEstimator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1TwoStepLocalLengthEstimator.html" title="Aim: a simple model of CGlobalCurveEstimator that compute the length of a curve using the l_1 metric ...">TwoStepLocalLengthEstimator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1TwoStepLocalLengthEstimator.html" title="Aim: a simple model of CGlobalCurveEstimator that compute the length of a curve using the l_1 metric ...">TwoStepLocalLengthEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="afa315c6c8d41dbc29ddf8acc5be306a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa315c6c8d41dbc29ddf8acc5be306a4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[245/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalSurfaceTracker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1UmbrellaComputer.html">UmbrellaComputer</a>&lt; TDigitalSurfaceTracker &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1UmbrellaComputer.html" title="Aim: Useful for computing umbrellas on &#39;DigitalSurface&#39;s, ie set of n-1 cells around a n-3 cell.">UmbrellaComputer</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1UmbrellaComputer.html" title="Aim: Useful for computing umbrellas on &#39;DigitalSurface&#39;s, ie set of n-1 cells around a n-3 cell.">UmbrellaComputer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ae0261bc5b59d46e47f7d5292c86d53df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0261bc5b59d46e47f7d5292c86d53df">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[246/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalSurfaceContainer , typename TSeparableMetric , typename TKernelFunction , typename TVCMGeometricFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1VCMDigitalSurfaceLocalEstimator.html">VCMDigitalSurfaceLocalEstimator</a>&lt; TDigitalSurfaceContainer, TSeparableMetric, TKernelFunction, TVCMGeometricFunctor &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1VCMDigitalSurfaceLocalEstimator.html" title="Aim: This class adapts a VoronoiCovarianceMeasureOnDigitalSurface to be a model of CDigitalSurfaceLoc...">VCMDigitalSurfaceLocalEstimator</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1VCMDigitalSurfaceLocalEstimator.html" title="Aim: This class adapts a VoronoiCovarianceMeasureOnDigitalSurface to be a model of CDigitalSurfaceLoc...">VCMDigitalSurfaceLocalEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ad080b33a7338e70ac2095ecbfc1d463a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad080b33a7338e70ac2095ecbfc1d463a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[247/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Calculus , Duality duality&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1VectorField.html">VectorField</a>&lt; Calculus, duality &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1VectorField.html" title="Aim: VectorField represents a discrete vector field in the dec package. Vector field values are attac...">VectorField</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1VectorField.html" title="Aim: VectorField represents a discrete vector field in the dec package. Vector field values are attac...">VectorField</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aab8db91c68b970e26585a4e832a08f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8db91c68b970e26585a4e832a08f99">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[248/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace , typename TKSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a>&lt; TSpace, TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a44966d3cf1d860c33b6865fd6eb01ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44966d3cf1d860c33b6865fd6eb01ceb">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[249/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace , typename TSeparableMetric &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1VoronoiCovarianceMeasure.html">VoronoiCovarianceMeasure</a>&lt; TSpace, TSeparableMetric &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1VoronoiCovarianceMeasure.html" title="Aim: This class precomputes the Voronoi Covariance Measure of a set of points. It can compute the cov...">VoronoiCovarianceMeasure</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1VoronoiCovarianceMeasure.html" title="Aim: This class precomputes the Voronoi Covariance Measure of a set of points. It can compute the cov...">VoronoiCovarianceMeasure</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="afd535555f8033a00f05ff1ae4206ade1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd535555f8033a00f05ff1ae4206ade1">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[250/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalSurfaceContainer , typename TSeparableMetric , typename TKernelFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1VoronoiCovarianceMeasureOnDigitalSurface.html">VoronoiCovarianceMeasureOnDigitalSurface</a>&lt; TDigitalSurfaceContainer, TSeparableMetric, TKernelFunction &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1VoronoiCovarianceMeasureOnDigitalSurface.html" title="Aim: This class specializes the Voronoi covariance measure for digital surfaces. It adds notably the ...">VoronoiCovarianceMeasureOnDigitalSurface</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1VoronoiCovarianceMeasureOnDigitalSurface.html" title="Aim: This class specializes the Voronoi covariance measure for digital surfaces. It adds notably the ...">VoronoiCovarianceMeasureOnDigitalSurface</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="a9b0a7c1e2501fb4352ecb8e8922cba23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0a7c1e2501fb4352ecb8e8922cba23">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[251/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename P , typename Sep , typename TI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1VoronoiMap.html">VoronoiMap</a>&lt; S, P, Sep, TI &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ExactPredicateLpSeparableMetric.html" title="Aim: implements separable l_p metrics with exact predicates.">ExactPredicateLpSeparableMetric</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ExactPredicateLpSeparableMetric.html" title="Aim: implements separable l_p metrics with exact predicates.">ExactPredicateLpSeparableMetric</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="acd92c3e107e9c40b882500181482ee9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd92c3e107e9c40b882500181482ee9c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[252/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1VoxelComplex.html">VoxelComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1VoxelComplex.html" title="This class represents a voxel complex living in some Khalimsky space. Voxel complexes are derived fro...">VoxelComplex</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1VoxelComplex.html" title="This class represents a voxel complex living in some Khalimsky space. Voxel complexes are derived fro...">VoxelComplex</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ad7441c7bd823132ee0e0ab3f59afcfb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7441c7bd823132ee0e0ab3f59afcfb7">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[253/255]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>that_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1OrderedLinearRegression.html">OrderedLinearRegression</a> &amp;&#160;</td>
          <td class="paramname"><em>that_object_to_display</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1OrderedLinearRegression.html" title="Description of class &#39;OrderedLinearRegression&#39;.">OrderedLinearRegression</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that_stream</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">that_object_to_display</td><td>the object of class '<a class="el" href="classDGtal_1_1OrderedLinearRegression.html" title="Description of class &#39;OrderedLinearRegression&#39;.">OrderedLinearRegression</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="acf6e2015e5afa4a87b9ea4fc4e462a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6e2015e5afa4a87b9ea4fc4e462a11">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[254/255]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>that_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SimpleLinearRegression.html">SimpleLinearRegression</a> &amp;&#160;</td>
          <td class="paramname"><em>that_object_to_display</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1SimpleLinearRegression.html" title="Description of class &#39;SimpleLinearRegression&#39;.">SimpleLinearRegression</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that_stream</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">that_object_to_display</td><td>the object of class '<a class="el" href="classDGtal_1_1SimpleLinearRegression.html" title="Description of class &#39;SimpleLinearRegression&#39;.">SimpleLinearRegression</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="ab082ebd8a30a323e3dc31426bd8cccb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab082ebd8a30a323e3dc31426bd8cccb1">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[255/255]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TQuantity &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>thatStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Statistic.html">Statistic</a>&lt; TQuantity &gt; &amp;&#160;</td>
          <td class="paramname"><em>that_object_to_display</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Statistic.html" title="Aim: This class processes a set of sample values for one variable and can then compute different stat...">Statistic</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thatStream</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">that_object_to_display</td><td>the object of class '<a class="el" href="classDGtal_1_1Statistic.html" title="Aim: This class processes a set of sample values for one variable and can then compute different stat...">Statistic</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a id="aecc3c423f122c30fbd6e27dd50c72cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc3c423f122c30fbd6e27dd50c72cd9">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inclusion test (subset of).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input cubical complex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff <em>S1</em> is a subcomplex of <em>S2</em>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00316">316</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;  {</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="testCubicalComplex_8cpp.html#a9f6eee55782bbac774730b7688010a1e">CC</a>;</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    ASSERT( &amp;(S1.space()) == &amp;(S2.space()) );</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= CC::dimension; ++i )</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;      <span class="keywordflow">if</span> ( ! functions::isSubset( S1.myCells[ i ], S2.myCells[ i ] ) )</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l00845">DGtal::functions::isSubset()</a>, <a class="el" href="CubicalComplex_8h_source.html#l01301">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>, and <a class="el" href="classDGtal_1_1CubicalComplex.html#a32db9584d04e62cd205002dd7279b36a">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::space()</a>.</p>

</div>
</div>
<a id="a762b7a56c29d9277e293fe02da37e075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762b7a56c29d9277e293fe02da37e075">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator on Points/Vectors (LesserOrEqualThan). </p>
<dl class="section return"><dt>Returns</dt><dd>true iff lhs &lt;= rhs, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It uses the lexicographical order. </dd></dl>

</div>
</div>
<a id="acdb3dcff560928e3a800f615a32e2e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb3dcff560928e3a800f615a32e2e7a">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equality test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input cubical complex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff <em>S1</em> is equal to <em>S2</em> (i.e. <em>S1</em> is a subcomplex of <em>S2</em> and <em>S2</em> is a subcomplex of <em>S1</em>). </dd></dl>

<p class="definition">Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00266">266</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;  {</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="testCubicalComplex_8cpp.html#a9f6eee55782bbac774730b7688010a1e">CC</a>;</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    ASSERT( &amp;(S1.space()) == &amp;(S2.space()) );</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= CC::dimension; ++i )</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;      <span class="keywordflow">if</span> ( ! <a class="code" href="testIndexedListWithBlocks_8cpp.html#a8094f96118b5321654e1671f513371f8">functions::isEqual</a>( S1.myCells[ i ], S2.myCells[ i ] ) )</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l00789">DGtal::functions::isEqual()</a>, <a class="el" href="CubicalComplex_8h_source.html#l01301">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>, and <a class="el" href="classDGtal_1_1CubicalComplex.html#a32db9584d04e62cd205002dd7279b36a">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::space()</a>.</p>

</div>
</div>
<a id="a25becea09496daadf802e0b440a2a31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25becea09496daadf802e0b440a2a31c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator between two Points/Vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>true iff the two points are equal. </dd></dl>

<p class="reference">Referenced by <a class="el" href="Color_8cpp_source.html#l00129">DGtal::Color::operator&lt;=()</a>, and <a class="el" href="Color_8cpp_source.html#l00135">DGtal::Color::operator&gt;=()</a>.</p>

</div>
</div>
<a id="ad94cc295d2a53018ab279b554ad84259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94cc295d2a53018ab279b554ad84259">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator on Points/Vectors (GreaterThan). </p>
<dl class="section return"><dt>Returns</dt><dd>true iff lhs &gt; rhs, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It uses the lexicographical order. </dd></dl>

<p class="reference">Referenced by <a class="el" href="Color_8cpp_source.html#l00135">DGtal::Color::operator&gt;=()</a>.</p>

</div>
</div>
<a id="a6c39f690fb8547062411990779442ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c39f690fb8547062411990779442ae5">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inclusion test (supset of).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input cubical complex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff <em>S2</em> is a subcomplex of <em>S1</em>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00340">340</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;  {</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="testCubicalComplex_8cpp.html#a9f6eee55782bbac774730b7688010a1e">CC</a>;</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    ASSERT( &amp;(S1.space()) == &amp;(S2.space()) );</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= CC::dimension; ++i )</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;      <span class="keywordflow">if</span> ( ! functions::isSubset( S2.myCells[ i ], S1.myCells[ i ] ) )</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l00845">DGtal::functions::isSubset()</a>, <a class="el" href="CubicalComplex_8h_source.html#l01301">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>, and <a class="el" href="classDGtal_1_1CubicalComplex.html#a32db9584d04e62cd205002dd7279b36a">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::space()</a>.</p>

</div>
</div>
<a id="a003343ddf52f61621688be55f2c9e463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003343ddf52f61621688be55f2c9e463">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator on Points/Vectors (GreaterOrEqualThan). </p>
<dl class="section return"><dt>Returns</dt><dd>true iff lhs &gt;= rhs, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It uses the lexicographical order. </dd></dl>

</div>
</div>
<a id="abf670898dd1e99bc4c6447117ed29eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf670898dd1e99bc4c6447117ed29eb7">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Space , typename KSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Display3D.html">Display3D</a>&lt; <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a38dfaf1641eab4d3fb805df4b52ab10d">Space</a>, <a class="el" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aDisplay3D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1Mesh.html">DGtal::Mesh</a>&lt; typename <a class="el" href="classDGtal_1_1Display3D.html">Display3D</a>&lt; <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a38dfaf1641eab4d3fb805df4b52ab10d">Space</a>, <a class="el" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a> &gt;::<a class="el" href="testAstroid2D_8cpp.html#ac914bb734ccb5a7c569747c1e699c1aa">RealPoint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aMesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator "&gt;&gt;" to export a <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like BallVector,...">Display3D</a> into a <a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces....">Mesh</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDisplay3D</td><td>the <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like BallVector,...">Display3D</a> to be exported. </td></tr>
    <tr><td class="paramname">aMesh</td><td>(return) the resulting mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb296bcee16299e888ac032e4ec5c31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb296bcee16299e888ac032e4ec5c31c">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Space , typename KSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Display3D.html">Display3D</a>&lt; <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a38dfaf1641eab4d3fb805df4b52ab10d">Space</a>, <a class="el" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aDisplay3D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>aFilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator "&gt;&gt;" to export a <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like BallVector,...">Display3D</a> directly a file </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDisplay3D</td><td>the <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like BallVector,...">Display3D</a> to be exported. </td></tr>
    <tr><td class="paramname">aFilename</td><td>(return) the resulting mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26182a3cb414de00abe8a72418594cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26182a3cb414de00abe8a72418594cb9">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImageContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const TImageContainer &amp;&#160;</td>
          <td class="paramname"><em>aContainer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>aFilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>'operator&gt;&gt;' for exporting an ImageContainer. This operator automatically selects the best method according to the filename extension (pgm, pgm3D, raw, vol).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aContainer</td><td>the container to be exported. </td></tr>
    <tr><td class="paramname">aFilename</td><td>the filename of the file to be exported. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the export was successful. </dd></dl>

</div>
</div>
<a id="abec0f66667f87bf9084634774c580216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec0f66667f87bf9084634774c580216">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1Mesh.html">Mesh</a>&lt; TPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>aMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>aFilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>'operator&gt;&gt;' for exporting objects of class '<a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces....">Mesh</a>'. This operator automatically selects the good method according to the filename extension (off, obj).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aMesh</td><td>the mesh to be exported. </td></tr>
    <tr><td class="paramname">aFilename</td><td>the filename of the file to be exported. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the export was successful. </dd></dl>

</div>
</div>
<a id="a978d84bb767fd5317f6b5a34fc943bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978d84bb767fd5317f6b5a34fc943bc6">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1Mesh.html">Mesh</a>&lt; TPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>aMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>'operator&gt;&gt;' for exporting objects of class '<a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces....">Mesh</a>' in OFF format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aMesh</td><td>the mesh to be exported. </td></tr>
    <tr><td class="paramname">out</td><td>the output of the OFF exportation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the export was successful. </dd></dl>

</div>
</div>
<a id="ad11563209db63d64213d8ca0f0e1b849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11563209db63d64213d8ca0f0e1b849">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, typename TRing , class TAlloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; DGtal::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, TRing, TAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>aMPolynomial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&gt;&gt;' to create directly multi-variate polynomials from input istreams. Note that the type of aMPolynomial defines the kind of constructed polynomial. For instance, if the stream is "x+1" and the type is MPolynomial&lt;2,int&gt;, then the polynomial is 2-variate like P(x,y)=1+x.</p>
<p>The stream is read till the end of line. It may stop before if the stream does not correspond anymore to a multi-variate polynomial. The stream is returned at the position where the polynomial reader stopped (except the newline).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream.</td></tr>
    <tr><td class="paramname">aMPolynomial</td><td>(returns) the modified polynomial constructed from the input stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">n</td><td>the number of variables of the polynomial</td></tr>
    <tr><td class="paramname">TRing</td><td>the coefficient ring</td></tr>
    <tr><td class="paramname">TAlloc</td><td>is an allocator for TRing, for example std::allocator&lt;TRing&gt;; this is also the default parameter. Usually this parameter does not needs to be changed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92450fc7a0bf65f4932235a3f91da5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92450fc7a0bf65f4932235a3f91da5c6">&#9670;&nbsp;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; DGtal::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cubical Complex symmetric difference operation. Returns the cubical complex \( S1 \Delta S2 \).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input cubical complex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the cubical complex \( S1 \Delta S2 \). </dd></dl>

<p class="definition">Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00222">222</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;  {</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="testCubicalComplex_8cpp.html#a9f6eee55782bbac774730b7688010a1e">CC</a>;</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;    <a class="code" href="testCubicalComplex_8cpp.html#a9f6eee55782bbac774730b7688010a1e">CC</a> S( S1 );</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= CC::dimension; ++i )</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;      functions::setops::operator^=( S.myCells[ i ], S2.myCells[ i ] );</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    <span class="keywordflow">return</span> S;</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="CubicalComplex_8h_source.html#l01301">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>.</p>

</div>
</div>
<a id="a06f59aad62cd99cb5ea20c3a8ae3eae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f59aad62cd99cb5ea20c3a8ae3eae5">&#9670;&nbsp;</a></span>operator^=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp; DGtal::operator^= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cubical Complex symmetric difference operation. Updates the cubical complex <em>S1</em> as \( S1 \Delta S2 \).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input cubical complex, \( S1 \Delta S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the modified cubical complex S1. </dd></dl>

<p class="definition">Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00245">245</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;  {</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="testCubicalComplex_8cpp.html#a9f6eee55782bbac774730b7688010a1e">CC</a>;</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= CC::dimension; ++i )</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;      functions::setops::operator^=( S1.myCells[ i ], S2.myCells[ i ] );</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    <span class="keywordflow">return</span> S1;</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="CubicalComplex_8h_source.html#l01301">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>.</p>

</div>
</div>
<a id="ae9c2868470d3334e4a75f4aeeec81057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c2868470d3334e4a75f4aeeec81057">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; DGtal::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cubical Complex union operation. Returns the cubical complex \( S1 \cup S2 \). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input cubical complex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the cubical complex \( S1 \cup S2 \). </dd></dl>

<p class="definition">Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00139">139</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  {</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="testCubicalComplex_8cpp.html#a9f6eee55782bbac774730b7688010a1e">CC</a>;</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    <a class="code" href="testCubicalComplex_8cpp.html#a9f6eee55782bbac774730b7688010a1e">CC</a> S( S1 );</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= CC::dimension; ++i )</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;      functions::setops::operator|=( S.myCells[ i ],S2.myCells[ i ] );</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    <span class="keywordflow">return</span> S;</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="CubicalComplex_8h_source.html#l01301">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>.</p>

</div>
</div>
<a id="ad958d9fade88203495529f0fb4dc892b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad958d9fade88203495529f0fb4dc892b">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp; DGtal::operator|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cubical Complex union operation. Updates the cubical complex <em>S1</em> as \( S1 \cup S2 \). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input cubical complex, \( S1 \cup S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the modified cubical complex S1. </dd></dl>

<p class="definition">Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00160">160</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;  {</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="testCubicalComplex_8cpp.html#a9f6eee55782bbac774730b7688010a1e">CC</a>;</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= CC::dimension; ++i )</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;      functions::setops::operator|=( S1.myCells[ i ], S2.myCells[ i ] );</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    <span class="keywordflow">return</span> S1;</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="CubicalComplex_8h_source.html#l01301">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>.</p>

</div>
</div>
<a id="a72222c0249e63a488c6c1ebc23dffb36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72222c0249e63a488c6c1ebc23dffb36">&#9670;&nbsp;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; DGtal::operator~ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cubical Complex close operation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input cubical complex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new cubical complex that is the closing of S1. </dd></dl>

<p class="definition">Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00061">61</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  {</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    CubicalComplex&lt; TKSpace, TCellContainer &gt; S( S1 );</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    S.close();</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keywordflow">return</span> S;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classDGtal_1_1CubicalComplex.html#aaeda923879c69e02aa85ba6622698d97">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::close()</a>.</p>

</div>
</div>
<a id="a567c997ae858c829256cc8a13c04d230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567c997ae858c829256cc8a13c04d230">&#9670;&nbsp;</a></span>oppositeEndMaximalExtension() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::oppositeEndMaximalExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls s.extendBack() while possible </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of (bidirectional) segment computer </td></tr>
    <tr><td class="paramname">begin</td><td>any ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of CBidirectionalSegmentComputer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00225">225</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                                                                               {</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;  <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorCirculatorTraits&lt;typename SC::ConstIterator&gt;::Type Type; </div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;  <a class="code" href="namespaceDGtal.html#a462eaaf587bc04ebd2e6141bed3fc21e">oppositeEndMaximalExtension</a>( s, begin, Type() ); </div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00198">oppositeEndMaximalExtension()</a>.</p>

</div>
</div>
<a id="a9f50b26bc3256332ab287e1bb2a3e7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f50b26bc3256332ab287e1bb2a3e7cf">&#9670;&nbsp;</a></span>oppositeEndMaximalExtension() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::oppositeEndMaximalExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for <a class="el" href="classDGtal_1_1Circulator.html" title="Aim: Provides an adapter for classical iterators that can iterate through the underlying data structu...">Circulator</a> type </p>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00209">209</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;{</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;  boost::ignore_unused_variable_warning( begin );</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;  <span class="comment">//stop if the segment is the whole range</span></div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> newBegin( s.end() ); </div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;  <span class="keywordflow">while</span> ( (s.extendBack())</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;       &amp;&amp; (s.begin() != newBegin) ) {}</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a462eaaf587bc04ebd2e6141bed3fc21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462eaaf587bc04ebd2e6141bed3fc21e">&#9670;&nbsp;</a></span>oppositeEndMaximalExtension() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::oppositeEndMaximalExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for Iterator type </p>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00198">198</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;                                                                                              {</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;  <span class="comment">//extend one more time if s.begin() == begin</span></div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;  <span class="keywordflow">while</span> ( (s.begin() != begin)</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;       &amp;&amp; (s.extendBack()) ) {}</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;  <span class="keywordflow">if</span> (s.begin() == begin) s.extendBack();</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00449">firstMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00717">lastMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00587">mostCenteredMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00225">oppositeEndMaximalExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00928">previousMaximalSegment()</a>.</p>

</div>
</div>
<a id="a137f26d321873e90065142afff6fa928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137f26d321873e90065142afff6fa928">&#9670;&nbsp;</a></span>oppositeEndMaximalRetraction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::oppositeEndMaximalRetraction </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls s.retractFront() while s.isExtendableBack() returns false </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">begin</td><td>any ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00341">341</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;{</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;  <span class="keywordflow">if</span> ( isNotEmpty&lt;typename SC::ConstIterator&gt;(s.begin(),begin) ) {</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    <span class="keywordflow">while</span> ( (! s.isExtendableBack() ) </div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;          &amp;&amp;(s.retractFront() ) ) {}  </div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;  } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;    <span class="keywordflow">while</span> ( s.retractFront() ) {} </div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;  }</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00928">previousMaximalSegment()</a>.</p>

</div>
</div>
<a id="af03fbf680fc202a21ef0801ee9240934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03fbf680fc202a21ef0801ee9240934">&#9670;&nbsp;</a></span>previousMaximalSegment() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::previousMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the previous maximal segment of s (s is assumed to be maximal) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">begin</td><td>any begin ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00978">978</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;{</div>
<div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;  <a class="code" href="namespaceDGtal.html#adabb9ea04f81cba914f3ac178439ffd4">previousMaximalSegment</a>(s, begin, </div>
<div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;<span class="keyword">typename</span> <a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::SegmentComputerTraits&lt;SC&gt;::Category</a>() );</div>
<div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;}</div>
<div class="ttc" id="anamespaceDGtal_html_adabb9ea04f81cba914f3ac178439ffd4"><div class="ttname"><a href="namespaceDGtal.html#adabb9ea04f81cba914f3ac178439ffd4">DGtal::previousMaximalSegment</a></div><div class="ttdeci">void previousMaximalSegment(SC &amp;s, const typename SC::ConstIterator &amp;begin, DGtal::ForwardSegmentComputer)</div><div class="ttdef"><b>Definition:</b> <a href="SegmentComputerUtils_8h_source.html#l00895">SegmentComputerUtils.h:895</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00895">previousMaximalSegment()</a>.</p>

</div>
</div>
<a id="a8e35d35160afaea835678e7bf4a3458c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e35d35160afaea835678e7bf4a3458c">&#9670;&nbsp;</a></span>previousMaximalSegment() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::previousMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the previous maximal segment of s (s is assumed to be maximal) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">begin</td><td>any begin ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of CBidirectionalSegmentComputer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>lastMaximalSegment of &ndash;s.begin() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00912">912</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;{</div>
<div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;  <span class="keywordflow">if</span> ( isNotEmpty&lt;typename SC::ConstIterator&gt;(s.begin(),begin) )</div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;    <a class="code" href="namespaceDGtal.html#a19f04b5f095862ee00e620f8246df2f8">lastMaximalSegment</a>(s, --s.begin(), begin, s.end(), <a class="code" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>() );</div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00681">lastMaximalSegment()</a>.</p>

</div>
</div>
<a id="afa1f75e59b72ea5e69760c965e20b3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1f75e59b72ea5e69760c965e20b3ff">&#9670;&nbsp;</a></span>previousMaximalSegment() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::previousMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the previous maximal segment of s (s is assumed to be maximal) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">begin</td><td>any begin ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of CDynamicSegmentComputer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00928">928</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;{</div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160; </div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a>; </div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160; </div>
<div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;  <span class="comment">//rectract</span></div>
<div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;  <a class="code" href="namespaceDGtal.html#a137f26d321873e90065142afff6fa928">oppositeEndMaximalRetraction</a>(s, begin); </div>
<div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160; </div>
<div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;  <span class="comment">//intersection test</span></div>
<div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;  <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a> i( s.end() ); --i; </div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;  <span class="comment">//if the intersection between the two </span></div>
<div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;  <span class="comment">// consecutive maximal segments is empty </span></div>
<div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;  <span class="keywordflow">if</span> ( i == s.begin() ) {</div>
<div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;    <span class="keywordflow">if</span> ( isNotEmpty&lt;ConstIterator&gt;(i, begin) ) {</div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;      --i; </div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;      s.init(i);  </div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;    }</div>
<div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;  }</div>
<div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160; </div>
<div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;  <span class="comment">//extend</span></div>
<div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;  <a class="code" href="namespaceDGtal.html#a462eaaf587bc04ebd2e6141bed3fc21e">oppositeEndMaximalExtension</a>(s, begin);</div>
<div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160; </div>
<div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;}</div>
<div class="ttc" id="anamespaceDGtal_html_a137f26d321873e90065142afff6fa928"><div class="ttname"><a href="namespaceDGtal.html#a137f26d321873e90065142afff6fa928">DGtal::oppositeEndMaximalRetraction</a></div><div class="ttdeci">void oppositeEndMaximalRetraction(SC &amp;s, const typename SC::ConstIterator &amp;begin)</div><div class="ttdef"><b>Definition:</b> <a href="SegmentComputerUtils_8h_source.html#l00341">SegmentComputerUtils.h:341</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00198">oppositeEndMaximalExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00341">oppositeEndMaximalRetraction()</a>.</p>

</div>
</div>
<a id="adabb9ea04f81cba914f3ac178439ffd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabb9ea04f81cba914f3ac178439ffd4">&#9670;&nbsp;</a></span>previousMaximalSegment() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::previousMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the previous maximal segment of s (s is assumed to be maximal) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">begin</td><td>any begin ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of CForwardSegmentComputer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>lastMaximalSegment of &ndash;s.begin() </dd></dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00895">895</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;{</div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;  <span class="keywordflow">if</span> ( isNotEmpty&lt;typename SC::ConstIterator&gt;(s.begin(),begin) )</div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;    <a class="code" href="namespaceDGtal.html#a19f04b5f095862ee00e620f8246df2f8">lastMaximalSegment</a>(s, --s.begin(), begin, s.end(), <a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>() );</div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00681">lastMaximalSegment()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00963">previousMaximalSegment()</a>.</p>

</div>
</div>
<a id="ad14e74091568436294698404dc08c9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14e74091568436294698404dc08c9c5">&#9670;&nbsp;</a></span>previousMaximalSegment() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::previousMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="greedy-plane-segmentation_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">SC::ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the previous maximal segment of s (s is assumed to be maximal) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">end</td><td>end ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SC</td><td>any model of CDynamicBidirectionalSegmentComputer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DynamicSegmentComputer</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00963">963</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;{ </div>
<div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;  <a class="code" href="namespaceDGtal.html#adabb9ea04f81cba914f3ac178439ffd4">previousMaximalSegment</a>(s, end, <a class="code" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>() ); </div>
<div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SegmentComputerUtils_8h_source.html#l00895">previousMaximalSegment()</a>.</p>

</div>
</div>
<a id="a7cb96c2af7c44c9d1b5f6690317c8530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb96c2af7c44c9d1b5f6690317c8530">&#9670;&nbsp;</a></span>rangeMiddle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IC DGtal::rangeMiddle </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the middle iterator of a given range [ <em>itb</em> , <em>ite</em> ). If the size of a given range is n, its middle would be equal to the iterator <em>itb</em> after n/2 incrementations. In the two following examples, m locates the middle of the range : <br  />
</p><ul>
<li>odd case: b&mdash;|&mdash;m&mdash;|&mdash;|&mdash;e</li>
<li>even case: b&mdash;|&mdash;|&mdash;m&mdash;|&mdash;|&mdash;e <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator of the range </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the middle iterator of the range [ <em>itb</em> , <em>ite</em> ) </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IC</td><td>any model iterator or circulator </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

<p class="reference">Referenced by <a class="el" href="testIteratorFunctions_8cpp_source.html#l00247">testMiddle()</a>.</p>

</div>
</div>
<a id="a25eb68dd5105a89999495322717ad375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25eb68dd5105a89999495322717ad375">&#9670;&nbsp;</a></span>rangeSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1IteratorCirculatorTraits.html">IteratorCirculatorTraits</a>&lt;IC&gt;::Difference DGtal::rangeSize </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the size of a given range [ <em>itb</em> , <em>ite</em> ) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator of the range </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IC</td><td>any model of iterator or circulator </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="testIteratorFunctions_8cpp_source.html#l00129">testSize()</a>.</p>

</div>
</div>
<a id="aa1ae76fb7492c32363914f09e8ad5d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ae76fb7492c32363914f09e8ad5d23">&#9670;&nbsp;</a></span>raw_reader_read_word()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FILE* DGtal::raw_reader_read_word </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word &amp;&#160;</td>
          <td class="paramname"><em>aValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic read word (binary mode) in little-endian mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fin</td><td>input FILE. </td></tr>
    <tr><td class="paramname">aValue</td><td>value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>modified stream. </dd></dl>

</div>
</div>
<a id="a6e4f65e9452ec5865b8959a728a0f2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4f65e9452ec5865b8959a728a0f2db">&#9670;&nbsp;</a></span>raw_writer_write_word()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Word &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::raw_writer_write_word </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>outs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Word&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic write word (binary mode) in little-endian.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outs</td><td>output stream. </td></tr>
    <tr><td class="paramname">value</td><td>value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>modified stream. </dd></dl>

</div>
</div>
<a id="af1ed66b76e2b393001ace71569e839ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ed66b76e2b393001ace71569e839ff">&#9670;&nbsp;</a></span>setDimensionsIn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::bitset&lt;<a class="el" href="viewDualSurface_8cpp.html#a1a254aa17418553bc21790001a69262a">dim</a>&gt; DGtal::setDimensionsIn </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a bitset having true for each dimension presents in dimensions. </dd></dl>

</div>
</div>
<a id="ac0d0cc741e29aea32636e795dda2f109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d0cc741e29aea32636e795dda2f109">&#9670;&nbsp;</a></span>setDimensionsNotIn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::bitset&lt;<a class="el" href="viewDualSurface_8cpp.html#a1a254aa17418553bc21790001a69262a">dim</a>&gt; DGtal::setDimensionsNotIn </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a bitset having true for each dimension not presents in dimensions. </dd></dl>

</div>
</div>
<a id="a202be24e94b5bdfba2d8563d0947f373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202be24e94b5bdfba2d8563d0947f373">&#9670;&nbsp;</a></span>setFromImage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::setFromImage </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const O &amp;&#160;</td>
          <td class="paramname"><em>ito</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">I::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>aThreshold</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill a set through the inserter <em>ito</em> with the points lying within the domain of the image <em>aImg</em> whose value (in the image) is less than or equal to <em>aThreshold</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aImg</td><td>any image </td></tr>
    <tr><td class="paramname">ito</td><td>set inserter </td></tr>
    <tr><td class="paramname">aThreshold</td><td>any value (default: 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>any model of CConstImage </td></tr>
    <tr><td class="paramname">O</td><td>any model of output iterator </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="exampleGridCurve3d-2_8cpp_source.html#l00085">main()</a>, and <a class="el" href="testImagesSetsUtilities_8cpp_source.html#l00135">testSetFromImage()</a>.</p>

</div>
</div>
<a id="aecddf53312d4b765f34a022b049627c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecddf53312d4b765f34a022b049627c3">&#9670;&nbsp;</a></span>setFromImage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::setFromImage </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const O &amp;&#160;</td>
          <td class="paramname"><em>ito</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">I::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">I::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>up</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill a set through the inserter <em>ito</em> with the points lying within the domain of the image <em>aImg</em> whose value (in the image) lies between <em>low</em> and <em>up</em> (both included)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aImg</td><td>any image </td></tr>
    <tr><td class="paramname">ito</td><td>set inserter </td></tr>
    <tr><td class="paramname">low</td><td>lower value </td></tr>
    <tr><td class="paramname">up</td><td>upper value</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>any model of CConstImage </td></tr>
    <tr><td class="paramname">O</td><td>any model of output iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad57d4465e40fe4c1982ec2e01985be73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57d4465e40fe4c1982ec2e01985be73">&#9670;&nbsp;</a></span>setFromPointsRangeAndFunctor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::setFromPointsRangeAndFunctor </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const O &amp;&#160;</td>
          <td class="paramname"><em>ito</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>aFunctor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">F::Value</a> &amp;&#160;</td>
          <td class="paramname"><em>aThreshold</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill a set through the inserter <em>ito</em> with the points of the range [<em>itb</em> , <em>ite</em> ) such that their associated value (returned by <em>aFunctor</em> ) is less than or equal to <em>aThreshold</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator on points </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator on points </td></tr>
    <tr><td class="paramname">ito</td><td>output iterator on points </td></tr>
    <tr><td class="paramname">aFunctor</td><td>any functor on points </td></tr>
    <tr><td class="paramname">aThreshold</td><td>any value (default: 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>any model of input iterator </td></tr>
    <tr><td class="paramname">O</td><td>any model of output iterator </td></tr>
    <tr><td class="paramname">F</td><td>any model of CPointFunctor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad67647d42db11b7b3d3533e1cba6c2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67647d42db11b7b3d3533e1cba6c2ba">&#9670;&nbsp;</a></span>setFromPointsRangeAndPredicate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::setFromPointsRangeAndPredicate </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const O &amp;&#160;</td>
          <td class="paramname"><em>ito</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>aPred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>useful functions </p>
<p>Fill a set through the inserter <em>ito</em> with the points of the range [<em>itb</em> , <em>ite</em> ) such that <em>aPred</em> is true</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator on points </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator on points </td></tr>
    <tr><td class="paramname">ito</td><td>output iterator on points </td></tr>
    <tr><td class="paramname">aPred</td><td>any predicate</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>any model of input iterator </td></tr>
    <tr><td class="paramname">O</td><td>any model of output iterator </td></tr>
    <tr><td class="paramname">P</td><td>any model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">concepts::CPointPredicate</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="testImagesSetsUtilities_8cpp_source.html#l00135">testSetFromImage()</a>.</p>

</div>
</div>
<a id="a66b5d1c71b11470ae43ced01591c326d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b5d1c71b11470ae43ced01591c326d">&#9670;&nbsp;</a></span>subRangeMiddle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IC DGtal::subRangeMiddle </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the middle iterator of a given subrange [ <em>itb</em> , <em>ite</em> ) (calls rangeMiddle with <a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a> whatever the true type of <em>IC</em>) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator of the subrange </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator of the subrange </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the middle iterator of the subrange [ <em>itb</em> , <em>ite</em> ) </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IC</td><td>any model of iterator or circulator </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="testIteratorFunctions_8cpp_source.html#l00247">testMiddle()</a>.</p>

</div>
</div>
<a id="a5272d9b624e986d687282c2d2ba21527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5272d9b624e986d687282c2d2ba21527">&#9670;&nbsp;</a></span>subRangeSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1IteratorCirculatorTraits.html">IteratorCirculatorTraits</a>&lt;IC&gt;::Difference DGtal::subRangeSize </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the size of a given subrange [ <em>itb</em> , <em>ite</em> ), (calls rangeSize functions with <a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>, whatever the true type of <em>IC</em>) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator of the subrange </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator of the subrange </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IC</td><td>any model of iterator or circulator </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="testIteratorFunctions_8cpp_source.html#l00129">testSize()</a>.</p>

</div>
</div>
<a id="af54927e5046a35cccb452a0b72e27b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af54927e5046a35cccb452a0b72e27b76">&#9670;&nbsp;</a></span>sup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension ptDim, typename LeftEuclideanRing , typename LeftContainer , typename RightEuclideanRing , typename RightContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DGtal::sup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, LeftEuclideanRing, LeftContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; ptDim, RightEuclideanRing, RightContainer &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(<a class="el" href="namespaceDGtal.html#abc6d219dcad7382fbe63f8b98941d0d8">DGtal::constructFromArithmeticConversion</a>(lhs, rhs))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the supremum (or least upper bound). </p>
<p>It means the point whose coordinates are exactly the maximum of the two points coordinate by coordinate.</p>
<dl class="section return"><dt>Returns</dt><dd>a new point (with best Euclidean ring type accordingly to the C++ conversion rules) being the sup between *this and apoint. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceDGtal.html#a7f9e179d700c18214b8be7752c7c2d2b" title="Return true if the first point is upper the second point.">isUpper</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="testPointVector_8cpp_source.html#l00152">TEST_CASE()</a>.</p>

</div>
</div>
<a id="a446432667939719ccd514801eaebbf97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446432667939719ccd514801eaebbf97">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter , class Hash , class KeyEqual , class UnorderedMapAllocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This functions swaps in O(1) the given two sets. Calls <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a36172e48062d5a70acd083827ed5f225">UnorderedSetByBlock::swap</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>the type of integral array. </td></tr>
    <tr><td class="paramname">TSplitter</td><td>the type for splitting a key into a block and a bit (see <a class="el" href="structDGtal_1_1Splitter.html">Splitter</a>). </td></tr>
    <tr><td class="paramname">Hash</td><td>the type that provides a hasher for Key. </td></tr>
    <tr><td class="paramname">KeyEqual</td><td>the type that provides an equality comparator for Key. </td></tr>
    <tr><td class="paramname">UnorderedMapAllocator</td><td>the type that provides an allocator for the underlying unordered_map container. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l01099">1099</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;  {</div>
<div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;    s1.swap( s2 );</div>
<div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="QuickHull_8h_source.html#l00926">DGtal::QuickHull&lt; TKernel &gt;::renumberInfiniteFacets()</a>.</p>

</div>
</div>
<a id="a9d0c060685d6e9a49445a562a99c5286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0c060685d6e9a49445a562a99c5286">&#9670;&nbsp;</a></span>testImplicitDigitalSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KSpace , typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::testImplicitDigitalSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae4aa1c6d804b5e0ad5de4fb395a96321">KSpace::Surfel</a> &amp;&#160;</td>
          <td class="paramname"><em>bel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="testImplicitDigitalSurface-benchmark_8cpp_source.html#l00049">49</a> of file <a class="el" href="testImplicitDigitalSurface-benchmark_8cpp_source.html">testImplicitDigitalSurface-benchmark.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  {</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <span class="keyword">typedef</span> <a class="code" href="classDGtal_1_1ImplicitDigitalSurface.html">ImplicitDigitalSurface&lt;KSpace,PointPredicate&gt;</a> Boundary;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    <span class="keyword">typedef</span> <span class="keyword">typename</span> Boundary::SurfelConstIterator <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a>;</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    </div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbok = 0;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb = 0;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a> ( <span class="stringliteral">&quot;Testing block ... ImplicitDigitalSurface&quot;</span> );</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a> ( <span class="stringliteral">&quot;ImplicitDigitalSurface instanciation&quot;</span> );</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    Boundary boundary( <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, pp,</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;                       <a class="code" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency&lt;KSpace::dimension&gt;</a>( <span class="keyword">true</span> ), bel,</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;                       <span class="keyword">true</span> );</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a> ( <span class="stringliteral">&quot;Counting the number of surfels (breadth first traversal)&quot;</span> );</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbsurfels = 0;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <span class="keywordflow">for</span> ( <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a> it = boundary.begin(), it_end = boundary.end();</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;          it != it_end; ++it )</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;      {</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        ++nbsurfels;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;      }</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; nbsurfels &lt;&lt; <span class="stringliteral">&quot; surfels found.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    nb++; nbok += nbsurfels == 354382 ? 1 : 0;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; nbok &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; nb &lt;&lt; <span class="stringliteral">&quot;) &quot;</span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;                   &lt;&lt; <span class="stringliteral">&quot;nbsurfels == 354382&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <span class="keywordflow">return</span> nbok == nb;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  }</div>
<div class="ttc" id="aclassDGtal_1_1ImplicitDigitalSurface_html"><div class="ttname"><a href="classDGtal_1_1ImplicitDigitalSurface.html">DGtal::ImplicitDigitalSurface</a></div><div class="ttdoc">Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...</div><div class="ttdef"><b>Definition:</b> <a href="ImplicitDigitalSurface_8h_source.html#l00071">ImplicitDigitalSurface.h:72</a></div></div>
<div class="ttc" id="aclassDGtal_1_1SurfelAdjacency_html"><div class="ttname"><a href="classDGtal_1_1SurfelAdjacency.html">DGtal::SurfelAdjacency&lt; KSpace::dimension &gt;</a></div></div>
<div class="ttc" id="aclassDGtal_1_1Trace_html_a352b7160bf722e2f0bcbee5d0bad6ef3"><div class="ttname"><a href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">DGtal::Trace::beginBlock</a></div><div class="ttdeci">void beginBlock(const std::string &amp;keyword=&quot;&quot;)</div></div>
<div class="ttc" id="aclassDGtal_1_1Trace_html_ad054990834d2763627166540087a2980"><div class="ttname"><a href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">DGtal::Trace::info</a></div><div class="ttdeci">std::ostream &amp; info()</div></div>
<div class="ttc" id="aclassDGtal_1_1Trace_html_afa3a2874289734884107b1ce68ccb93d"><div class="ttname"><a href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">DGtal::Trace::endBlock</a></div><div class="ttdeci">double endBlock()</div></div>
<div class="ttc" id="atestCubicalComplex_8cpp_html_a2b87ed989d2519d025bd5d4fbcbac062"><div class="ttname"><a href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a></div><div class="ttdeci">KSpace K</div><div class="ttdef"><b>Definition:</b> <a href="testCubicalComplex_8cpp_source.html#l00062">testCubicalComplex.cpp:62</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">DGtal::Trace::beginBlock()</a>, <a class="el" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">DGtal::Trace::endBlock()</a>, <a class="el" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">DGtal::Trace::info()</a>, <a class="el" href="testCubicalComplex_8cpp_source.html#l00062">K</a>, and <a class="el" href="Common_8h_source.html#l00154">trace</a>.</p>

</div>
</div>
<a id="a08886ee117009e48c66e4349c7c47265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08886ee117009e48c66e4349c7c47265">&#9670;&nbsp;</a></span>testLightImplicitDigitalSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KSpace , typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::testLightImplicitDigitalSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae4aa1c6d804b5e0ad5de4fb395a96321">KSpace::Surfel</a> &amp;&#160;</td>
          <td class="paramname"><em>bel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="testLightImplicitDigitalSurface-benchmark_8cpp_source.html#l00049">49</a> of file <a class="el" href="testLightImplicitDigitalSurface-benchmark_8cpp_source.html">testLightImplicitDigitalSurface-benchmark.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  {</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <span class="keyword">typedef</span> <a class="code" href="classDGtal_1_1LightImplicitDigitalSurface.html">LightImplicitDigitalSurface&lt;KSpace,PointPredicate&gt;</a> Boundary;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    <span class="keyword">typedef</span> <span class="keyword">typename</span> Boundary::SurfelConstIterator <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a>;</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    </div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbok = 0;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb = 0;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a> ( <span class="stringliteral">&quot;Testing block ... LightImplicitDigitalSurface&quot;</span> );</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a> ( <span class="stringliteral">&quot;LightImplicitDigitalSurface instanciation&quot;</span> );</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    Boundary boundary( <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, pp,</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;                       <a class="code" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency&lt;KSpace::dimension&gt;</a>( <span class="keyword">true</span> ), bel );</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a> ( <span class="stringliteral">&quot;Counting the number of surfels (breadth first traversal)&quot;</span> );</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbsurfels = 0;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keywordflow">for</span> ( <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a> it = boundary.begin(), it_end = boundary.end();</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;          it != it_end; ++it )</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;      {</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;        ++nbsurfels;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;      }</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; nbsurfels &lt;&lt; <span class="stringliteral">&quot; surfels found.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    nb++; nbok += nbsurfels == 354382 ? 1 : 0;</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; nbok &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; nb &lt;&lt; <span class="stringliteral">&quot;) &quot;</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;                   &lt;&lt; <span class="stringliteral">&quot;nbsurfels == 354382&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    <span class="keywordflow">return</span> nbok == nb;</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  }</div>
<div class="ttc" id="aclassDGtal_1_1LightImplicitDigitalSurface_html"><div class="ttname"><a href="classDGtal_1_1LightImplicitDigitalSurface.html">DGtal::LightImplicitDigitalSurface</a></div><div class="ttdoc">Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...</div><div class="ttdef"><b>Definition:</b> <a href="LightImplicitDigitalSurface_8h_source.html#l00115">LightImplicitDigitalSurface.h:116</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">DGtal::Trace::beginBlock()</a>, <a class="el" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">DGtal::Trace::endBlock()</a>, <a class="el" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">DGtal::Trace::info()</a>, <a class="el" href="testCubicalComplex_8cpp_source.html#l00062">K</a>, and <a class="el" href="Common_8h_source.html#l00154">trace</a>.</p>

</div>
</div>
<a id="a604c07ec391ad12a1f3fb6479993f112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a604c07ec391ad12a1f3fb6479993f112">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Trace.html">Trace</a> DGtal::trace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDGtal.html#ae801de7ee4d22c47257dc7e00e0c5dd7">traceWriterTerm</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a948cc02e8fe7e8ab1051bce164421fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948cc02e8fe7e8ab1051bce164421fa8">&#9670;&nbsp;</a></span>Xe_k() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, typename Ring , typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;n, Ring, Alloc&gt; DGtal::Xe_k </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a monomial X_k^e </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the index of the variable (X_k) </td></tr>
    <tr><td class="paramname">e</td><td>the exponent for X_k </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 1-variable polynomial X_0^e </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">n</td><td>the number of indetermionates. </td></tr>
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
    <tr><td class="paramname">Alloc</td><td>the type of allocator. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MPolynomial_8h_source.html#l01654">1654</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01655"></a><span class="lineno"> 1655</span>&#160;  {</div>
<div class="line"><a name="l01656"></a><span class="lineno"> 1656</span>&#160;    <span class="keywordflow">return</span> Xe_kComputer&lt;n, Ring, Alloc&gt;().get( k, e );</div>
<div class="line"><a name="l01657"></a><span class="lineno"> 1657</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="MPolynomial_8h_source.html#l01614">DGtal::Xe_kComputer&lt; n, Ring, Alloc &gt;::get()</a>.</p>

</div>
</div>
<a id="ad099005ab7d493b2ea19026e2fb96a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad099005ab7d493b2ea19026e2fb96a32">&#9670;&nbsp;</a></span>Xe_k() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, typename Ring &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;n, Ring, std::allocator&lt;Ring&gt; &gt; DGtal::Xe_k </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a monomial X_k^e </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the index of the variable (X_k) </td></tr>
    <tr><td class="paramname">e</td><td>the exponent for X_k </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 1-variable polynomial X_0^e </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">n</td><td>the number of indetermionates. </td></tr>
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MPolynomial_8h_source.html#l01670">1670</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01671"></a><span class="lineno"> 1671</span>&#160;  {</div>
<div class="line"><a name="l01672"></a><span class="lineno"> 1672</span>&#160;    <span class="keywordflow">return</span> Xe_kComputer&lt;n, Ring, std::allocator&lt;Ring&gt; &gt;().get( k, e );</div>
<div class="line"><a name="l01673"></a><span class="lineno"> 1673</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a5fd8233d566e467056fa785b63463416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd8233d566e467056fa785b63463416">&#9670;&nbsp;</a></span>HALF_EDGE_INVALID_INDEX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t const DGtal::HALF_EDGE_INVALID_INDEX = boost::integer_traits&lt;std::size_t&gt;::const_max</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines the invalid half-edge (i.e. exterior).</p>
<dl class="section note"><dt>Note</dt><dd>It is defined external to the <a class="el" href="classDGtal_1_1HalfEdgeDataStructure.html" title="Aim: This class represents an half-edge data structure, which is a structure for representing the top...">HalfEdgeDataStructure</a> because there was link error with gcc 4.8.4 for all variants within <a class="el" href="classDGtal_1_1HalfEdgeDataStructure.html" title="Aim: This class represents an half-edge data structure, which is a structure for representing the top...">HalfEdgeDataStructure</a> (e.g. BOOST_STATIC_CONSTANT, c++ constexpr, c++ constexpr with const reference). </dd></dl>

<p class="definition">Definition at line <a class="el" href="HalfEdgeDataStructure_8h_source.html#l00057">57</a> of file <a class="el" href="HalfEdgeDataStructure_8h_source.html">HalfEdgeDataStructure.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="HalfEdgeDataStructure_8h_source.html#l01413">DGtal::HalfEdgeDataStructure::arc2FaceIndex()</a>, <a class="el" href="HalfEdgeDataStructure_8h_source.html#l00566">DGtal::HalfEdgeDataStructure::boundaryArcs()</a>, <a class="el" href="HalfEdgeDataStructure_8h_source.html#l00552">DGtal::HalfEdgeDataStructure::boundaryHalfEdgeIndices()</a>, <a class="el" href="HalfEdgeDataStructure_8h_source.html#l00536">DGtal::HalfEdgeDataStructure::boundaryVertices()</a>, <a class="el" href="HalfEdgeDataStructure_8h_source.html#l00430">DGtal::HalfEdgeDataStructure::findHalfEdgeIndexFromArc()</a>, <a class="el" href="HalfEdgeDataStructure_8h_source.html#l00501">DGtal::HalfEdgeDataStructure::getNeighboringFaces()</a>, <a class="el" href="HalfEdgeDataStructure_8h_source.html#l00402">DGtal::HalfEdgeDataStructure::halfEdgeIndexFromArc()</a>, <a class="el" href="HalfEdgeDataStructure_8h_source.html#l00628">DGtal::HalfEdgeDataStructure::isFlippable()</a>, <a class="el" href="HalfEdgeDataStructure_8h_source.html#l00827">DGtal::HalfEdgeDataStructure::isMergeable()</a>, <a class="el" href="HalfEdgeDataStructure_8h_source.html#l01109">DGtal::HalfEdgeDataStructure::isValid()</a>, <a class="el" href="HalfEdgeDataStructure_8h_source.html#l00526">DGtal::HalfEdgeDataStructure::isVertexBoundary()</a>, and <a class="el" href="HalfEdgeDataStructure_8h_source.html#l00580">DGtal::HalfEdgeDataStructure::nbSides()</a>.</p>

</div>
</div>
<a id="a8fc7012708b0416880a5c8b12dfdf9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc7012708b0416880a5c8b12dfdf9dd">&#9670;&nbsp;</a></span>trace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Trace.html">Trace</a> DGtal::trace</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> Assert function.</p>
<p>ASSERT(expr) and ASSERT_MSG(expr, message) are defined and expr is avaluated only when NDEBUG isn't defined. FATAL_ERROR(expr) and FATAL_ERROR_MSG(expr, message) are always defined. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="dec_2exampleDECSurface_8cpp-example.html#a6">dec/exampleDECSurface.cpp</a>, <a class="el" href="dec_2exampleDiscreteExteriorCalculusSolve_8cpp-example.html#a0">dec/exampleDiscreteExteriorCalculusSolve.cpp</a>, <a class="el" href="dec_2exampleHeatLaplace_8cpp-example.html#a9">dec/exampleHeatLaplace.cpp</a>, <a class="el" href="dec_2examplePropagation_8cpp-example.html#a2">dec/examplePropagation.cpp</a>, <a class="el" href="geometry_2tools_2checkLatticeBallQuickHull_8cpp-example.html#a11">geometry/tools/checkLatticeBallQuickHull.cpp</a>, <a class="el" href="geometry_2tools_2exampleLatticeBallDelaunay3D_8cpp-example.html#a3">geometry/tools/exampleLatticeBallDelaunay3D.cpp</a>, <a class="el" href="geometry_2tools_2exampleQuickHull3D_8cpp-example.html#a3">geometry/tools/exampleQuickHull3D.cpp</a>, <a class="el" href="geometry_2tools_2exampleRationalBallDelaunay3D_8cpp-example.html#a3">geometry/tools/exampleRationalBallDelaunay3D.cpp</a>, <a class="el" href="geometry_2volumes_2distance_2exampleFMM3D_8cpp-example.html#a2">geometry/volumes/distance/exampleFMM3D.cpp</a>, <a class="el" href="tutorial-examples_2AreaSurfaceEstimation-final_8cpp-example.html#a1">tutorial-examples/AreaSurfaceEstimation-final.cpp</a>, <a class="el" href="tutorial-examples_2FMMErosion_8cpp-example.html#a3">tutorial-examples/FMMErosion.cpp</a>, and <a class="el" href="tutorial-examples_2volDTGranulo_8cpp-example.html#a3">tutorial-examples/volDTGranulo.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Common_8h_source.html#l00154">154</a> of file <a class="el" href="Common_8h_source.html">Common.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="testFMM_8cpp_source.html#l00233">accuracyTest()</a>, <a class="el" href="BoundedLatticePolytope_8h_source.html#l00745">DGtal::detail::BoundedLatticePolytopeSpecializer&lt; N, TInteger &gt;::addEdgeConstraint()</a>, <a class="el" href="BoundedRationalPolytope_8h_source.html#l00721">DGtal::detail::BoundedRationalPolytopeSpecializer&lt; N, TInteger &gt;::addEdgeConstraint()</a>, <a class="el" href="exampleAlphaShape_8cpp_source.html#l00123">alphaShape()</a>, <a class="el" href="Assert_8h_source.html#l00065">assert_failed()</a>, <a class="el" href="Assert_8h_source.html#l00081">assert_failed_message()</a>, <a class="el" href="ATSolver2D_8h_source.html#l00202">DGtal::ATSolver2D&lt; TKSpace, TLinearAlgebra &gt;::ATSolver2D()</a>, <a class="el" href="testCirculator_8cpp_source.html#l00151">basicBidirectionalTest()</a>, <a class="el" href="testCirculator_8cpp_source.html#l00089">basicForwardTest()</a>, <a class="el" href="testCirculator_8cpp_source.html#l00190">basicRandomAccessTest()</a>, <a class="el" href="testArithmeticalDSSConvexHull_8cpp_source.html#l00061">basicTest()</a>, <a class="el" href="testArithmeticalDSSConvexHull_8cpp_source.html#l00499">basicTest2()</a>, <a class="el" href="testOwningOrAliasingPtr_8cpp_source.html#l00180">basicUsage()</a>, <a class="el" href="IntegerConverter_8h_source.html#l00281">DGtal::IntegerConverter&lt; dim, DGtal::int64_t &gt;::cast()</a>, <a class="el" href="IntegerConverter_8h_source.html#l00173">DGtal::IntegerConverter&lt; dim, DGtal::int32_t &gt;::cast()</a>, <a class="el" href="QuickHull_8h_source.html#l00715">DGtal::QuickHull&lt; TKernel &gt;::check()</a>, <a class="el" href="testChordGenericStandardPlaneComputer_8cpp_source.html#l00083">checkChordGenericStandardPlaneComputer()</a>, <a class="el" href="testCOBAGenericStandardPlaneComputer_8cpp_source.html#l00083">checkCOBAGenericStandardPlaneComputer()</a>, <a class="el" href="testLatticePolytope2D_8cpp_source.html#l00051">checkCut()</a>, <a class="el" href="testChordNaivePlaneComputer_8cpp_source.html#l00695">checkExtendWithManyPoints()</a>, <a class="el" href="QuickHull_8h_source.html#l01161">DGtal::QuickHull&lt; TKernel &gt;::checkFacet()</a>, <a class="el" href="QuickHull_8h_source.html#l00762">DGtal::QuickHull&lt; TKernel &gt;::checkHull()</a>, <a class="el" href="testCompressedVolWriter_8cpp_source.html#l00052">checkImage()</a>, <a class="el" href="testChordNaivePlaneComputer_8cpp_source.html#l00675">checkManyPlanes()</a>, <a class="el" href="testPowerMap_8cpp_source.html#l00091">checkPowerMap()</a>, <a class="el" href="testLighterSternBrocot_8cpp_source.html#l00619">checkSubStandardDSLQ0()</a>, <a class="el" href="ATSolver2D_8h_source.html#l00722">DGtal::ATSolver2D&lt; TKSpace, TLinearAlgebra &gt;::checkV0()</a>, <a class="el" href="testDistanceTransformationMetrics_8cpp_source.html#l00068">checkVoronoi()</a>, <a class="el" href="testChordNaivePlaneComputer_8cpp_source.html#l00426">checkWidth()</a>, <a class="el" href="QuickHull_8h_source.html#l00873">DGtal::QuickHull&lt; TKernel &gt;::cleanFacets()</a>, <a class="el" href="testCombinDSS_8cpp_source.html#l00140">CompareToArithmetical()</a>, <a class="el" href="testArithmeticalDSSConvexHull_8cpp_source.html#l00196">comparisonLeftHull()</a>, <a class="el" href="testArithmeticalDSS_8cpp_source.html#l00833">comparisonSubsegment()</a>, <a class="el" href="testArithmeticalDSSConvexHull_8cpp_source.html#l00685">comparisonSubsegment2()</a>, <a class="el" href="testArithmeticalDSS_8cpp_source.html#l00659">compatibleStepsTest()</a>, <a class="el" href="ConvexCellComplex_8h_source.html#l00442">DGtal::ConvexCellComplex&lt; TPoint &gt;::computeFaceGeometry()</a>, <a class="el" href="QuickHull_8h_source.html#l00523">DGtal::QuickHull&lt; TKernel &gt;::computeFacets()</a>, <a class="el" href="QuickHull_8h_source.html#l01454">DGtal::QuickHull&lt; TKernel &gt;::computeSimplexConfiguration()</a>, <a class="el" href="QuickHull_8h_source.html#l00553">DGtal::QuickHull&lt; TKernel &gt;::computeVertices()</a>, <a class="el" href="ConstImageAdapter_8h_source.html#l00134">DGtal::ConstImageAdapter&lt; TImageContainer, TNewDomain, TFunctorD, TNewValue, TFunctorV &gt;::ConstImageAdapter()</a>, <a class="el" href="testArithmeticalDSS_8cpp_source.html#l00740">constructorsTest()</a>, <a class="el" href="exampleConvexHull2D_8cpp_source.html#l00122">convexHull()</a>, <a class="el" href="testArithmeticalDSS_8cpp_source.html#l01302">createDSSTest()</a>, <a class="el" href="VoxelComplex_8h_source.html#l00384">DGtal::VoxelComplex&lt; TKSpace, TCellContainer &gt;::criticalCliques()</a>, <a class="el" href="BoundedLatticePolytope_8h_source.html#l00755">DGtal::detail::BoundedLatticePolytopeSpecializer&lt; N, TInteger &gt;::crossProduct()</a>, <a class="el" href="BoundedRationalPolytope_8h_source.html#l00731">DGtal::detail::BoundedRationalPolytopeSpecializer&lt; N, TInteger &gt;::crossProduct()</a>, <a class="el" href="Clone_8h_source.html#l00280">DGtal::Clone&lt; T &gt;::display()</a>, <a class="el" href="testLinearStructure_8cpp_source.html#l00281">display_operator_info()</a>, <a class="el" href="exampleGridCurve2d_8cpp_source.html#l00062">displayAll()</a>, <a class="el" href="testConstImageAdapter_8cpp_source.html#l00052">displayRange()</a>, <a class="el" href="exampleArithmeticalDSL_8cpp_source.html#l00185">drawArithmeticalDSL()</a>, <a class="el" href="exampleCurvature_8cpp_source.html#l00065">estimatorOnShapeDigitization()</a>, <a class="el" href="SphereFittingEstimator_8h_source.html#l00221">DGtal::functors::SphereFittingEstimator&lt; TSurfel, TEmbedder, TNormalVectorEstimatorCache &gt;::eval()</a>, <a class="el" href="exampleFMM2D_8cpp_source.html#l00124">example()</a>, <a class="el" href="exampleArithmeticalDSL_8cpp_source.html#l00356">exampleArithmeticalDSLTypes()</a>, <a class="el" href="exampleArithmeticalDSS_8cpp_source.html#l00197">exampleConstructors()</a>, <a class="el" href="exampleImageFactoryFromHDF5_8cpp_source.html#l00195">exampleImage3D()</a>, <a class="el" href="exampleArithmeticalDSL_8cpp_source.html#l00061">exampleNaiveDSL()</a>, <a class="el" href="exampleArithmeticalDSS_8cpp_source.html#l00060">exampleNaiveDSS()</a>, <a class="el" href="exampleArithmeticalDSL_8cpp_source.html#l00121">exampleStandardDSL()</a>, <a class="el" href="exampleArithmeticalDSS_8cpp_source.html#l00126">exampleStandardDSS()</a>, <a class="el" href="exampleImageFactoryFromHDF5_8cpp_source.html#l00470">exampleTiledImageFromHDF5_10blocks3D()</a>, <a class="el" href="exampleImageFactoryFromHDF5_8cpp_source.html#l00304">exampleTiledImageFromHDF5_1block3D()</a>, <a class="el" href="exampleImageFactoryFromHDF5_8cpp_source.html#l00355">exampleTiledImageFromImage_10blocks3D()</a>, <a class="el" href="exampleImageFactoryFromHDF5_8cpp_source.html#l00239">exampleTiledImageFromImage_1block3D()</a>, <a class="el" href="exampleArithmeticalDSS_8cpp_source.html#l00270">exampleUpdate()</a>, <a class="el" href="testLatticePolytope2D_8cpp_source.html#l00218">exhaustiveTestLatticePolytope2D()</a>, <a class="el" href="testArithmeticalDSS_8cpp_source.html#l00289">extensionTest()</a>, <a class="el" href="Assert_8h_source.html#l00093">fatal_error_failed()</a>, <a class="el" href="Assert_8h_source.html#l00104">fatal_error_failed_message()</a>, <a class="el" href="ImageFactoryFromHDF5_8h_source.html#l00435">DGtal::ImageFactoryFromHDF5&lt; TImageContainer &gt;::flushImage()</a>, <a class="el" href="NeighborhoodTablesGenerators_8h_source.html#l00071">DGtal::functions::generateSimplicityTable()</a>, <a class="el" href="NeighborhoodTablesGenerators_8h_source.html#l00132">DGtal::functions::generateVoxelComplexTable()</a>, <a class="el" href="ShortcutsGeometry_8h_source.html#l00699">DGtal::ShortcutsGeometry&lt; TKSpace &gt;::getCTrivialNormalVectors()</a>, <a class="el" href="ShortcutsGeometry_8h_source.html#l01176">DGtal::ShortcutsGeometry&lt; TKSpace &gt;::getIIGaussianCurvatures()</a>, <a class="el" href="ShortcutsGeometry_8h_source.html#l01052">DGtal::ShortcutsGeometry&lt; TKSpace &gt;::getIIMeanCurvatures()</a>, <a class="el" href="ShortcutsGeometry_8h_source.html#l00925">DGtal::ShortcutsGeometry&lt; TKSpace &gt;::getIINormalVectors()</a>, <a class="el" href="ShortcutsGeometry_8h_source.html#l01302">DGtal::ShortcutsGeometry&lt; TKSpace &gt;::getIIPrincipalCurvaturesAndDirections()</a>, <a class="el" href="Shortcuts_8h_source.html#l00331">DGtal::Shortcuts&lt; TKSpace &gt;::getKSpace()</a>, <a class="el" href="ShortcutsGeometry_8h_source.html#l00755">DGtal::ShortcutsGeometry&lt; TKSpace &gt;::getVCMNormalVectors()</a>, <a class="el" href="ShortcutsGeometry_8h_source.html#l01663">DGtal::ShortcutsGeometry&lt; TKSpace &gt;::getVectorsAngleDeviation()</a>, <a class="el" href="testSegmentation_8cpp_source.html#l00200">greedySegmentationVisualTest()</a>, <a class="el" href="raw2HDF5_8cpp_source.html#l00199">HDF5_3D2vol()</a>, <a class="el" href="Image_8h_source.html#l00099">DGtal::Image&lt; TImageContainer &gt;::Image()</a>, <a class="el" href="ImageAdapter_8h_source.html#l00139">DGtal::ImageAdapter&lt; TImageContainer, TNewDomain, TFunctorD, TNewValue, TFunctorV, TFunctorVm1 &gt;::ImageAdapter()</a>, <a class="el" href="GenericReader_8h_source.html#l00176">DGtal::GenericReader&lt; TContainer, Tdim, TValue &gt;::importWithColorFunctor()</a>, <a class="el" href="GenericReader_8h_source.html#l00434">DGtal::GenericReader&lt; TContainer, 2, TValue &gt;::importWithColorFunctor()</a>, <a class="el" href="GenericReader_8h_source.html#l00552">DGtal::GenericReader&lt; TContainer, 2, DGtal::uint32_t &gt;::importWithColorFunctor()</a>, <a class="el" href="GenericReader_8h_source.html#l00131">DGtal::GenericReader&lt; TContainer, Tdim, TValue &gt;::importWithValueFunctor()</a>, <a class="el" href="GenericReader_8h_source.html#l00482">DGtal::GenericReader&lt; TContainer, 2, TValue &gt;::importWithValueFunctor()</a>, <a class="el" href="GenericReader_8h_source.html#l00599">DGtal::GenericReader&lt; TContainer, 2, DGtal::uint32_t &gt;::importWithValueFunctor()</a>, <a class="el" href="GenericReader_8h_source.html#l00247">DGtal::GenericReader&lt; TContainer, 3, TValue &gt;::importWithValueFunctor()</a>, <a class="el" href="GenericReader_8h_source.html#l00338">DGtal::GenericReader&lt; TContainer, 3, DGtal::uint32_t &gt;::importWithValueFunctor()</a>, <a class="el" href="ATSolver2D_8h_source.html#l00330">DGtal::ATSolver2D&lt; TKSpace, TLinearAlgebra &gt;::initInputScalarFieldU2()</a>, <a class="el" href="ATSolver2D_8h_source.html#l00288">DGtal::ATSolver2D&lt; TKSpace, TLinearAlgebra &gt;::initInputVectorFieldU2()</a>, <a class="el" href="ATSolver2D_8h_source.html#l00975">DGtal::ATSolver2D&lt; TKSpace, TLinearAlgebra &gt;::initOperators()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l01024">DGtal::UnorderedSetByBlock&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::internal_trace_includes_by_iterator()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00970">DGtal::UnorderedSetByBlock&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::internal_trace_includes_by_map_iterator()</a>, <a class="el" href="HalfEdgeDataStructure_8h_source.html#l01109">DGtal::HalfEdgeDataStructure::isValid()</a>, <a class="el" href="HalfEdgeDataStructure_8h_source.html#l01322">DGtal::HalfEdgeDataStructure::isValidTriangulation()</a>, <a class="el" href="sphereCotangentLaplaceOperator_8cpp_source.html#l00089">laplacian()</a>, <a class="el" href="area-estimation-with-digital-surface_8cpp_source.html#l00083">main()</a>, <a class="el" href="testArithmeticalDSS_8cpp_source.html#l00052">mainTest()</a>, <a class="el" href="Shortcuts_8h_source.html#l01307">DGtal::Shortcuts&lt; TKSpace &gt;::makeIdxDigitalSurface()</a>, <a class="el" href="Shortcuts_8h_source.html#l00281">DGtal::Shortcuts&lt; TKSpace &gt;::makeImplicitShape3D()</a>, <a class="el" href="Shortcuts_8h_source.html#l01061">DGtal::Shortcuts&lt; TKSpace &gt;::makeLightDigitalSurface()</a>, <a class="el" href="HalfEdgeDataStructure_8h_source.html#l00865">DGtal::HalfEdgeDataStructure::merge()</a>, <a class="el" href="exampleArrayImageAdapter_8cpp_source.html#l00091">moduleImages_example()</a>, <a class="el" href="TiledImage_8h_source.html#l00706">DGtal::TiledImage&lt; TImageContainer, TImageFactory, TImageCacheReadPolicy, TImageCacheWritePolicy &gt;::operator()()</a>, <a class="el" href="BasicPointFunctors_8h_source.html#l00647">DGtal::functors::BasicDomainSubSampler&lt; TDomain, TInteger, TValue &gt;::operator()()</a>, <a class="el" href="BasicPointFunctors_8h_source.html#l00478">DGtal::functors::Point2DEmbedderIn3D&lt; TDomain3D, TInteger &gt;::operator()()</a>, <a class="el" href="ConstImageAdapter_8h_source.html#l00159">DGtal::ConstImageAdapter&lt; TImageContainer, TNewDomain, TFunctorD, TNewValue, TFunctorV &gt;::operator=()</a>, <a class="el" href="Image_8h_source.html#l00163">DGtal::Image&lt; TImageContainer &gt;::operator=()</a>, <a class="el" href="ImageAdapter_8h_source.html#l00165">DGtal::ImageAdapter&lt; TImageContainer, TNewDomain, TFunctorD, TNewValue, TFunctorV, TFunctorVm1 &gt;::operator=()</a>, <a class="el" href="QuickHull_8h_source.html#l01397">DGtal::QuickHull&lt; TKernel &gt;::pickInitialSimplex()</a>, <a class="el" href="ShroudsRegularization_8h_source.html#l00476">DGtal::ShroudsRegularization&lt; TDigitalSurfaceContainer &gt;::precomputeTopology()</a>, <a class="el" href="QuickHull_8h_source.html#l00969">DGtal::QuickHull&lt; TKernel &gt;::processFacet()</a>, <a class="el" href="SphereFittingEstimator_8h_source.html#l00187">DGtal::functors::SphereFittingEstimator&lt; TSurfel, TEmbedder, TNormalVectorEstimatorCache &gt;::pushSurfel()</a>, <a class="el" href="test2x2DetComputers_8cpp_source.html#l00205">randomTest2x2DetComputer()</a>, <a class="el" href="testArithmeticalDSS_8cpp_source.html#l00204">rangeTest()</a>, <a class="el" href="raw2HDF5_8cpp_source.html#l00059">raw2HDF5_3D()</a>, <a class="el" href="ShroudsRegularization_8h_source.html#l00304">DGtal::ShroudsRegularization&lt; TDigitalSurfaceContainer &gt;::regularize()</a>, <a class="el" href="QuickHull_8h_source.html#l00926">DGtal::QuickHull&lt; TKernel &gt;::renumberInfiniteFacets()</a>, <a class="el" href="ImageFactoryFromHDF5_8h_source.html#l00323">DGtal::ImageFactoryFromHDF5&lt; TImageContainer &gt;::requestImage()</a>, <a class="el" href="testArithmeticalDSS_8cpp_source.html#l00360">retractionTest()</a>, <a class="el" href="testMetrics-benchmark_8cpp_source.html#l00047">runATest()</a>, <a class="el" href="testSegmentation_8cpp_source.html#l00890">SaturatedSegmentationTest()</a>, <a class="el" href="testSegmentation_8cpp_source.html#l00549">SaturatedSegmentationVisualTest()</a>, <a class="el" href="testDigitalConvexity_8cpp_source.html#l00408">SCENARIO()</a>, <a class="el" href="QuickHull_8h_source.html#l00410">DGtal::QuickHull&lt; TKernel &gt;::setInitialSimplex()</a>, <a class="el" href="ATSolver2D_8h_source.html#l00463">DGtal::ATSolver2D&lt; TKSpace, TLinearAlgebra &gt;::setUp()</a>, <a class="el" href="testCombinDSS_8cpp_source.html#l00244">showGreedySegmantation()</a>, <a class="el" href="test2x2DetComputers_8cpp_source.html#l00056">simpleTest2x2DetComputer()</a>, <a class="el" href="ATSolver2D_8h_source.html#l00605">DGtal::ATSolver2D&lt; TKSpace, TLinearAlgebra &gt;::solveForEpsilon()</a>, <a class="el" href="ATSolver2D_8h_source.html#l00656">DGtal::ATSolver2D&lt; TKSpace, TLinearAlgebra &gt;::solveGammaConvergence()</a>, <a class="el" href="ATSolver2D_8h_source.html#l00546">DGtal::ATSolver2D&lt; TKSpace, TLinearAlgebra &gt;::solveOneAlternateStep()</a>, <a class="el" href="testArithmeticalDSLKernel_8cpp_source.html#l00094">specialCases()</a>, <a class="el" href="testFP_8cpp_source.html#l00112">stoppingCriterionTest()</a>, <a class="el" href="DECCommon_8h_source.html#l00059">HodgeTester&lt; Calculus, order &gt;::test()</a>, <a class="el" href="DECCommon_8h_source.html#l00200">DerivativeTester&lt; Calculus, order &gt;::test()</a>, <a class="el" href="testArithmeticalDSLKernel_8cpp_source.html#l00054">test()</a>, <a class="el" href="testImageFactoryFromHDF5_8cpp_source.html#l00308">test2D_int32()</a>, <a class="el" href="testTiledImage_8cpp_source.html#l00129">test3d()</a>, <a class="el" href="testSurfaceHelper_8cpp_source.html#l00190">test3dSurfaceHelper()</a>, <a class="el" href="testCompressedVolWriter_8cpp_source.html#l00089">TEST_CASE()</a>, <a class="el" href="benchmarkHyperRectDomain_8cpp_source.html#l00089">TEST_CASE_METHOD()</a>, <a class="el" href="testImageAdapter_8cpp_source.html#l00145">test_g_f_fm1()</a>, <a class="el" href="testImageContainerByHashTree_8cpp_source.html#l00120">test_get()</a>, <a class="el" href="testITKio_8cpp_source.html#l00049">test_image()</a>, <a class="el" href="testLinearStructure_8cpp_source.html#l00286">test_linear_ring()</a>, <a class="el" href="testLinearStructure_8cpp_source.html#l00046">test_linear_structure()</a>, <a class="el" href="testClock_8cpp_source.html#l00058">test_loopTick()</a>, <a class="el" href="testLinearStructure_8cpp_source.html#l00450">test_manual_operators_2d()</a>, <a class="el" href="testLinearStructure_8cpp_source.html#l00337">test_manual_operators_3d()</a>, <a class="el" href="testClock_8cpp_source.html#l00044">test_minimalTick()</a>, <a class="el" href="testClock_8cpp_source.html#l00073">test_MultipleLoop()</a>, <a class="el" href="testImageAdapter_8cpp_source.html#l00228">test_range_constRange()</a>, <a class="el" href="testClock_8cpp_source.html#l00103">test_RestartClock()</a>, <a class="el" href="testImageContainerByHashTree_8cpp_source.html#l00052">test_setVal()</a>, <a class="el" href="testIteratorFunctions_8cpp_source.html#l00072">testAdvance()</a>, <a class="el" href="testClone2_8cpp_source.html#l00477">testAliasCases()</a>, <a class="el" href="testAlphaThickSegmentComputer_8cpp_source.html#l00196">testAlphaThickSegmentComputerFloatingPointContour()</a>, <a class="el" href="testAlphaThickSegmentComputer_8cpp_source.html#l00052">testAlphaThickSegmentConvexHullAndBox()</a>, <a class="el" href="testAlphaThickSegmentComputer_8cpp_source.html#l00263">testAlphaThickSegmentFreeman()</a>, <a class="el" href="testAlphaThickSegmentComputer_8cpp_source.html#l00331">testAlphaThickSpecialInit()</a>, <a class="el" href="testAngleLinearMinimizer_8cpp_source.html#l00047">testAngleLinearMinimizer()</a>, <a class="el" href="testImageSimple_8cpp_source.html#l00118">testAPI()</a>, <a class="el" href="testSimpleMatrix_8cpp_source.html#l00091">testArithm()</a>, <a class="el" href="testHashTree_8cpp_source.html#l00241">testBadKeySizes()</a>, <a class="el" href="testBallQuad_8cpp_source.html#l00068">testBallQuad()</a>, <a class="el" href="testBasicBoolFunctors_8cpp_source.html#l00059">testBasicBoolFunctors()</a>, <a class="el" href="testBasicFunctors_8cpp_source.html#l00057">testBasicFunctors()</a>, <a class="el" href="testChamferDT_8cpp_source.html#l00179">testBasicMasks()</a>, <a class="el" href="testBasicMathFunctions_8cpp_source.html#l00046">testBasicMathFunctions()</a>, <a class="el" href="testArithmeticalDSSComputer_8cpp_source.html#l00378">testBIGINTEGER()</a>, <a class="el" href="testDGtalGMP_8cpp_source.html#l00082">testBIGINTEGERSpace()</a>, <a class="el" href="testMetrics_8cpp_source.html#l00287">testBinarySearch()</a>, <a class="el" href="testBinomialConvolver_8cpp_source.html#l00048">testBinomialConvolver()</a>, <a class="el" href="testObjectBorder_8cpp_source.html#l00232">testBoard2D()</a>, <a class="el" href="testBoard3D_8cpp_source.html#l00049">testBoard3D()</a>, <a class="el" href="testIntegerComputer_8cpp_source.html#l00122">testCeilFloorDiv()</a>, <a class="el" href="testIntegerComputer_8cpp_source.html#l00082">testCFrac()</a>, <a class="el" href="testChamferDT_8cpp_source.html#l00059">testChamferSimple()</a>, <a class="el" href="testCheckImageConcept_8cpp_source.html#l00054">testCheckImageConcept()</a>, <a class="el" href="testDistanceTransformation_8cpp_source.html#l00468">testChessboard()</a>, <a class="el" href="testChordNaivePlaneComputer_8cpp_source.html#l00525">testChordNaivePlaneComputer()</a>, <a class="el" href="testClone2_8cpp_source.html#l00693">testCloneCases()</a>, <a class="el" href="testClone2_8cpp_source.html#l00884">testCloneTimings()</a>, <a class="el" href="testTickedColorMap_8cpp_source.html#l00100">testCMAP()</a>, <a class="el" href="testCOBANaivePlaneComputer_8cpp_source.html#l00283">testCOBANaivePlaneComputer()</a>, <a class="el" href="testFreemanChain_8cpp_source.html#l00280">testCodesIterators()</a>, <a class="el" href="testIntegerComputer_8cpp_source.html#l00176">testCoefficientIntersection()</a>, <a class="el" href="testColor_8cpp_source.html#l00048">testColor()</a>, <a class="el" href="testSimpleMatrix_8cpp_source.html#l00192">testColRow()</a>, <a class="el" href="testUmbrellaComputer_8cpp_source.html#l00139">testCombinatorialSurface()</a>, <a class="el" href="testEstimatorComparator_8cpp_source.html#l00069">testCompareEstimator()</a>, <a class="el" href="testDistanceTransformationMetrics_8cpp_source.html#l00094">testCompareExactBruteForce()</a>, <a class="el" href="testDistanceTransformation_8cpp_source.html#l00575">testCompareExactInexact()</a>, <a class="el" href="testDistanceTransformationMetrics_8cpp_source.html#l00136">testCompareInexactBruteForce()</a>, <a class="el" href="testFMM_8cpp_source.html#l00579">testComparison()</a>, <a class="el" href="testSurfaceHelper_8cpp_source.html#l00060">testComputeInterior()</a>, <a class="el" href="testLocalEstimatorFromFunctorAdapter_8cpp_source.html#l00181">testConcepts()</a>, <a class="el" href="testVolReader_8cpp_source.html#l00136">testConsistence()</a>, <a class="el" href="testClone2_8cpp_source.html#l00576">testConstAliasCases()</a>, <a class="el" href="testSimpleMatrix_8cpp_source.html#l00354">testConstructor()</a>, <a class="el" href="testFreemanChain_8cpp_source.html#l00058">testConstructors()</a>, <a class="el" href="testLighterSternBrocot_8cpp_source.html#l00736">testContinuedFraction()</a>, <a class="el" href="testLighterSternBrocot_8cpp_source.html#l00773">testContinuedFractions()</a>, <a class="el" href="testContourHelper_8cpp_source.html#l00049">testContourHelper()</a>, <a class="el" href="testConvexHull2D_8cpp_source.html#l00102">testConvexHull2D()</a>, <a class="el" href="testConvexHull2D_8cpp_source.html#l00274">testConvexHullCompThickness()</a>, <a class="el" href="testArithmeticalDSSComputer_8cpp_source.html#l00432">testCorner()</a>, <a class="el" href="testCountedConstPtrOrConstPtr_8cpp_source.html#l00072">testCountedConstPtrOrConstPtrMemory()</a>, <a class="el" href="testCountedPtr_8cpp_source.html#l00048">testCountedPtr()</a>, <a class="el" href="testCountedPtr_8cpp_source.html#l00076">testCountedPtrCopy()</a>, <a class="el" href="testCountedPtr_8cpp_source.html#l00135">testCountedPtrMemory()</a>, <a class="el" href="testCountedPtrOrPtr_8cpp_source.html#l00072">testCountedPtrOrPtrMemory()</a>, <a class="el" href="testImageSimple_8cpp_source.html#l00072">testCreate()</a>, <a class="el" href="testTensorVoting_8cpp_source.html#l00137">testCube()</a>, <a class="el" href="testIntegralInvariantVolumeEstimator_8cpp_source.html#l00059">testCurvature2d()</a>, <a class="el" href="testSimpleMatrix_8cpp_source.html#l00242">testDetCofactor()</a>, <a class="el" href="testDGtalGMP_8cpp_source.html#l00053">testDGtalBIGINTEGER()</a>, <a class="el" href="testDicomReader_8cpp_source.html#l00053">testDicomReader()</a>, <a class="el" href="testDicomReader_8cpp_source.html#l00093">testDicomReaderFromDirectory()</a>, <a class="el" href="testDigitalSet_8cpp_source.html#l00149">testDigitalSet()</a>, <a class="el" href="testDigitalSurface_8cpp_source.html#l00061">testDigitalSetBoundary()</a>, <a class="el" href="testDigitalSet_8cpp_source.html#l00317">testDigitalSetDomain()</a>, <a class="el" href="testDigitalSet_8cpp_source.html#l00276">testDigitalSetDraw()</a>, <a class="el" href="testDigitalSet_8cpp_source.html#l00252">testDigitalSetSelector()</a>, <a class="el" href="testDigitalShapesDecorator_8cpp_source.html#l00055">testDigitalShapesDecorator()</a>, <a class="el" href="testDigitalSurface_8cpp_source.html#l00491">testDigitalSurface()</a>, <a class="el" href="testDigitalSurfaceBoostGraphInterface_8cpp_source.html#l00122">testDigitalSurfaceBoostGraphInterface()</a>, <a class="el" href="testDigitalTopology_8cpp_source.html#l00048">testDigitalTopologyZ2()</a>, <a class="el" href="testFMM_8cpp_source.html#l00195">testDisplayDT2d()</a>, <a class="el" href="testFMM_8cpp_source.html#l00382">testDisplayDT3d()</a>, <a class="el" href="testFMM_8cpp_source.html#l00438">testDisplayDTFromCircle()</a>, <a class="el" href="testDistancePropagation_8cpp_source.html#l00057">testDistancePropagation()</a>, <a class="el" href="testDistanceTransformation_8cpp_source.html#l00085">testDistanceTransformation()</a>, <a class="el" href="testDistanceTransformation_8cpp_source.html#l00417">testDistanceTransformation3D()</a>, <a class="el" href="testDistanceTransformation_8cpp_source.html#l00344">testDistanceTransformationBorder()</a>, <a class="el" href="testDistanceTransformation_8cpp_source.html#l00201">testDistanceTransformationNeg()</a>, <a class="el" href="testDistanceTransformationND_8cpp_source.html#l00056">testDistanceTransformND()</a>, <a class="el" href="testChamferDT_8cpp_source.html#l00790">testDoubleOnSegment()</a>, <a class="el" href="testChamferDT_8cpp_source.html#l00419">testDoubleShrink()</a>, <a class="el" href="testChamferDT_8cpp_source.html#l00572">testDoubleShrinkHorizontal()</a>, <a class="el" href="testObject_8cpp_source.html#l00416">testDraw()</a>, <a class="el" href="testDSLSubsegment_8cpp_source.html#l00058">testDSLSubsegment()</a>, <a class="el" href="testArithmeticalDSSComputer_8cpp_source.html#l00066">testDSS4drawing()</a>, <a class="el" href="testArithmeticalDSSComputer_8cpp_source.html#l00127">testDSS8drawing()</a>, <a class="el" href="testArithDSS3d_8cpp_source.html#l00062">testDSSreco()</a>, <a class="el" href="testDistanceTransformation_8cpp_source.html#l00287">testDTFromSet()</a>, <a class="el" href="testOrderedAlphabet_8cpp_source.html#l00088">testDuvalPP()</a>, <a class="el" href="testOrderedAlphabet_8cpp_source.html#l00119">testDuvalPPMod()</a>, <a class="el" href="testEigenDecomposition_8cpp_source.html#l00046">testEigenDecomposition()</a>, <a class="el" href="testEmbedder_8cpp_source.html#l00065">testEmbedder()</a>, <a class="el" href="testEstimatorCache_8cpp_source.html#l00064">testEstimatorCache()</a>, <a class="el" href="testEuclideanShapesDecorator_8cpp_source.html#l00050">testEuclideanShapesDecorator()</a>, <a class="el" href="testMostCenteredMSEstimator_8cpp_source.html#l00148">testEval()</a>, <a class="el" href="testExpander_8cpp_source.html#l00069">testExpander()</a>, <a class="el" href="testDigitalSurface_8cpp_source.html#l00273">testExplicitDigitalSurface()</a>, <a class="el" href="testIntegerComputer_8cpp_source.html#l00154">testExtendedEuclid()</a>, <a class="el" href="testArithmeticalDSSComputer_8cpp_source.html#l00182">testExtendRetractFront()</a>, <a class="el" href="testTrace_8cpp_source.html#l00088">testFileStream()</a>, <a class="el" href="testSurfaceHelper_8cpp_source.html#l00271">testFindABel()</a>, <a class="el" href="testSphereFitting_8cpp_source.html#l00067">testFitting()</a>, <a class="el" href="testOrderedAlphabet_8cpp_source.html#l00051">testFLF()</a>, <a class="el" href="testFP_8cpp_source.html#l00056">testFP()</a>, <a class="el" href="testFrechetShortcut_8cpp_source.html#l00067">testFrechetShortcut()</a>, <a class="el" href="testGaussDigitizer_8cpp_source.html#l00143">testGaussDigitizer()</a>, <a class="el" href="testIntegralInvariantCovarianceEstimator_8cpp_source.html#l00061">testGaussianCurvature3d()</a>, <a class="el" href="testIntegerComputer_8cpp_source.html#l00045">testGCD()</a>, <a class="el" href="testGenericReader_8cpp_source.html#l00051">testGenericReader()</a>, <a class="el" href="testGenericWriter_8cpp_source.html#l00051">testGenericWriter()</a>, <a class="el" href="testHashTree_8cpp_source.html#l00112">testGetSetVal()</a>, <a class="el" href="testColorMaps_8cpp_source.html#l00075">testGrayscaleColorMap()</a>, <a class="el" href="testHashTree_8cpp_source.html#l00058">testHashTree()</a>, <a class="el" href="testHashTree_8cpp_source.html#l00095">testHashTree2D()</a>, <a class="el" href="testHDF5Reader_8cpp_source.html#l00076">testHDF5_3DReader()</a>, <a class="el" href="testHDF5Reader_8cpp_source.html#l00047">testHDF5Reader()</a>, <a class="el" href="testChamferDT_8cpp_source.html#l00701">testHiddenBy()</a>, <a class="el" href="testHullFunctions2D_8cpp_source.html#l00050">testHullFunctions2D()</a>, <a class="el" href="testImage_8cpp_source.html#l00057">testImage()</a>, <a class="el" href="testImageAdapter_8cpp_source.html#l00289">testImageAdapter()</a>, <a class="el" href="testImageSimple_8cpp_source.html#l00163">testImageCopy()</a>, <a class="el" href="testImageSimple_8cpp_source.html#l00212">testImageCopyShort()</a>, <a class="el" href="testImagesSetsUtilities_8cpp_source.html#l00079">testImageFromSet()</a>, <a class="el" href="testImageSimple_8cpp_source.html#l00272">testImageScan()</a>, <a class="el" href="testDigitalSurface_8cpp_source.html#l00136">testImplicitDigitalSurface()</a>, <a class="el" href="testImplicitDigitalSurface-benchmark_8cpp_source.html#l00049">testImplicitDigitalSurface()</a>, <a class="el" href="testImplicitShape_8cpp_source.html#l00052">testImplicitShape()</a>, <a class="el" href="testImplicitShape_8cpp_source.html#l00106">testImplicitShape3D()</a>, <a class="el" href="testTrace_8cpp_source.html#l00056">testIndent()</a>, <a class="el" href="testMetrics_8cpp_source.html#l00131">testInexactMetrics()</a>, <a class="el" href="testInHalfPlane_8cpp_source.html#l00097">testInGeneralizedDiskOfGivenRadius()</a>, <a class="el" href="testCombinDSS_8cpp_source.html#l00208">testInGreedySegmentation()</a>, <a class="el" href="testInHalfPlane_8cpp_source.html#l00057">testInHalfPlane()</a>, <a class="el" href="testLighterSternBrocot_8cpp_source.html#l00127">testInitFraction()</a>, <a class="el" href="testInteger_8cpp_source.html#l00049">testInteger()</a>, <a class="el" href="testIntegerComputer_8cpp_source.html#l00264">testIntegerComputer()</a>, <a class="el" href="testChamferDT_8cpp_source.html#l00214">testIntersection()</a>, <a class="el" href="testSimpleMatrix_8cpp_source.html#l00305">testInverse()</a>, <a class="el" href="testDicomReader_8cpp_source.html#l00142">testIOException()</a>, <a class="el" href="testArithmeticalDSSComputer_8cpp_source.html#l00298">testIsInside()</a>, <a class="el" href="testHyperRectDomain_8cpp_source.html#l00251">testIterator()</a>, <a class="el" href="testIteratorCirculatorTraits_8cpp_source.html#l00082">testIteratorCirculatorTraits()</a>, <a class="el" href="testIteratorCirculatorTraits_8cpp_source.html#l00182">testIteratorCirculatorTraitsAndAdapters()</a>, <a class="el" href="testHyperRectDomain_8cpp_source.html#l00163">testIteratorHelperImpl()</a>, <a class="el" href="testTiledImage_8cpp_source.html#l00183">testIterators()</a>, <a class="el" href="testITKImage_8cpp_source.html#l00067">testITKImage()</a>, <a class="el" href="testITKImage_8cpp_source.html#l00216">testITKImageWithMetadata()</a>, <a class="el" href="testITKImage_8cpp_source.html#l00300">testITKImageWithShiftDomain()</a>, <a class="el" href="testITKio_8cpp_source.html#l00146">testITKio()</a>, <a class="el" href="testITKImage_8cpp_source.html#l00136">testITKMethod()</a>, <a class="el" href="testITKio_8cpp_source.html#l00103">testITKSpacingIO()</a>, <a class="el" href="testKanungo_8cpp_source.html#l00050">testKanungo2D()</a>, <a class="el" href="testL1LengthEstimator_8cpp_source.html#l00064">testL1LengthEstimator()</a>, <a class="el" href="testLatticePolytope2D_8cpp_source.html#l00122">testLatticePolytope2D()</a>, <a class="el" href="testSimpleExpander_8cpp_source.html#l00209">testLayers()</a>, <a class="el" href="testLighterSternBrocot_8cpp_source.html#l00702">testLighterSternBrocot()</a>, <a class="el" href="testDigitalSurface_8cpp_source.html#l00382">testLightExplicitDigitalSurface()</a>, <a class="el" href="testDigitalSurface_8cpp_source.html#l00196">testLightImplicitDigitalSurface()</a>, <a class="el" href="testLightImplicitDigitalSurface-benchmark_8cpp_source.html#l00049">testLightImplicitDigitalSurface()</a>, <a class="el" href="testLightSternBrocot_8cpp_source.html#l00700">testLightSternBrocot()</a>, <a class="el" href="testLinearAlgebra_8cpp_source.html#l00047">testLinearAlgebra()</a>, <a class="el" href="testLocalConvolutionNormalVectorEstimator_8cpp_source.html#l00071">testLocalConvolutionNormalVectorEstimator()</a>, <a class="el" href="testLocalEstimatorFromFunctorAdapter_8cpp_source.html#l00096">testLocalEstimatorFromFunctorAdapter()</a>, <a class="el" href="testAdjacency_8cpp_source.html#l00174">testLocalGraphModel()</a>, <a class="el" href="testLongvol_8cpp_source.html#l00051">testLongvol()</a>, <a class="el" href="testSimpleMatrix_8cpp_source.html#l00296">testM1Matrix()</a>, <a class="el" href="testIntegralInvariantVolumeEstimator_8cpp_source.html#l00161">testMeanCurvature3d()</a>, <a class="el" href="testMesh_8cpp_source.html#l00051">testMesh()</a>, <a class="el" href="testMesh_8cpp_source.html#l00217">testMeshGeneration()</a>, <a class="el" href="testMeshReader_8cpp_source.html#l00090">testMeshReader()</a>, <a class="el" href="testMeshWriter_8cpp_source.html#l00053">testMeshWriter()</a>, <a class="el" href="testAdjacency_8cpp_source.html#l00061">testMetricAdjacency()</a>, <a class="el" href="testMetrics_8cpp_source.html#l00048">testMetrics()</a>, <a class="el" href="testIteratorFunctions_8cpp_source.html#l00247">testMiddle()</a>, <a class="el" href="testModuloComputer_8cpp_source.html#l00048">testModuloComputer()</a>, <a class="el" href="testMorton_8cpp_source.html#l00049">testMorton()</a>, <a class="el" href="testMPolynomial_8cpp_source.html#l00138">testMPolynomial()</a>, <a class="el" href="testMPolynomialReader_8cpp_source.html#l00046">testMPolynomialReader()</a>, <a class="el" href="testMPolynomialReader_8cpp_source.html#l00088">testMPolynomialReader2()</a>, <a class="el" href="testMPolynomial_8cpp_source.html#l00072">testMPolynomialSpeed()</a>, <a class="el" href="testAlphaThickSegmentComputer_8cpp_source.html#l00384">testMultiWidth()</a>, <a class="el" href="testBoard3D_8cpp_source.html#l00131">testNormaliation()</a>, <a class="el" href="testTableReader_8cpp_source.html#l00051">testNumberReader()</a>, <a class="el" href="testObject_8cpp_source.html#l00079">testObject()</a>, <a class="el" href="testObject_8cpp_source.html#l00261">testObject3D()</a>, <a class="el" href="testObjectBorder_8cpp_source.html#l00113">testObjectBorder()</a>, <a class="el" href="testObject_8cpp_source.html#l00657">testObjectGraph()</a>, <a class="el" href="testCirculator_8cpp_source.html#l00053">testOffset()</a>, <a class="el" href="testCombinDSS_8cpp_source.html#l00067">testOneBalancedWordComputer()</a>, <a class="el" href="testOpenMP_8cpp_source.html#l00045">testOpenMP()</a>, <a class="el" href="testOrderedAlphabet_8cpp_source.html#l00154">testOrderedAlphabet()</a>, <a class="el" href="testDigitalSurface_8cpp_source.html#l00588">testOrderingDigitalSurfaceFacesAroundVertex()</a>, <a class="el" href="testOwningOrAliasingPtr_8cpp_source.html#l00075">testOwningOrAliasingPtr()</a>, <a class="el" href="testOutputIteratorAdapter_8cpp_source.html#l00053">testPairs()</a>, <a class="el" href="testArithmeticalDSS_8cpp_source.html#l01333">testPatchCreatePattern()</a>, <a class="el" href="testLighterSternBrocot_8cpp_source.html#l00157">testPattern()</a>, <a class="el" href="testPNMReader_8cpp_source.html#l00111">testPNM3DASCIIReader()</a>, <a class="el" href="testPNMReader_8cpp_source.html#l00095">testPNM3DReader()</a>, <a class="el" href="testPNMReader_8cpp_source.html#l00053">testPNMReader()</a>, <a class="el" href="testPNMRawWriter_8cpp_source.html#l00060">testPNMWriter()</a>, <a class="el" href="testPointListReader_8cpp_source.html#l00052">testPointListReader()</a>, <a class="el" href="testFreemanChain_8cpp_source.html#l00229">testPointsIterators()</a>, <a class="el" href="testPolarPointComparatorBy2x2DetComputer_8cpp_source.html#l00047">testPolarPointComparatorBy2x2DetComputer()</a>, <a class="el" href="testPowerMap_8cpp_source.html#l00297">testPowerMapFromSites()</a>, <a class="el" href="testMetrics_8cpp_source.html#l00206">testPowerMetrics()</a>, <a class="el" href="testIntegralInvariantCovarianceEstimator_8cpp_source.html#l00163">testPrincipalCurvatures3d()</a>, <a class="el" href="testProgressBar_8cpp_source.html#l00050">testProgressBar()</a>, <a class="el" href="testConstIteratorAdapter_8cpp_source.html#l00054">testProjection()</a>, <a class="el" href="testBasicPointFunctors_8cpp_source.html#l00052">testProjector()</a>, <a class="el" href="testFreemanChain_8cpp_source.html#l00113">testPublicSercives()</a>, <a class="el" href="testBoard3D_8cpp_source.html#l00088">testQuadNorm()</a>, <a class="el" href="testIteratorFunctions_8cpp_source.html#l00428">testRange()</a>, <a class="el" href="testRationalAngle_8cpp_source.html#l00046">testRationalAngle()</a>, <a class="el" href="testRayIntersection_8cpp_source.html#l00058">testRayIntersection()</a>, <a class="el" href="testRayIntersection_8cpp_source.html#l00115">testRayQuadIntersection()</a>, <a class="el" href="testRayIntersection_8cpp_source.html#l00188">testRaySurface()</a>, <a class="el" href="testRayIntersection_8cpp_source.html#l00148">testRaySurfelIntersection()</a>, <a class="el" href="testStabbingCircleComputer_8cpp_source.html#l00278">testRecognition()</a>, <a class="el" href="testLighterSternBrocot_8cpp_source.html#l00075">testReducedFraction()</a>, <a class="el" href="testReverseDT_8cpp_source.html#l00077">testReverseDT()</a>, <a class="el" href="testReverseDT_8cpp_source.html#l00184">testReverseDTL1()</a>, <a class="el" href="testPNMRawWriter_8cpp_source.html#l00117">testRWIssue254()</a>, <a class="el" href="testSCellsFunctor_8cpp_source.html#l00059">testSCellsFunctors()</a>, <a class="el" href="testArithDSS3d_8cpp_source.html#l00114">testSegmentation()</a>, <a class="el" href="testImageSimple_8cpp_source.html#l00051">testSelfCheckConcept()</a>, <a class="el" href="testSeparableMetricAdapter_8cpp_source.html#l00059">testSeparableMetricAdapter()</a>, <a class="el" href="testImagesSetsUtilities_8cpp_source.html#l00135">testSetFromImage()</a>, <a class="el" href="testObject_8cpp_source.html#l00741">testSetTable()</a>, <a class="el" href="testBoard3D_8cpp_source.html#l00159">testShapes()</a>, <a class="el" href="testChamferDT_8cpp_source.html#l00289">testShrink()</a>, <a class="el" href="testSignal_8cpp_source.html#l00046">testSignal()</a>, <a class="el" href="testImageAdapter_8cpp_source.html#l00053">testSimple()</a>, <a class="el" href="testPowerMap_8cpp_source.html#l00348">testSimple2D()</a>, <a class="el" href="testPowerMap_8cpp_source.html#l00374">testSimple3D()</a>, <a class="el" href="testPowerMap_8cpp_source.html#l00399">testSimple4D()</a>, <a class="el" href="testSimpleExpander_8cpp_source.html#l00077">testSimpleExpander()</a>, <a class="el" href="testSimpleMatrix_8cpp_source.html#l00052">testSimpleMatrix()</a>, <a class="el" href="testObject_8cpp_source.html#l00547">testSimplePoints2D()</a>, <a class="el" href="testObject_8cpp_source.html#l00355">testSimplePoints3D()</a>, <a class="el" href="testVoronoiMap_8cpp_source.html#l00552">testSimpleRandom2D()</a>, <a class="el" href="testVoronoiMap_8cpp_source.html#l00619">testSimpleRandom3D()</a>, <a class="el" href="testSimpleRegression_8cpp_source.html#l00049">testSimpleRegression()</a>, <a class="el" href="testSimpleRegression_8cpp_source.html#l00090">testSimpleRegression2()</a>, <a class="el" href="testSimpleRegression_8cpp_source.html#l00138">testSimpleRegression3()</a>, <a class="el" href="testSimpleRegression_8cpp_source.html#l00181">testSimpleRegressionOrdered()</a>, <a class="el" href="testSternBrocot_8cpp_source.html#l00812">testSimplestFractionInBetween()</a>, <a class="el" href="testIteratorFunctions_8cpp_source.html#l00129">testSize()</a>, <a class="el" href="testSliceImageFromFunctor_8cpp_source.html#l00056">testSliceImageFromFunctor()</a>, <a class="el" href="testPolarPointComparatorBy2x2DetComputer_8cpp_source.html#l00190">testSort()</a>, <a class="el" href="testImageSpanIterators_8cpp_source.html#l00046">testSpanIterators()</a>, <a class="el" href="testChamferDT_8cpp_source.html#l00882">testSpecialCase()</a>, <a class="el" href="testMetrics_8cpp_source.html#l00426">testSpecialCasesL2()</a>, <a class="el" href="testMetrics_8cpp_source.html#l00373">testSpecialCasesLp()</a>, <a class="el" href="testSphericalAccumulator_8cpp_source.html#l00044">testSphericalAccumulator()</a>, <a class="el" href="testSphericalAccumulator_8cpp_source.html#l00121">testSphericalMore()</a>, <a class="el" href="testSphericalAccumulator_8cpp_source.html#l00160">testSphericalMoreIntegerDir()</a>, <a class="el" href="testStabbingCircleComputer_8cpp_source.html#l00186">testStabbingCircleComputer()</a>, <a class="el" href="testStabbingLineComputer_8cpp_source.html#l00061">testStabbingLineComputer()</a>, <a class="el" href="testLighterSternBrocot_8cpp_source.html#l00564">testStandardDSLQ0()</a>, <a class="el" href="testArithDSS3d_8cpp_source.html#l00159">testStandardDSS6ComputerConceptChecking()</a>, <a class="el" href="testFreemanChain_8cpp_source.html#l00333">testStaticServices()</a>, <a class="el" href="testStatistics_8cpp_source.html#l00047">testStatistics()</a>, <a class="el" href="testStatistics_8cpp_source.html#l00080">testStatisticsSaving()</a>, <a class="el" href="testSternBrocot_8cpp_source.html#l00699">testSternBrocot()</a>, <a class="el" href="testArithmeticalDSSConvexHull_8cpp_source.html#l00448">testSubsegment()</a>, <a class="el" href="testArithmeticalDSSConvexHull_8cpp_source.html#l00730">testSubsegment2()</a>, <a class="el" href="testLighterSternBrocot_8cpp_source.html#l00656">testSubStandardDSLQ0()</a>, <a class="el" href="testAlphaThickSegmentComputer_8cpp_source.html#l00427">testThicknessDefinitions()</a>, <a class="el" href="testTickedColorMap_8cpp_source.html#l00051">testTickedColorMap()</a>, <a class="el" href="testImageFactoryFromHDF5_8cpp_source.html#l00441">testTiledImage2D_int64()</a>, <a class="el" href="testImageFactoryFromHDF5_8cpp_source.html#l00510">testTiledImage3D_double()</a>, <a class="el" href="testTrace_8cpp_source.html#l00115">testTimings()</a>, <a class="el" href="testTrueLocalEstimator_8cpp_source.html#l00072">testTrueLocalEstimator()</a>, <a class="el" href="testTrueLocalEstimator_8cpp_source.html#l00124">testTrueLocalEstimatorOnShapeDigitization()</a>, <a class="el" href="testUmbrellaComputer_8cpp_source.html#l00048">testUmbrellaComputer()</a>, <a class="el" href="testMeasure_8cpp_source.html#l00051">testUnitSquare()</a>, <a class="el" href="testMeasure_8cpp_source.html#l00078">testUnitSquareCentroid()</a>, <a class="el" href="testDigitalMetricAdapter_8cpp_source.html#l00067">testVal()</a>, <a class="el" href="testIntegerComputer_8cpp_source.html#l00210">testValidBezout()</a>, <a class="el" href="testMesh_8cpp_source.html#l00307">testVisualTubularMesh()</a>, <a class="el" href="testVolReader_8cpp_source.html#l00057">testVolReader()</a>, <a class="el" href="testVoronoiCovarianceMeasure_8cpp_source.html#l00048">testVoronoiCovarianceMeasure()</a>, <a class="el" href="testSeparableMetricAdapter_8cpp_source.html#l00172">testVoronoiMap()</a>, <a class="el" href="testVoronoiMap_8cpp_source.html#l00473">testVoronoiMapFromSites()</a>, <a class="el" href="testArithmeticalDSSConvexHull_8cpp_source.html#l00286">testWithLengthConstraint()</a>, <a class="el" href="testArithmeticalDSSConvexHull_8cpp_source.html#l00137">testWithoutLengthConstraint()</a>, <a class="el" href="testArithmeticalDSSConvexHull_8cpp_source.html#l00574">testWithoutLengthConstraint2()</a>, <a class="el" href="VoxelComplexThinning_8h_source.html#l00092">DGtal::functions::thinningVoxelComplex()</a>, <a class="el" href="testArithmeticalDSS_8cpp_source.html#l01119">unionComparisonTest()</a>, <a class="el" href="testArithmeticalDSS_8cpp_source.html#l00880">unionTest()</a>, <a class="el" href="testArithmeticalDSS_8cpp_source.html#l00423">updateTest()</a>, <a class="el" href="testImageFactoryFromHDF5_8cpp_source.html#l00056">writeHDF5_2D()</a>, <a class="el" href="testImageFactoryFromHDF5_8cpp_source.html#l00124">writeHDF5_2D_TILED()</a>, <a class="el" href="exampleImageFactoryFromHDF5_8cpp_source.html#l00068">writeHDF5_3D_TILED()</a>, and <a class="el" href="testImageFactoryFromHDF5_8cpp_source.html#l00190">writeHDF5_3D_TILED_for_easy_reading()</a>.</p>

</div>
</div>
<a id="ae801de7ee4d22c47257dc7e00e0c5dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae801de7ee4d22c47257dc7e00e0c5dd7">&#9670;&nbsp;</a></span>traceWriterTerm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1TraceWriterTerm.html">TraceWriterTerm</a> DGtal::traceWriterTerm </td>
          <td>(</td>
          <td class="paramtype">std::cerr&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> Global variables </p>

<p class="definition">Definition at line <a class="el" href="Common_8h_source.html#l00153">153</a> of file <a class="el" href="Common_8h_source.html">Common.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 1 2021 17:06:41 for DGtal by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
