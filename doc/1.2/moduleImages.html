<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Images</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Images </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#dgtalImagesAbstract">Overview</a></li>
<li class="level1"><a href="#dgtalImagesDetails">Let us go into details</a><ul><li class="level2"><a href="#dgtalImagesConcepts">Concepts</a></li>
<li class="level2"><a href="#dgtalImagesMainMethods">Main methods</a></li>
<li class="level2"><a href="#dgtalImagesRanges">Ranges of values</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtalImagesModels">Main models</a><ul><li class="level2"><a href="#dgtalImagesModelsVector">ImageContainerBySTLVector</a></li>
<li class="level2"><a href="#dgtalImagesModelsMap">ImageContainerBySTLMap</a></li>
<li class="level2"><a href="#dgtalImagesModelsHashTree">ImageContainerByHashTree</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtalImagesAdapters">Image Adapter classes</a><ul><li class="level2"><a href="#constimage">ConstImageAdapter</a></li>
<li class="level2"><a href="#imageadat">ImageAdapter</a></li>
<li class="level2"><a href="#arrayimageadat">ArrayImageAdapter</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtalImagesFunctions">Useful classes and functions</a><ul><li class="level2"><a href="#SubSampleFct">Subsampling functor</a></li>
<li class="level2"><a href="#moduleImages_functorconstimage">Constant image from a function, functor or lambda</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Authors</dt><dd>Tristan Roussillon, David Coeurjolly, Martial Tola, Roland Denis </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2012/12/05</dd></dl>
<h1><a class="anchor" id="dgtalImagesAbstract"></a>
Overview</h1>
<p>The concept of <em>point</em> <em>functor</em> describes a mapping between the points of a digital space and a set of values. The only method of a point functor is the <code>operator()</code>, which must take a point as argument and must return a value.</p>
<p>The concept of <em>constant</em> image is a point functor bounded by a domain. It is thus a refinement of the concept of point functor, describing a mapping between points and values, but having in addition a domain, returned by the <code>domain</code> method, and a range of values (for each point of the domain), returned by the <code>constRange</code> method. <br  />
</p>
<p>The concept of <em>image</em>, which is a refinement of the concept of constant image, provides extra services to update values. <br  />
 Any model of image must have a method <code>setValue</code> taking a point and a value as input parameters and updating the value associated with the given point with the given value. <br  />
 In addition, they must have a range, returned by the <code>range</code> method, providing output iterators. <br  />
</p>
<p>Different models of images are available: <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>, <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a>, <a class="el" href="classDGtal_1_1ImageContainerByITKImage.html" title="Aim: implements a model of CImageContainer using a ITK Image.">ImageContainerByITKImage</a> (a wrapper for ITK images) and &mdash; coming soon &mdash; <a class="el" href="classDGtal_1_1experimental_1_1ImageContainerByHashTree.html" title="Model of CImageContainer implementing the association key&lt;-&gt;Value using a hash tree....">experimental::ImageContainerByHashTree</a>.</p>
<h1><a class="anchor" id="dgtalImagesDetails"></a>
Let us go into details</h1>
<p>In this section, the concepts and the main services to read and write values in images are detailed. <br  />
</p>
<h2><a class="anchor" id="dgtalImagesConcepts"></a>
Concepts</h2>
<p>Any model of the concept <a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html" title="Aim: Defines a functor on points.">concepts::CPointFunctor</a> must have two nested types:</p>
<ul>
<li>Point, which specifies the type for a point.</li>
<li>Value, which specifies the type for a value.</li>
</ul>
<p>Moreover, it must have the following method:</p>
<ul>
<li><code>operator()</code>, which takes a point as argument and returns a value, like a function.</li>
</ul>
<p>The concept <a class="el" href="structDGtal_1_1concepts_1_1CConstImage.html" title="Aim: Defines the concept describing a read-only image, which is a refinement of CPointFunctor.">concepts::CConstImage</a> is a refinement of <a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html" title="Aim: Defines a functor on points.">concepts::CPointFunctor</a>. Its models must have two extra nested types:</p>
<ul>
<li>Domain, a model of <a class="el" href="structDGtal_1_1concepts_1_1CDomain.html" title="Aim: This concept represents a digital domain, i.e. a non mutable subset of points of the given digit...">concepts::CDomain</a></li>
<li>ConstRange, a model of <a class="el" href="structDGtal_1_1concepts_1_1CConstBidirectionalRangeFromPoint.html" title="Aim: refined concept of const bidirectional range with a begin() method from a point.">concepts::CConstBidirectionalRangeFromPoint</a></li>
</ul>
<p>Obviously, there are two methods that return instances of these two types:</p>
<ul>
<li><code>domain</code>, which returns a constant reference on the image domain</li>
<li><code>constRange</code>, which returns a range providing constant bidirectional iterators on the image values (associated to each point of the image domain)</li>
</ul>
<p>You can see <a class="el" href="moduleSpacePointVectorDomain.html">Digital Spaces, Points, Vectors and Domains</a> for more details about spaces and domains and <a class="el" href="moduleImages.html#dgtalImagesRanges">Ranges of values</a> for more details about ranges in images.</p>
<p>The concept <a class="el" href="structDGtal_1_1concepts_1_1CImage.html" title="Aim: Defines the concept describing a read/write image, having an output iterator.">concepts::CImage</a> is a refinement of <a class="el" href="structDGtal_1_1concepts_1_1CConstImage.html" title="Aim: Defines the concept describing a read-only image, which is a refinement of CPointFunctor.">concepts::CConstImage</a>. <br  />
 Images, instead of constant ones, provide services to update values. The main way of assigning values to points is the following method:</p>
<ul>
<li><code>setValue</code>, which updates a given value at a given point.</li>
</ul>
<p>Moreover, in addition to the ConstRange, images must have the following inner type:</p>
<ul>
<li>Range, a model of <a class="el" href="structDGtal_1_1concepts_1_1CConstBidirectionalRangeFromPoint.html" title="Aim: refined concept of const bidirectional range with a begin() method from a point.">concepts::CConstBidirectionalRangeFromPoint</a>, like ConstRange, and a model of <a class="el" href="structDGtal_1_1concepts_1_1CBidirectionalRangeWithWritableIteratorFromPoint.html" title="Aim: refined concept of single pass range with an routputIterator() method from a point.">concepts::CBidirectionalRangeWithWritableIteratorFromPoint</a>, which must provide output iterators for incrementally updating a (sub)range of values. <br  />
</li>
</ul>
<p>Obviously, you can get an instance of this type using the following method:</p>
<ul>
<li><code>range</code>, which returns a range providing both constant bidirectional iterators and output iterators.</li>
</ul>
<p>Lastly, note that the Value type in the (constant) images is expected to be at least a model of <a class="el" href="structDGtal_1_1concepts_1_1CLabel.html" title="Aim: Define the concept of DGtal labels. Models of CLabel can be default-constructible,...">concepts::CLabel</a>, ie. <br  />
 to be default-constructible, assignable and equality comparable.</p>
<dl class="section note"><dt>Note</dt><dd>In the snippets of the following subsections, the type of image used is <code><a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a></code> and its instances are <code>image</code>, <code>image1</code>, <code>image2</code>.</dd></dl>
<h2><a class="anchor" id="dgtalImagesMainMethods"></a>
Main methods</h2>
<p>All models of images have a domain returned by the method <code>domain</code>. This domain is the set of points for which the image is defined and has values. Since a domain is a range, you can straightforwardly use it in order to iterate over the points of an image.</p>
<div class="fragment"><div class="line"><span class="comment">//iterate over the points</span></div>
<div class="line"><a class="code" href="classDGtal_1_1Image.html#ace481f886b37a80824817b5f1494df58">Image::Domain</a> d = image.domain(); </div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">Image::Domain::ConstIterator</a> it = d.begin(), itEnd = d.end(); </div>
<div class="line">     it != itEnd; ++it)</div>
<div class="line">{}</div>
<div class="ttc" id="aclassDGtal_1_1Image_html_ace481f886b37a80824817b5f1494df58"><div class="ttname"><a href="classDGtal_1_1Image.html#ace481f886b37a80824817b5f1494df58">DGtal::Image::Domain</a></div><div class="ttdeci">TImageContainer::Domain Domain</div><div class="ttdef"><b>Definition:</b> <a href="Image_8h_source.html#l00082">Image.h:82</a></div></div>
<div class="ttc" id="agreedy-plane-segmentation-ex2_8cpp_html_a6d06fad433cff067dfcbbbf16d6e2dbf"><div class="ttname"><a href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a></div><div class="ttdeci">MyDigitalSurface::ConstIterator ConstIterator</div><div class="ttdef"><b>Definition:</b> <a href="greedy-plane-segmentation-ex2_8cpp_source.html#l00093">greedy-plane-segmentation-ex2.cpp:93</a></div></div>
</div><!-- fragment --><p>Models of images have also two main methods in order to read or write values at a given point:</p>
<ul>
<li><code>operator()</code> to get the value associated to a given point</li>
<li><code>setValue</code> to assign a value to a given point.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">//process the values</span></div>
<div class="line"><a class="code" href="classDGtal_1_1Image.html#ace481f886b37a80824817b5f1494df58">Image::Domain</a> d = image.domain(); </div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">Image::Domain::ConstIterator</a> it = d.begin(), itEnd = d.end(); </div>
<div class="line">     it != itEnd; ++it)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classDGtal_1_1Image.html#ad56b43a36c897e64398934c8f7a3b01c">Image::Value</a> v = <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a614d1b1c043b31763c1eb50f64666737">image</a>( *it ); </div>
<div class="line">  v += 5; <span class="comment">//adding 5 to all values</span></div>
<div class="line">  image.setValue( *it, v ); </div>
<div class="line">}</div>
<div class="ttc" id="aclassDGtal_1_1Image_html_ad56b43a36c897e64398934c8f7a3b01c"><div class="ttname"><a href="classDGtal_1_1Image.html#ad56b43a36c897e64398934c8f7a3b01c">DGtal::Image::Value</a></div><div class="ttdeci">TImageContainer::Value Value</div><div class="ttdef"><b>Definition:</b> <a href="Image_8h_source.html#l00084">Image.h:84</a></div></div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_a614d1b1c043b31763c1eb50f64666737"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a614d1b1c043b31763c1eb50f64666737">image</a></div><div class="ttdeci">Image image(domain)</div></div>
</div><!-- fragment --><p>Note that this method of iterating over the values of an image is not always the fastest and that is why we also provide ranges of values.</p>
<h2><a class="anchor" id="dgtalImagesRanges"></a>
Ranges of values</h2>
<p>Constant images provide a constant range of values returned by the <code>constRange</code> method. As every model of <a class="el" href="structDGtal_1_1concepts_1_1CConstBidirectionalRange.html" title="Aim: Defines the concept describing a bidirectional const range.">concepts::CConstBidirectionalRange</a>, it provides <code>begin</code>, <code>end</code>, <code>rbegin</code> and <code>rend</code> methods returning constant iterators to iterate over the values in the forward or backward direction.</p>
<div class="fragment"><div class="line"><span class="comment">//iterate over the values</span></div>
<div class="line"><a class="code" href="classDGtal_1_1Image.html#a0f2c0b68fdedee9231353fc0900e94b6">Image::ConstRange</a> r = image.constRange(); </div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="classDGtal_1_1ImageContainerBySTLVector.html#a7c3bf02944fcaa9efa550e266663e773">Image::ConstRange::ConstIterator</a> it = r.begin(), itEnd = r.end(); </div>
<div class="line">     it != itEnd; ++it)</div>
<div class="line">{} </div>
<div class="ttc" id="aclassDGtal_1_1ImageContainerBySTLVector_html_a7c3bf02944fcaa9efa550e266663e773"><div class="ttname"><a href="classDGtal_1_1ImageContainerBySTLVector.html#a7c3bf02944fcaa9efa550e266663e773">DGtal::ImageContainerBySTLVector&lt; Domain, Value &gt;::ConstIterator</a></div><div class="ttdeci">std::vector&lt; Value &gt;::const_iterator ConstIterator</div><div class="ttdef"><b>Definition:</b> <a href="ImageContainerBySTLVector_8h_source.html#l00265">ImageContainerBySTLVector.h:265</a></div></div>
<div class="ttc" id="aclassDGtal_1_1Image_html_a0f2c0b68fdedee9231353fc0900e94b6"><div class="ttname"><a href="classDGtal_1_1Image.html#a0f2c0b68fdedee9231353fc0900e94b6">DGtal::Image::ConstRange</a></div><div class="ttdeci">TImageContainer::ConstRange ConstRange</div><div class="ttdef"><b>Definition:</b> <a href="Image_8h_source.html#l00085">Image.h:85</a></div></div>
</div><!-- fragment --><p>However, this range is also a model of <a class="el" href="structDGtal_1_1concepts_1_1CConstBidirectionalRangeFromPoint.html" title="Aim: refined concept of const bidirectional range with a begin() method from a point.">concepts::CConstBidirectionalRangeFromPoint</a>, which is a refinement of <a class="el" href="structDGtal_1_1concepts_1_1CConstBidirectionalRange.html" title="Aim: Defines the concept describing a bidirectional const range.">concepts::CConstBidirectionalRange</a>. That is why it also has overloaded versions of the <code>begin</code> and <code>rbegin</code> methods taking a point as input argument. This provides a way of iterating on sub-ranges defined from points. <br  />
</p>
<div class="fragment"><div class="line"><span class="comment">//iterator on the origin (0, ... , 0)</span></div>
<div class="line"><a class="code" href="classDGtal_1_1ImageContainerBySTLVector.html#a7c3bf02944fcaa9efa550e266663e773">Image::ConstRange::ConstIterator</a> it = r.begin( <a class="code" href="classDGtal_1_1PointVector.html#aba9def1d899ca259f6fa532a6eb9a8b5">Image::Point::diagonal</a>(0) )</div>
<div class="ttc" id="aclassDGtal_1_1PointVector_html_aba9def1d899ca259f6fa532a6eb9a8b5"><div class="ttname"><a href="classDGtal_1_1PointVector.html#aba9def1d899ca259f6fa532a6eb9a8b5">DGtal::PointVector&lt; dim, Integer &gt;::diagonal</a></div><div class="ttdeci">static Self diagonal(Component val=1)</div></div>
</div><!-- fragment --><p>Note that if the point does not belong to the domain, the returned iterators (resp. reverse iterators) must be equal to the <code>end</code> (resp. <code>rend</code>) methods.</p>
<div class="fragment"><div class="line">ASSERT( image.constRange().begin( image.domain().end() ) == image.constRange().end() )</div>
</div><!-- fragment --><p>Images provide in addition to a constant range, a richer range returned by the <code>range</code> method. This range is not only a model of <a class="el" href="structDGtal_1_1concepts_1_1CBidirectionalRangeFromPoint.html" title="Aim: refined concept of single pass range with a begin() method from a point.">concepts::CBidirectionalRangeFromPoint</a>, but also a model of <a class="el" href="structDGtal_1_1concepts_1_1CBidirectionalRangeWithWritableIteratorFromPoint.html" title="Aim: refined concept of single pass range with an routputIterator() method from a point.">concepts::CBidirectionalRangeWithWritableIteratorFromPoint</a>. That is why, it must have two methods: <br  />
 <code>outputIterator</code> and <code>routputIterator</code> returning output iterators. Moreover, it must have overloaded versions of these methods taking a point as input argument. Thus, these output iterators are useful in order to incrementaly fill (a part of) an image. For instance, you can fill an image from the values of another one (assumed to have the same domain) as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="classDGtal_1_1Image.html#ae6fed39eb72f60bddeb9fb6c1e636ab8">Image::Range</a> r1 = image1.range(); </div>
<div class="line"><a class="code" href="classDGtal_1_1Image.html#a0f2c0b68fdedee9231353fc0900e94b6">Image::ConstRange</a> r2 = image2.constRange(); </div>
<div class="line">std::copy( r2.begin(), r2.end(), r1.outputIterator() ); </div>
<div class="ttc" id="aclassDGtal_1_1Image_html_ae6fed39eb72f60bddeb9fb6c1e636ab8"><div class="ttname"><a href="classDGtal_1_1Image.html#ae6fed39eb72f60bddeb9fb6c1e636ab8">DGtal::Image::Range</a></div><div class="ttdeci">TImageContainer::Range Range</div><div class="ttdef"><b>Definition:</b> <a href="Image_8h_source.html#l00086">Image.h:86</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="dgtalImagesModels"></a>
Main models</h1>
<p>Different models of images are available: <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>, <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a>, <a class="el" href="classDGtal_1_1experimental_1_1ImageContainerByHashTree.html" title="Model of CImageContainer implementing the association key&lt;-&gt;Value using a hash tree....">experimental::ImageContainerByHashTree</a> and <a class="el" href="classDGtal_1_1ImageContainerByITKImage.html" title="Aim: implements a model of CImageContainer using a ITK Image.">ImageContainerByITKImage</a>, a wrapper for ITK images.</p>
<h2><a class="anchor" id="dgtalImagesModelsVector"></a>
ImageContainerBySTLVector</h2>
<p><a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a> is a model of <a class="el" href="structDGtal_1_1concepts_1_1CImage.html" title="Aim: Defines the concept describing a read/write image, having an output iterator.">concepts::CImage</a> that inherits the STL vector class. The hyper-rectangular domain, which the only model of domain accepted, is linearized so that <br  />
 each point is mapped, from its coordinates, into an index and each index is mapped into a unique value, as in any one-dimensional array.</p>
<p>Let \( n \) be the domain size (the number of points). At construction all the needed space is allocated and filled with a default value (0) in \( O(n) \) space and time. After that, you can access to the value associated to any point at any time. Each access for reading (<code>operator()</code>) or writing ('setValue`) values is in \( O(1) \).</p>
<p>The (constant) range of this class only used the built-in iterators of the underlying STL vector. It is therefore a fast way of iterating over the values of the image.</p>
<h2><a class="anchor" id="dgtalImagesModelsMap"></a>
ImageContainerBySTLMap</h2>
<p><a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> is a model of <a class="el" href="structDGtal_1_1concepts_1_1CImage.html" title="Aim: Defines the concept describing a read/write image, having an output iterator.">concepts::CImage</a> that inherits the STL map class. The domain can be any set of points. Values are stored and associated to points in pairs point-value. The set of points stored in this way may be any domain subset. A default value (user-defined) is automatically associated to each point of the domain that does not belong the subset for which values are known. Once constructed (in \( O(1) \)), the image is valid and every point of the image domain has a value, which can be read and overwritten.</p>
<p>The pairs point-value are stored in a red-black tree, where the points are used as keys, so that <br  />
 each access for reading (<code>operator()</code>) or writing (<code>setValue</code>) values is in \( O(log m) \), where \( m \) is the cardinal of the subset for which values are known (less or equal to the domain size \( n \)). <br  />
</p>
<p>The (constant) range of this class adapts the domain iterators in order to deal with values instead of points. The <code>operator*</code> of the iterators provided by the range calls the <code>operator()</code> and use the <code>setValue</code> method of the class.</p>
<h2><a class="anchor" id="dgtalImagesModelsHashTree"></a>
ImageContainerByHashTree</h2>
<p><a class="el" href="classDGtal_1_1experimental_1_1ImageContainerByHashTree.html" title="Model of CImageContainer implementing the association key&lt;-&gt;Value using a hash tree....">experimental::ImageContainerByHashTree</a> is an experimental image container implementing a pointerless nD-tree structure. In dimension 2 and 3, this structure is similar to quadtree and octree repsectively in which hierarchical links between a node and its children is given by prefix of a binary representation of the node coordinates using <a class="el" href="classDGtal_1_1Morton.html" title="Aim: Implements the binary Morton code construction in nD.">Morton</a> keys. Finally, data values are stored in the structure in a hash table whose hash function is a suffix on the <a class="el" href="classDGtal_1_1Morton.html" title="Aim: Implements the binary Morton code construction in nD.">Morton</a> key code.</p>
<p>Such container is well adapted for high resolution sparse images.</p>
<p>For more details, please refer to <a class="el" href="citelist.html#CITEREF_Lewiner2009a">[69]</a></p>
<h1><a class="anchor" id="dgtalImagesAdapters"></a>
Image Adapter classes</h1>
<p><a class="el" href="classDGtal_1_1ImageAdapter.html" title="Aim: implements an image adapter with a given domain (i.e. a subdomain) and 3 functors : g for domain...">ImageAdapter</a>, <a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a> are perfect swiss-knifes to transform and adapt images (change their domain definition, change their value types, ...). These classses are parametrized by several types and functor in order to adapt the behavior of image getters/setters (<em>operator()</em> and <em>setValue</em> methods). These adapted behaviors are computed on-the-fly when calling these methods.</p>
<p><a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a> requires several types and functors to create a "read-only" adapted image (operator(), constRange(), ...)</p>
<p><a class="el" href="classDGtal_1_1ImageAdapter.html" title="Aim: implements an image adapter with a given domain (i.e. a subdomain) and 3 functors : g for domain...">ImageAdapter</a> requires a supplementary functor and allows write access to the image (<em>setValue</em> methods, range(), ... )</p>
<dl class="section note"><dt>Note</dt><dd>Functors used to convert domains or values may be complex. Keep in mind that each time operator() or setValue() methods are called, such functors are evaluated (with potential side-effects depending on the functors).</dd></dl>
<p>In addition, ArrayImageAdapter allows to convert any iterable storage (like a C-style array or some <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> image models), to a <a class="el" href="structDGtal_1_1concepts_1_1CImage.html" title="Aim: Defines the concept describing a read/write image, having an output iterator.">concepts::CImage</a> (or <a class="el" href="structDGtal_1_1concepts_1_1CConstImage.html" title="Aim: Defines the concept describing a read-only image, which is a refinement of CPointFunctor.">concepts::CConstImage</a>) model with the possibility to restrict his visibility to a sub-domain of the definition domain.</p>
<h2><a class="anchor" id="constimage"></a>
ConstImageAdapter</h2>
<p><a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a> is a small class that adapts any (constant or not) image into a constant one, which provides a virtual view (so read-only) of the true values contained in the adapted image. The class is parametrized by several template arguments: <em>TImageContainer:</em> the type of image to adapt. <em>TNewDomain:</em> the type of the new domain. <em>TFunctorD:</em> type of functor used to convert image domain points to new domain points <em>TNewValue:</em> type of the new image value type. <em>TFucntorV:</em> functor to convert values.</p>
<p>The values associated to access the point values are adapted <br  />
 with a functor <em>g</em> and a functor <em>f</em> given at construction so that operator() calls <em>f</em>(img(g(aPoint))), instead of calling directly img.operator() of the underlying image <em>img</em>.</p>
<p>Functor g (and/or functor f) can be a default functor, i.e. a simple functor that just returns its argument.</p>
<p>In order to illustrate the next <a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a> usage samples, we are going a) to use these includes:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/io/colormaps/HueShadeColorMap.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/io/colormaps/GrayscaleColorMap.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/images/ImageContainerBySTLVector.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/images/ConstImageAdapter.h&quot;</span></div>
</div><!-- fragment --><p> b) then define these types and variables:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> HueShadeColorMap&lt;unsigned char&gt; HueShade;     <span class="comment">// a simple HueShadeColorMap varying on &#39;unsigned char&#39; values</span></div>
<div class="line">  <span class="keyword">typedef</span> HueShadeColorMap&lt;double&gt; HueShadeDouble;      <span class="comment">// a simple HueShadeColorMap varying on &#39;double&#39; values</span></div>
<div class="line">  <span class="keyword">typedef</span> GrayscaleColorMap&lt;unsigned char&gt; Gray;        <span class="comment">// a simple GrayscaleColorMap varying on &#39;unsigned char&#39; values</span></div>
<div class="line">  </div>
<div class="line">  functors::Identity df;                                    <span class="comment">// a simple functor that just returns its argument</span></div>
</div><!-- fragment --><p> c) then define a simple 16x16 (1,1) to (16,16) image (of 'unsigned char' type):</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ImageContainerBySTLVector&lt;Domain, unsigned char&gt; <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a852ab282e5168b5711ef7a87b3aefa68">Image</a>;</div>
<div class="line">  <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1,1), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(16,16));</div>
<div class="line">  <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a852ab282e5168b5711ef7a87b3aefa68">Image</a> <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a614d1b1c043b31763c1eb50f64666737">image</a>(<a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>);</div>
<div class="ttc" id="atestClone2_8cpp_html_a15e9592ccc512dc691b46185e6814758"><div class="ttname"><a href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a></div><div class="ttdeci">MyPointD Point</div><div class="ttdef"><b>Definition:</b> <a href="testClone2_8cpp_source.html#l00383">testClone2.cpp:383</a></div></div>
<div class="ttc" id="atestProjection_8cpp_html_a1f1a69f8d8b037b72c2160ed12b3ef51"><div class="ttname"><a href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a></div><div class="ttdeci">Domain domain</div><div class="ttdef"><b>Definition:</b> <a href="testProjection_8cpp_source.html#l00088">testProjection.cpp:88</a></div></div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_a852ab282e5168b5711ef7a87b3aefa68"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a852ab282e5168b5711ef7a87b3aefa68">Image</a></div><div class="ttdeci">ImageContainerBySTLVector&lt; Domain, Value &gt; Image</div><div class="ttdef"><b>Definition:</b> <a href="testSimpleRandomAccessRangeFromPoint_8cpp_source.html#l00045">testSimpleRandomAccessRangeFromPoint.cpp:45</a></div></div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_acd532b318489cd93df57e0b3d136d050"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a></div><div class="ttdeci">HyperRectDomain&lt; Space &gt; Domain</div><div class="ttdef"><b>Definition:</b> <a href="testSimpleRandomAccessRangeFromPoint_8cpp_source.html#l00044">testSimpleRandomAccessRangeFromPoint.cpp:44</a></div></div>
</div><!-- fragment --><p> filled with 0 to 255 values like that:</p>
<div class="fragment"><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> i = 0;</div>
<div class="line">  <span class="keywordflow">for</span> (Image::Iterator it = image.begin(); it != image.end(); ++it)</div>
<div class="line">      *it = i++;</div>
</div><!-- fragment --><p> which looks like that with a simple <a class="el" href="classDGtal_1_1HueShadeColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">HueShadeColorMap</a> varying from 0 to 255 and with (1,1) the first bottom-left point:</p>
<div class="image">
<img src="image.png" alt=""/>
<div class="caption">
(1) simple 16x16 image: (1,1) to (16,16) drawn with a simple HueShadeColorMap varying from 0 to 255.</div></div>
 <p>Here is now the construction of a simple image adapter that use a subdomain of the initial image domain to access the first bottom-left 8x8 image:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ConstImageAdapter&lt;Image, Domain, functors::Identity, Image::Value, functors::Identity &gt; ConstImageAdapterForSubImage;</div>
<div class="line">  <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> subDomain(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1,1), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(8,8));</div>
<div class="line">  ConstImageAdapterForSubImage subImage(image, subDomain, df, df);</div>
</div><!-- fragment --><p> and here is the result: </p><div class="image">
<img src="subImage.png" alt=""/>
<div class="caption">
(2) first bottom-left 8x8 image: (1,1) to (8,8) adapted from image (1) with a subdomain.</div></div>
 <p>Here is then the construction of an image adapter that use a specific domain: here, only one pixel on two in x and y coordinates, created like that:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal_1_1Z2i.html#a371252c324e496cf8650757c1a2b4eb0">DigitalSet</a> set(<a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>);</div>
<div class="line">  <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y=0; y &lt; 17; y++)</div>
<div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=0; x &lt; 17; x++)</div>
<div class="line">        <span class="keywordflow">if</span> ((x%2) &amp;&amp; (y%2))</div>
<div class="line">          set.insertNew(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(x,y));</div>
<div class="line">        </div>
<div class="line">  DigitalSetDomain&lt;DigitalSet&gt; specificDomain(set);</div>
<div class="ttc" id="anamespaceDGtal_1_1Z2i_html_a371252c324e496cf8650757c1a2b4eb0"><div class="ttname"><a href="namespaceDGtal_1_1Z2i.html#a371252c324e496cf8650757c1a2b4eb0">DGtal::Z2i::DigitalSet</a></div><div class="ttdeci">DigitalSetSelector&lt; Domain, BIG_DS+HIGH_BEL_DS &gt;::Type DigitalSet</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00100">StdDefs.h:100</a></div></div>
</div><!-- fragment --><p> from the initial image domain.</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ConstImageAdapter&lt;Image, DigitalSetDomain&lt;DigitalSet&gt;, functors::Identity, <a class="code" href="classDGtal_1_1Image.html#ad56b43a36c897e64398934c8f7a3b01c">Image::Value</a>, functors::Identity &gt; ConstImageAdapterForSpecificImage;</div>
<div class="line">  ConstImageAdapterForSpecificImage specificImage(image, specificDomain, df, df);</div>
</div><!-- fragment --><p> Here is the result:</p>
<div class="image">
<img src="specificImage.png" alt=""/>
<div class="caption">
(3) 16x16 image: (1,1) to (16,16) adapted from image (1) with a specific domain.</div></div>
 <p>Here is now the construction of an image adapter that is a thresholded view of the initial scalar image:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ConstImageAdapter&lt;Image, Domain, functors::Identity, bool, DGtal::functors::Thresholder&lt;Image::Value&gt; &gt; ConstImageAdapterForThresholderImage;</div>
<div class="line">  <a class="code" href="classDGtal_1_1functors_1_1Thresholder.html">DGtal::functors::Thresholder&lt;Image::Value&gt;</a> t(127);</div>
<div class="line">  ConstImageAdapterForThresholderImage thresholderImage(image, <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>, df, t);</div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1Thresholder_html"><div class="ttname"><a href="classDGtal_1_1functors_1_1Thresholder.html">DGtal::functors::Thresholder</a></div><div class="ttdoc">Aim: A small functor with an operator () that compares one value to a threshold value according to tw...</div><div class="ttdef"><b>Definition:</b> <a href="BasicFunctors_8h_source.html#l00500">BasicFunctors.h:501</a></div></div>
</div><!-- fragment --><p> and here is the result with a simple <a class="el" href="classDGtal_1_1GrayscaleColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into gray l...">GrayscaleColorMap</a> varying from 0 to 1:</p>
<div class="image">
<img src="thresholderImage.png" alt=""/>
<div class="caption">
(4) 16x16 image: (1,1) to (16,16) adapted from image (1) with a thresholder set to 127.</div></div>
 <p>Here is finally the construction of an image adapter that use a functor to change 'unsigned char' values to 'double' values using a log scale functor defined like that:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Scalar&gt;</div>
<div class="line"><span class="keyword">struct </span>LogScaleFunctor {</div>
<div class="line"> </div>
<div class="line">  LogScaleFunctor() {};</div>
<div class="line">  <span class="keywordtype">double</span> operator()(<span class="keyword">const</span> Scalar &amp;a)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> std::log( 1 + <a class="code" href="structDGtal_1_1NumberTraitsImpl.html#af97eb78317d1fc1c6babd4dcc95ed336">NumberTraits&lt;Scalar&gt;::castToDouble</a>(a) );</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">};</div>
<div class="ttc" id="astructDGtal_1_1NumberTraitsImpl_html_af97eb78317d1fc1c6babd4dcc95ed336"><div class="ttname"><a href="structDGtal_1_1NumberTraitsImpl.html#af97eb78317d1fc1c6babd4dcc95ed336">DGtal::NumberTraitsImpl&lt; std::decay&lt; T &gt;::type &gt;::castToDouble</a></div><div class="ttdeci">static double castToDouble(const std::decay&lt; T &gt;::type &amp;aT)</div><div class="ttdoc">Cast method to double (for I/O or board export uses only).</div><div class="ttdef"><b>Definition:</b> <a href="NumberTraits_8h_source.html#l00154">NumberTraits.h:154</a></div></div>
</div><!-- fragment --><p> defined from the initial image:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ConstImageAdapter&lt;Image, Domain, functors::Identity, double, LogScaleFunctor&lt;Image::Value&gt; &gt; ConstImageAdapterForLogScale;</div>
<div class="line">  LogScaleFunctor&lt;Image::Value&gt; logScale;</div>
<div class="line">  ConstImageAdapterForLogScale logImage(image, <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>, df, logScale);</div>
</div><!-- fragment --><p> and here is the result with a simple <a class="el" href="classDGtal_1_1HueShadeColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">HueShadeColorMap</a> varying from 0. to logScale(255):</p>
<div class="image">
<img src="logImage.png" alt=""/>
<div class="caption">
(5) 16x16 image: (1,1) to (16,16) adapted from image (1) with a log scale functor.</div></div>
 <h2><a class="anchor" id="imageadat"></a>
ImageAdapter</h2>
<p><a class="el" href="classDGtal_1_1ImageAdapter.html" title="Aim: implements an image adapter with a given domain (i.e. a subdomain) and 3 functors : g for domain...">ImageAdapter</a> is a small class that adapts an image (like <a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a>) but provides a virtual access (reading and writing) of the true values contained in the adapted image. It uses a given Domain (i.e. a subdomain) but work directly (for reading and writing processes) thanks to an alias (i.e. a pointer) on the original <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> given in argument.</p>
<p>This class requires an additional templare paremter: <em>TFunctoVm1:</em> functor to convert adapted image values to the original image values.</p>
<p>The values associated to accessing the point values are adapted <br  />
 with a functor g and a functor f given at construction so that operator() calls f(img(g(aPoint))), instead of calling directly operator() of the underlying image img.</p>
<p>The values associated to writing the points are adapted <br  />
 with a functor <em>g</em> and a functor \( f^{-1}\) given at construction so that setValue() is <em>img.setValue</em>(g(aPoint), f-1(aValue)).</p>
<p>The use is the same that for <a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a>.</p>
<h2><a class="anchor" id="arrayimageadat"></a>
ArrayImageAdapter</h2>
<p>The ArrayImageAdapter class is less generic than <a class="el" href="classDGtal_1_1ImageAdapter.html" title="Aim: implements an image adapter with a given domain (i.e. a subdomain) and 3 functors : g for domain...">ImageAdapter</a> but is able to adapt any storage that have a random-access iterator to a <a class="el" href="structDGtal_1_1concepts_1_1CImage.html" title="Aim: Defines the concept describing a read/write image, having an output iterator.">concepts::CImage</a> model. It is thus usable on C-style array but also on STL container like <code>std::vector</code> (and therefore on <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>) and on another ArrayImageAdapter instances.</p>
<p>In addition, this class allows to restrict the visibility to a sub-domain of the definition domain and provides a read-write random-access iterator (depending on the mutability of the storage's iterator) with fast access to the underlying point (no need to iterate over the domain).</p>
<p>A common usage of this last feature is for padded raw data.</p>
<p>In order to illustrate the following ArrayImageAdapter usages, we need some common includes: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;new&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;DGtal/io/colormaps/HueShadeColorMap.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;DGtal/images/ImageContainerBySTLVector.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;DGtal/images/ArrayImageAdapter.h&gt;</span></div>
</div><!-- fragment --><p>and the next definitions: </p><div class="fragment"><div class="line">  <span class="keyword">using</span> <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Value</a> = double; <span class="comment">// value type  of the image</span></div>
<div class="line">  <span class="keyword">using</span> HueShadeDouble = HueShadeColorMap&lt;Value&gt;;   <span class="comment">// a simple HueShadeColorMap varying on &#39;double&#39; values</span></div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_a566a00621638570a4186414035153a2e"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Value</a></div><div class="ttdeci">double Value</div><div class="ttdef"><b>Definition:</b> <a href="testSimpleRandomAccessRangeFromPoint_8cpp_source.html#l00041">testSimpleRandomAccessRangeFromPoint.cpp:38</a></div></div>
</div><!-- fragment --><p> From a C-style array, we can create an image that spans the full definition domain: </p><div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1,1), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(16,16));</div>
<div class="line">  <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Value</a>* data = <span class="keyword">new</span> <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Value</a>[ <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.size() ];</div>
<div class="line">  ArrayImageAdapter&lt; Value*, Domain &gt; <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a614d1b1c043b31763c1eb50f64666737">image</a>( data, <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a> );</div>
</div><!-- fragment --><p>and fill it using common iterator syntax: </p><div class="fragment"><div class="line">  <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Value</a> i = 0;</div>
<div class="line">  <span class="keywordflow">for</span> ( <span class="keyword">auto</span> &amp; value : image )</div>
<div class="line">    value = i++;</div>
</div><!-- fragment --><p>that gives us the following result: </p><div class="image">
<img src="ArrayImageAdapter_image.png" alt=""/>
<div class="caption">
(6) simple 16x16 image: (1,1) to (16,16) drawn with a simple HueShadeColorMap varying from 0 to 255.</div></div>
 <p>We can now create a read-only view of the same image on a sub-domain: </p><div class="fragment"><div class="line">  <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> subDomain(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1,1), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(8,8));</div>
<div class="line">  ArrayImageAdapter&lt; Value const*, Domain &gt; constSubImage( data, <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>, subDomain );</div>
</div><!-- fragment --><p>that gives us: </p><div class="image">
<img src="ArrayImageAdapter_subImage.png" alt=""/>
<div class="caption">
(7) first bottom-left 8x8 image: (1,1) to (8,8) adapted from image (1) with a subdomain.</div></div>
 <p>If we want to modify the image through this adapter, we must create a read-write instance using the following syntax: </p><div class="fragment"><div class="line">  ArrayImageAdapter&lt; Value*, Domain &gt; subImage( data, <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>, subDomain );</div>
</div><!-- fragment --><p>or the alternate method using the helpers: </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> subImage = <a class="code" href="namespaceDGtal.html#a4d7cc85d6072793cb8f15694be4d0d44">makeArrayImageAdapterFromIterator</a>( data, <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>, subDomain );</div>
<div class="ttc" id="anamespaceDGtal_html_a4d7cc85d6072793cb8f15694be4d0d44"><div class="ttname"><a href="namespaceDGtal.html#a4d7cc85d6072793cb8f15694be4d0d44">DGtal::makeArrayImageAdapterFromIterator</a></div><div class="ttdeci">ArrayImageAdapter&lt; TArrayIterator, TDomain &gt; makeArrayImageAdapterFromIterator(TArrayIterator anArrayIterator, TDomain const &amp;aFullDomain, TDomain const &amp;aViewDomain)</div><div class="ttdef"><b>Definition:</b> <a href="ArrayImageAdapter_8h_source.html#l00465">ArrayImageAdapter.h:465</a></div></div>
</div><!-- fragment --><p>and we can then modify it using the common syntax with a domain iterator: </p><div class="fragment"><div class="line">  <span class="keywordflow">for</span> ( <span class="keyword">auto</span> point : subImage.domain() )</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Value</a> coord = (point - <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(4,4)).norm();</div>
<div class="line">      subImage.setValue( point, 25*(cos(coord)+1) );</div>
<div class="line">    }</div>
</div><!-- fragment --> <div class="image">
<img src="ArrayImageAdapter_subImage_modifByDomain.png" alt=""/>
<div class="caption">
(8) modifying the first bottom-left 8x8 image through the sub-domain view with a domain iterator.</div></div>
 <p>Alternatively, there is a computationally faster syntax (no need to linearize the point) using the method <code>getPoint</code> featured by the ArrayImageAdapter iterators (see <a class="el" href="classDGtal_1_1ArrayImageIterator.html" title="Aim: Random access iterator over an image given his definition domain and viewable domain.">ArrayImageIterator</a>): </p><div class="fragment"><div class="line">  <span class="keywordflow">for</span> ( <span class="keyword">auto</span> it = subImage.begin(), it_end = subImage.end(); it != it_end; ++it )</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Value</a> coord = (it.getPoint() - <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(4,4)).norm();</div>
<div class="line">      *it = 25*(sin(coord)+1);</div>
<div class="line">    }</div>
</div><!-- fragment --> <div class="image">
<img src="ArrayImageAdapter_subImage_modifByImage.png" alt=""/>
<div class="caption">
(9) modifying the first bottom-left 8x8 image through the sub-domain view with an image iterator.</div></div>
 <p>It is also possible to use ArrayImageAdater on any image model that provides a random-access iterator, like <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>: </p><div class="fragment"><div class="line">  ImageContainerBySTLVector&lt;Domain, Value&gt; anIterableImage(<a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; value : anIterableImage)</div>
<div class="line">    value = 0;</div>
</div><!-- fragment --><p>and adapt it using: </p><div class="fragment"><div class="line">  {</div>
<div class="line">  ArrayImageAdapter&lt; ImageContainerBySTLVector&lt;Domain,Value&gt;::Iterator, <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> &gt; subImageSTL( anIterableImage.begin(), <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>, subDomain );</div>
<div class="line">  }</div>
</div><!-- fragment --><p>or, thanks to the helpers: </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> subImageSTL = <a class="code" href="namespaceDGtal.html#a5d8f2b0c05fa81f94692c1c48bb44c6b">makeArrayImageAdapterFromImage</a>( anIterableImage, subDomain );</div>
<div class="ttc" id="anamespaceDGtal_html_a5d8f2b0c05fa81f94692c1c48bb44c6b"><div class="ttname"><a href="namespaceDGtal.html#a5d8f2b0c05fa81f94692c1c48bb44c6b">DGtal::makeArrayImageAdapterFromImage</a></div><div class="ttdeci">ArrayImageAdapter&lt; decltype(((TImage *) nullptr) -&gt;begin()), TDomain &gt; makeArrayImageAdapterFromImage(TImage &amp;anImage, TDomain const &amp;aViewDomain)</div><div class="ttdef"><b>Definition:</b> <a href="ArrayImageAdapter_8h_source.html#l00500">ArrayImageAdapter.h:500</a></div></div>
</div><!-- fragment --><p> From there, we can use all the previous features or, for example, use available STL algorithms: </p><div class="fragment"><div class="line">  std::copy( subImage.cbegin(), subImage.cend(), subImageSTL.begin() );</div>
</div><!-- fragment --> <div class="image">
<img src="ArrayImageAdapter_subImage_copyToImageSTL.png" alt=""/>
<div class="caption">
(10) modifying the first bottom-left 8x8 image of a ImageContainerBySTLVector through the sub-domain view.</div></div>
 <h1><a class="anchor" id="dgtalImagesFunctions"></a>
Useful classes and functions</h1>
<p>In addition to the image containers and the image adapters described in the previous sections, there are also image proxys:</p>
<p><a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> is a light proxy on image containers based on a COW pointer. It can be constructed, copied, assigned, deleted without any special care.</p>
<p>Moreover, in <a class="el" href="ImageHelper_8h_source.html">ImageHelper.h</a>, many useful functions are provided.</p>
<ol type="1">
<li>Conversely, others convert images into digital sets with value comparators: setFromPointsRangeAndPredicate, setFromPointsRangeAndFunctor, setFromImage.</li>
<li>Some of them convert digital sets into images, imageFromRangeAndValue assigns a given value in an image to each point of a given range.</li>
<li>Some functions are available to fastly fill images from point functors or other images: imageFromFunctor and imageFromImage.</li>
<li>Lastly, some functor like the Projector from BasicPointFunctors can be useful to manipulate domain points and permits to extract N-1 images from ND images (see example <a class="el" href="extract2DImagesFrom3D_8cpp.html">extract2DImagesFrom3D.cpp</a>). <br  />
</li>
</ol>
<h2><a class="anchor" id="SubSampleFct"></a>
Subsampling functor</h2>
<p>In association with <a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a> or <a class="el" href="classDGtal_1_1ImageAdapter.html" title="Aim: implements an image adapter with a given domain (i.e. a subdomain) and 3 functors : g for domain...">ImageAdapter</a> you can apply image subsampling using a domain subsampler (BasicDomainSubSampler from the BasicPointFunctors class). The example <a class="el" href="imageBasicSubsampling_8cpp.html">imageBasicSubsampling.cpp</a> illustrates such a simple image subsampling (in 2D and 3D).</p>
<p>To apply the subsampling, you first have to import the headers associated with the <a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a> and to the BasicDomainSubSampler:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/kernel/BasicPointFunctors.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/images/ConstImageAdapter.h&quot;</span></div>
</div><!-- fragment --><p>Then you can define some image types including the <a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a>:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ImageContainerBySTLVector &lt; Z2i::Domain, unsigned char&gt; Image2D;</div>
<div class="line">  <span class="keyword">typedef</span> ConstImageAdapter&lt;Image2D,  <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Image2D::Domain</a>, </div>
<div class="line">                            functors::BasicDomainSubSampler&lt;Image2D::Domain&gt;,  </div>
<div class="line">                            <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Image2D::Value</a>,</div>
<div class="line">                            functors::Identity &gt; ConstImageAdapterForSubSampling;</div>
<div class="line"> </div>
</div><!-- fragment --><p> A subsampling functor can be constructed from a given grid size and a shift vector:</p>
<div class="fragment"><div class="line">    <a class="code" href="classDGtal_1_1functors_1_1BasicDomainSubSampler.html">DGtal::functors::BasicDomainSubSampler&lt;Image2D::Domain&gt;</a> subSampler2D(image2D.domain(), aGridSize2D, <a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(0 ,0));</div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1BasicDomainSubSampler_html"><div class="ttname"><a href="classDGtal_1_1functors_1_1BasicDomainSubSampler.html">DGtal::functors::BasicDomainSubSampler</a></div><div class="ttdoc">Aim: Functor that subsamples an initial domain by given a grid size and a shift vector....</div><div class="ttdef"><b>Definition:</b> <a href="BasicPointFunctors_8h_source.html#l00590">BasicPointFunctors.h:591</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z2i_html_ac0a04516c81db6f4a583eddda0f64875"><div class="ttname"><a href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">DGtal::Z2i::Point</a></div><div class="ttdeci">Space::Point Point</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00095">StdDefs.h:95</a></div></div>
</div><!-- fragment --><p> Afterwards the <a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a> can be defined as follows:</p>
<div class="fragment"><div class="line">    <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Image2D::Domain</a> subSampledDomain2D  = subSampler2D.getSubSampledDomain();</div>
<div class="line">    ConstImageAdapterForSubSampling subsampledImage2D (image2D, subSampledDomain2D, subSampler2D, df);</div>
</div><!-- fragment --><p> The resulting image can be exported with the <a class="el" href="structDGtal_1_1GenericWriter.html" title="Aim: Provide a mechanism to save image (2D or 3D) into file with the best saver loader according to a...">GenericWriter</a> class:</p>
<div class="fragment"><div class="line">    <a class="code" href="structDGtal_1_1GenericWriter.html#ae9f11d212f4136c678a4a5b3b8b6c111">GenericWriter&lt;ConstImageAdapterForSubSampling&gt;::exportFile</a>(outputname.str(), subsampledImage2D );</div>
<div class="ttc" id="astructDGtal_1_1GenericWriter_html_ae9f11d212f4136c678a4a5b3b8b6c111"><div class="ttname"><a href="structDGtal_1_1GenericWriter.html#ae9f11d212f4136c678a4a5b3b8b6c111">DGtal::GenericWriter::exportFile</a></div><div class="ttdeci">static bool exportFile(const std::string &amp;filename, const TContainer &amp;anImage, const TFunctor &amp;aFunctor=TFunctor())</div></div>
</div><!-- fragment --><p>You will obtain such a result (with also the result on 3D images): </p><div class="image">
<img src="imageBasicSubsamplingExample.png" alt=""/>
<div class="caption">
(11) Illustration of the resulting subsampling given by the imageBasicSubsampling.cpp example</div></div>
<p>.</p>
<h2><a class="anchor" id="moduleImages_functorconstimage"></a>
Constant image from a function, functor or lambda</h2>
<p>If you need to define an image as the result of a callable object (function, functor or lambda) and you don't want to precalculate it or to store it, you should consider using the <a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html">functors::ConstImageFunctorHolder</a> class.</p>
<p>An instance of this class must be constructed through the associated helper <a class="el" href="namespaceDGtal_1_1functors.html#ae078b1e517d167341988d5a5d6366a91">functors::holdConstImageFunctor</a> and you can use any callable object that accepts a point alone or a point and a domain (in order to have a domain dependent image definition).</p>
<p>A first usage example should be composed of the appropriate include: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/images/ConstImageFunctorHolder.h&quot;</span></div>
</div><!-- fragment --><p>followed by the image definition: </p><div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> domain1(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1,1), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(16,16));</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> image1 = <a class="code" href="namespaceDGtal_1_1functors.html#ae078b1e517d167341988d5a5d6366a91">DGtal::functors::holdConstImageFunctor</a>(</div>
<div class="line">      domain1,</div>
<div class="line">      [] (<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> <span class="keyword">const</span>&amp; pt) { <span class="keywordflow">return</span> 25 * ( std::cos( (pt - <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(4,4)).norm() ) + 1 ); }</div>
<div class="line">  );</div>
<div class="ttc" id="anamespaceDGtal_1_1functors_html_ae078b1e517d167341988d5a5d6366a91"><div class="ttname"><a href="namespaceDGtal_1_1functors.html#ae078b1e517d167341988d5a5d6366a91">DGtal::functors::holdConstImageFunctor</a></div><div class="ttdeci">auto holdConstImageFunctor(TDomain const &amp;aDomain, TFunctor &amp;&amp;aFunctor) -&gt; ConstImageFunctorHolder&lt; TDomain, TValue, decltype(holdFunctor(std::forward&lt; TFunctor &gt;(aFunctor)))&gt;</div><div class="ttdoc">ConstImageFunctorHolder construction helper with specification of the return type.</div><div class="ttdef"><b>Definition:</b> <a href="ConstImageFunctorHolder_8h_source.html#l00277">ConstImageFunctorHolder.h:277</a></div></div>
</div><!-- fragment --><p>that gives us the following result: </p><div class="image">
<img src="ConstImageFunctorHolder_example1.png" alt=""/>
<div class="caption">
(12) Image generated from a point-dependent lambda.</div></div>
 <p>You can also use a functor that depends on the point and the image's domain: </p><div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> domain2(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(-1,1), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(18,18));</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> image2 = <a class="code" href="namespaceDGtal_1_1functors.html#ae078b1e517d167341988d5a5d6366a91">DGtal::functors::holdConstImageFunctor</a>(</div>
<div class="line">      domain2,</div>
<div class="line">      [] (<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> <span class="keyword">const</span>&amp; pt, <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> <span class="keyword">const</span>&amp; d) { <span class="comment">// we could also capture the domain</span></div>
<div class="line">        <span class="keywordflow">return</span> 2 * std::min( ( pt - d.lowerBound() ).norm(), ( pt - d.upperBound() ).norm() );</div>
<div class="line">      }</div>
<div class="line">  );</div>
</div><!-- fragment --><p>resulting in: </p><div class="image">
<img src="ConstImageFunctorHolder_example2.png" alt=""/>
<div class="caption">
(13) Image generated from a lambda that depends on the point and the domain.</div></div>
 <p>Going further, you can also capture other images in the lambda so that to define a mix: </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> image3 = <a class="code" href="namespaceDGtal_1_1functors.html#ae078b1e517d167341988d5a5d6366a91">DGtal::functors::holdConstImageFunctor</a>(</div>
<div class="line">      domain1,</div>
<div class="line">      [&amp;image1, &amp;image2] (<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> <span class="keyword">const</span>&amp; pt) { <span class="keywordflow">return</span> image1(pt) + image2(pt); }</div>
<div class="line">  );</div>
</div><!-- fragment --><p>resulting in: </p><div class="image">
<img src="ConstImageFunctorHolder_example3.png" alt=""/>
<div class="caption">
(14) Image generated as the sum of two images.</div></div>
 <dl class="section see"><dt>See also</dt><dd>FunctorHolder, <a class="el" href="moduleFunctors.html">Using functions, functors and lambdas in DGtal</a> </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 1 2021 17:06:31 for DGtal by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
