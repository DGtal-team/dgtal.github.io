<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Digital Spaces, Points, Vectors and Domains</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Digital Spaces, Points, Vectors and Domains </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sectSpace">DGtal Space</a></li>
<li class="level1"><a href="#sectPointVector">Points and Vectors</a></li>
<li class="level1"><a href="#sectDomain">Domains and HyperRectDomains</a><ul><li class="level2"><a href="#sectDomDef">Definition</a></li>
<li class="level2"><a href="#sectDomIter">Iterating over an  HyperRectDomain</a></li>
<li class="level2"><a href="#sectDomParScan">Scanning an HyperRectDomain in parallel</a></li>
<li class="level2"><a href="#sectDomEmpty">Empty domains</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Authors</dt><dd>David Coeurjolly, Jacques-Olivier Lachaud, Guillaume Damiand</dd></dl>
<p>This part of the manual describes the <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> kernel and its classes. More precisely, we define several key concepts in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> such as Space or Domain. All classes and utilities defined in the <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> library require a specification of the digital space in which the objects are defined.</p>
<p>For <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> users, the specification of the digital Space usually corresponds to the first lines of <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> codes.</p>
<h1><a class="anchor" id="sectSpace"></a>
DGtal Space</h1>
<p>A <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> Space parametrized by two things: a dimension (<a class="el" href="classDGtal_1_1SpaceND.html#aae87d3efb1051dbdeac28e159781ba92" title="static constants to store the dimension.">SpaceND::dimension</a>) and a type for integers (<a class="el" href="classDGtal_1_1SpaceND.html#a3217d099840050eb7135e24b1ed7940d" title="Arithmetic ring induced by (+,-,*) and Integer numbers.">SpaceND::Integer</a>). Using these information, we aim at approximating the digital space \(Z^n\) by \(Integer^{dimension}\). Hence, we have several constraints these parameters:</p><ul>
<li>the dimension should also be a integer;</li>
<li>Integer should characterize a commutative ring with unity using the addition and multiplication operators.</li>
</ul>
<p>Since the Space is obtained by direct product of the range associated to the type Integer. Such type is also used to characterized the coordinates of points lying in this space.</p>
<p>In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>, Space specification is addresses by the class <a class="el" href="classDGtal_1_1SpaceND.html">DGtal::SpaceND</a>. More precisely, this class is templated by two arguments (the static dimension and the Integer type) and provides types for several objects that can be deduced from the template parameters. For example, once the parameter are specified, the class provides a type Point for all points in the space.</p>
<p>For example, digital spaces can be defined as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/base/Common.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/kernel/SpaceND.h&quot;</span></div>
<div class="line">{...}</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classDGtal_1_1SpaceND.html">DGtal::SpaceND&lt;3, DGtal::int32_t&gt;</a> MySpace32;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classDGtal_1_1SpaceND.html">DGtal::SpaceND&lt;1, DGtal::int64_t&gt;</a> MySpace64;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef WITH_BIGINTEGER</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classDGtal_1_1SpaceND.html">DGtal::SpaceND&lt;3, DGtal::Integer&gt;</a> MySpaceBigInteger;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="ttc" id="aclassDGtal_1_1SpaceND_html"><div class="ttname"><a href="classDGtal_1_1SpaceND.html">DGtal::SpaceND</a></div><div class="ttdef"><b>Definition:</b> <a href="SpaceND_8h_source.html#l00095">SpaceND.h:96</a></div></div>
</div><!-- fragment --><p>In the latter example, we construct a digital space using multiprecision intergers (implemented using the GMP arbitrary precision library). For details, see the documentation page <a class="el" href="moduleNumber.html">Number and Integer Concepts</a>.</p>
<p>Using the shortcuts provides in <a class="el" href="StdDefs_8h_source.html">StdDefs.h</a>, the types defined in the namespace <a class="el" href="namespaceDGtal_1_1Z2i.html" title="Z2i this namespace gathers the standard of types for 2D imagery.">DGtal::Z2i</a> correspond to a digital space in dimension 2 based on int (<code>int32_t</code>). Hence, we can simple define <code>MySpace</code> as:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/base/Common.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/helpers/StdDefs.h&quot;</span></div>
<div class="line">{...}</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classDGtal_1_1SpaceND.html">DGtal::Z2i::Space</a> MySpace; </div>
</div><!-- fragment --><p>We can construct a point lying in this space as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/base/Common.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/helpers/StdDefs.h&quot;</span></div>
<div class="line">{...}</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceDGtal_1_1Z2i.html">DGtal::Z2i</a>;</div>
<div class="line"><span class="comment">//We use default types Z2i::Space and Z2i::Point</span></div>
<div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> p(13,-5);</div>
<div class="ttc" id="anamespaceDGtal_1_1Z2i_html"><div class="ttname"><a href="namespaceDGtal_1_1Z2i.html">DGtal::Z2i</a></div><div class="ttdoc">Z2i this namespace gathers the standard of types for 2D imagery.</div></div>
<div class="ttc" id="atestClone2_8cpp_html_a15e9592ccc512dc691b46185e6814758"><div class="ttname"><a href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a></div><div class="ttdeci">MyPointD Point</div><div class="ttdef"><b>Definition:</b> <a href="testClone2_8cpp_source.html#l00383">testClone2.cpp:383</a></div></div>
</div><!-- fragment --><p>Beside the type <code>Point</code> (defined as a specialization of the class <a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a>), <a class="el" href="classDGtal_1_1SpaceND.html">SpaceND</a> (or <a class="el" href="namespaceDGtal_1_1Z2i.html#a9b96ab8175cf9c54b1f451858ccd46a4">Z2i::Space</a>) provides several other types and methodes such as</p><ul>
<li>types associated to the canonical vector space (<a class="el" href="classDGtal_1_1SpaceND.html#a34beb5f81d0848e8ae393f39a1422ebc" title="Points in DGtal::SpaceND.">SpaceND::Point</a>, <a class="el" href="classDGtal_1_1SpaceND.html#ae194f4dfc28465ea14b437c066e69604" title="Vectors in DGtal::SpaceND.">SpaceND::Vector</a>,...)</li>
<li>types and methods for subspace and subcospace construction</li>
<li>...</li>
</ul>
<h1><a class="anchor" id="sectPointVector"></a>
Points and Vectors</h1>
<p><code>Point</code>s and <code>Vector</code>s are fundamental objects in the digital space. Indeed, they allow us to access to grid point location or to represent displacements between grid points. Many methods are defined for Point and Vector instances. For example we have</p><ul>
<li>arithmetic operators (<code>*</code>, <code>-</code>, ...)</li>
<li>comparison operators (<code>&lt;</code> ,<code>&gt;</code>, ...)</li>
<li>methods associate to the canonical lattice associated to points (<code>inf</code>, <code>sup</code>, <code>isLower</code>,...)</li>
<li>methods to compute various norms of <code>Point</code>s/<code>Vector</code>s.</li>
<li>last but not least, the interface also provides iterators and accessors.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>For the sake of simplicity, both <a class="el" href="classDGtal_1_1SpaceND.html#a34beb5f81d0848e8ae393f39a1422ebc" title="Points in DGtal::SpaceND.">SpaceND::Point</a> and <a class="el" href="classDGtal_1_1SpaceND.html#ae194f4dfc28465ea14b437c066e69604" title="Vectors in DGtal::SpaceND.">SpaceND::Vector</a> in a space <a class="el" href="classDGtal_1_1SpaceND.html">DGtal::SpaceND</a> are aliases of the specialized type <a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">DGtal::PointVector</a>. In other words, these two types can be exchanged without any problem, even if it does not make sense in a mathematical. For instance, from a vector, we can define its opposite but the opposite does not make sense for a point.</dd></dl>
<p>An element of a <code>Point</code> has type <code>Coordinate</code> and an element of a <code>Vector</code> has type <code>Component</code>. For instance, the following code is valid in terms of type. </p><div class="fragment"><div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> p;</div>
<div class="line">Point::Coordinate coord = 24;</div>
<div class="line"><span class="keywordflow">for</span>(<a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> d = 0 ; d &lt; Space::dimension; ++d)</div>
<div class="line">   p[d] = coord;</div>
<div class="ttc" id="anamespaceDGtal_html_a8fbe8c8d47ca5c36ced14284ac62613d"><div class="ttname"><a href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">DGtal::Dimension</a></div><div class="ttdeci">DGtal::uint32_t Dimension</div><div class="ttdef"><b>Definition:</b> <a href="Common_8h_source.html#l00137">Common.h:137</a></div></div>
</div><!-- fragment --><p> However, we encourage the use of iterators as follows </p><div class="fragment"><div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> p;</div>
<div class="line">Point::Coordinate coord = 24;</div>
<div class="line"><span class="keywordflow">for</span>(Point::Iterator it=p.begin(), itend=p.end() ; </div>
<div class="line">    it != itend;</div>
<div class="line">    ++it)</div>
<div class="line">    (*it) = coord;</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Similarly to the previous note and since <code>Vector</code> and <code>Space</code> are aliases, <a class="el" href="classDGtal_1_1PointVector.html#a6409a51203e0edc907d523fb19ed7e41" title="Type for Point elements.">SpaceND::Point::Coordinate</a> and <a class="el" href="classDGtal_1_1PointVector.html#ab5f7548d4edc0d8edb4b64cc332db8f2" title="Type for Vector elements.">SpaceND::Vector::Component</a> are aliases of <a class="el" href="classDGtal_1_1SpaceND.html#a3217d099840050eb7135e24b1ed7940d" title="Arithmetic ring induced by (+,-,*) and Integer numbers.">SpaceND::Integer</a>. It does not lead to a strong typing of <code>Point</code> and <code>Vector</code> but it helps the user to design code as close as possible to a mathematical formulation.</dd></dl>
<p><a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a> class is parametrized by the following template parameters:</p><ul>
<li>the static dimension of the underlying space (of type <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">DGtal::Dimension</a>);</li>
<li>a model of <a class="el" href="structDGtal_1_1concepts_1_1CEuclideanRing.html" title="Aim: Defines the mathematical concept equivalent to a unitary commutative ring with a division operat...">concepts::CEuclideanRing</a> to be used as <a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a> components/coordinates;</li>
<li>a model of bidirectional random access iterator to store the point or vector (default container: <code>boost::array</code> with static size equals to the space dimension). In fact, we consider a weaker concept than <a class="el" href="structboost_1_1RandomAccessContainer.html" title="Go to http://www.sgi.com/tech/stl/RandomAccessContainer.html.">boost::RandomAccessContainer</a> since we only need iterators and reverse_iterators (<code>const</code> and non-<code>const</code>) to be defined, default/copy constructors and <code>operator[]</code>. Models can be <code>boost::array</code>, <code>std::vector</code> or even <code>std::array</code> (for <code>C++11</code> enabled projects).</li>
</ul>
<h1><a class="anchor" id="sectDomain"></a>
Domains and HyperRectDomains</h1>
<h2><a class="anchor" id="sectDomDef"></a>
Definition</h2>
<p>Once we have defined the fundamental characteristics of our digital space, we can define a domain on which all the computations will done. A domain is characterized by a starting point A, an end point B and a way to scan all the point between A and B. In most situation, one may want the domain to be a finite isothetic subset of the digital space. Hence, an important model of the concept of domain (specified in the <a class="el" href="structDGtal_1_1concepts_1_1CDomain.html" title="Aim: This concept represents a digital domain, i.e. a non mutable subset of points of the given digit...">concepts::CDomain</a> class) is the class <a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a>. Since the domain lies on a digital space, the <a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a> class has a template argument which correspond to the type of space we consider.</p>
<p>For example, let us consider the following code snippet </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;DGtal/base/Common.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;DGtal/kernel/SpaceND.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;DGtal/helpers/StdDefs.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;DGtal/kernel/domains/HyperRectDomain.h&gt;</span></div>
<div class="line">{...}</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceDGtal_1_1Z2i.html">DGtal::Z2i</a>;</div>
</div><!-- fragment --><p>An instance of <a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a> can be created as follows: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> HyperRectDomain&lt;Space&gt; MyDomain;</div>
<div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> a(-3,-4);</div>
<div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> b(10,4);</div>
<div class="line">MyDomain <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>(a,b);</div>
<div class="ttc" id="atestProjection_8cpp_html_a1f1a69f8d8b037b72c2160ed12b3ef51"><div class="ttname"><a href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a></div><div class="ttdeci">Domain domain</div><div class="ttdef"><b>Definition:</b> <a href="testProjection_8cpp_source.html#l00088">testProjection.cpp:88</a></div></div>
</div><!-- fragment --><p>The instance is thus an isothetic domain lying on the space <code><a class="el" href="classDGtal_1_1SpaceND.html">SpaceND</a>&lt;2,<a class="el" href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e" title="unsigned 32-bit integer.">DGtal::uint32_t</a>&gt;</code> defined by the bounding box of the points a and b. Note that type <a class="el" href="namespaceDGtal_1_1Z2i.html#aca523bebdae58eb19385aaefffff8bc5">Z2i::Domain</a> in <a class="el" href="StdDefs_8h_source.html">StdDefs.h</a> exactly corresponds to <a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a> on the <a class="el" href="namespaceDGtal_1_1Z2i.html#a9b96ab8175cf9c54b1f451858ccd46a4">Z2i::Space</a>. We can visualise the domain using the <a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (with &lt;&lt;)....">Board2D</a> stream mechanism (see <a class="el" href="moduleBoard2D.html">Board2D: a stream mechanism for displaying 2D digital objects</a>).</p>
<div class="image">
<img src="kernel-domain.png" alt=""/>
<div class="caption">
Illustration of a simple 2-D domain</div></div>
 <p>The <a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a> class provides several methods such as <a class="el" href="classDGtal_1_1HyperRectDomain.html#a3bea82f197b8b6ff235206724b5c8c2e">HyperRectDomain::isInside</a> to decide if a point is inside the domain or not.</p>
<div class="fragment"><div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> c(5,1);</div>
<div class="line"><span class="keywordflow">if</span> ( <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.isInside( c ) )</div>
<div class="line">   <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;C is inside the domain&quot;</span>&lt;&lt;endl;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">   <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;C is outside the domain&quot;</span>&lt;&lt;endl;</div>
<div class="ttc" id="aclassDGtal_1_1Trace_html_ad054990834d2763627166540087a2980"><div class="ttname"><a href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">DGtal::Trace::info</a></div><div class="ttdeci">std::ostream &amp; info()</div></div>
<div class="ttc" id="anamespaceDGtal_html_a8fc7012708b0416880a5c8b12dfdf9dd"><div class="ttname"><a href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">DGtal::trace</a></div><div class="ttdeci">Trace trace</div><div class="ttdef"><b>Definition:</b> <a href="Common_8h_source.html#l00154">Common.h:154</a></div></div>
</div><!-- fragment --><div class="image">
<img src="kernel-domain-point.png" alt=""/>
<div class="caption">
Illustration of a simple 2-D domain with a point</div></div>
 <h2><a class="anchor" id="sectDomIter"></a>
Iterating over an  HyperRectDomain</h2>
<p>An important feature of <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> domain is based on iterators it defines to scan the grid points in various orders. For example, to scan the whole domain we can use</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>( <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">MyDomain::ConstIterator</a> it = <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.begin(), itend = <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.end();</div>
<div class="line">     it != itend;   </div>
<div class="line">     ++it)</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;Processing point&quot;</span>&lt;&lt; (*it) &lt;&lt; endl;</div>
<div class="ttc" id="agreedy-plane-segmentation-ex2_8cpp_html_a6d06fad433cff067dfcbbbf16d6e2dbf"><div class="ttname"><a href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a></div><div class="ttdeci">MyDigitalSurface::ConstIterator ConstIterator</div><div class="ttdef"><b>Definition:</b> <a href="greedy-plane-segmentation-ex2_8cpp_source.html#l00093">greedy-plane-segmentation-ex2.cpp:93</a></div></div>
</div><!-- fragment --><p>By default, <a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a> iterators use the lexicographic order on the dimensions. To visualise this order in dimension 2, we can use the following code snippet in which we display each point by a color map from blue to red according to the order (blue point corresponds to the first point and the red one to the last point). Note that in this example, we use a specific drawing primitive (<code>draw</code>) in order to draw a <a class="el" href="classDGtal_1_1SpaceND.html#ae194f4dfc28465ea14b437c066e69604" title="Vectors in DGtal::SpaceND.">SpaceND::Vector</a> as an arrow..</p>
<p>Again, for details on the <a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (with &lt;&lt;)....">Board2D</a> mechanism, please refer to <a class="el" href="moduleBoard2D.html">Board2D: a stream mechanism for displaying 2D digital objects</a>.</p>
<div class="fragment"><div class="line"><span class="comment">//We draw an arrow between two consecutive points during the iteration.</span></div>
<div class="line"><a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">MyDomain::ConstIterator</a> itPrec = <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.begin();</div>
<div class="line"><a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">MyDomain::ConstIterator</a> it = itPrec;</div>
<div class="line"><a class="code" href="testCombinDSS_8cpp.html#a609ee1808a3b4f883fb28df65e9a2ed6">MyDomain::Vector</a> shift;</div>
<div class="line">++it;</div>
<div class="line"> </div>
<div class="line">board &lt;&lt; (*itPrec); <span class="comment">//We display the first point as a pixel.</span></div>
<div class="line"><span class="keywordflow">for</span>( <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">MyDomain::ConstIterator</a> itend = <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.end();</div>
<div class="line">     it != itend;   </div>
<div class="line">     ++it, ++itPrec)</div>
<div class="line">  {</div>
<div class="line">    shift =   (*it) -(*itPrec);</div>
<div class="line">    <a class="code" href="testSegmentation_8cpp.html#ad3481e408a11633aeaa7732e7faf6b56">draw</a>(board, shift, (*itPrec));</div>
<div class="line">  }</div>
<div class="line">board.saveSVG(<span class="stringliteral">&quot;kernel-domain-it-arrow.svg&quot;</span>);</div>
<div class="ttc" id="atestCombinDSS_8cpp_html_a609ee1808a3b4f883fb28df65e9a2ed6"><div class="ttname"><a href="testCombinDSS_8cpp.html#a609ee1808a3b4f883fb28df65e9a2ed6">Vector</a></div><div class="ttdeci">FreemanChain&lt; int &gt;::Vector Vector</div><div class="ttdef"><b>Definition:</b> <a href="testCombinDSS_8cpp_source.html#l00060">testCombinDSS.cpp:60</a></div></div>
<div class="ttc" id="atestSegmentation_8cpp_html_ad3481e408a11633aeaa7732e7faf6b56"><div class="ttname"><a href="testSegmentation_8cpp.html#ad3481e408a11633aeaa7732e7faf6b56">draw</a></div><div class="ttdeci">void draw(const Iterator &amp;itb, const Iterator &amp;ite, Board &amp;aBoard)</div><div class="ttdef"><b>Definition:</b> <a href="testSegmentation_8cpp_source.html#l00075">testSegmentation.cpp:75</a></div></div>
</div><!-- fragment --><div class="image">
<img src="kernel-domain-it-arrow.png" alt=""/>
<div class="caption">
Iteration over a domain with displacements depicted as arrows.</div></div>
 <p>For each iterator ̀ XXX<code>, there is a corresponding</code>ReverseXXX` class allowing to run through the same elements but in reverse direction. For the whole domain, we wan use</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>( MyDomain::ReverseConstIterator it = <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.rbegin(), itend = <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.rend();</div>
<div class="line">     it != itend;   </div>
<div class="line">     ++it)</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;Processing point&quot;</span>&lt;&lt; (*it) &lt;&lt; endl;</div>
</div><!-- fragment --><p>Note that the <a class="el" href="classDGtal_1_1HyperRectDomain.html#a49ca258f671ae5c5a5b1f6f9401f4741">HyperRectDomain::begin</a> and <a class="el" href="classDGtal_1_1HyperRectDomain.html#a6369feb21714dd5671507979a5c144a8">HyperRectDomain::rbegin</a> methods can take an optional <code>Point</code> as parameter which is used as starting point for the iterator. In this case, the point must belongs to the domain.</p>
<p>There are some classes and methods to run through a given subdomain, and allowing to change the order in which dimension are considered. To facilitate their use, these subdomains use the range concept. A range provides iterators for accessing a half-open range <code>[first,one_past_last)</code> of elements. There iterators are accessible by <code>begin()</code> and <code>end()</code> methods of each range class. Moreover, a range can be iterated in reverse direction thanks to iterators returned by <code>rbegin()</code> and <code>rend()</code> methods. As for the <code>begin</code> and <code>rbegin</code> methods on the whole domain, the <code>begin</code> and <code>rbegin</code> range methods can have an optional point as parameter which is used as starting point for the iterator. In this case, the point must belongs to the given range.</p>
<p>To use these ranges, we need first to get a subrange thanks to one <a class="el" href="classDGtal_1_1HyperRectDomain.html#a8e72aa9573bf0481a4681d23f1bb3c41">HyperRectDomain::subRange</a> method. As illustrate below, the basic method take a <code>std::vector&lt;Dimension&gt;</code> as first parameter, describing the dimensions of the subdomain, and a <code>Point</code> as second parameter which give the position of the subdomain for the dimensions not in the vector. Other dimensions are not used. In the example below, <code>Point c(3,1,1)</code> is only used for its first dimension. Thus we would have obtained the same <code>subRange</code> by using for example <code>Point d(3,2,4)</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> SpaceND&lt;3&gt; TSpace;  </div>
<div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">TSpace::Point</a> a(1, 1, 1);</div>
<div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">TSpace::Point</a> b(5, 5, 5);</div>
<div class="line">HyperRectDomain&lt;TSpace&gt; <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>(a,b);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;TSpace::Dimension&gt; v(2); v[0]=2; v[1]=1;</div>
<div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">TSpace::Point</a> c(3,1,1);</div>
<div class="line"><span class="keywordflow">for</span>( HyperRectDomain&lt;TSpace&gt;::ConstSubRange::ReverseConstIterator </div>
<div class="line">       it = <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.subRange(v, c).rbegin(), itend =  <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.subRange(v, c).rend();</div>
<div class="line">     it != itend; </div>
<div class="line">     ++it)</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;Processing point&quot;</span>&lt;&lt; (*it) &lt;&lt; endl;</div>
</div><!-- fragment --><p>This example run through all the points in the plane <code>X=3</code> (if we suppose that dimension 0 is <code>X</code>, dimension 1 is <code>Y</code> and dimension 2 is <code>Z</code>) in reverse direction. Note that you can chose to instantiate <code>domain.subRange(v, c)</code> only once before the loop, but the gain is negligible regarding the given example where the subrange is instantiated twice. However, the gain can be important comparing with the bad version where the range is instantiated at each step of the loop to compare it with <code>domain.subRange(v, c).rend()</code>.</p>
<p>Note also that the vector gives not only the dimensions of the subrange but also the order in which these dimensions are considered. In the example above, we start to iterate through <code>Z</code>, then to <code>Y</code> since vector <code>v={2,1}</code>. For this reason, the subrange class can also be used to run through a whole given domain but considering the dimensions in a different order.</p>
<p>There are some shortcuts for the <a class="el" href="classDGtal_1_1HyperRectDomain.html#a8e72aa9573bf0481a4681d23f1bb3c41">HyperRectDomain::subRange</a> method to facilitate the iteration through subrange having 1, 2, and 3 dimensions: <code>subRange(Dimension adim, const Point &amp; startingPoint)</code>; <code>subRange(Dimension adim1, Dimension adim2, const Point &amp; startingPoint)</code>; and <code>subRange(Dimension adim1, Dimension adim2, Dimension adim3, const Point &amp; startingPoint)</code>.</p>
<p>Lastly, if your compiler supports <code>C++11</code> initializer list, there is a custom <code>subRange</code> method taking an <code>std::initializer_list&lt;Dimension&gt;</code> instead of the <code>std::vector&lt;Dimension&gt;</code>. This simplifies the use as we can see in the following example since this avoid the creation of a <code>std::vector</code> and its initialization:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> SpaceND&lt;3&gt; TSpace;  </div>
<div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">TSpace::Point</a> a(1, 1, 1);</div>
<div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">TSpace::Point</a> b(5, 5, 5);</div>
<div class="line">HyperRectDomain&lt;TSpace&gt; <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>(a,b);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>( HyperRectDomain&lt;TSpace&gt;::ConstSubRange::ReverseConstIterator </div>
<div class="line">       it = <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.subRange({2,1}, c).rbegin(), itend =  <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.subRange({2,1}, c).rend();</div>
<div class="line">     it != itend; </div>
<div class="line">     ++it)</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;Processing point&quot;</span>&lt;&lt; (*it) &lt;&lt; endl;</div>
</div><!-- fragment --><h2><a class="anchor" id="sectDomParScan"></a>
Scanning an HyperRectDomain in parallel</h2>
<p>Iterators of <a class="el" href="classDGtal_1_1HyperRectDomain.html">HyperRectDomain</a> are random-access iterators thus allowing to easily split the scan of a domain in multiple parts, e.g. for parallelization purpose.</p>
<p>You first need to define how to split a range (begin and end iterators) given a total number of launched threads and the id of the current thread: </p><div class="fragment"><div class="line"><span class="comment">// Splits range in given parts count and returns the part of given idx</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIterator&gt;</div>
<div class="line">SimpleConstRange&lt;TIterator&gt;</div>
<div class="line"><a class="code" href="exampleHyperRectDomainParallelScan_8cpp.html#aaaf46ca42bd7c0e665e04c54d4a9cbf7">split_range</a>(TIterator it_begin, TIterator it_end, std::size_t idx, std::size_t count)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> range_size  = std::distance(it_begin, it_end);</div>
<div class="line">  <span class="keyword">auto</span> begin_shift = (range_size*idx) / count;</div>
<div class="line">  <span class="keyword">auto</span> end_shift   = (range_size*(idx+1)) / count;</div>
<div class="line">  <span class="keywordflow">return</span> { it_begin + begin_shift, it_begin + end_shift };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Splits range in given parts count and returns the part of given idx</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIterable&gt;</div>
<div class="line"><span class="keyword">auto</span></div>
<div class="line"><a class="code" href="exampleHyperRectDomainParallelScan_8cpp.html#aaaf46ca42bd7c0e665e04c54d4a9cbf7">split_range</a>(TIterable &amp; iterable, std::size_t idx, std::size_t count)</div>
<div class="line">    -&gt; decltype(<a class="code" href="exampleHyperRectDomainParallelScan_8cpp.html#aaaf46ca42bd7c0e665e04c54d4a9cbf7">split_range</a>(iterable.begin(), iterable.end(), idx, count))</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="exampleHyperRectDomainParallelScan_8cpp.html#aaaf46ca42bd7c0e665e04c54d4a9cbf7">split_range</a>(iterable.begin(), iterable.end(), idx, count);</div>
<div class="line">}</div>
<div class="ttc" id="aexampleHyperRectDomainParallelScan_8cpp_html_aaaf46ca42bd7c0e665e04c54d4a9cbf7"><div class="ttname"><a href="exampleHyperRectDomainParallelScan_8cpp.html#aaaf46ca42bd7c0e665e04c54d4a9cbf7">split_range</a></div><div class="ttdeci">SimpleConstRange&lt; TIterator &gt; split_range(TIterator it_begin, TIterator it_end, std::size_t idx, std::size_t count)</div><div class="ttdoc">[split_range]</div><div class="ttdef"><b>Definition:</b> <a href="exampleHyperRectDomainParallelScan_8cpp_source.html#l00073">exampleHyperRectDomainParallelScan.cpp:73</a></div></div>
</div><!-- fragment --><p> Now, if you want for example to sum the result of a function applied on each point of a domain, you can first initiate a bunch of threads using an OpenMP parallel region and then iterate over the appropriate part of the point range depending on the current thread id: </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> sum = 0 * fn(<a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.lowerBound()); <span class="comment">// To initialize the sum depending on the function return type</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">  #pragma omp parallel reduction(+:sum)</span></div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// OpenMP context</span></div>
<div class="line">      std::size_t thread_idx = omp_get_thread_num();</div>
<div class="line">      std::size_t thread_cnt = omp_get_num_threads();</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; pt : <a class="code" href="exampleHyperRectDomainParallelScan_8cpp.html#aaaf46ca42bd7c0e665e04c54d4a9cbf7">split_range</a>(<a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>, thread_idx, thread_cnt))</div>
<div class="line">        sum += fn(pt);</div>
<div class="line">    }</div>
</div><!-- fragment --><p> Going further, if you want to use such strategy to initialize or modify an image, you can do: </p><div class="fragment"><div class="line"><span class="preprocessor">  #pragma omp parallel</span></div>
<div class="line">    {</div>
<div class="line">      std::size_t thread_idx = omp_get_thread_num();</div>
<div class="line">      std::size_t thread_cnt = omp_get_num_threads();</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; pt : <a class="code" href="exampleHyperRectDomainParallelScan_8cpp.html#aaaf46ca42bd7c0e665e04c54d4a9cbf7">split_range</a>(image.domain(), thread_idx, thread_cnt))</div>
<div class="line">        image.setValue(pt, fn(pt, <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a614d1b1c043b31763c1eb50f64666737">image</a>(pt)));</div>
<div class="line">    }</div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_a614d1b1c043b31763c1eb50f64666737"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a614d1b1c043b31763c1eb50f64666737">image</a></div><div class="ttdeci">Image image(domain)</div></div>
</div><!-- fragment --><p> Additionally, if your image also provides random-access iterators (like <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>), you can save the getter/setter overhead by using iterators (if the function is not too much CPU intensive): </p><div class="fragment"><div class="line"><span class="preprocessor">  #pragma omp parallel</span></div>
<div class="line">    {</div>
<div class="line">      std::size_t thread_idx = omp_get_thread_num();</div>
<div class="line">      std::size_t thread_cnt = omp_get_num_threads();</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">auto</span> domain_it = <a class="code" href="exampleHyperRectDomainParallelScan_8cpp.html#aaaf46ca42bd7c0e665e04c54d4a9cbf7">split_range</a>(image.domain(), thread_idx, thread_cnt).begin();</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; v : <a class="code" href="exampleHyperRectDomainParallelScan_8cpp.html#aaaf46ca42bd7c0e665e04c54d4a9cbf7">split_range</a>(image, thread_idx, thread_cnt))</div>
<div class="line">        {</div>
<div class="line">          v = fn(*domain_it, v);</div>
<div class="line">          ++domain_it;</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --><p> You can find the complete example and a benchmark in <a class="el" href="exampleHyperRectDomainParallelScan_8cpp.html">exampleHyperRectDomainParallelScan.cpp</a></p>
<h2><a class="anchor" id="sectDomEmpty"></a>
Empty domains</h2>
<p>Since version 0.9 of <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>, <a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a> can model an empty domain and it is what the default constructor returns now.</p>
<p>An empty domain is so that the difference between his lower bound and his upper bound has every component equal to 1. For example, here is some equivalent definitions of an empty domain: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> SpaceND&lt;3&gt; TSpace;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">TSpace::Point</a> TPoint;</div>
<div class="line">TPoint a = TPoint::diagonal(5);</div>
<div class="line"> </div>
<div class="line">HyperRectDomain&lt;TSpace&gt; empty_domain1;</div>
<div class="line">HyperRectDomain&lt;TSpace&gt; empty_domain2( TPoint(1, 1, 1), TPoint(0, 0, 0) );</div>
<div class="line">HyperRectDomain&lt;TSpace&gt; empty_domain3( a, a - TPoint::diagonal(1) );</div>
</div><!-- fragment --><p>Furthermore, a new method, <a class="el" href="classDGtal_1_1HyperRectDomain.html#ace00b156c587e2b92b63bae045d30222">HyperRectDomain::isEmpty</a>, returns <code>true</code> if the domain is empty, <code>false</code> otherwise.</p>
<p>As expected, the following properties are observed if <code>domain</code> is an empty domain:</p><ul>
<li><code>domain.size()</code> returns 0,</li>
<li><code>domain.isInside(p)</code> returns <code>false</code> for every point <code>p</code>,</li>
<li><code>domain.begin() == domain.end()</code> is <code>true</code>, and similarly for the reverse iterators,</li>
<li><code>domain.subRange(v, domain.lowerBound()).begin() == domain.subRange(v, domain.lowerBound()).end()</code> is <code>true</code> for every subset <code>v</code> of dimensions, and similarly for the reverse iterators. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 1 2021 17:06:33 for DGtal by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
