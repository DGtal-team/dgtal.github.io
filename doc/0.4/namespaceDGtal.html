<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DGtal: DGtal Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DGtal&#160;<span id="projectnumber">0.4.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>DGtal Namespace Reference</h1>  </div>
</div>
<div class="contents">

<p><code><a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a></code> is the top-level namespace which contains all <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> functions and types.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1ConceptUtils.html">ConceptUtils</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1deprecated.html">deprecated</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1detail.html">detail</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1experimental.html">experimental</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1Z2i.html">Z2i</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1Z3i.html">Z3i</a></td></tr>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBidirectionalIteratorArchetype.html">CBidirectionalIteratorArchetype</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An archetype of BidirectionalIterator.  <a href="structDGtal_1_1CBidirectionalIteratorArchetype.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CConstBidirectionalIteratorArchetype.html">CConstBidirectionalIteratorArchetype</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An archetype of ConstBidirectionalIterator.  <a href="structDGtal_1_1CConstBidirectionalIteratorArchetype.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CForwardIteratorArchetype.html">CForwardIteratorArchetype</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An archetype of ForwardIterator.  <a href="structDGtal_1_1CForwardIteratorArchetype.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TrueBoolFct0.html">TrueBoolFct0</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1FalseBoolFct0.html">FalseBoolFct0</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IdentityBoolFct1.html">IdentityBoolFct1</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NotBoolFct1.html">NotBoolFct1</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1AndBoolFct2.html">AndBoolFct2</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1OrBoolFct2.html">OrBoolFct2</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1XorBoolFct2.html">XorBoolFct2</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ImpliesBoolFct2.html">ImpliesBoolFct2</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1MinFunctor.html">MinFunctor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1MaxFunctor.html">MaxFunctor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1MinusFunctor.html">MinusFunctor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1AbsFunctor.html">AbsFunctor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1POW.html">POW</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1POW_3_01X_00_011_01_4.html">POW&lt; X, 1 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LOG2.html">LOG2</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LOG2_3_012_01_4.html">LOG2&lt; 2 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LOG2_3_011_01_4.html">LOG2&lt; 1 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Bits.html">Bits</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CConstRange.html">CConstRange</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a const range.  <a href="structDGtal_1_1CConstRange.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1forward__circulator__tag.html">forward_circulator_tag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1bidirectional__circulator__tag.html">bidirectional_circulator_tag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1random__access__circulator__tag.html">random_access_circulator_tag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ForwardCategory.html">ForwardCategory</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1BidirectionalCategory.html">BidirectionalCategory</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1RandomAccessCategory.html">RandomAccessCategory</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits.html">IteratorCirculatorTagTraits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Provides the category of the iterator (resp. circulator) {<a class="el" href="structDGtal_1_1ForwardCategory.html">ForwardCategory</a>,<a class="el" href="structDGtal_1_1BidirectionalCategory.html">BidirectionalCategory</a>,<a class="el" href="structDGtal_1_1RandomAccessCategory.html">RandomAccessCategory</a>} and the type {<a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>,<a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>}.  <a href="structDGtal_1_1IteratorCirculatorTagTraits.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01forward__circulator__tag_01_4.html">IteratorCirculatorTagTraits&lt; forward_circulator_tag &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01bidirectional__circulator__tag_01_4.html">IteratorCirculatorTagTraits&lt; bidirectional_circulator_tag &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01random__access__circulator__tag_01_4.html">IteratorCirculatorTagTraits&lt; random_access_circulator_tag &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01std_1_1forward__iterator__tag_01_4.html">IteratorCirculatorTagTraits&lt; std::forward_iterator_tag &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01std_1_1bidirectional__iterator__tag_01_4.html">IteratorCirculatorTagTraits&lt; std::bidirectional_iterator_tag &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01std_1_1random__access__iterator__tag_01_4.html">IteratorCirculatorTagTraits&lt; std::random_access_iterator_tag &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTraits.html">IteratorCirculatorTraits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Provides definition types for both iterators and circulators: Type, Category, Value, Difference, Pointer and Reference.  <a href="structDGtal_1_1IteratorCirculatorTraits.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTraits_3_01T_01_5_01_4.html">IteratorCirculatorTraits&lt; T * &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CirculatorTagTraits.html">CirculatorTagTraits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Transform std::forward_iterator_tag into <a class="el" href="structDGtal_1_1forward__circulator__tag.html">forward_circulator_tag</a> Transform std::bidirectional_iterator_tag into <a class="el" href="structDGtal_1_1bidirectional__circulator__tag.html">bidirectional_circulator_tag</a> Transform std::random_access_iterator_tag into <a class="el" href="structDGtal_1_1random__access__circulator__tag.html">random_access_circulator_tag</a>.  <a href="structDGtal_1_1CirculatorTagTraits.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CirculatorTagTraits_3_01std_1_1forward__iterator__tag_01_4.html">CirculatorTagTraits&lt; std::forward_iterator_tag &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CirculatorTagTraits_3_01std_1_1bidirectional__iterator__tag_01_4.html">CirculatorTagTraits&lt; std::bidirectional_iterator_tag &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CirculatorTagTraits_3_01std_1_1random__access__iterator__tag_01_4.html">CirculatorTagTraits&lt; std::random_access_iterator_tag &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Circulator.html">Circulator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Provides an adapter for STL iterators that can iterate through the underlying data structure as in a loop. The increment (resp. decrement if at least bidirectionnal) operator encapsulates the validity test and the assignement to the first (resp. last) iterator of a given range. For instance, the pre-increment operator does:  <a href="classDGtal_1_1Circulator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Clock.html">Clock</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawableWithDisplay3D.html">DrawableWithDisplay3D</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawableWithBoard2D.html">DrawableWithBoard2D</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TagFalse.html">TagFalse</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TagTrue.html">TagTrue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TagUnknown.html">TagUnknown</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Negate.html">Negate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Negate_3_01TagTrue_01_4.html">Negate&lt; TagTrue &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Negate_3_01TagFalse_01_4.html">Negate&lt; TagFalse &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DummyObject.html">DummyObject</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ConstIteratorAdapter.html">ConstIteratorAdapter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Any iterator (at least forward) can be adapted so that operator* returns a modified element of a given type instead the element pointed to by the iterator.  <a href="classDGtal_1_1ConstIteratorAdapter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CountedPtr.html">CountedPtr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Smart pointer based on reference counts.  <a href="classDGtal_1_1CountedPtr.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CowPtr.html">CowPtr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Copy on write shared pointer.  <a href="classDGtal_1_1CowPtr.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CRange.html">CRange</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a const range.  <a href="structDGtal_1_1CRange.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSinglePassConstRange.html">CSinglePassConstRange</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a const range.  <a href="structDGtal_1_1CSinglePassConstRange.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSinglePassRange.html">CSinglePassRange</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a range.  <a href="structDGtal_1_1CSinglePassRange.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IOException.html">IOException</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1InputException.html">InputException</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ConnectivityException.html">ConnectivityException</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MemoryException.html">MemoryException</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Point3dTo2dXY.html">Point3dTo2dXY</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a 3d point into a 2d point due to a projection on the xy-plane.  <a href="classDGtal_1_1Point3dTo2dXY.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Point3dTo2dXZ.html">Point3dTo2dXZ</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a 3d point into a 2d point due to a projection on the xz-plane.  <a href="classDGtal_1_1Point3dTo2dXZ.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Point3dTo2dYZ.html">Point3dTo2dYZ</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a 3d point into a 2d point due to a projection on the yz-plane.  <a href="classDGtal_1_1Point3dTo2dYZ.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SCellToPoint.html">SCellToPoint</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a scell into a point.  <a href="classDGtal_1_1SCellToPoint.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SCellToMidPoint.html">SCellToMidPoint</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a scell into a real point (the coordinates are divided by 2)  <a href="classDGtal_1_1SCellToMidPoint.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SCellToArrow.html">SCellToArrow</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a signed cell into an arrow, ie. a pair point-vector.  <a href="classDGtal_1_1SCellToArrow.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SCellToInnerPoint.html">SCellToInnerPoint</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a signed cell into a point, basically a linel into the indirect incident pixel center.  <a href="classDGtal_1_1SCellToInnerPoint.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SCellToOuterPoint.html">SCellToOuterPoint</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a sigend cell into a point, basically a linel into the direct incident pixel center.  <a href="classDGtal_1_1SCellToOuterPoint.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SCellToIncidentPoints.html">SCellToIncidentPoints</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a linel into a pair of points, which are the centers of the two incident pixels.  <a href="classDGtal_1_1SCellToIncidentPoints.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SCellToCode.html">SCellToCode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a 2d scell, basically a linel, into a code (0,1,2 or 3),.  <a href="classDGtal_1_1SCellToCode.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1OpInSTLContainers.html">OpInSTLContainers</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implementation of an adapter for erase and insert methods of STL containers so that they not only work for the iterator type, but also for the reverse_iterator type.  <a href="structDGtal_1_1OpInSTLContainers.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1OpInSTLContainers_3_01Container_00_01std_1_1reverse__iterator_3_01typename_01Container_1_1iterator_01_4_01_4.html">OpInSTLContainers&lt; Container, std::reverse_iterator&lt; typename Container::iterator &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1OrderedAlphabet.html">OrderedAlphabet</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Describes an alphabet over an interval of (ascii) letters, where the lexicographic order can be changed (shifted, reversed, ...). Useful for the arithmetic minimum length polygon (AMLP).  <a href="classDGtal_1_1OrderedAlphabet.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Statistic.html">Statistic</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class processes a set of sample values for one variable and can then compute different statistics, like sample mean, sample variance, sample unbiased variance, etc. It is minimalistic for space efficiency. For multiple variables, sample storage and others, see Statistics class.  <a href="classDGtal_1_1Statistic.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Trace.html">Trace</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of basic methods to trace out messages with indentation levels.  <a href="classDGtal_1_1Trace.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TraceWriter.html">TraceWriter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual Class to implement trace writers.  <a href="classDGtal_1_1TraceWriter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TraceWriterFile.html">TraceWriterFile</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TraceWriterTerm.html">TraceWriterTerm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements trace prefix for color terminals.  <a href="classDGtal_1_1TraceWriterTerm.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Dynamic recognition of a digital straight segment (DSS) defined as the sequence of simply connected points (x,y) such that mu &lt;= ax - by &lt; mu + omega.  <a href="classDGtal_1_1ArithmeticalDSS.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawDSSBoundingBox.html">DrawDSSBoundingBox</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawDSSPoints.html">DrawDSSPoints</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1BinomialConvolver.html">BinomialConvolver</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class represents a 2D contour convolved by some binomial. It computes first and second order derivatives so as to be able to estimate tangent and curvature. In particular, it smoothes digital contours but could be used for other kind of contours.  <a href="classDGtal_1_1BinomialConvolver.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TangentFromBinomialConvolverFunctor.html">TangentFromBinomialConvolverFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is a functor for getting the tangent vector of a binomial convolver.  <a href="structDGtal_1_1TangentFromBinomialConvolverFunctor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CurvatureFromBinomialConvolverFunctor.html">CurvatureFromBinomialConvolverFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is a functor for getting the tangent vector of a binomial convolver.  <a href="structDGtal_1_1CurvatureFromBinomialConvolverFunctor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1BinomialConvolverEstimator.html">BinomialConvolverEstimator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class encapsulates a <a class="el" href="classDGtal_1_1BinomialConvolver.html" title="Aim: This class represents a 2D contour convolved by some binomial. It computes first and second orde...">BinomialConvolver</a> and a functor on <a class="el" href="classDGtal_1_1BinomialConvolver.html" title="Aim: This class represents a 2D contour convolved by some binomial. It computes first and second orde...">BinomialConvolver</a> so as to be a model of CLocalGeometricEstimator.  <a href="classDGtal_1_1BinomialConvolverEstimator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CombinatorialDSS.html">CombinatorialDSS</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="classDGtal_1_1CombinatorialDSS.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1BLUELocalLengthEstimator.html">BLUELocalLengthEstimator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Best Linear Unbiased Two step length estimator.  <a href="classDGtal_1_1BLUELocalLengthEstimator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CompareLocalEstimators.html">CompareLocalEstimators</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Functor to compare two local geometric estimators.  <a href="structDGtal_1_1CompareLocalEstimators.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DSSLengthEstimator.html">DSSLengthEstimator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a model of CGlobalCurveEstimator that segments the digital curve into DSS and computes the length of the resulting (not uniquely defined) polygon.  <a href="classDGtal_1_1DSSLengthEstimator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1FPLengthEstimator.html">FPLengthEstimator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a model of CGlobalCurveEstimator that computes the length of a digital curve using its <a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a> (faithful polygon)  <a href="classDGtal_1_1FPLengthEstimator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1L1LengthEstimator.html">L1LengthEstimator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a simple model of CGlobalCurveEstimator that compute the length of a curve using the l_1 metric (just add 1/h for every step).  <a href="classDGtal_1_1L1LengthEstimator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MLPLengthEstimator.html">MLPLengthEstimator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a model of CGlobalCurveEstimator that computes the length of a digital curve using its MLP (given by the <a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a>)  <a href="classDGtal_1_1MLPLengthEstimator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ParametricShapeArcLengthFunctor.html">ParametricShapeArcLengthFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements a functor that estimates the arc length of a paramtric curve.  <a href="classDGtal_1_1ParametricShapeArcLengthFunctor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ParametricShapeCurvatureFunctor.html">ParametricShapeCurvatureFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements a functor that computes the curvature at a given point of a parametric shape.  <a href="classDGtal_1_1ParametricShapeCurvatureFunctor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ParametricShapeTangentFunctor.html">ParametricShapeTangentFunctor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements a functor that computes the tangent vector at a given point of a parametric shape.  <a href="classDGtal_1_1ParametricShapeTangentFunctor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1RosenProffittLocalLengthEstimator.html">RosenProffittLocalLengthEstimator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Rosen-Proffitt Length Estimator.  <a href="classDGtal_1_1RosenProffittLocalLengthEstimator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TrueGlobalEstimatorOnPoints.html">TrueGlobalEstimatorOnPoints</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the true quantity to each element of a range associated to a parametric shape.  <a href="classDGtal_1_1TrueGlobalEstimatorOnPoints.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TrueLocalEstimatorOnPoints.html">TrueLocalEstimatorOnPoints</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the true quantity to each element of a range associated to a parametric shape.  <a href="classDGtal_1_1TrueLocalEstimatorOnPoints.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TwoStepLocalLengthEstimator.html">TwoStepLocalLengthEstimator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a simple model of CGlobalCurveEstimator that compute the length of a curve using the l_1 metric (just add 1/h for every step).  <a href="classDGtal_1_1TwoStepLocalLengthEstimator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Adapter.html">Adapter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: abstract adapter for <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: Dynamic recognition of a digital straight segment (DSS) defined as the sequence of simply connec...">ArithmeticalDSS</a>. Has 2 virtual methods:</p>
<ul>
<li><a class="el" href="classDGtal_1_1Adapter.html#a609e3054db8a085c7599552530a269da">firstLeaningPoint()</a></li>
<li><a class="el" href="classDGtal_1_1Adapter.html#a8d4ca4e2c5be3455e32adc557b59be49">lastLeaningPoint()</a> </li>
</ul>
 <a href="classDGtal_1_1Adapter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Adapter4ConvexPart.html">Adapter4ConvexPart</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: adapter for <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: Dynamic recognition of a digital straight segment (DSS) defined as the sequence of simply connec...">ArithmeticalDSS</a> used by <a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a> in convex parts. Has 2 methods:</p>
<ul>
<li><a class="el" href="classDGtal_1_1Adapter4ConvexPart.html#a5534d5ab110856e8f1c3389a503d5f44">firstLeaningPoint()</a></li>
<li><a class="el" href="classDGtal_1_1Adapter4ConvexPart.html#af4e4e76639524ef0474c761c3cafe37f">lastLeaningPoint()</a> </li>
</ul>
 <a href="classDGtal_1_1Adapter4ConvexPart.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Adapter4ConcavePart.html">Adapter4ConcavePart</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: adapter for <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: Dynamic recognition of a digital straight segment (DSS) defined as the sequence of simply connec...">ArithmeticalDSS</a> used by <a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a> in concave parts. Has 2 methods:</p>
<ul>
<li><a class="el" href="classDGtal_1_1Adapter4ConcavePart.html#a1fdab8fa6589d3e0662cddb27486aef4">firstLeaningPoint()</a></li>
<li><a class="el" href="classDGtal_1_1Adapter4ConcavePart.html#abb6aab1b7ffb447f973ef5dd808fceba">lastLeaningPoint()</a> </li>
</ul>
 <a href="classDGtal_1_1Adapter4ConcavePart.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1FP.html">FP</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the faithful polygon (<a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a>) of a range of 4/8-connected 2D Points.  <a href="classDGtal_1_1FP.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GreedySegmentation.html">GreedySegmentation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the greedy segmentation of a range given by a pair of ConstIterators. The last element of a given segment is the first one one of the next segment.  <a href="classDGtal_1_1GreedySegmentation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GridCurve.html">GridCurve</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: describes an alternative sequence of signed 0-cell (pointels) and 1-cell (linels) in any dimension, closed or open. For instance, the topological boundary of a simply connected digital set is a closed grid curve in 2d.  <a href="classDGtal_1_1GridCurve.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MostCenteredMaximalSegmentEstimator.html">MostCenteredMaximalSegmentEstimator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:Computes a quantity to each element of a range associated to the most centered maximal segment.  <a href="classDGtal_1_1MostCenteredMaximalSegmentEstimator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Point2ShapePredicate.html">Point2ShapePredicate</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Predicate returning 'true' iff a given point is in the 'interior' of a given shape, 'false' otherwise.  <a href="classDGtal_1_1Point2ShapePredicate.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Point2ShapePredicateComparator.html">Point2ShapePredicateComparator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small struct with an operator that compares two values according to two bool template parameters.  <a href="structDGtal_1_1Point2ShapePredicateComparator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01false_00_01false_01_4.html">Point2ShapePredicateComparator&lt; T, false, false &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small struct with an operator that compares two values (&lt;).  <a href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01false_00_01false_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01false_00_01true_01_4.html">Point2ShapePredicateComparator&lt; T, false, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small struct with an operator that compares two values (&lt;=).  <a href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01false_00_01true_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01true_00_01false_01_4.html">Point2ShapePredicateComparator&lt; T, true, false &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small struct with an operator that compares two values (&gt;).  <a href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01true_00_01false_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01true_00_01true_01_4.html">Point2ShapePredicateComparator&lt; T, true, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small struct with an operator that compares two values (&gt;=).  <a href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01true_00_01true_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Preimage2D.html">Preimage2D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the preimage of the 2D Euclidean shapes crossing a sequence of n straigth segments in O(n), with the algorithm of O'Rourke (1981).  <a href="classDGtal_1_1Preimage2D.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SaturatedSegmentation.html">SaturatedSegmentation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the saturated segmentation, that is the whole set of maximal segments within a range given by a pair of ConstIterators (maximal segments are segments that cannot be included in greater segments).  <a href="classDGtal_1_1SaturatedSegmentation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TangentFromDSSFunctor.html">TangentFromDSSFunctor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TangentAngleFromDSSFunctor.html">TangentAngleFromDSSFunctor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CurvatureFromDSSLengthFunctor.html">CurvatureFromDSSLengthFunctor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CurvatureFromDSSFunctor.html">CurvatureFromDSSFunctor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">ForwardSegmentComputer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DynamicSegmentComputer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DynamicBidirectionalSegmentComputer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SegmentComputerTraits.html">SegmentComputerTraits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Provides the category of the segment computer {<a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">ForwardSegmentComputer</a>,<a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a>, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DynamicSegmentComputer</a>, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DynamicBidirectionalSegmentComputer</a>}.  <a href="structDGtal_1_1SegmentComputerTraits.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1StraightLine.html">StraightLine</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a <a class="el" href="classDGtal_1_1StraightLine.html" title="Aim: Represents a StraightLine uniquely defined by two 2D points and that is able to return for each ...">StraightLine</a> uniquely defined by two 2D points and that is able to return for each 2D point of the domain its signed distance to itself.  <a href="classDGtal_1_1StraightLine.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ArithmeticalDSS3d.html">ArithmeticalDSS3d</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Dynamic recognition of a 3d-digital straight segment (DSS)  <a href="classDGtal_1_1ArithmeticalDSS3d.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html">CBidirectionalSegmentComputer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a bidirectional segment computer, ie. a model of <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment of a range, ie. a valid and not empty subrange...">CSegment</a> that can extend itself in the two possible directions.  <a href="structDGtal_1_1CBidirectionalSegmentComputer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html">CDynamicBidirectionalSegmentComputer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie. a model of <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment of a range, ie. a valid and not empty subrange...">CSegment</a> that can extend and retract itself in either direction.  <a href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html">CDynamicSegmentComputer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a dynamic segment computer, ie. a model of <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment of a range, ie. a valid and not empty subrange...">CSegment</a> that can extend and retract itself (in the direction that is relative to the underlying iterator).  <a href="structDGtal_1_1CDynamicSegmentComputer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CForwardSegmentComputer.html">CForwardSegmentComputer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a forward segment computer, ie. a model of <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment of a range, ie. a valid and not empty subrange...">CSegment</a> that can extend itself (in the direction that is relative to the underlying iterator).  <a href="structDGtal_1_1CForwardSegmentComputer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSegment.html">CSegment</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a segment of a range, ie. a valid and not empty subrange.  <a href="structDGtal_1_1CSegment.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CTrivialSegmentComputer.html">CTrivialSegmentComputer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing the most trivial segment computer, ie. a model of <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment of a range, ie. a valid and not empty subrange...">CSegment</a> that can extend itself.  <a href="structDGtal_1_1CTrivialSegmentComputer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ContourHelper.html">ContourHelper</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a helper class to process sequences of points.  <a href="classDGtal_1_1ContourHelper.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Measure.html">Measure</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements a simple measure computation (in the Lesbegue sens) of a set. In dimension 2, it corresponds to the area of the set, to the volume in dimension 3,...  <a href="classDGtal_1_1Measure.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GaussDigitizer.html">GaussDigitizer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A class for computing the Gauss digitization of some Euclidean shape, i.e. its intersection with some <img class="formulaInl" alt="$ h_1 Z \times h_2 Z \times \cdots \times h_n Z $" src="form_39.png"/>. It is also a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> and of <a class="el" href="structDGtal_1_1CShape.html">CShape</a>. Note that the real point (0,...,0) is mapped onto the digital point (0,...,0).  <a href="classDGtal_1_1GaussDigitizer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSeparableMetric.html">CSeparableMetric</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DistanceTransformation.html">DistanceTransformation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implementation of the linear in time distance transformation.  <a href="classDGtal_1_1DistanceTransformation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ReverseDistanceTransformation.html">ReverseDistanceTransformation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implementation of the linear in time reverse distance transformation.  <a href="classDGtal_1_1ReverseDistanceTransformation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SeparableMetricTraits.html">SeparableMetricTraits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements basic functions associated to metrics used by separable volumetric algorithms.  <a href="structDGtal_1_1SeparableMetricTraits.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SeparableMetricTraits_3_01TAbscissa_00_01TInternalValue_00_012_01_4.html">SeparableMetricTraits&lt; TAbscissa, TInternalValue, 2 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SeparableMetricTraits_3_01TAbscissa_00_01TInternalValue_00_011_01_4.html">SeparableMetricTraits&lt; TAbscissa, TInternalValue, 1 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SeparableMetricTraits_3_01TAbscissa_00_01TInternalValue_00_010_01_4.html">SeparableMetricTraits&lt; TAbscissa, TInternalValue, 0 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CImageContainer.html">CImageContainer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CValue.html">CValue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ImageSelector.html">ImageSelector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Automatically defines an adequate image type according to the hints given by the user.  <a href="structDGtal_1_1ImageSelector.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ImageSelector_3_01Domain_00_01Value_00_01LOW__ITER__I_09LOW__BEL__I_01_4.html">ImageSelector&lt; Domain, Value, LOW_ITER_I+LOW_BEL_I &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ImageFromSet.html">ImageFromSet</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define utilities to convert a digital set into an image.  <a href="structDGtal_1_1ImageFromSet.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SetFromImage.html">SetFromImage</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define utilities to convert a digital set into an image.  <a href="structDGtal_1_1SetFromImage.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SimpleForegroundPredicate.html">SimpleForegroundPredicate</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a simple Foreground predicate thresholding image values between to constant values.  <a href="classDGtal_1_1SimpleForegroundPredicate.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Morton.html">Morton</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements the binary <a class="el" href="classDGtal_1_1Morton.html" title="Aim: Implements the binary Morton code construction in nD.">Morton</a> code construction in nD.  <a href="classDGtal_1_1Morton.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Board2D.html">Board2D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class specializes a 'Board' class so as to display <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> objects more naturally (with &lt;&lt;). The user has simply to declare a <a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (wi...">Board2D</a> object and uses stream operators to display most digital objects. Furthermore, one can use this class to modify the current style for drawing.  <a href="classDGtal_1_1Board2D.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawWithBoardModifier.html">DrawWithBoardModifier</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomStyle.html">CustomStyle</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SetMode.html">SetMode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifier class in a <a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (wi...">Board2D</a> stream. Useful to choose your own mode for a given class. Realizes the concept <a class="el" href="structDGtal_1_1CDrawableWithBoard2D.html">CDrawableWithBoard2D</a>.  <a href="structDGtal_1_1SetMode.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomColors.html">CustomColors</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom style class redefining the pen color and the fill color. You may use Board2D::Color::None for transparent color.  <a href="structDGtal_1_1CustomColors.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomPenColor.html">CustomPenColor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom style class redefining the pen color. You may use Board2D::Color::None for transparent color.  <a href="structDGtal_1_1CustomPenColor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomFillColor.html">CustomFillColor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom style class redefining the fill color. You may use Board2D::Color::None for transparent color.  <a href="structDGtal_1_1CustomFillColor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomPen.html">CustomPen</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom style class redefining the pen attributes. You may use Board2D::Color::None for transparent color.  <a href="structDGtal_1_1CustomPen.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Board3DTo2D.html">Board3DTo2D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for PDF, PNG, PS, EPS, SVG export drawings with Cairo with 3D-&gt;2D projection.  <a href="classDGtal_1_1Board3DTo2D.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDrawableWithBoard2D.html">CDrawableWithBoard2D</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDrawableWithDisplay3D.html">CDrawableWithDisplay3D</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Color.html">Color</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing an RGB triple.  <a href="classDGtal_1_1Color.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CColorMap.html">CColorMap</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a color map. A color map converts a value within a given range into an RGB triple.  <a href="structDGtal_1_1CColorMap.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ColorBrightnessColorMap.html">ColorBrightnessColorMap</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class template may be used to (linearly) convert scalar values in a given range into a color with given lightness.  <a href="classDGtal_1_1ColorBrightnessColorMap.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GradientColorMap.html">GradientColorMap</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class template may be used to (linearly) convert scalar values in a given range into a color in a gradient defined by two or more colors.  <a href="classDGtal_1_1GradientColorMap.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GrayscaleColorMap.html">GrayscaleColorMap</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class template may be used to (linearly) convert scalar values in a given range into gray levels.  <a href="classDGtal_1_1GrayscaleColorMap.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1HueShadeColorMap.html">HueShadeColorMap</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class template may be used to (linearly) convert scalar values in a given range into a color in a <em>cyclic</em> hue shade colormap, maybe aka rainbow color map. This color map is suitable, for example, to colorize distance functions. By default, only one hue cycle is used.  <a href="classDGtal_1_1HueShadeColorMap.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1RandomColorMap.html">RandomColorMap</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: access to random color from a gradientColorMap.  <a href="classDGtal_1_1RandomColorMap.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Display3D.html">Display3D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like <a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a>, <a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim: A container class for storing sets of digital points within some given domain.">DigitalSetBySTLSet</a>, <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> ...). The class <a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a> and <a class="el" href="classDGtal_1_1Board3DTo2D.html" title="Class for PDF, PNG, PS, EPS, SVG export drawings with Cairo with 3D-&gt;2D projection.">Board3DTo2D</a> implement two different ways to display 3D objects. The first one (<a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a>), permits an interactive visualisation (based on  OpenGL ) and the second one (<a class="el" href="classDGtal_1_1Board3DTo2D.html" title="Class for PDF, PNG, PS, EPS, SVG export drawings with Cairo with 3D-&gt;2D projection.">Board3DTo2D</a>) provides 3D visualisation from 2D vectorial display (based on the CAIRO library)  <a href="classDGtal_1_1Display3D.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawWithDisplay3DModifier.html">DrawWithDisplay3DModifier</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class specifying the methods for classes which intend to modify a <a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a> stream.  <a href="structDGtal_1_1DrawWithDisplay3DModifier.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SetMode3D.html">SetMode3D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifier class in a <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like PointVector...">Display3D</a> stream. Useful to choose your own mode for a given class. Realizes the concept <a class="el" href="structDGtal_1_1CDrawableWithDisplay3D.html">CDrawableWithDisplay3D</a>.  <a href="structDGtal_1_1SetMode3D.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomStyle3D.html">CustomStyle3D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifier class in a <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like PointVector...">Display3D</a> stream. Useful to choose your own style for a given class. Realizes the concept <a class="el" href="structDGtal_1_1CDrawableWithDisplay3D.html">CDrawableWithDisplay3D</a>.  <a href="structDGtal_1_1CustomStyle3D.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomColors3D.html">CustomColors3D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom style class redefining the fill color and the gl_LINE/gl_POINT color. You can use <a class="el" href="classDGtal_1_1Color.html" title="Structure representing an RGB triple.">DGtal::Color</a> with alpha transparency value but you nedd to take into account the z-buffer during the Open-GL based rendering.  <a href="structDGtal_1_1CustomColors3D.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ClippingPlane.html">ClippingPlane</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for adding a Clipping plane through the <a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a> stream. Realizes the concept CDrawableWithViewer3D.  <a href="structDGtal_1_1ClippingPlane.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CameraPosition.html">CameraPosition</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structDGtal_1_1CameraPosition.html" title="CameraPosition class to set camera position.">CameraPosition</a> class to set camera position.  <a href="structDGtal_1_1CameraPosition.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CameraDirection.html">CameraDirection</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structDGtal_1_1CameraDirection.html" title="CameraDirection class to set camera direction.">CameraDirection</a> class to set camera direction.  <a href="structDGtal_1_1CameraDirection.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CameraUpVector.html">CameraUpVector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structDGtal_1_1CameraUpVector.html" title="CameraUpVector class to set camera up-vector.">CameraUpVector</a> class to set camera up-vector.  <a href="structDGtal_1_1CameraUpVector.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CameraZNearFar.html">CameraZNearFar</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structDGtal_1_1CameraZNearFar.html" title="CameraZNearFar class to set near and far distance.">CameraZNearFar</a> class to set near and far distance.  <a href="structDGtal_1_1CameraZNearFar.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1LongvolReader.html">LongvolReader</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements methods to read a "Longvol" file format (with <a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5" title="unsigned 64-bit integer.">DGtal::uint64_t</a> value type).  <a href="structDGtal_1_1LongvolReader.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1MagickReader.html">MagickReader</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements methods to read a 2D image using the ImageMagick library.  <a href="structDGtal_1_1MagickReader.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1PNMReader.html">PNMReader</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Import a 2D or 3D using the Netpbm formats (ASCII mode).</p>
<ul>
<li>PPM: RGB<ul>
<li>PGM: grayscale</li>
<li>PPM3D: 3D variant of PPM</li>
<li>PGM3D: 3D variant of PGM. </li>
</ul>
</li>
</ul>
 <a href="structDGtal_1_1PNMReader.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1PointListReader.html">PointListReader</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements method to read a set of points represented in each line of a file.  <a href="structDGtal_1_1PointListReader.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1RawReader.html">RawReader</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements methods to read a "Vol" file format.  <a href="structDGtal_1_1RawReader.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1VolReader.html">VolReader</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements methods to read a "Vol" file format.  <a href="structDGtal_1_1VolReader.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DGtalInventor.html">DGtalInventor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A stream object based on Open Inventor for exporting or displaying <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> objects.  <a href="classDGtal_1_1DGtalInventor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IVViewer.html">IVViewer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A facade to represent an inventor window for 3D objects. May be a SoXt or a SoQt examiner viewer. NB: backported from ImaGeneUtils library.  <a href="classDGtal_1_1IVViewer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Lattice.html">Lattice</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents an n-dimensional integer lattice in an m-dimensional real vector space.  <a href="classDGtal_1_1Lattice.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Display 3D primitive (like <a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a>, <a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim: A container class for storing sets of digital points within some given domain.">DigitalSetBySTLSet</a>, <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> ...). This class uses the libQGLViewer library (<a href="http://www.libqglviewer.com">http://www.libqglviewer.com </a>). It inherits of the class <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like PointVector...">Display3D</a> and permits to display object using a simple stream mechanism of "&lt;&lt;".  <a href="classDGtal_1_1Viewer3D.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1LongvolWriter.html">LongvolWriter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Export a 3D Image using the Longvol formats (volumetric image with <a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5" title="unsigned 64-bit integer.">DGtal::uint64_t</a> value type).  <a href="structDGtal_1_1LongvolWriter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1PNMWriter.html">PNMWriter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Export a 2D and a 3D Image using the Netpbm formats (ASCII mode).</p>
<ul>
<li>PPM: RGB</li>
<li>PGM: grayscale</li>
<li>PPM3D: 3D variant of PPM</li>
<li>PGM3D: 3D variant of PGM. </li>
</ul>
 <a href="structDGtal_1_1PNMWriter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1RawWriter.html">RawWriter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Raw binary export of an Image.  <a href="structDGtal_1_1RawWriter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1VolWriter.html">VolWriter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Export a 3D Image using the Vol formats.  <a href="structDGtal_1_1VolWriter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ConstantPointPredicate.html">ConstantPointPredicate</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate that returns always the same value boolCst.  <a href="structDGtal_1_1ConstantPointPredicate.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TruePointPredicate.html">TruePointPredicate</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate that returns always true.  <a href="structDGtal_1_1TruePointPredicate.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1FalsePointPredicate.html">FalsePointPredicate</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate that returns always false.  <a href="structDGtal_1_1FalsePointPredicate.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsLowerPointPredicate.html">IsLowerPointPredicate</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the point is below (or equal) the given upper bound.  <a href="structDGtal_1_1IsLowerPointPredicate.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsUpperPointPredicate.html">IsUpperPointPredicate</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the point is above (or equal) the given lower bound.  <a href="structDGtal_1_1IsUpperPointPredicate.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsWithinPointPredicate.html">IsWithinPointPredicate</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the point is within the given bounds.  <a href="structDGtal_1_1IsWithinPointPredicate.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NotPointPredicate.html">NotPointPredicate</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the point predicate given at construction return false. Thus inverse a predicate: NOT operator.  <a href="structDGtal_1_1NotPointPredicate.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1BinaryPointPredicate.html">BinaryPointPredicate</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the given binary functor returns true for the two PointPredicate(s) given at construction.  <a href="structDGtal_1_1BinaryPointPredicate.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBoundedInteger.html">CBoundedInteger</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The concept <a class="el" href="structDGtal_1_1CBoundedInteger.html" title="Aim: The concept CBoundedInteger specifies what are the bounded integer numbers. Hence, it is a refinement of CInteger Concept ensuring that the numbers are bounded.">CBoundedInteger</a> specifies what are the bounded integer numbers. Hence, it is a refinement of <a class="el" href="structDGtal_1_1CInteger.html" title="Aim: The concept CInteger specifies what are the usual integer numbers, more precisely the ones that ...">CInteger</a> Concept ensuring that the numbers are bounded.  <a href="structDGtal_1_1CBoundedInteger.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CCommutativeRing.html">CCommutativeRing</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the mathematical concept equivalent to a unitary commutative ring.  <a href="structDGtal_1_1CCommutativeRing.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CEuclideanRing.html">CEuclideanRing</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the mathematical concept equivalent to a unitary commutative ring with a division operator.  <a href="structDGtal_1_1CEuclideanRing.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CInteger.html">CInteger</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The concept <a class="el" href="structDGtal_1_1CInteger.html" title="Aim: The concept CInteger specifies what are the usual integer numbers, more precisely the ones that ...">CInteger</a> specifies what are the usual integer numbers, more precisely the ones that are representable on a computer.  <a href="structDGtal_1_1CInteger.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CPointPredicate.html">CPointPredicate</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a predicate on a point.  <a href="structDGtal_1_1CPointPredicate.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSignedInteger.html">CSignedInteger</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Concept checking for Signed Integer.  <a href="structDGtal_1_1CSignedInteger.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSpace.html">CSpace</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a digital space, ie a cartesian product of integer lines.  <a href="structDGtal_1_1CSpace.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CUnsignedInteger.html">CUnsignedInteger</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Concept checking for Unsigned Integer.  <a href="structDGtal_1_1CUnsignedInteger.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDomain.html">CDomain</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept represents a digital domain, i.e. a non mutable subset of points of the given digital space.  <a href="structDGtal_1_1CDomain.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CDomainArchetype.html">CDomainArchetype</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The archetype of a class that represents a digital domain, i.e. a non mutable subset of points of the given digital space.  <a href="classDGtal_1_1CDomainArchetype.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DomainPredicate.html">DomainPredicate</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returning true iff the point is in the domain given at construction. It is just a wrapper class around the methods Domain::isInside( const Point &amp; ), where <code>Domain</code> stands for any model of <a class="el" href="structDGtal_1_1CDomain.html" title="Aim: This concept represents a digital domain, i.e. a non mutable subset of points of the given digit...">CDomain</a>.  <a href="structDGtal_1_1DomainPredicate.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1HyperRectDomain.html">HyperRectDomain</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Parallelepidec region of a digital space, model of a 'CDomain'.  <a href="classDGtal_1_1HyperRectDomain.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawPavingVoxel3D.html">DrawPavingVoxel3D</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawGridVoxel3D.html">DrawGridVoxel3D</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawDomainGrid.html">DrawDomainGrid</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawDomainPaving.html">DrawDomainPaving</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1HyperRectDomain__Iterator.html">HyperRectDomain_Iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1HyperRectDomain__subIterator.html">HyperRectDomain_subIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1LinearAlgebra.html">LinearAlgebra</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A utility class that contains methods to perform integral linear algebra.  <a href="structDGtal_1_1LinearAlgebra.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits.html">NumberTraits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The traits class for all models of Cinteger.  <a href="structDGtal_1_1NumberTraits.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01uint16__t_01_4.html">NumberTraits&lt; uint16_t &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01int16__t_01_4.html">NumberTraits&lt; int16_t &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01uint8__t_01_4.html">NumberTraits&lt; uint8_t &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01int8__t_01_4.html">NumberTraits&lt; int8_t &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01uint32__t_01_4.html">NumberTraits&lt; uint32_t &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01int32__t_01_4.html">NumberTraits&lt; int32_t &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01uint64__t_01_4.html">NumberTraits&lt; uint64_t &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01int64__t_01_4.html">NumberTraits&lt; int64_t &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01float_01_4.html">NumberTraits&lt; float &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01double_01_4.html">NumberTraits&lt; double &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01long_01double_01_4.html">NumberTraits&lt; long double &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Warning__promote__trait__not__specialized__for__this__case.html">Warning_promote_trait_not_specialized_for_this_case</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1promote__trait.html">promote_trait</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1promote__trait_3_01int32__t_00_01int64__t_01_4.html">promote_trait&lt; int32_t, int64_t &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements basic operations that will be used in Point and Vector classes.  <a href="classDGtal_1_1PointVector.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawPavingPixel.html">DrawPavingPixel</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawGridPixel.html">DrawGridPixel</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawPavingVoxel.html">DrawPavingVoxel</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawGridVoxel.html">DrawGridVoxel</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDigitalSet.html">CDigitalSet</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a set of points within the given domain. This set of points is modifiable by the user.  <a href="structDGtal_1_1CDigitalSet.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CDigitalSetArchetype.html">CDigitalSetArchetype</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The archetype of a container class for storing sets of digital points within some given domain.  <a href="classDGtal_1_1CDigitalSetArchetype.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html">DigitalSetBySTLSet</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A container class for storing sets of digital points within some given domain.  <a href="classDGtal_1_1DigitalSetBySTLSet.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSetBySTLVector.html">DigitalSetBySTLVector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Realizes the concept <a class="el" href="structDGtal_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">CDigitalSet</a> by using the STL container std::vector.  <a href="classDGtal_1_1DigitalSetBySTLVector.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DigitalSetConverter.html">DigitalSetConverter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Utility class to convert between types of sets.  <a href="structDGtal_1_1DigitalSetConverter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSetDomain.html">DigitalSetDomain</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Constructs a domain limited to the given digital set.  <a href="classDGtal_1_1DigitalSetDomain.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DigitalSetSelector.html">DigitalSetSelector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Automatically defines an adequate digital set type according to the hints given by the user.  <a href="structDGtal_1_1DigitalSetSelector.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DigitalSetSelector_3_01Domain_00_01SMALL__DS_09LOW__VAR__DS_09LOW__ITER__DS_09LOW__BEL__DS_01_4.html">DigitalSetSelector&lt; Domain, SMALL_DS+LOW_VAR_DS+LOW_ITER_DS+LOW_BEL_DS &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DigitalSetSelector_3_01Domain_00_01SMALL__DS_09LOW__VAR__DS_09HIGH__ITER__DS_09LOW__BEL__DS_01_4.html">DigitalSetSelector&lt; Domain, SMALL_DS+LOW_VAR_DS+HIGH_ITER_DS+LOW_BEL_DS &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SetPredicate.html">SetPredicate</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returning true iff the point is in the domain given at construction.  <a href="structDGtal_1_1SetPredicate.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SpaceND.html">SpaceND</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: <a class="el" href="classDGtal_1_1SpaceND.html" title="Aim: SpaceND is a utility class that defines the fundamental structure of a Digital Space in ND...">SpaceND</a> is a utility class that defines the fundamental structure of a Digital Space in ND.  <a href="classDGtal_1_1SpaceND.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1AngleComputer.html">AngleComputer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1AngleLinearMinimizer.html">AngleLinearMinimizer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Used to minimize the angle variation between different angles while taking into accounts min and max constraints. Example (.  <a href="classDGtal_1_1AngleLinearMinimizer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1AngleLinearMinimizerByRelaxation.html">AngleLinearMinimizerByRelaxation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1AngleLinearMinimizerByGradientDescent.html">AngleLinearMinimizerByGradientDescent</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1AngleLinearMinimizerByAdaptiveStepGradientDescent.html">AngleLinearMinimizerByAdaptiveStepGradientDescent</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ModuloComputer.html">ModuloComputer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">implements basic functions on modular arithmetic.  <a href="classDGtal_1_1ModuloComputer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MeasureOfStraightLines.html">MeasureOfStraightLines</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The aim of this class is to compute the measure in the Lebesgues sense of the set of straight lines associated to domains defined as polygons in the (a,b)-parameter space. This parameter space maps the line $ax-y+b=0$ to the point $(a,b)$.  <a href="classDGtal_1_1MeasureOfStraightLines.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SignalData.html">SignalData</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Signal.html">Signal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a discrete signal, periodic or not. The signal can be passed by value since it is only cloned when modified.  <a href="classDGtal_1_1Signal.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CShape.html">CShape</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitBall.html">ImplicitBall</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of CImplicitShape concept to create a ball in nD..  <a href="classDGtal_1_1ImplicitBall.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitHyperCube.html">ImplicitHyperCube</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of CImplicitShape concept to create an hypercube in nD..  <a href="classDGtal_1_1ImplicitHyperCube.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitNorm1Ball.html">ImplicitNorm1Ball</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of CImplicitShape concept to create a ball for the L_1 norm in nD..  <a href="classDGtal_1_1ImplicitNorm1Ball.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitRoundedHyperCube.html">ImplicitRoundedHyperCube</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of CImplicitShape concept to create a rounded hypercube in nD..  <a href="classDGtal_1_1ImplicitRoundedHyperCube.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1AccFlower2D.html">AccFlower2D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept StarShaped represents any accelerated flower in the plane.  <a href="classDGtal_1_1AccFlower2D.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Ball2D.html">Ball2D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept StarShaped represents any circle in the plane.  <a href="classDGtal_1_1Ball2D.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Ellipse2D.html">Ellipse2D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept StarShaped represents any ellipse in the plane.  <a href="classDGtal_1_1Ellipse2D.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Flower2D.html">Flower2D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept StarShaped represents any flower with k-petals in the plane.  <a href="classDGtal_1_1Flower2D.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1NGon2D.html">NGon2D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept StarShaped represents any regular k-gon in the plane.  <a href="classDGtal_1_1NGon2D.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1StarShaped2D.html">StarShaped2D</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Shapes.html">Shapes</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A utility class for constructing different shapes (balls, diamonds, and others).  <a href="classDGtal_1_1Shapes.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CAdjacency.html">CAdjacency</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The concept <a class="el" href="structDGtal_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">CAdjacency</a> defines an elementary adjacency relation between points of a digital space.  <a href="structDGtal_1_1CAdjacency.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDigitalSurface.html">CDigitalSurface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDomainAdjacency.html">CDomainAdjacency</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Refines the concept <a class="el" href="structDGtal_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">CAdjacency</a> by telling that the adjacency is specific to a given domain of the embedding digital space.  <a href="structDGtal_1_1CDomainAdjacency.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalTopology.html">DigitalTopology</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a digital topology as a couple of adjacency relations.  <a href="classDGtal_1_1DigitalTopology.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DomainAdjacency.html">DomainAdjacency</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Given a domain and an adjacency, limits the given adjacency to the specified domain for all adjacency and neighborhood computations.  <a href="classDGtal_1_1DomainAdjacency.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Expander.html">Expander</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is useful to visit an object by adjacencies, layer by layer.  <a href="classDGtal_1_1Expander.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A utility class for constructing surfaces (i.e. set of (n-1)-cells).  <a href="classDGtal_1_1Surfaces.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1KhalimskyCell.html">KhalimskyCell</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an (unsigned) cell in a cellular grid space by its Khalimsky coordinates.  <a href="structDGtal_1_1KhalimskyCell.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SignedKhalimskyCell.html">SignedKhalimskyCell</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a signed cell in a cellular grid space by its Khalimsky coordinates and a boolean value.  <a href="structDGtal_1_1SignedKhalimskyCell.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CellDirectionIterator.html">CellDirectionIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1KhalimskySpaceND.html">KhalimskySpaceND</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex, whose cells are defined as an array of integers. The topology of the cells is defined by the parity of the coordinates (even: closed, odd: open).  <a href="classDGtal_1_1KhalimskySpaceND.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MetricAdjacency.html">MetricAdjacency</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Describes digital adjacencies in digital spaces that are defined with the 1-norm and the infinity-norm.  <a href="classDGtal_1_1MetricAdjacency.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MetricAdjacency_3_01TSpace_00_012_00_012_01_4.html">MetricAdjacency&lt; TSpace, 2, 2 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MetricAdjacency_3_01TSpace_00_011_00_012_01_4.html">MetricAdjacency&lt; TSpace, 1, 2 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Object.html">Object</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: An object (or digital object) represents a set in some digital space associated with a digital topology.  <a href="classDGtal_1_1Object.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawObjectAdjacencies.html">DrawObjectAdjacencies</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent adjacencies between surfel elements, telling if it follows an interior to exterior ordering or exterior to interior ordering. It allows tracking of boundaries and of surfaces.  <a href="classDGtal_1_1SurfelAdjacency.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This helper class is useful to compute the neighboring surfels of a given surfel, especially over a digital surface or over an object boundary. Two signed surfels are incident if they share a common n-2 cell. This class uses a <a class="el" href="classDGtal_1_1SurfelAdjacency.html" title="Aim: Represent adjacencies between surfel elements, telling if it follows an interior to exterior ord...">SurfelAdjacency</a> so as to determine adjacent surfels (either looking for them from interior to exterior or inversely).  <a href="classDGtal_1_1SurfelNeighborhood.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::function0&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a40f198468aea6d0121b11cd49e599e92">BoolFunction0</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::function1&lt; bool, <br class="typebreak"/>
bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9a92f37472d9010932be3fe6d28f94cb">BoolFunction1</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::function2&lt; bool, <br class="typebreak"/>
bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::function3&lt; bool, <br class="typebreak"/>
bool, bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1bbf050f10f3c666dc5e170e893d8e57">BoolFunction3</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3f01c0f785c605d021be8e328180f502">uint8_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a30f912c6a9d587320495d627df2719ba">uint16_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e">uint32_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5">uint64_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac28d51e0b1672afa52b3c218a32a6a01">int8_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac62de8348789e05494b7515c6525baa0">int16_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac1e9ac6a329319ae13c51c0c9e92486a">int32_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63">int64_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e">DGtal::uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854dda">ImageIterability</a> { <a class="el" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854ddaafe7ef4e4a753d22facbda2b8298062af">HIGH_ITER_I</a> =  0, 
<a class="el" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854ddaa66f45381ecc834daac482ee3493a79f7">LOW_ITER_I</a> =  1
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6a">ImageBelongTestability</a> { <a class="el" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6aa3417447f6aa436ccbf37e0c359adac12">HIGH_BEL_I</a> =  0, 
<a class="el" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6aa5bb4ca524cc66ff98e8b4ad4b4138630">LOW_BEL_I</a> =  2
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7">ImageSpecificContainer</a> { <a class="el" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7a0a9f2a6126427332825d75e775f59388">NORMAL_CONTAINER_I</a> =  0, 
<a class="el" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7ad4deed74c04fa5f801b7c2638d536c1d">VTKIMAGEDATA_CONTAINER_I</a> =  4
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3">DomainDrawMode</a> { <a class="el" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3a6cfb206d9d6225066329a79e83db654e">GRID</a> =  0, 
<a class="el" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3ad788351651a8e983ca1b5b30861ad8ba">PAVING</a> =  1
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2">ColorGradientPreset</a> { <br/>
&#160;&#160;<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a97a652eb81107a63d65d0d091f48e320">CMAP_CUSTOM</a> =  0, 
<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a03f20e9e057e38ce03220e2a43b1a366">CMAP_GRAYSCALE</a>, 
<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2ad222787b0de6a7d74f0e403da496266c">CMAP_SPRING</a>, 
<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2aa5b0ef9d5b1e2e496ac149d9a42dd3e7">CMAP_SUMMER</a>, 
<br/>
&#160;&#160;<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a3ff3c09197871bad3bb5921e30223533">CMAP_AUTUMN</a>, 
<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2acd0da059abca1decd6b75ecc6d131be7">CMAP_WINTER</a>, 
<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a40d9e19d8fbedda0f45c0673c6c6dcbf">CMAP_COOL</a>, 
<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a2b8eab305f63590e49a6dab0b628ae33">CMAP_COPPER</a>, 
<br/>
&#160;&#160;<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a075659185495ce61ea5b09ab439e2abe">CMAP_HOT</a>, 
<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2ac677c31e4299bc29c4e591063b4fc9bb">CMAP_JET</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31">BoundEnum</a> { <a class="el" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31a4b4e195031215bcfc63b5bf65c1c1035">BOUNDED</a> =  0, 
<a class="el" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31a1906bfa4ce33f3c129b1e974826f686d">UNBOUNDED</a> =  1, 
<a class="el" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31aec51247a223f33a421840eb3cbd5598e">BOUND_UNKNOWN</a> =  2
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86db">SignEnum</a> { <a class="el" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dbae3e0717ad611faed845dd64931b1f99c">SIGNED</a> =  0, 
<a class="el" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dba4e5cd9a9d62617341034f3f1c0f79b32">UNSIGNED</a> =  1, 
<a class="el" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dba23888a413fb400a53deeb0b0e17d3100">SIGN_UNKNOWN</a> =  2
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4">DigitalSetSize</a> { <a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4acf48b00343e26a7f40a1fdbbc7af4d70">SMALL_DS</a> =  0, 
<a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4a0df10d7a38d07b6795da39a66cbe97cc">MEDIUM_DS</a> =  1, 
<a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4a37af4f429983b8069af58a2334f776a0">BIG_DS</a> =  2, 
<a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4ac6f14eff3712732f6fa6d608f11e79fe">WHOLE_DS</a> =  3
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426a">DigitalSetVariability</a> { <a class="el" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426aa453acc6bba092ef2476618fad08d47f3">LOW_VAR_DS</a> =  0, 
<a class="el" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426aabef0d75c93891808eaa54c78aa08484a">HIGH_VAR_DS</a> =  4
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccc">DigitalSetIterability</a> { <a class="el" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccca73f1c02534747463a70f05e94ad50b3d">LOW_ITER_DS</a> =  0, 
<a class="el" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccca0f85b8033e1532f5c4a0ff3d59a187bc">HIGH_ITER_DS</a> =  8
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513a">DigitalSetBelongTestability</a> { <a class="el" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513aac54bafeace89b71100756e99a7ef368e">LOW_BEL_DS</a> =  0, 
<a class="el" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513aadcca3a30244180b4238a80ae3a06e01d">HIGH_BEL_DS</a> =  16
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083d">DigitalTopologyProperties</a> { <a class="el" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083dabce62ac78855e24784c74bdd7d8e4e88">UNKNOWN_DT</a> =  0, 
<a class="el" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083da76d2c48b4a35a0dcb5ca4e6cf2462ff0">NOT_JORDAN_DT</a> =  1, 
<a class="el" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083da731ee8276af4e05e2fe322cf2a4fd179">JORDAN_DT</a> =  2
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4fb46fd8e66b190839b2fcaf6e32ed92">isEmpty</a> (const IC &amp;itb, const IC &amp;ite)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac12ee193a856476ce759a147a29d0703">isNotEmpty</a> (const IC &amp;itb, const IC &amp;ite)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac4d5198d8a044649b47cf6ccecf43549">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Clock.html">Clock</a> &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TModifier &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1ConstIteratorAdapter.html">ConstIteratorAdapter</a><br class="typebreak"/>
&lt; TIterator, TModifier &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9d7eb379ac0e530438eeae86106b623e">operator+</a> (typename iterator_traits&lt; TIterator &gt;::difference_type d, <a class="el" href="classDGtal_1_1ConstIteratorAdapter.html">ConstIteratorAdapter</a>&lt; TIterator, TModifier &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a32e9d703ca58b80d140a0713632cbda4">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1CountedPtr.html">CountedPtr</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae48f4d094a9375288d99c2ca0c9e6165">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1CowPtr.html">CowPtr</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5bf1970623d249f257d90c2f0005e4cd">min</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9c89fcba2bbb0b612b7b78346fa27809">max</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab168656deabe25707afc0e15f79d7bef">abs</a> (const T &amp;a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a32d01b810419a09cc24a2e4fa05c66e6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1OrderedAlphabet.html">OrderedAlphabet</a> &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename RealNumberType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a351b036f5289769b5538eb91b68f4031">operator&lt;&lt;</a> (std::ostream &amp;thatStream, const <a class="el" href="classDGtal_1_1Statistic.html">Statistic</a>&lt; RealNumberType &gt; &amp;that_object_to_display)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae5cfe3192eb33036ed5a6afdce4fa90c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Trace.html">Trace</a> &amp;object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa1a0c72f3ea963c433d33b86d1fba535">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1TraceWriter.html">TraceWriter</a> &amp;object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abb0ae3e476260be1ddbbe6c881738e81">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1TraceWriterFile.html">TraceWriterFile</a> &amp;object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa60540f21dc15c6580824e2e370a7600">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1TraceWriterTerm.html">TraceWriterTerm</a> &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TInteger , int connectivity&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a77e224545933cc2f357fcf95dfac25e0">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TIterator, TInteger, connectivity &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TConstIteratorOnPoints , typename TValue &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7a49e73d156eaef47e93a20520f97e67">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1BinomialConvolver.html">BinomialConvolver</a>&lt; TConstIteratorOnPoints, TValue &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab1e154c5c6b8bf237661f55811b280ce">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1CombinatorialDSS.html">CombinatorialDSS</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a14f71daf482381c86a9e3070e9c9644c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1BLUELocalLengthEstimator.html">BLUELocalLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab45a30fbad9ab649b675f951c75c02a0">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DSSLengthEstimator.html">DSSLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aba020cbf0d508e7cecc26c88e71d2b7b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1FPLengthEstimator.html">FPLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abae347753ffeed62dd198ff01c4bb399">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1L1LengthEstimator.html">L1LengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6448fecf8616da4cdd3f1e1bcde2f8df">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1MLPLengthEstimator.html">MLPLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa29dbf2926d9b269c070197fe1335e3a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1RosenProffittLocalLengthEstimator.html">RosenProffittLocalLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a38abf097f50d029195819d8f23770a33">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1TwoStepLocalLengthEstimator.html">TwoStepLocalLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TInteger , int connectivity&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4b85b590fdca0a2dbba91481b7cda794">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1FP.html">FP</a>&lt; TIterator, TInteger, connectivity &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TInteger &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a692c3dfd29a20f6461bd2014295980d6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a>&lt; TInteger &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SegmentComputer &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aaa1f6a42800cc6f4798ac838736790aa">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GreedySegmentation.html">GreedySegmentation</a>&lt; SegmentComputer &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TKSpace &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a62b53564776f9ad979781882fd1c3bf6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GridCurve.html">GridCurve</a>&lt; TKSpace &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TSurface , bool isUpward, bool isClosed&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a609eff5e615033ac1984199d099023d6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Point2ShapePredicate.html">Point2ShapePredicate</a>&lt; TSurface, isUpward, isClosed &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Shape &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab41e56e6538db4bd6d84a583d05aa0dc">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Preimage2D.html">Preimage2D</a>&lt; Shape &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SegmentComputer &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0be4c956dced55d1a11a088881e3ad16">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1SaturatedSegmentation.html">SaturatedSegmentation</a>&lt; SegmentComputer &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">IC&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aae23d0701354b50d02d8a1a838af37ba">getMiddleIterator</a> (const IC &amp;itb, const IC &amp;ite, <a class="el" href="structDGtal_1_1RandomAccessCategory.html">RandomAccessCategory</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">IC&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6d2e6dc5f5906a029e4cdcfea0cef388">getMiddleIterator</a> (const IC &amp;itb, const IC &amp;ite, <a class="el" href="structDGtal_1_1BidirectionalCategory.html">BidirectionalCategory</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">IC&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a629e810899293e8776233307cfcd4fd4">getMiddleIterator</a> (const IC &amp;itb, const IC &amp;ite, <a class="el" href="structDGtal_1_1ForwardCategory.html">ForwardCategory</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">IC&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa85af01e0bb8a84cf0a244853cb16405">getMiddleIterator</a> (const IC &amp;itb, const IC &amp;ite)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af9e2ace671869d2b7c960dea548e7af9">maximalExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab170f387bfd8ad0405c30f21776e78c3">maximalExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;, <a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8d4a9eb5dacd301ab14aca826e9efab0">maximalExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;end)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abdbcbec916407d99ff5c770a564f3baa">oppositeEndMaximalExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, <a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a378df6c82574aff83d591a8748b80e1d">oppositeEndMaximalExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, <a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a38f9cc978f49499b1cce5d1d17904816">oppositeEndMaximalExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abe1197deb2db043ed8e1a948ac0447bf">maximalSymmetricExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9ab416c8e82115d6edde02b56ec2cace">maximalSymmetricExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abc9c7d3f87ad11f89eb0cd2eee49f2cc">maximalSymmetricExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a75880af22a02c157a470549f9c5a1ead">maximalRetraction</a> (SC &amp;s, const typename SC::ConstIterator &amp;end)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad401c0603f3ee18ff583b102258537ff">oppositeEndMaximalRetraction</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aea23b71788e20ea640ba4b280f37bc92">longestSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae1d90a4b99049d7b1e66bdd9251a464d">longestSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4e65fa8b4a581f24f52882ba3c65ce50">longestSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;end)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa10d5f86389592cbfd2bc538fd163177">firstMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2b302c8637285cfd8e15f1d7b0c012c6">firstMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a59251c9a4ec9b9da486e455ff1bd7496">firstMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad346dfdbf80b0522393cc96b5e87e503">firstMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5d5cfff59977ac68881b4f45bb8f7034">firstMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#acd44c719e6035c904cf14e5c9a4a4db6">mostCenteredMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a903f274dc68a3bb5c8435d2437f4a64c">mostCenteredMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af0153f233ab99e77197909650aa7acb3">mostCenteredMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1daeba1ea4003b32d882b27def321055">mostCenteredMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9e96e844bcf7269d0b5c820ae46163a9">mostCenteredMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7f49157673c4175be11111f1aec05283">lastMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae1214921abff6fd7753fd0498e641d16">lastMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5653f0e9a836b7f243d53bb51f0f4593">lastMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a35a4bf24f32ecf8d3253ed987e337ce6">lastMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a50d8d6b6db6f9a9d227fcee15eaa133e">lastMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8d5018746e6e7bd8eadbd086be35a1c5">nextMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a57278384cb2be6e5869e51ed53ccdd97">nextMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4dd7c7c4013b58d494840f55f9c1fd46">nextMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a43d98d6affef7feefd6eaabd25fa08ed">nextMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a94679efff9a03cb733cf9c08ca9eaa89">nextMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;end)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac35b312417d30f4a3c2b16bef0e2c924">previousMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4510773e68134d8cebc17d5d869275c2">previousMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0661af0aaa51ac8fe9691ef97d66ea23">previousMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a461a01d471e9b8ab99e1bbd2675179f2">previousMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afa601b209cbe7f7453c63f9ae801edf0">previousMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TInteger &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7ce9095af66805bee2c7a9e284ae0a7c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1StraightLine.html">StraightLine</a>&lt; TInteger &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TInteger , int connectivity&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aaae6ac82eda677f9a3fd33f34d201a1a">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="classDGtal_1_1ArithmeticalDSS3d.html">ArithmeticalDSS3d</a>&lt; TIterator, TInteger, connectivity &gt; &amp;object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3e210a0da2db0fe767f88859a7ec00ba">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ContourHelper.html">ContourHelper</a> &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a67a58bdea57f0223d380e5c20692fa77">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Measure.html">Measure</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TSpace , typename TEuclideanShape &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af807f7f242709d2a971623a7f7335bc2">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GaussDigitizer.html">GaussDigitizer</a>&lt; TSpace, TEuclideanShape &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename TV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae1f371b56b8e5bb0f3812b6eccab11f9">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1experimental_1_1ImageContainerByITKImage.html">experimental::ImageContainerByITKImage</a>&lt; T, TV &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TDomain , typename TValue &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a501422a3c732e50eec64ef075d5d9703">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1experimental_1_1ImageContainerByITKImage.html">experimental::ImageContainerByITKImage</a>&lt; TDomain, TValue &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Domain , typename V &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a57651a313ad22dfe73ac8f319fcc514f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>&lt; Domain, V &gt; &amp;object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac3c6d87ade0e0da551f72c4e645771e1">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Board2D.html">Board2D</a> &amp;object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa32e43bdffbdc24f45de94ad9102978a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Board3DTo2D.html">Board3DTo2D</a> &amp;object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abb59a7087b1ca526c94078e5cc499672">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Color.html">Color</a> &amp;aColor)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PValue , int PDefaultColor&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#adfd9d0e6b6af2cf02812c497eceda17f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ColorBrightnessColorMap.html">ColorBrightnessColorMap</a>&lt; PValue, PDefaultColor &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PValue , int PDefaultPreset, int PDefaultFirstColor, int PDefaultLastColor&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae680f57b0ef71c1747973693a606845a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GradientColorMap.html">GradientColorMap</a>&lt; PValue, PDefaultPreset, PDefaultFirstColor, PDefaultLastColor &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PValue &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afc551689f30561a9d7be61ff12aa43ac">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GrayscaleColorMap.html">GrayscaleColorMap</a>&lt; PValue &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PValue , int DefaultCycles&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afc56aaa7bdc45b5b34c66a04841c4684">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1HueShadeColorMap.html">HueShadeColorMap</a>&lt; PValue, DefaultCycles &gt; &amp;object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0862dd8a38f8e16ed9bc34ad6ba2bc55">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1RandomColorMap.html">RandomColorMap</a> &amp;object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7b632be90297f1d6a81a58c1a0a4bdc3">cross</a> (double dst[3], double srcA[3], double srcB[3])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5953d43d65a342438b932b5fac6a0334">normalize</a> (double vec[3])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab58d2ea12ddf3ceb1b0d9fef20ae6875">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Display3D.html">Display3D</a> &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aec7be58fdbe4ff85a343cd2f1982bfa2">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DGtalInventor.html">DGtalInventor</a>&lt; TSpace &gt; &amp;object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#adbf9270f5f724d5e51d1356f3372783c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1IVViewer.html">IVViewer</a> &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a331bfa49e24a620921033079171d72b1">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Lattice.html">Lattice</a>&lt; TSpace &gt; &amp;object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac2a53895055b003622553da7cb636570">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a> &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae58b0d1dec58726723db23aa84a06bdb">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1HyperRectDomain.html">HyperRectDomain</a>&lt; TSpace &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename Container &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::bitset&lt; dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7a8a1f84da3e6a36b8089ae35c4125d0">setDimensionsIn</a> (const Container &amp;dimensions)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename Container &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::bitset&lt; dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a86e2ce57d34daf05049b1701aadbdab3">setDimensionsNotIn</a> (const Container &amp;dimensions)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename Component &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aacee1ffcfe75b25c14c2d3962ffe08ca">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; dim, Component &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Domain &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aaa78c16ab34385ecc35b1da67da693fb">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html">DigitalSetBySTLSet</a>&lt; Domain &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Domain &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a23142ad65da7c1f1bbc180c9417a0a9e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSetBySTLVector.html">DigitalSetBySTLVector</a>&lt; Domain &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aee2b7e1960351e49d925fb7a241aa892">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSetDomain.html">DigitalSetDomain</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1110460d51a1259c4fd360616c67e72a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1AngleLinearMinimizer.html">AngleLinearMinimizer</a> &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a51f23a1fe0b52ef3d5d8d0475d631a71">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ModuloComputer.html">ModuloComputer</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0c685b28cb1a025847d30274b28d0edd">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1MeasureOfStraightLines.html">MeasureOfStraightLines</a> &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TValue &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a22c496ec3cf202f1e2befbedb3254351">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Signal.html">Signal</a>&lt; TValue &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7a27da9cd185ae063d9a8bd77d70510a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitBall.html">ImplicitBall</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aeb9eff1676e395814be1efb1837eb5ba">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitHyperCube.html">ImplicitHyperCube</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab94d08e6ed6283cea5cf72d51316d329">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitNorm1Ball.html">ImplicitNorm1Ball</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abc47262779fe4c5a69fcea8354861ed4">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitRoundedHyperCube.html">ImplicitRoundedHyperCube</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5031410a071126043e1dee8afa405aa3">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1AccFlower2D.html">AccFlower2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abc5badd1a31cea58669461e54fb2e9cd">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Ball2D.html">Ball2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afd145e5bc5d37eeff4c4d983435c044d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Ellipse2D.html">Ellipse2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af4182e2d0d2b32617fe41632540b2828">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Flower2D.html">Flower2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#acd57220d9ba6549d53cd047448ec433b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1NGon2D.html">NGon2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad704eebb68f8627370551d327e8fe8b5">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1StarShaped2D.html">StarShaped2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TDomain &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aecc3405305cc1cc6d60be331cf84010e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Shapes.html">Shapes</a>&lt; TDomain &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TForegroundAdjacency , typename TBackgroundAdjacency &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2bbe9e883045906c9749d7f5274ff271">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalTopology.html">DigitalTopology</a>&lt; TForegroundAdjacency, TBackgroundAdjacency &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TDomain , typename TAdjacency &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a02149fb142666f65cc606e265a715373">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DomainAdjacency.html">DomainAdjacency</a>&lt; TDomain, TAdjacency &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4101846412f2ebb4d267f74b0eb62bbc">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Expander.html">Expander</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TKSpace &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7a6f99a0d051afc09431083976c42d98">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a>&lt; TKSpace &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename TInteger &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a66f899fb94343dd458f3cf071ab5062c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1KhalimskyCell.html">KhalimskyCell</a>&lt; dim, TInteger &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename TInteger &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a83e62453a3f79b94019e2626feff5b4f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1SignedKhalimskyCell.html">SignedKhalimskyCell</a>&lt; dim, TInteger &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename TInteger &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab4eff7ee02d8f7b17ad3d2e00d25c0d1">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1KhalimskySpaceND.html">KhalimskySpaceND</a>&lt; dim, TInteger &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TSpace , Dimension maxNorm1&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa963a8f3bce2c1ebd26f685ca9bc3f0d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1MetricAdjacency.html">MetricAdjacency</a>&lt; TSpace, maxNorm1, TSpace::dimension &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TDigitalTopology , typename TDigitalSet &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aae2aad28cbae6a58095d02ff3fa5fbc6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Object.html">Object</a>&lt; TDigitalTopology, TDigitalSet &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;Dimension dim&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a89c001da11ad7d8fec9a5bbc30fd3f87">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; dim &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9412fbec2409ca09fc2abba8b53501c2">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood</a>&lt; T &gt; &amp;object)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">It also possible to remove the <br class="typebreak"/>
visualisation of the <br class="typebreak"/>
transparent clipping plane by <br class="typebreak"/>
adding boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7df3f0545c8e59b83394c60601c122e3">option</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">It also possible to remove the <br class="typebreak"/>
visualisation of the <br class="typebreak"/>
transparent clipping plane by <br class="typebreak"/>
adding boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3c1454fe50af31341c890919f93b76b6">false</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a40f198468aea6d0121b11cd49e599e92">BoolFunction0</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aad0fa31bef8d6552db900af1809d787d">trueBF0</a> = <a class="el" href="structDGtal_1_1TrueBoolFct0.html">TrueBoolFct0</a>()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a40f198468aea6d0121b11cd49e599e92">BoolFunction0</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8c0dbf38da6779899ca99fc25ec8b0be">falseBF0</a> = <a class="el" href="structDGtal_1_1FalseBoolFct0.html">FalseBoolFct0</a>()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a9a92f37472d9010932be3fe6d28f94cb">BoolFunction1</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a154eac21029f20806b646b025b6d59a0">identityBF1</a> = <a class="el" href="structDGtal_1_1IdentityBoolFct1.html">IdentityBoolFct1</a>()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a9a92f37472d9010932be3fe6d28f94cb">BoolFunction1</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a31614f15cda0ab53c57cf414e48c149f">notBF1</a> = <a class="el" href="structDGtal_1_1NotBoolFct1.html">NotBoolFct1</a>()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a70c28100eb4618dbb59a4080cbdf383b">andBF2</a> = <a class="el" href="structDGtal_1_1AndBoolFct2.html">AndBoolFct2</a>()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a14f119bf8a5eb80a58870ebbd33bfb07">orBF2</a> = <a class="el" href="structDGtal_1_1OrBoolFct2.html">OrBoolFct2</a>()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a29281e7462720aa5d454fa2355baa0f3">xorBF2</a> = <a class="el" href="structDGtal_1_1XorBoolFct2.html">XorBoolFct2</a>()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af22fdd40c268d4270906236e3ce234cb">impliesBF2</a> = <a class="el" href="structDGtal_1_1ImpliesBoolFct2.html">ImpliesBoolFct2</a>()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1TraceWriterTerm.html">TraceWriterTerm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae801de7ee4d22c47257dc7e00e0c5dd7">traceWriterTerm</a> (std::cerr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1Trace.html">Trace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a> (<a class="el" href="namespaceDGtal.html#ae801de7ee4d22c47257dc7e00e0c5dd7">traceWriterTerm</a>)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><code><a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a></code> is the top-level namespace which contains all <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> functions and types. </p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this program. If not, see &lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Jacques-Olivier Lachaud (<code><a href="mailto:jacques-olivier.lachaud@univ-savoie.fr">jacques-olivier.lachaud@univ-savoie.fr</a></code> ) Laboratory of Mathematics (CNRS, UMR 5807), University of Savoie, France</dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2011/09/19</dd></dl>
<p>Documentation file for feature Geometric</p>
<p>This file is part of the <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> library.</p>
<p><a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> Global variables </p>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a40f198468aea6d0121b11cd49e599e92"></a><!-- doxytag: member="DGtal::BoolFunction0" ref="a40f198468aea6d0121b11cd49e599e92" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function0&lt; bool &gt; <a class="el" href="namespaceDGtal.html#a40f198468aea6d0121b11cd49e599e92">DGtal::BoolFunction0</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>May hold bool functions taking no arguments. </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00053">53</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9a92f37472d9010932be3fe6d28f94cb"></a><!-- doxytag: member="DGtal::BoolFunction1" ref="a9a92f37472d9010932be3fe6d28f94cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function1&lt; bool, bool &gt; <a class="el" href="namespaceDGtal.html#a9a92f37472d9010932be3fe6d28f94cb">DGtal::BoolFunction1</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>May hold bool functions taking one bool argument. </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00058">58</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7d57d4419aa9656ae4be838f903b5dd2"></a><!-- doxytag: member="DGtal::BoolFunction2" ref="a7d57d4419aa9656ae4be838f903b5dd2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function2&lt; bool, bool, bool &gt; <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">DGtal::BoolFunction2</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>May hold bool functions taking two bool arguments. </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00063">63</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1bbf050f10f3c666dc5e170e893d8e57"></a><!-- doxytag: member="DGtal::BoolFunction3" ref="a1bbf050f10f3c666dc5e170e893d8e57" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function3&lt; bool, bool, bool, bool &gt; <a class="el" href="namespaceDGtal.html#a1bbf050f10f3c666dc5e170e893d8e57">DGtal::BoolFunction3</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>May hold bool functions taking three bool arguments (Useful ?). </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00068">68</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8fbe8c8d47ca5c36ced14284ac62613d"></a><!-- doxytag: member="DGtal::Dimension" ref="a8fbe8c8d47ca5c36ced14284ac62613d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e">DGtal::uint32_t</a> <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">DGtal::Dimension</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Global static type to represent the dimension in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> </p>

<p>Definition at line <a class="el" href="Common_8h_source.html#l00095">95</a> of file <a class="el" href="Common_8h_source.html">Common.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac62de8348789e05494b7515c6525baa0"></a><!-- doxytag: member="DGtal::int16_t" ref="ac62de8348789e05494b7515c6525baa0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::int16_t <a class="el" href="namespaceDGtal.html#ac62de8348789e05494b7515c6525baa0">DGtal::int16_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>signed 16-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00071">71</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac1e9ac6a329319ae13c51c0c9e92486a"></a><!-- doxytag: member="DGtal::int32_t" ref="ac1e9ac6a329319ae13c51c0c9e92486a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::int32_t <a class="el" href="namespaceDGtal.html#ac1e9ac6a329319ae13c51c0c9e92486a">DGtal::int32_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>signed 32-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00073">73</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1c09e3f63904ff371f1b99f45069fc63"></a><!-- doxytag: member="DGtal::int64_t" ref="a1c09e3f63904ff371f1b99f45069fc63" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::int64_t <a class="el" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63">DGtal::int64_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>signed 94-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00075">75</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac28d51e0b1672afa52b3c218a32a6a01"></a><!-- doxytag: member="DGtal::int8_t" ref="ac28d51e0b1672afa52b3c218a32a6a01" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::int8_t <a class="el" href="namespaceDGtal.html#ac28d51e0b1672afa52b3c218a32a6a01">DGtal::int8_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>signed 8-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00069">69</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="a30f912c6a9d587320495d627df2719ba"></a><!-- doxytag: member="DGtal::uint16_t" ref="a30f912c6a9d587320495d627df2719ba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::uint16_t <a class="el" href="namespaceDGtal.html#a30f912c6a9d587320495d627df2719ba">DGtal::uint16_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>unsigned 16-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00062">62</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="a27c59126488e9c545120667959d2fc4e"></a><!-- doxytag: member="DGtal::uint32_t" ref="a27c59126488e9c545120667959d2fc4e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::uint32_t <a class="el" href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e">DGtal::uint32_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>unsigned 32-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00064">64</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab33c0c25b8cc3cd86de343bca34329f5"></a><!-- doxytag: member="DGtal::uint64_t" ref="ab33c0c25b8cc3cd86de343bca34329f5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::uint64_t <a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5">DGtal::uint64_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>unsigned 64-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00066">66</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3f01c0f785c605d021be8e328180f502"></a><!-- doxytag: member="DGtal::uint8_t" ref="a3f01c0f785c605d021be8e328180f502" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::uint8_t <a class="el" href="namespaceDGtal.html#a3f01c0f785c605d021be8e328180f502">DGtal::uint8_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>unsigned 8-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00060">60</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a65228f031a436d2f4edd698ae733ba31"></a><!-- doxytag: member="DGtal::BoundEnum" ref="a65228f031a436d2f4edd698ae733ba31" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31">DGtal::BoundEnum</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a65228f031a436d2f4edd698ae733ba31a4b4e195031215bcfc63b5bf65c1c1035"></a><!-- doxytag: member="BOUNDED" ref="a65228f031a436d2f4edd698ae733ba31a4b4e195031215bcfc63b5bf65c1c1035" args="" -->BOUNDED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a65228f031a436d2f4edd698ae733ba31a1906bfa4ce33f3c129b1e974826f686d"></a><!-- doxytag: member="UNBOUNDED" ref="a65228f031a436d2f4edd698ae733ba31a1906bfa4ce33f3c129b1e974826f686d" args="" -->UNBOUNDED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a65228f031a436d2f4edd698ae733ba31aec51247a223f33a421840eb3cbd5598e"></a><!-- doxytag: member="BOUND_UNKNOWN" ref="a65228f031a436d2f4edd698ae733ba31aec51247a223f33a421840eb3cbd5598e" args="" -->BOUND_UNKNOWN</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="NumberTraits_8h_source.html#l00055">55</a> of file <a class="el" href="NumberTraits_8h_source.html">NumberTraits.h</a>.</p>
<div class="fragment"><pre class="fragment">{<a class="code" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31a4b4e195031215bcfc63b5bf65c1c1035">BOUNDED</a> = 0, <a class="code" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31a1906bfa4ce33f3c129b1e974826f686d">UNBOUNDED</a> = 1, <a class="code" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31aec51247a223f33a421840eb3cbd5598e">BOUND_UNKNOWN</a> = 2};
</pre></div>
</div>
</div>
<a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2"></a><!-- doxytag: member="DGtal::ColorGradientPreset" ref="aa68309838cffd86a3c671c44ef129cb2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2">DGtal::ColorGradientPreset</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2a97a652eb81107a63d65d0d091f48e320"></a><!-- doxytag: member="CMAP_CUSTOM" ref="aa68309838cffd86a3c671c44ef129cb2a97a652eb81107a63d65d0d091f48e320" args="" -->CMAP_CUSTOM</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2a03f20e9e057e38ce03220e2a43b1a366"></a><!-- doxytag: member="CMAP_GRAYSCALE" ref="aa68309838cffd86a3c671c44ef129cb2a03f20e9e057e38ce03220e2a43b1a366" args="" -->CMAP_GRAYSCALE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2ad222787b0de6a7d74f0e403da496266c"></a><!-- doxytag: member="CMAP_SPRING" ref="aa68309838cffd86a3c671c44ef129cb2ad222787b0de6a7d74f0e403da496266c" args="" -->CMAP_SPRING</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2aa5b0ef9d5b1e2e496ac149d9a42dd3e7"></a><!-- doxytag: member="CMAP_SUMMER" ref="aa68309838cffd86a3c671c44ef129cb2aa5b0ef9d5b1e2e496ac149d9a42dd3e7" args="" -->CMAP_SUMMER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2a3ff3c09197871bad3bb5921e30223533"></a><!-- doxytag: member="CMAP_AUTUMN" ref="aa68309838cffd86a3c671c44ef129cb2a3ff3c09197871bad3bb5921e30223533" args="" -->CMAP_AUTUMN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2acd0da059abca1decd6b75ecc6d131be7"></a><!-- doxytag: member="CMAP_WINTER" ref="aa68309838cffd86a3c671c44ef129cb2acd0da059abca1decd6b75ecc6d131be7" args="" -->CMAP_WINTER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2a40d9e19d8fbedda0f45c0673c6c6dcbf"></a><!-- doxytag: member="CMAP_COOL" ref="aa68309838cffd86a3c671c44ef129cb2a40d9e19d8fbedda0f45c0673c6c6dcbf" args="" -->CMAP_COOL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2a2b8eab305f63590e49a6dab0b628ae33"></a><!-- doxytag: member="CMAP_COPPER" ref="aa68309838cffd86a3c671c44ef129cb2a2b8eab305f63590e49a6dab0b628ae33" args="" -->CMAP_COPPER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2a075659185495ce61ea5b09ab439e2abe"></a><!-- doxytag: member="CMAP_HOT" ref="aa68309838cffd86a3c671c44ef129cb2a075659185495ce61ea5b09ab439e2abe" args="" -->CMAP_HOT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2ac677c31e4299bc29c4e591063b4fc9bb"></a><!-- doxytag: member="CMAP_JET" ref="aa68309838cffd86a3c671c44ef129cb2ac677c31e4299bc29c4e591063b4fc9bb" args="" -->CMAP_JET</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="GradientColorMap_8h_source.html#l00060">60</a> of file <a class="el" href="GradientColorMap_8h_source.html">GradientColorMap.h</a>.</p>
<div class="fragment"><pre class="fragment">                           { <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a97a652eb81107a63d65d0d091f48e320">CMAP_CUSTOM</a> = 0,
           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a03f20e9e057e38ce03220e2a43b1a366">CMAP_GRAYSCALE</a>,
           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2ad222787b0de6a7d74f0e403da496266c">CMAP_SPRING</a>,
           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2aa5b0ef9d5b1e2e496ac149d9a42dd3e7">CMAP_SUMMER</a>,
           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a3ff3c09197871bad3bb5921e30223533">CMAP_AUTUMN</a>,
           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2acd0da059abca1decd6b75ecc6d131be7">CMAP_WINTER</a>,
           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a40d9e19d8fbedda0f45c0673c6c6dcbf">CMAP_COOL</a>,
           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a2b8eab305f63590e49a6dab0b628ae33">CMAP_COPPER</a>,
           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a075659185495ce61ea5b09ab439e2abe">CMAP_HOT</a>,
           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2ac677c31e4299bc29c4e591063b4fc9bb">CMAP_JET</a> };
</pre></div>
</div>
</div>
<a class="anchor" id="a0f37e197740e9d7742426109610c513a"></a><!-- doxytag: member="DGtal::DigitalSetBelongTestability" ref="a0f37e197740e9d7742426109610c513a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513a">DGtal::DigitalSetBelongTestability</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a0f37e197740e9d7742426109610c513aac54bafeace89b71100756e99a7ef368e"></a><!-- doxytag: member="LOW_BEL_DS" ref="a0f37e197740e9d7742426109610c513aac54bafeace89b71100756e99a7ef368e" args="" -->LOW_BEL_DS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0f37e197740e9d7742426109610c513aadcca3a30244180b4238a80ae3a06e01d"></a><!-- doxytag: member="HIGH_BEL_DS" ref="a0f37e197740e9d7742426109610c513aadcca3a30244180b4238a80ae3a06e01d" args="" -->HIGH_BEL_DS</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="DigitalSetSelector_8h_source.html#l00060">60</a> of file <a class="el" href="DigitalSetSelector_8h_source.html">DigitalSetSelector.h</a>.</p>
<div class="fragment"><pre class="fragment">{ <a class="code" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513aac54bafeace89b71100756e99a7ef368e">LOW_BEL_DS</a> = 0, <a class="code" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513aadcca3a30244180b4238a80ae3a06e01d">HIGH_BEL_DS</a> = 16 };
</pre></div>
</div>
</div>
<a class="anchor" id="abae5017e6f3a3d5e0c4debd8142e8ccc"></a><!-- doxytag: member="DGtal::DigitalSetIterability" ref="abae5017e6f3a3d5e0c4debd8142e8ccc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccc">DGtal::DigitalSetIterability</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="abae5017e6f3a3d5e0c4debd8142e8ccca73f1c02534747463a70f05e94ad50b3d"></a><!-- doxytag: member="LOW_ITER_DS" ref="abae5017e6f3a3d5e0c4debd8142e8ccca73f1c02534747463a70f05e94ad50b3d" args="" -->LOW_ITER_DS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="abae5017e6f3a3d5e0c4debd8142e8ccca0f85b8033e1532f5c4a0ff3d59a187bc"></a><!-- doxytag: member="HIGH_ITER_DS" ref="abae5017e6f3a3d5e0c4debd8142e8ccca0f85b8033e1532f5c4a0ff3d59a187bc" args="" -->HIGH_ITER_DS</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="DigitalSetSelector_8h_source.html#l00059">59</a> of file <a class="el" href="DigitalSetSelector_8h_source.html">DigitalSetSelector.h</a>.</p>
<div class="fragment"><pre class="fragment">{ <a class="code" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccca73f1c02534747463a70f05e94ad50b3d">LOW_ITER_DS</a> = 0, <a class="code" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccca0f85b8033e1532f5c4a0ff3d59a187bc">HIGH_ITER_DS</a> = 8 };
</pre></div>
</div>
</div>
<a class="anchor" id="a07a2f5d6c861cd13dd680ea2e64e2dd4"></a><!-- doxytag: member="DGtal::DigitalSetSize" ref="a07a2f5d6c861cd13dd680ea2e64e2dd4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4">DGtal::DigitalSetSize</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a07a2f5d6c861cd13dd680ea2e64e2dd4acf48b00343e26a7f40a1fdbbc7af4d70"></a><!-- doxytag: member="SMALL_DS" ref="a07a2f5d6c861cd13dd680ea2e64e2dd4acf48b00343e26a7f40a1fdbbc7af4d70" args="" -->SMALL_DS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a07a2f5d6c861cd13dd680ea2e64e2dd4a0df10d7a38d07b6795da39a66cbe97cc"></a><!-- doxytag: member="MEDIUM_DS" ref="a07a2f5d6c861cd13dd680ea2e64e2dd4a0df10d7a38d07b6795da39a66cbe97cc" args="" -->MEDIUM_DS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a07a2f5d6c861cd13dd680ea2e64e2dd4a37af4f429983b8069af58a2334f776a0"></a><!-- doxytag: member="BIG_DS" ref="a07a2f5d6c861cd13dd680ea2e64e2dd4a37af4f429983b8069af58a2334f776a0" args="" -->BIG_DS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a07a2f5d6c861cd13dd680ea2e64e2dd4ac6f14eff3712732f6fa6d608f11e79fe"></a><!-- doxytag: member="WHOLE_DS" ref="a07a2f5d6c861cd13dd680ea2e64e2dd4ac6f14eff3712732f6fa6d608f11e79fe" args="" -->WHOLE_DS</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="DigitalSetSelector_8h_source.html#l00057">57</a> of file <a class="el" href="DigitalSetSelector_8h_source.html">DigitalSetSelector.h</a>.</p>
<div class="fragment"><pre class="fragment">{ <a class="code" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4acf48b00343e26a7f40a1fdbbc7af4d70">SMALL_DS</a> = 0, <a class="code" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4a0df10d7a38d07b6795da39a66cbe97cc">MEDIUM_DS</a> = 1, <a class="code" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4a37af4f429983b8069af58a2334f776a0">BIG_DS</a> = 2, <a class="code" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4ac6f14eff3712732f6fa6d608f11e79fe">WHOLE_DS</a> = 3 };
</pre></div>
</div>
</div>
<a class="anchor" id="ae37267b68e31ee8f7531488f7e88426a"></a><!-- doxytag: member="DGtal::DigitalSetVariability" ref="ae37267b68e31ee8f7531488f7e88426a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426a">DGtal::DigitalSetVariability</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ae37267b68e31ee8f7531488f7e88426aa453acc6bba092ef2476618fad08d47f3"></a><!-- doxytag: member="LOW_VAR_DS" ref="ae37267b68e31ee8f7531488f7e88426aa453acc6bba092ef2476618fad08d47f3" args="" -->LOW_VAR_DS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae37267b68e31ee8f7531488f7e88426aabef0d75c93891808eaa54c78aa08484a"></a><!-- doxytag: member="HIGH_VAR_DS" ref="ae37267b68e31ee8f7531488f7e88426aabef0d75c93891808eaa54c78aa08484a" args="" -->HIGH_VAR_DS</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="DigitalSetSelector_8h_source.html#l00058">58</a> of file <a class="el" href="DigitalSetSelector_8h_source.html">DigitalSetSelector.h</a>.</p>
<div class="fragment"><pre class="fragment">{ <a class="code" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426aa453acc6bba092ef2476618fad08d47f3">LOW_VAR_DS</a> = 0, <a class="code" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426aabef0d75c93891808eaa54c78aa08484a">HIGH_VAR_DS</a> = 4 };
</pre></div>
</div>
</div>
<a class="anchor" id="a9f57dcd68d3056024eec6b4205f7083d"></a><!-- doxytag: member="DGtal::DigitalTopologyProperties" ref="a9f57dcd68d3056024eec6b4205f7083d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083d">DGtal::DigitalTopologyProperties</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Possible properties of digital topologies. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a9f57dcd68d3056024eec6b4205f7083dabce62ac78855e24784c74bdd7d8e4e88"></a><!-- doxytag: member="UNKNOWN_DT" ref="a9f57dcd68d3056024eec6b4205f7083dabce62ac78855e24784c74bdd7d8e4e88" args="" -->UNKNOWN_DT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9f57dcd68d3056024eec6b4205f7083da76d2c48b4a35a0dcb5ca4e6cf2462ff0"></a><!-- doxytag: member="NOT_JORDAN_DT" ref="a9f57dcd68d3056024eec6b4205f7083da76d2c48b4a35a0dcb5ca4e6cf2462ff0" args="" -->NOT_JORDAN_DT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9f57dcd68d3056024eec6b4205f7083da731ee8276af4e05e2fe322cf2a4fd179"></a><!-- doxytag: member="JORDAN_DT" ref="a9f57dcd68d3056024eec6b4205f7083da731ee8276af4e05e2fe322cf2a4fd179" args="" -->JORDAN_DT</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="DigitalTopology_8h_source.html#l00054">54</a> of file <a class="el" href="DigitalTopology_8h_source.html">DigitalTopology.h</a>.</p>
<div class="fragment"><pre class="fragment">                                 { <a class="code" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083dabce62ac78855e24784c74bdd7d8e4e88">UNKNOWN_DT</a> = 0, 
           <a class="code" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083da76d2c48b4a35a0dcb5ca4e6cf2462ff0">NOT_JORDAN_DT</a> = 1,
           <a class="code" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083da731ee8276af4e05e2fe322cf2a4fd179">JORDAN_DT</a> = 2 };
</pre></div>
</div>
</div>
<a class="anchor" id="a2526218ffac7b4842d393facbedd9ee3"></a><!-- doxytag: member="DGtal::DomainDrawMode" ref="a2526218ffac7b4842d393facbedd9ee3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3">DGtal::DomainDrawMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specifies the drawing mode for domains. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a2526218ffac7b4842d393facbedd9ee3a6cfb206d9d6225066329a79e83db654e"></a><!-- doxytag: member="GRID" ref="a2526218ffac7b4842d393facbedd9ee3a6cfb206d9d6225066329a79e83db654e" args="" -->GRID</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a2526218ffac7b4842d393facbedd9ee3ad788351651a8e983ca1b5b30861ad8ba"></a><!-- doxytag: member="PAVING" ref="a2526218ffac7b4842d393facbedd9ee3ad788351651a8e983ca1b5b30861ad8ba" args="" -->PAVING</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="Board2D_8h_source.html#l00056">56</a> of file <a class="el" href="Board2D_8h_source.html">Board2D.h</a>.</p>
<div class="fragment"><pre class="fragment">{ <a class="code" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3a6cfb206d9d6225066329a79e83db654e">GRID</a> = 0, <a class="code" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3ad788351651a8e983ca1b5b30861ad8ba">PAVING</a> = 1 };
</pre></div>
</div>
</div>
<a class="anchor" id="afbda75b83fdb9094d0e38931838c8d6a"></a><!-- doxytag: member="DGtal::ImageBelongTestability" ref="afbda75b83fdb9094d0e38931838c8d6a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6a">DGtal::ImageBelongTestability</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="afbda75b83fdb9094d0e38931838c8d6aa3417447f6aa436ccbf37e0c359adac12"></a><!-- doxytag: member="HIGH_BEL_I" ref="afbda75b83fdb9094d0e38931838c8d6aa3417447f6aa436ccbf37e0c359adac12" args="" -->HIGH_BEL_I</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afbda75b83fdb9094d0e38931838c8d6aa5bb4ca524cc66ff98e8b4ad4b4138630"></a><!-- doxytag: member="LOW_BEL_I" ref="afbda75b83fdb9094d0e38931838c8d6aa5bb4ca524cc66ff98e8b4ad4b4138630" args="" -->LOW_BEL_I</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="ImageSelector_8h_source.html#l00054">54</a> of file <a class="el" href="ImageSelector_8h_source.html">ImageSelector.h</a>.</p>
<div class="fragment"><pre class="fragment">{  <a class="code" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6aa3417447f6aa436ccbf37e0c359adac12">HIGH_BEL_I</a> = 0, <a class="code" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6aa5bb4ca524cc66ff98e8b4ad4b4138630">LOW_BEL_I</a> = 2 };
</pre></div>
</div>
</div>
<a class="anchor" id="a7f3384cac6dea91b4d46cc1421854dda"></a><!-- doxytag: member="DGtal::ImageIterability" ref="a7f3384cac6dea91b4d46cc1421854dda" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854dda">DGtal::ImageIterability</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a7f3384cac6dea91b4d46cc1421854ddaafe7ef4e4a753d22facbda2b8298062af"></a><!-- doxytag: member="HIGH_ITER_I" ref="a7f3384cac6dea91b4d46cc1421854ddaafe7ef4e4a753d22facbda2b8298062af" args="" -->HIGH_ITER_I</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a7f3384cac6dea91b4d46cc1421854ddaa66f45381ecc834daac482ee3493a79f7"></a><!-- doxytag: member="LOW_ITER_I" ref="a7f3384cac6dea91b4d46cc1421854ddaa66f45381ecc834daac482ee3493a79f7" args="" -->LOW_ITER_I</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="ImageSelector_8h_source.html#l00053">53</a> of file <a class="el" href="ImageSelector_8h_source.html">ImageSelector.h</a>.</p>
<div class="fragment"><pre class="fragment">{  <a class="code" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854ddaafe7ef4e4a753d22facbda2b8298062af">HIGH_ITER_I</a> = 0 , <a class="code" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854ddaa66f45381ecc834daac482ee3493a79f7">LOW_ITER_I</a> = 1};
</pre></div>
</div>
</div>
<a class="anchor" id="a0a142484d2c7efc3d29f5bbde3b449b7"></a><!-- doxytag: member="DGtal::ImageSpecificContainer" ref="a0a142484d2c7efc3d29f5bbde3b449b7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7">DGtal::ImageSpecificContainer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a0a142484d2c7efc3d29f5bbde3b449b7a0a9f2a6126427332825d75e775f59388"></a><!-- doxytag: member="NORMAL_CONTAINER_I" ref="a0a142484d2c7efc3d29f5bbde3b449b7a0a9f2a6126427332825d75e775f59388" args="" -->NORMAL_CONTAINER_I</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0a142484d2c7efc3d29f5bbde3b449b7ad4deed74c04fa5f801b7c2638d536c1d"></a><!-- doxytag: member="VTKIMAGEDATA_CONTAINER_I" ref="a0a142484d2c7efc3d29f5bbde3b449b7ad4deed74c04fa5f801b7c2638d536c1d" args="" -->VTKIMAGEDATA_CONTAINER_I</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="ImageSelector_8h_source.html#l00055">55</a> of file <a class="el" href="ImageSelector_8h_source.html">ImageSelector.h</a>.</p>
<div class="fragment"><pre class="fragment">{ <a class="code" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7a0a9f2a6126427332825d75e775f59388">NORMAL_CONTAINER_I</a> = 0, <a class="code" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7ad4deed74c04fa5f801b7c2638d536c1d">VTKIMAGEDATA_CONTAINER_I</a> = 4 };
</pre></div>
</div>
</div>
<a class="anchor" id="a679e16b34aad98ff340decf89d1c86db"></a><!-- doxytag: member="DGtal::SignEnum" ref="a679e16b34aad98ff340decf89d1c86db" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86db">DGtal::SignEnum</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a679e16b34aad98ff340decf89d1c86dbae3e0717ad611faed845dd64931b1f99c"></a><!-- doxytag: member="SIGNED" ref="a679e16b34aad98ff340decf89d1c86dbae3e0717ad611faed845dd64931b1f99c" args="" -->SIGNED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a679e16b34aad98ff340decf89d1c86dba4e5cd9a9d62617341034f3f1c0f79b32"></a><!-- doxytag: member="UNSIGNED" ref="a679e16b34aad98ff340decf89d1c86dba4e5cd9a9d62617341034f3f1c0f79b32" args="" -->UNSIGNED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a679e16b34aad98ff340decf89d1c86dba23888a413fb400a53deeb0b0e17d3100"></a><!-- doxytag: member="SIGN_UNKNOWN" ref="a679e16b34aad98ff340decf89d1c86dba23888a413fb400a53deeb0b0e17d3100" args="" -->SIGN_UNKNOWN</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="NumberTraits_8h_source.html#l00056">56</a> of file <a class="el" href="NumberTraits_8h_source.html">NumberTraits.h</a>.</p>
<div class="fragment"><pre class="fragment">{<a class="code" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dbae3e0717ad611faed845dd64931b1f99c">SIGNED</a> = 0, <a class="code" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dba4e5cd9a9d62617341034f3f1c0f79b32">UNSIGNED</a> = 1, <a class="code" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dba23888a413fb400a53deeb0b0e17d3100">SIGN_UNKNOWN</a> = 2};
</pre></div>
</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ab168656deabe25707afc0e15f79d7bef"></a><!-- doxytag: member="DGtal::abs" ref="ab168656deabe25707afc0e15f79d7bef" args="(const T &amp;a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T DGtal::abs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the absolute value of an instance of type T.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">T</td><td>the type of elements to compare (model of boost::LessThanComparable). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first value</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the absolute value |a|. </dd></dl>

<p>Definition at line <a class="el" href="GlobalFunctions_8h_source.html#l00105">105</a> of file <a class="el" href="GlobalFunctions_8h_source.html">GlobalFunctions.h</a>.</p>

<p>Referenced by <a class="el" href="Display3D_8ih_source.html#l00556">DGtal::Display3D::addClippingPlane()</a>, <a class="el" href="SeparableMetricTraits_8h_source.html#l00117">DGtal::SeparableMetricTraits&lt; Abscissa, IntegerLong, p &gt;::F()</a>, <a class="el" href="Viewer3D_8cpp_source.html#l00245">DGtal::Viewer3D::postSelection()</a>, <a class="el" href="SeparableMetricTraits_8h_source.html#l00360">DGtal::SeparableMetricTraits&lt; TAbscissa, TInternalValue, 0 &gt;::power()</a>, <a class="el" href="SeparableMetricTraits_8h_source.html#l00303">DGtal::SeparableMetricTraits&lt; TAbscissa, TInternalValue, 1 &gt;::power()</a>, <a class="el" href="SeparableMetricTraits_8h_source.html#l00274">DGtal::SeparableMetricTraits&lt; TAbscissa, TInternalValue, 1 &gt;::reversedF()</a>, and <a class="el" href="SeparableMetricTraits_8h_source.html#l00133">DGtal::SeparableMetricTraits&lt; Abscissa, IntegerLong, p &gt;::reversedF()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    BOOST_CONCEPT_ASSERT((boost::LessThanComparable&lt;T&gt;));
    <span class="keywordflow">if</span> (a&lt;0) 
      <span class="keywordflow">return</span> -a;
    <span class="keywordflow">else</span>
      <span class="keywordflow">return</span> a;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a7b632be90297f1d6a81a58c1a0a4bdc3"></a><!-- doxytag: member="DGtal::cross" ref="a7b632be90297f1d6a81a58c1a0a4bdc3" args="(double dst[3], double srcA[3], double srcB[3])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void DGtal::cross </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dst</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>srcA</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>srcB</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the cross product of two 3d vectors and return it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>destination vector. </td></tr>
    <tr><td class="paramname">srcA</td><td>source vector A. </td></tr>
    <tr><td class="paramname">srcB</td><td>source vector B. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Display3D_8ih_source.html#l00056">56</a> of file <a class="el" href="Display3D_8ih_source.html">Display3D.ih</a>.</p>

<p>Referenced by <a class="el" href="Display3D_8ih_source.html#l00294">DGtal::Display3D::addKSSurfel()</a>.</p>
<div class="fragment"><pre class="fragment">{
  dst[0] = srcA[1]*srcB[2] - srcA[2]*srcB[1];
  dst[1] = srcA[2]*srcB[0] - srcA[0]*srcB[2];
  dst[2] = srcA[0]*srcB[1] - srcA[1]*srcB[0];
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa10d5f86389592cbfd2bc538fd163177"></a><!-- doxytag: member="DGtal::firstMaximalSegment" ref="aa10d5f86389592cbfd2bc538fd163177" args="(SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, DGtal::ForwardSegmentComputer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::firstMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the first maximal segment passing through i </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer, ie. a model of CSegment that can exte...">CForwardSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00403">403</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00352">longestSegment()</a>.</p>

<p>Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00458">firstMaximalSegment()</a>, <a class="el" href="SaturatedSegmentation_8ih_source.html#l00104">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initFirstMaximalSegment()</a>, <a class="el" href="SaturatedSegmentation_8ih_source.html#l00122">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initLastMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00510">mostCenteredMaximalSegment()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00759">nextMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{

  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::ConstIterator ConstIterator; 
  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::Reverse ReverseSegmentComputer; 
  <span class="keyword">typedef</span> <span class="keyword">typename</span> ReverseSegmentComputer::ConstIterator ConstReverseIterator; 

  <span class="keywordflow">if</span> ( isNotEmpty&lt;ConstIterator&gt;(i,end) ) {

    <span class="comment">//backward extension</span>
    ConstIterator it( i ); ++it; 
    ConstReverseIterator rit( it );
    ConstReverseIterator rend( begin );
    ReverseSegmentComputer r( s.getReverse() ); 
    <a class="code" href="namespaceDGtal.html#aea23b71788e20ea640ba4b280f37bc92">longestSegment</a>(r, rit, rend);

    <span class="comment">//forward extension</span>
    ConstIterator it2( r.end().base() );
    <a class="code" href="namespaceDGtal.html#aea23b71788e20ea640ba4b280f37bc92">longestSegment</a>(s, it2, end);

  }

}
</pre></div>
</div>
</div>
<a class="anchor" id="a2b302c8637285cfd8e15f1d7b0c012c6"></a><!-- doxytag: member="DGtal::firstMaximalSegment" ref="a2b302c8637285cfd8e15f1d7b0c012c6" args="(SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, DGtal::BidirectionalSegmentComputer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::firstMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the first maximal segment passing through i </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00438">438</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">maximalExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00197">oppositeEndMaximalExtension()</a>.</p>
<div class="fragment"><pre class="fragment">{
  s.init(i);

  <a class="code" href="namespaceDGtal.html#abdbcbec916407d99ff5c770a564f3baa">oppositeEndMaximalExtension</a>(s, begin);
  <a class="code" href="namespaceDGtal.html#af9e2ace671869d2b7c960dea548e7af9">maximalExtension</a>(s, end);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a59251c9a4ec9b9da486e455ff1bd7496"></a><!-- doxytag: member="DGtal::firstMaximalSegment" ref="a59251c9a4ec9b9da486e455ff1bd7496" args="(SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, DGtal::DynamicSegmentComputer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::firstMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the first maximal segment passing through i </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html" title="Aim: Defines the concept describing a dynamic segment computer, ie. a model of CSegment that can exte...">CDynamicSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">ForwardSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00458">458</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00403">firstMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="namespaceDGtal.html#aa10d5f86389592cbfd2bc538fd163177">firstMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad346dfdbf80b0522393cc96b5e87e503"></a><!-- doxytag: member="DGtal::firstMaximalSegment" ref="ad346dfdbf80b0522393cc96b5e87e503" args="(SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, DGtal::DynamicBidirectionalSegmentComputer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::firstMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the first maximal segment passing through i </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie...">CDynamicBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00475">475</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00403">firstMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="namespaceDGtal.html#aa10d5f86389592cbfd2bc538fd163177">firstMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5d5cfff59977ac68881b4f45bb8f7034"></a><!-- doxytag: member="DGtal::firstMaximalSegment" ref="a5d5cfff59977ac68881b4f45bb8f7034" args="(SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::firstMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the first maximal segment passing through i </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00491">491</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  firstMaximalSegment&lt;SC&gt;(s, i, begin, end, 
<span class="keyword">typename</span> <a class="code" href="structDGtal_1_1SegmentComputerTraits.html#aec543e23f154c340dd52511204ed977f">DGtal::SegmentComputerTraits&lt;SC&gt;::Category</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6d2e6dc5f5906a029e4cdcfea0cef388"></a><!-- doxytag: member="DGtal::getMiddleIterator" ref="a6d2e6dc5f5906a029e4cdcfea0cef388" args="(const IC &amp;itb, const IC &amp;ite, BidirectionalCategory)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IC DGtal::getMiddleIterator </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalCategory&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialization for bidirectional category NB: in O(ite-itb) </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00100">100</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  IC b( itb ); 
  IC f( ite ); 
  <span class="keywordtype">bool</span> flag = <span class="keyword">true</span>; 
  <span class="keywordflow">while</span> (b != f) {
    <span class="keywordflow">if</span> (flag) {
      --f;
      flag = <span class="keyword">false</span>; 
    } <span class="keywordflow">else</span> {
      ++b; 
      flag = <span class="keyword">true</span>; 
    } 
  }
  <span class="keywordflow">return</span> b;   
}
</pre></div>
</div>
</div>
<a class="anchor" id="a629e810899293e8776233307cfcd4fd4"></a><!-- doxytag: member="DGtal::getMiddleIterator" ref="a629e810899293e8776233307cfcd4fd4" args="(const IC &amp;itb, const IC &amp;ite, ForwardCategory)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IC DGtal::getMiddleIterator </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardCategory&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialization for forward category NB: in O(ite-itb) </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00122">122</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  IC i( itb ); 

  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; 
  <span class="keywordflow">while</span> (i != ite) {
    ++i; 
    ++c;
  } 
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = c/2;

  c = 0; 
  i = itb; 
  <span class="keywordflow">while</span> (c != k) {
    ++i; 
    ++c;
  } 

  <span class="keywordflow">return</span> i;   
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa85af01e0bb8a84cf0a244853cb16405"></a><!-- doxytag: member="DGtal::getMiddleIterator" ref="aa85af01e0bb8a84cf0a244853cb16405" args="(const IC &amp;itb, const IC &amp;ite)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IC DGtal::getMiddleIterator </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the middle iterator of a given range, i.e. itb + (ite-itb)/2) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">itb,ite,begin</td><td>and end iterators of a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the middle iterator of the range [itb,ite) </dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">any</td><td>iterator or circulator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00150">150</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00087">getMiddleIterator()</a>.</p>
<div class="fragment"><pre class="fragment">                                                   {
  <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorCirculatorTraits&lt;IC&gt;::Category Category; 
  <span class="keywordflow">return</span> <a class="code" href="namespaceDGtal.html#aae23d0701354b50d02d8a1a838af37ba">getMiddleIterator</a>(itb, ite, Category() ); 
} 
</pre></div>
</div>
</div>
<a class="anchor" id="aae23d0701354b50d02d8a1a838af37ba"></a><!-- doxytag: member="DGtal::getMiddleIterator" ref="aae23d0701354b50d02d8a1a838af37ba" args="(const IC &amp;itb, const IC &amp;ite, RandomAccessCategory)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IC DGtal::getMiddleIterator </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessCategory&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialization for random access category </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00087">87</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00150">getMiddleIterator()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00510">mostCenteredMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">//how to compute this with circulators ?</span>
<span class="comment">//return itb + ((ite-itb)/2);  </span>
<span class="comment">//does not work  </span>
  <span class="keywordflow">return</span> <a class="code" href="namespaceDGtal.html#aae23d0701354b50d02d8a1a838af37ba">getMiddleIterator</a>(itb, ite, BidirectionalCategory() ); 
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4fb46fd8e66b190839b2fcaf6e32ed92"></a><!-- doxytag: member="DGtal::isEmpty" ref="a4fb46fd8e66b190839b2fcaf6e32ed92" args="(const IC &amp;itb, const IC &amp;ite)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::isEmpty </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Circulator_8h_source.html#l00560">560</a> of file <a class="el" href="Circulator_8h_source.html">Circulator.h</a>.</p>
<div class="fragment"><pre class="fragment">                                            {
  <span class="keywordflow">return</span> detail::isEmpty&lt;IC&gt;( itb, ite, <span class="keyword">typename</span> IteratorCirculatorTraits&lt;IC&gt;::Type() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac12ee193a856476ce759a147a29d0703"></a><!-- doxytag: member="DGtal::isNotEmpty" ref="ac12ee193a856476ce759a147a29d0703" args="(const IC &amp;itb, const IC &amp;ite)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::isNotEmpty </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Circulator_8h_source.html#l00566">566</a> of file <a class="el" href="Circulator_8h_source.html">Circulator.h</a>.</p>

<p>Referenced by <a class="el" href="SaturatedSegmentation_8ih_source.html#l00122">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initLastMaximalSegment()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00566">mostCenteredMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">                                               {
  <span class="keywordflow">return</span> detail::isNotEmpty&lt;IC&gt;( itb, ite, <span class="keyword">typename</span> IteratorCirculatorTraits&lt;IC&gt;::Type() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a35a4bf24f32ecf8d3253ed987e337ce6"></a><!-- doxytag: member="DGtal::lastMaximalSegment" ref="a35a4bf24f32ecf8d3253ed987e337ce6" args="(SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, DGtal::DynamicBidirectionalSegmentComputer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::lastMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the last maximal segment passing through i </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie...">CDynamicBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00723">723</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00652">lastMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="namespaceDGtal.html#a7f49157673c4175be11111f1aec05283">lastMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a50d8d6b6db6f9a9d227fcee15eaa133e"></a><!-- doxytag: member="DGtal::lastMaximalSegment" ref="a50d8d6b6db6f9a9d227fcee15eaa133e" args="(SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::lastMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the last maximal segment passing through i </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00739">739</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><pre class="fragment">{
   lastMaximalSegment&lt;SC&gt;(s, i, begin, end, 
<span class="keyword">typename</span> <a class="code" href="structDGtal_1_1SegmentComputerTraits.html#aec543e23f154c340dd52511204ed977f">DGtal::SegmentComputerTraits&lt;SC&gt;::Category</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7f49157673c4175be11111f1aec05283"></a><!-- doxytag: member="DGtal::lastMaximalSegment" ref="a7f49157673c4175be11111f1aec05283" args="(SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, DGtal::ForwardSegmentComputer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::lastMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the last maximal segment passing through i </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer, ie. a model of CSegment that can exte...">CForwardSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00652">652</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00352">longestSegment()</a>.</p>

<p>Referenced by <a class="el" href="SaturatedSegmentation_8ih_source.html#l00104">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initFirstMaximalSegment()</a>, <a class="el" href="SaturatedSegmentation_8ih_source.html#l00122">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initLastMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00706">lastMaximalSegment()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00852">previousMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{

  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::ConstIterator ConstIterator; 
  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::Reverse ReverseSegmentComputer; 
  <span class="keyword">typedef</span> <span class="keyword">typename</span> ReverseSegmentComputer::ConstIterator ConstReverseIterator; 

  <span class="comment">//forward extension</span>
  ConstIterator j( i );
  <a class="code" href="namespaceDGtal.html#aea23b71788e20ea640ba4b280f37bc92">longestSegment</a>(s, j, end);

  <span class="comment">//backward extension</span>
  ConstIterator it( s.end() );
  ConstReverseIterator rit( it );
  ConstReverseIterator rend( begin );
  ReverseSegmentComputer r( s.getReverse() ); 
  <a class="code" href="namespaceDGtal.html#aea23b71788e20ea640ba4b280f37bc92">longestSegment</a>(r, rit, rend);

  <span class="comment">//forward extension</span>
  ConstIterator it2( r.end().base() );
  <a class="code" href="namespaceDGtal.html#aea23b71788e20ea640ba4b280f37bc92">longestSegment</a>(s, it2, end);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae1214921abff6fd7753fd0498e641d16"></a><!-- doxytag: member="DGtal::lastMaximalSegment" ref="ae1214921abff6fd7753fd0498e641d16" args="(SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, BidirectionalSegmentComputer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::lastMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalSegmentComputer&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the last maximal segment passing through i </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00686">686</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">maximalExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00197">oppositeEndMaximalExtension()</a>.</p>
<div class="fragment"><pre class="fragment">{
  s.init(i);

  <a class="code" href="namespaceDGtal.html#af9e2ace671869d2b7c960dea548e7af9">maximalExtension</a>(s, end);
  <a class="code" href="namespaceDGtal.html#abdbcbec916407d99ff5c770a564f3baa">oppositeEndMaximalExtension</a>(s, begin);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5653f0e9a836b7f243d53bb51f0f4593"></a><!-- doxytag: member="DGtal::lastMaximalSegment" ref="a5653f0e9a836b7f243d53bb51f0f4593" args="(SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, DGtal::DynamicSegmentComputer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::lastMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the last maximal segment passing through i </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html" title="Aim: Defines the concept describing a dynamic segment computer, ie. a model of CSegment that can exte...">CDynamicSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">ForwardSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00706">706</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00652">lastMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="namespaceDGtal.html#a7f49157673c4175be11111f1aec05283">lastMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae1d90a4b99049d7b1e66bdd9251a464d"></a><!-- doxytag: member="DGtal::longestSegment" ref="ae1d90a4b99049d7b1e66bdd9251a464d" args="(SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;end, CirculatorType)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::longestSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CirculatorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialization for <a class="el" href="classDGtal_1_1Circulator.html" title="Aim: Provides an adapter for STL iterators that can iterate through the underlying data structure as ...">Circulator</a> type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00367">367</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">maximalExtension()</a>.</p>
<div class="fragment"><pre class="fragment">{
  s.init(i);
  <a class="code" href="namespaceDGtal.html#af9e2ace671869d2b7c960dea548e7af9">maximalExtension</a>(s, end, CirculatorType() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4e65fa8b4a581f24f52882ba3c65ce50"></a><!-- doxytag: member="DGtal::longestSegment" ref="a4e65fa8b4a581f24f52882ba3c65ce50" args="(SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::longestSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the longest possible segment from [i] </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">i,a</td><td>given ConstIterator </td></tr>
    <tr><td class="paramname">end,any</td><td>end ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00384">384</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00352">longestSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorCirculatorTraits&lt;typename SC::ConstIterator&gt;::Type Type; 
  <a class="code" href="namespaceDGtal.html#aea23b71788e20ea640ba4b280f37bc92">longestSegment</a>( s, i, end, Type() ); 
}
</pre></div>
</div>
</div>
<a class="anchor" id="aea23b71788e20ea640ba4b280f37bc92"></a><!-- doxytag: member="DGtal::longestSegment" ref="aea23b71788e20ea640ba4b280f37bc92" args="(SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;end, IteratorType)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::longestSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialization for Iterator type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00352">352</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">maximalExtension()</a>.</p>

<p>Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00403">firstMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00652">lastMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00384">longestSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00510">mostCenteredMaximalSegment()</a>, <a class="el" href="GreedySegmentation_8ih_source.html#l00136">DGtal::GreedySegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::next()</a>, and <a class="el" href="GreedyDecomposition_8ih_source.html#l00262">DGtal::deprecated::GreedyDecomposition&lt; TSegment &gt;::SegmentIterator::next()</a>.</p>
<div class="fragment"><pre class="fragment"> {
  <span class="keywordflow">if</span> (i != end) {
    s.init(i);
    <a class="code" href="namespaceDGtal.html#af9e2ace671869d2b7c960dea548e7af9">maximalExtension</a>(s, end, IteratorType() );
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9c89fcba2bbb0b612b7b78346fa27809"></a><!-- doxytag: member="DGtal::max" ref="a9c89fcba2bbb0b612b7b78346fa27809" args="(const T &amp;a, const T &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T DGtal::max </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the max bewteen to instance of type T.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">T</td><td>the type of elements to compare (model of boost::LessThanComparable and EqualityComparable). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first value </td></tr>
    <tr><td class="paramname">b</td><td>second value</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the maximum between a and b. </dd></dl>

<p>Definition at line <a class="el" href="GlobalFunctions_8h_source.html#l00085">85</a> of file <a class="el" href="GlobalFunctions_8h_source.html">GlobalFunctions.h</a>.</p>

<p>Referenced by <a class="el" href="SeparableMetricTraits_8h_source.html#l00327">DGtal::SeparableMetricTraits&lt; TAbscissa, TInternalValue, 0 &gt;::F()</a>, <a class="el" href="ImageContainerBySTLVector_8ih_source.html#l00041">DGtal::ImageContainerBySTLVector&lt; Domain, Value &gt;::ImageContainerBySTLVector()</a>, <a class="el" href="AngleLinearMinimizer_8cpp_source.html#l00366">DGtal::AngleLinearMinimizerByRelaxation::lastDelta()</a>, <a class="el" href="AngleLinearMinimizer_8cpp_source.html#l00258">DGtal::AngleLinearMinimizer::lastDelta()</a>, <a class="el" href="BasicFunctors_8h_source.html#l00064">DGtal::MaxFunctor&lt; T &gt;::operator()()</a>, <a class="el" href="SeparableMetricTraits_8h_source.html#l00292">DGtal::SeparableMetricTraits&lt; TAbscissa, TInternalValue, 1 &gt;::reversedSep()</a>, <a class="el" href="ColorBrightnessColorMap_8ih_source.html#l00221">DGtal::ColorBrightnessColorMap&lt; PValue, PDefaultColor &gt;::RGBtoHSV()</a>, <a class="el" href="Statistic_8ih_source.html#l00384">DGtal::Statistic&lt; RealNumberType &gt;::selfDisplay()</a>, <a class="el" href="AngleLinearMinimizer_8ih_source.html#l00207">DGtal::AngleLinearMinimizer::selfDraw()</a>, <a class="el" href="SeparableMetricTraits_8h_source.html#l00343">DGtal::SeparableMetricTraits&lt; TAbscissa, TInternalValue, 0 &gt;::Sep()</a>, and <a class="el" href="SeparableMetricTraits_8h_source.html#l00282">DGtal::SeparableMetricTraits&lt; TAbscissa, TInternalValue, 1 &gt;::Sep()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    BOOST_CONCEPT_ASSERT((boost::EqualityComparable&lt;T&gt;));
    BOOST_CONCEPT_ASSERT((boost::LessThanComparable&lt;T&gt;));
    <span class="keywordflow">if</span> (a&gt;=b) 
      <span class="keywordflow">return</span> a;
    <span class="keywordflow">else</span>
      <span class="keywordflow">return</span> b;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="af9e2ace671869d2b7c960dea548e7af9"></a><!-- doxytag: member="DGtal::maximalExtension" ref="af9e2ace671869d2b7c960dea548e7af9" args="(SC &amp;s, const typename SC::ConstIterator &amp;end, IteratorType)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::maximalExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialization for Iterator type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">163</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00438">firstMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00686">lastMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00352">longestSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00187">maximalExtension()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00566">mostCenteredMaximalSegment()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00788">nextMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                 {
  <span class="comment">//stop if s.end() == end</span>
  <span class="keywordflow">while</span> ( (s.end() != end)
       &amp;&amp; (s.extend()) ) {}
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab170f387bfd8ad0405c30f21776e78c3"></a><!-- doxytag: member="DGtal::maximalExtension" ref="ab170f387bfd8ad0405c30f21776e78c3" args="(SC &amp;s, const typename SC::ConstIterator &amp;, CirculatorType)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::maximalExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CirculatorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialization for <a class="el" href="classDGtal_1_1Circulator.html" title="Aim: Provides an adapter for STL iterators that can iterate through the underlying data structure as ...">Circulator</a> type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00173">173</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//stop if the segment is the whole range</span>
  <span class="keyword">const</span> <span class="keyword">typename</span> SC::ConstIterator newEnd( s.begin() ); 
  <span class="keywordflow">while</span> ( (s.extend())
    &amp;&amp; (s.end() != newEnd) ) {}
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8d4a9eb5dacd301ab14aca826e9efab0"></a><!-- doxytag: member="DGtal::maximalExtension" ref="a8d4a9eb5dacd301ab14aca826e9efab0" args="(SC &amp;s, const typename SC::ConstIterator &amp;end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::maximalExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calls s.extend() while possible </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">end</td><td>any ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00187">187</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">maximalExtension()</a>.</p>
<div class="fragment"><pre class="fragment">                                                                  {
  <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorCirculatorTraits&lt;typename SC::ConstIterator&gt;::Type Type; 
  <a class="code" href="namespaceDGtal.html#af9e2ace671869d2b7c960dea548e7af9">maximalExtension</a>( s, end, Type() ); 
}
</pre></div>
</div>
</div>
<a class="anchor" id="a75880af22a02c157a470549f9c5a1ead"></a><!-- doxytag: member="DGtal::maximalRetraction" ref="a75880af22a02c157a470549f9c5a1ead" args="(SC &amp;s, const typename SC::ConstIterator &amp;end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::maximalRetraction </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calls s.retract() while s.isExtendable() returns false </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">end</td><td>any ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00316">316</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00788">nextMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> ( isNotEmpty&lt;typename SC::ConstIterator&gt;(s.end(),end) ) {
    <span class="keywordflow">while</span> ( (! s.isExtendable() ) 
          &amp;&amp;(s.retract() ) )  {}  
  } <span class="keywordflow">else</span> {
    <span class="keywordflow">while</span> ( s.retract() ) {} 
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="abc9c7d3f87ad11f89eb0cd2eee49f2cc"></a><!-- doxytag: member="DGtal::maximalSymmetricExtension" ref="abc9c7d3f87ad11f89eb0cd2eee49f2cc" args="(SC &amp;s, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::maximalSymmetricExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calls alternatively s.extend() and s.extendOppositeEnd() while it is possible </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of (bidirectional)segment computer </td></tr>
    <tr><td class="paramname">begin,end,begin</td><td>and end iterator of a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>'true' if the extension at the front fails first and 'false' if the extension at the back fails first </dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00298">298</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00233">maximalSymmetricExtension()</a>.</p>
<div class="fragment"><pre class="fragment">                                       {

  <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorCirculatorTraits&lt;typename SC::ConstIterator&gt;::Type Type; 
  <span class="keywordflow">return</span> <a class="code" href="namespaceDGtal.html#abe1197deb2db043ed8e1a948ac0447bf">maximalSymmetricExtension</a>( s, begin, end, Type() ); 

}
</pre></div>
</div>
</div>
<a class="anchor" id="abe1197deb2db043ed8e1a948ac0447bf"></a><!-- doxytag: member="DGtal::maximalSymmetricExtension" ref="abe1197deb2db043ed8e1a948ac0447bf" args="(SC &amp;s, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, IteratorType)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::maximalSymmetricExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialization for Iterator type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00233">233</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00298">maximalSymmetricExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00566">mostCenteredMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">                 {

  <span class="keywordtype">bool</span> flagOk = <span class="keyword">true</span>; 
  <span class="keywordtype">bool</span> flagForward = <span class="keyword">true</span>; 
  <span class="comment">//while the extension is possible </span>
  <span class="comment">//at the front and (then) at the back</span>
  <span class="keywordflow">while</span> (flagOk)  {
    <span class="keywordflow">if</span> (flagForward) {
      flagForward = <span class="keyword">false</span>; 
      <span class="keywordflow">if</span> ( s.end() != end ) flagOk = s.extend();
      <span class="keywordflow">else</span> flagOk = <span class="keyword">false</span>; 
    } <span class="keywordflow">else</span> {
      flagForward = <span class="keyword">true</span>; 
      <span class="keywordflow">if</span> ( s.begin() != begin ) flagOk = s.extendOppositeEnd();
      <span class="keywordflow">else</span> flagOk = <span class="keyword">false</span>; 
    } 
  }
  <span class="comment">//extend one more time if s.begin() == begin</span>
  <span class="keywordflow">if</span> (s.begin() != begin ) {
    <span class="keywordflow">if</span> (s.extendOppositeEnd()) <span class="keywordflow">return</span> !s.extend(); 
    <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>; 
  } <span class="keywordflow">else</span> {
    <span class="keywordflow">return</span> !flagForward; 
  }

}
</pre></div>
</div>
</div>
<a class="anchor" id="a9ab416c8e82115d6edde02b56ec2cace"></a><!-- doxytag: member="DGtal::maximalSymmetricExtension" ref="a9ab416c8e82115d6edde02b56ec2cace" args="(SC &amp;s, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, CirculatorType)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::maximalSymmetricExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CirculatorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialization for <a class="el" href="classDGtal_1_1Circulator.html" title="Aim: Provides an adapter for STL iterators that can iterate through the underlying data structure as ...">Circulator</a> type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00267">267</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><pre class="fragment">                   {

  <span class="keywordtype">bool</span> flagOk = <span class="keyword">true</span>; 
  <span class="keywordtype">bool</span> flagForward = <span class="keyword">true</span>; 
  <span class="comment">//while the extensions are possible and</span>
  <span class="comment">//the segment does not correspond to the whole range</span>
  <span class="keywordflow">while</span> ( (flagOk) &amp;&amp; ( s.end() != s.begin() ) )  {
    <span class="keywordflow">if</span> (flagForward) {
      flagForward = <span class="keyword">false</span>; 
      flagOk = s.extend(); 
    } <span class="keywordflow">else</span> {
      flagForward = <span class="keyword">true</span>; 
      flagOk = s.extendOppositeEnd(); 
    } 
  }
  <span class="keywordflow">return</span> !flagForward; 
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5bf1970623d249f257d90c2f0005e4cd"></a><!-- doxytag: member="DGtal::min" ref="a5bf1970623d249f257d90c2f0005e4cd" args="(const T &amp;a, const T &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T DGtal::min </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the min bewteen to instance of type T.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">T</td><td>the type of elements to compare (model of boost::LessThanComparable and EqualityComparable). </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first value </td></tr>
    <tr><td class="paramname">b</td><td>second value</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the minimum between a and b. </dd></dl>

<p>Definition at line <a class="el" href="GlobalFunctions_8h_source.html#l00064">64</a> of file <a class="el" href="GlobalFunctions_8h_source.html">GlobalFunctions.h</a>.</p>

<p>Referenced by <a class="el" href="Bits_8h_source.html#l00084">DGtal::Bits::bitString()</a>, <a class="el" href="CombinatorialDSS_8ih_source.html#l00833">DGtal::CombinatorialDSS&lt; TInteger &gt;::getArithmeticalDescription()</a>, <a class="el" href="GrayScaleColorMap_8ih_source.html#l00133">DGtal::GrayscaleColorMap&lt; PValue &gt;::getColor()</a>, <a class="el" href="ImageContainerBySTLVector_8ih_source.html#l00041">DGtal::ImageContainerBySTLVector&lt; Domain, Value &gt;::ImageContainerBySTLVector()</a>, <a class="el" href="BasicFunctors_8h_source.html#l00056">DGtal::MinFunctor&lt; T &gt;::operator()()</a>, <a class="el" href="SeparableMetricTraits_8h_source.html#l00292">DGtal::SeparableMetricTraits&lt; TAbscissa, TInternalValue, 1 &gt;::reversedSep()</a>, <a class="el" href="ColorBrightnessColorMap_8ih_source.html#l00221">DGtal::ColorBrightnessColorMap&lt; PValue, PDefaultColor &gt;::RGBtoHSV()</a>, <a class="el" href="Statistic_8ih_source.html#l00384">DGtal::Statistic&lt; RealNumberType &gt;::selfDisplay()</a>, <a class="el" href="AngleLinearMinimizer_8ih_source.html#l00207">DGtal::AngleLinearMinimizer::selfDraw()</a>, <a class="el" href="SeparableMetricTraits_8h_source.html#l00343">DGtal::SeparableMetricTraits&lt; TAbscissa, TInternalValue, 0 &gt;::Sep()</a>, and <a class="el" href="SeparableMetricTraits_8h_source.html#l00282">DGtal::SeparableMetricTraits&lt; TAbscissa, TInternalValue, 1 &gt;::Sep()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    BOOST_CONCEPT_ASSERT((boost::EqualityComparable&lt;T&gt;));
    BOOST_CONCEPT_ASSERT((boost::LessThanComparable&lt;T&gt;));
    <span class="keywordflow">if</span> (a&lt;=b) 
      <span class="keywordflow">return</span> a;
    <span class="keywordflow">else</span>
      <span class="keywordflow">return</span> b;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a903f274dc68a3bb5c8435d2437f4a64c"></a><!-- doxytag: member="DGtal::mostCenteredMaximalSegment" ref="a903f274dc68a3bb5c8435d2437f4a64c" args="(SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, DGtal::BidirectionalSegmentComputer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::mostCenteredMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the most centered maximal segment passing through i </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00566">566</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="Circulator_8h_source.html#l00566">isNotEmpty()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">maximalExtension()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00233">maximalSymmetricExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00197">oppositeEndMaximalExtension()</a>.</p>
<div class="fragment"><pre class="fragment">{
  
  <span class="keywordflow">if</span> ( (<a class="code" href="namespaceDGtal_1_1detail.html#a55fd4de42c6dd6a25d3ae1e655cc03ac">isNotEmpty</a>(i,end)) || (<a class="code" href="namespaceDGtal_1_1detail.html#a55fd4de42c6dd6a25d3ae1e655cc03ac">isNotEmpty</a>(i,begin)) ) { 

    s.init(i);

    <span class="comment">//symmetric extension</span>
    <span class="keywordflow">if</span> ( (<a class="code" href="namespaceDGtal_1_1detail.html#a55fd4de42c6dd6a25d3ae1e655cc03ac">isNotEmpty</a>(i,end)) &amp;&amp; (<a class="code" href="namespaceDGtal_1_1detail.html#a55fd4de42c6dd6a25d3ae1e655cc03ac">isNotEmpty</a>(i,begin)) ) { 
      <a class="code" href="namespaceDGtal.html#abe1197deb2db043ed8e1a948ac0447bf">maximalSymmetricExtension</a>(s, begin, end); 
    }

  <span class="comment">//forward extension</span>
  <a class="code" href="namespaceDGtal.html#af9e2ace671869d2b7c960dea548e7af9">maximalExtension</a>(s, end);
      
  <span class="comment">//backward extension</span>
  <a class="code" href="namespaceDGtal.html#abdbcbec916407d99ff5c770a564f3baa">oppositeEndMaximalExtension</a>(s, begin);

  }

}
</pre></div>
</div>
</div>
<a class="anchor" id="af0153f233ab99e77197909650aa7acb3"></a><!-- doxytag: member="DGtal::mostCenteredMaximalSegment" ref="af0153f233ab99e77197909650aa7acb3" args="(SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, DGtal::DynamicSegmentComputer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::mostCenteredMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the most centered maximal segment passing through i </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html" title="Aim: Defines the concept describing a dynamic segment computer, ie. a model of CSegment that can exte...">CDynamicSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">ForwardSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00600">600</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00510">mostCenteredMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="namespaceDGtal.html#acd44c719e6035c904cf14e5c9a4a4db6">mostCenteredMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1daeba1ea4003b32d882b27def321055"></a><!-- doxytag: member="DGtal::mostCenteredMaximalSegment" ref="a1daeba1ea4003b32d882b27def321055" args="(SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, DGtal::DynamicBidirectionalSegmentComputer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::mostCenteredMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the most centered maximal segment passing through i </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie...">CDynamicBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00617">617</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00510">mostCenteredMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="namespaceDGtal.html#acd44c719e6035c904cf14e5c9a4a4db6">mostCenteredMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9e96e844bcf7269d0b5c820ae46163a9"></a><!-- doxytag: member="DGtal::mostCenteredMaximalSegment" ref="a9e96e844bcf7269d0b5c820ae46163a9" args="(SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::mostCenteredMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the most centered maximal segment passing through i </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00633">633</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><pre class="fragment">{
   mostCenteredMaximalSegment&lt;SC&gt;(s, i, begin, end, 
<span class="keyword">typename</span> <a class="code" href="structDGtal_1_1SegmentComputerTraits.html#aec543e23f154c340dd52511204ed977f">DGtal::SegmentComputerTraits&lt;SC&gt;::Category</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="acd44c719e6035c904cf14e5c9a4a4db6"></a><!-- doxytag: member="DGtal::mostCenteredMaximalSegment" ref="acd44c719e6035c904cf14e5c9a4a4db6" args="(SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, DGtal::ForwardSegmentComputer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::mostCenteredMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the most centered maximal segment passing through i </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer, ie. a model of CSegment that can exte...">CForwardSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00510">510</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00403">firstMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00087">getMiddleIterator()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00352">longestSegment()</a>.</p>

<p>Referenced by <a class="el" href="SaturatedSegmentation_8ih_source.html#l00104">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initFirstMaximalSegment()</a>, <a class="el" href="SaturatedSegmentation_8ih_source.html#l00122">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initLastMaximalSegment()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00600">mostCenteredMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{

  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::ConstIterator ConstIterator; 
  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::Reverse ReverseSegmentComputer; 
  <span class="keyword">typedef</span> <span class="keyword">typename</span> ReverseSegmentComputer::ConstIterator ConstReverseIterator; 

 <span class="comment">//get the first maximal segment passing through i</span>

  <a class="code" href="namespaceDGtal.html#aa10d5f86389592cbfd2bc538fd163177">firstMaximalSegment</a>( s, i, begin, end, <a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>() );

 <span class="comment">//get the next maximal segment while i is not at the middle of </span>
 <span class="comment">//the current maximal segment. </span>

  ConstIterator k( s.begin() ); 
  <span class="keywordflow">while</span> ( k != i ) {

    <span class="keywordflow">if</span> ( isNotEmpty&lt;ConstIterator&gt;(s.end(),end) ) {

      <span class="comment">//backward extension</span>
      ConstIterator it( s.end() ); ++it; 
      ConstReverseIterator rit( it );
      ConstReverseIterator rend( s.begin() );
      ReverseSegmentComputer r( s.getReverse() ); 
      <a class="code" href="namespaceDGtal.html#aea23b71788e20ea640ba4b280f37bc92">longestSegment</a>(r, rit, rend);
      ConstIterator newBegin = r.end().base(); 
      ASSERT( newBegin != s.begin() );

      <span class="keywordflow">while</span> ( ( k != <a class="code" href="namespaceDGtal.html#aae23d0701354b50d02d8a1a838af37ba">getMiddleIterator</a>(newBegin, s.end() ) )
            &amp;&amp;( k != i ) ) {
        ++k; 
      }
      <span class="keywordflow">if</span> ( k != i ) {
   
        <span class="comment">//get the next maximal segment</span>
        <a class="code" href="namespaceDGtal.html#aea23b71788e20ea640ba4b280f37bc92">longestSegment</a>(s, newBegin, end);  

      }

    } <span class="keywordflow">else</span> {
      k = i; 
    }
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8d5018746e6e7bd8eadbd086be35a1c5"></a><!-- doxytag: member="DGtal::nextMaximalSegment" ref="a8d5018746e6e7bd8eadbd086be35a1c5" args="(SC &amp;s, const typename SC::ConstIterator &amp;end, DGtal::ForwardSegmentComputer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::nextMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the next maximal segment of s (s is assumed to be maximal) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">end,any</td><td>end ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer, ie. a model of CSegment that can exte...">CForwardSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>fistMaximalSegment of s.end() </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00759">759</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00403">firstMaximalSegment()</a>.</p>

<p>Referenced by <a class="el" href="MaximalSegments_8ih_source.html#l00063">DGtal::deprecated::MaximalSegments&lt; TSegment &gt;::SegmentIterator::firstMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00820">nextMaximalSegment()</a>, <a class="el" href="SaturatedSegmentation_8ih_source.html#l00168">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::nextMaximalSegment()</a>, <a class="el" href="SaturatedSegmentation_8ih_source.html#l00323">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::operator++()</a>, and <a class="el" href="MaximalSegments_8ih_source.html#l00369">DGtal::deprecated::MaximalSegments&lt; TSegment &gt;::SegmentIterator::operator++()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="namespaceDGtal.html#aa10d5f86389592cbfd2bc538fd163177">firstMaximalSegment</a>(s, s.end(), s.begin(), end, ForwardSegmentComputer() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a57278384cb2be6e5869e51ed53ccdd97"></a><!-- doxytag: member="DGtal::nextMaximalSegment" ref="a57278384cb2be6e5869e51ed53ccdd97" args="(SC &amp;s, const typename SC::ConstIterator &amp;end, DGtal::BidirectionalSegmentComputer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::nextMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the next maximal segment of s (s is assumed to be maximal) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">end,end</td><td>ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>fistMaximalSegment of s.end() </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00774">774</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00403">firstMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="namespaceDGtal.html#aa10d5f86389592cbfd2bc538fd163177">firstMaximalSegment</a>(s, s.end(), s.begin(), end, <a class="code" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4dd7c7c4013b58d494840f55f9c1fd46"></a><!-- doxytag: member="DGtal::nextMaximalSegment" ref="a4dd7c7c4013b58d494840f55f9c1fd46" args="(SC &amp;s, const typename SC::ConstIterator &amp;end, DGtal::DynamicSegmentComputer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::nextMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the next maximal segment of s (s is assumed to be maximal) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">end,end</td><td>ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html" title="Aim: Defines the concept describing a dynamic segment computer, ie. a model of CSegment that can exte...">CDynamicSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00788">788</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">maximalExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00316">maximalRetraction()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::ConstIterator ConstIterator; 

  <span class="comment">//rectract</span>
  <a class="code" href="namespaceDGtal.html#a75880af22a02c157a470549f9c5a1ead">maximalRetraction</a>(s, end); 

  <span class="comment">//intersection test</span>
  ConstIterator i( s.begin() ); ++i; 
  <span class="comment">//if the intersection between the two </span>
  <span class="comment">// consecutive maximal segments is empty </span>
  <span class="keywordflow">if</span> ( i == s.end() ) {
    <span class="keywordflow">if</span> ( isNotEmpty&lt;ConstIterator&gt;(i, end) ) {
      ++i; 
      s.init(i);  
    }
  }

  <span class="comment">//extend</span>
  <a class="code" href="namespaceDGtal.html#af9e2ace671869d2b7c960dea548e7af9">maximalExtension</a>(s, end);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a43d98d6affef7feefd6eaabd25fa08ed"></a><!-- doxytag: member="DGtal::nextMaximalSegment" ref="a43d98d6affef7feefd6eaabd25fa08ed" args="(SC &amp;s, const typename SC::ConstIterator &amp;end, DGtal::DynamicBidirectionalSegmentComputer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::nextMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the next maximal segment of s (s is assumed to be maximal) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">end,end</td><td>ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie...">CDynamicBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DynamicSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00820">820</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00759">nextMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{ 
  <a class="code" href="namespaceDGtal.html#a8d5018746e6e7bd8eadbd086be35a1c5">nextMaximalSegment</a>(s, end, <a class="code" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>() ); 
}
</pre></div>
</div>
</div>
<a class="anchor" id="a94679efff9a03cb733cf9c08ca9eaa89"></a><!-- doxytag: member="DGtal::nextMaximalSegment" ref="a94679efff9a03cb733cf9c08ca9eaa89" args="(SC &amp;s, const typename SC::ConstIterator &amp;end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::nextMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the next maximal segment of s (s is assumed to be maximal) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">end,any</td><td>end ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00834">834</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><pre class="fragment">{
   nextMaximalSegment&lt;SC&gt;(s, end, 
<span class="keyword">typename</span> <a class="code" href="structDGtal_1_1SegmentComputerTraits.html#aec543e23f154c340dd52511204ed977f">DGtal::SegmentComputerTraits&lt;SC&gt;::Category</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5953d43d65a342438b932b5fac6a0334"></a><!-- doxytag: member="DGtal::normalize" ref="a5953d43d65a342438b932b5fac6a0334" args="(double vec[3])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void DGtal::normalize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vec</em>[3]</td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Normalize the input 3d vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>source &amp; destination vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Display3D_8ih_source.html#l00069">69</a> of file <a class="el" href="Display3D_8ih_source.html">Display3D.ih</a>.</p>

<p>Referenced by <a class="el" href="Display3D_8ih_source.html#l00294">DGtal::Display3D::addKSSurfel()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">double</span> squaredLen = vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2];
  <span class="keyword">const</span> <span class="keywordtype">double</span> invLen = 1.0 /  sqrt (squaredLen);

  vec[0] *= invLen;
  vec[1] *= invLen;
  vec[2] *= invLen;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9d7eb379ac0e530438eeae86106b623e"></a><!-- doxytag: member="DGtal::operator+" ref="a9d7eb379ac0e530438eeae86106b623e" args="(typename iterator_traits&lt; TIterator &gt;::difference_type d, ConstIteratorAdapter&lt; TIterator, TModifier &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TModifier &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1ConstIteratorAdapter.html">ConstIteratorAdapter</a>&lt;TIterator,TModifier&gt; DGtal::operator+ </td>
          <td>(</td>
          <td class="paramtype">typename iterator_traits&lt; TIterator &gt;::difference_type&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstIteratorAdapter&lt; TIterator, TModifier &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ConstIteratorAdapter_8h_source.html#l00309">309</a> of file <a class="el" href="ConstIteratorAdapter_8h_source.html">ConstIteratorAdapter.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    ConstIteratorAdapter&lt;TIterator,TModifier&gt; tmp = object;
    <span class="keywordflow">return</span> tmp += d;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="afc56aaa7bdc45b5b34c66a04841c4684"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="afc56aaa7bdc45b5b34c66a04841c4684" args="(std::ostream &amp;out, const HueShadeColorMap&lt; PValue, DefaultCycles &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PValue , int DefaultCycles&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HueShadeColorMap&lt; PValue, DefaultCycles &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'HueShadeColorMap'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'HueShadeColorMap' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="afc551689f30561a9d7be61ff12aa43ac"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="afc551689f30561a9d7be61ff12aa43ac" args="(std::ostream &amp;out, const GrayscaleColorMap&lt; PValue &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GrayscaleColorMap&lt; PValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'GrayscaleColorMap'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'GrayscaleColorMap' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="ae680f57b0ef71c1747973693a606845a"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="ae680f57b0ef71c1747973693a606845a" args="(std::ostream &amp;out, const GradientColorMap&lt; PValue, PDefaultPreset, PDefaultFirstColor, PDefaultLastColor &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PValue , int PDefaultPreset, int PDefaultFirstColor, int PDefaultLastColor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GradientColorMap&lt; PValue, PDefaultPreset, PDefaultFirstColor, PDefaultLastColor &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'GradientColorMap'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'GradientColorMap' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="GradientColorMap_8ih_source.html#l00294">294</a> of file <a class="el" href="GradientColorMap_8ih_source.html">GradientColorMap.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="adfd9d0e6b6af2cf02812c497eceda17f"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="adfd9d0e6b6af2cf02812c497eceda17f" args="(std::ostream &amp;out, const ColorBrightnessColorMap&lt; PValue, PDefaultColor &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PValue , int PDefaultColor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColorBrightnessColorMap&lt; PValue, PDefaultColor &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'ColorBrightnessColorMap'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'ColorBrightnessColorMap' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ColorBrightnessColorMap_8ih_source.html#l00163">163</a> of file <a class="el" href="ColorBrightnessColorMap_8ih_source.html">ColorBrightnessColorMap.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abb59a7087b1ca526c94078e5cc499672"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="abb59a7087b1ca526c94078e5cc499672" args="(std::ostream &amp;out, const Color &amp;aColor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Color &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Color'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'Color' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Color_8ih_source.html#l00054">54</a> of file <a class="el" href="Color_8ih_source.html">Color.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa32e43bdffbdc24f45de94ad9102978a"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="aa32e43bdffbdc24f45de94ad9102978a" args="(std::ostream &amp;out, const Board3DTo2D &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Board3DTo2D &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Board3DTo2D'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'Board3DTo2D' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a0862dd8a38f8e16ed9bc34ad6ba2bc55"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a0862dd8a38f8e16ed9bc34ad6ba2bc55" args="(std::ostream &amp;out, const RandomColorMap &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomColorMap &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'RandomColorMap'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'RandomColorMap' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="RandomColorMap_8ih_source.html#l00157">157</a> of file <a class="el" href="RandomColorMap_8ih_source.html">RandomColorMap.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a57651a313ad22dfe73ac8f319fcc514f"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a57651a313ad22dfe73ac8f319fcc514f" args="(std::ostream &amp;out, const ImageContainerBySTLVector&lt; Domain, V &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Domain , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImageContainerBySTLVector&lt; Domain, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Image'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'Image' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImageContainerBySTLVector_8h_source.html#l00526">526</a> of file <a class="el" href="ImageContainerBySTLVector_8h_source.html">ImageContainerBySTLVector.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a6448fecf8616da4cdd3f1e1bcde2f8df"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a6448fecf8616da4cdd3f1e1bcde2f8df" args="(std::ostream &amp;out, const MLPLengthEstimator&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MLPLengthEstimator&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'MLPLengthEstimator'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'MLPLengthEstimator' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="MLPLengthEstimator_8ih_source.html#l00153">153</a> of file <a class="el" href="MLPLengthEstimator_8ih_source.html">MLPLengthEstimator.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae1f371b56b8e5bb0f3812b6eccab11f9"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="ae1f371b56b8e5bb0f3812b6eccab11f9" args="(std::ostream &amp;out, const experimental::ImageContainerByITKImage&lt; T, TV &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const experimental::ImageContainerByITKImage&lt; T, TV &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'ImageContainerByITKImage'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'ImageContainerByITKImage' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="aec7be58fdbe4ff85a343cd2f1982bfa2"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="aec7be58fdbe4ff85a343cd2f1982bfa2" args="(std::ostream &amp;out, const DGtalInventor&lt; TSpace &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DGtalInventor&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'DGtalInventor'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'DGtalInventor' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DGtalInventor_8ih_source.html#l00389">389</a> of file <a class="el" href="DGtalInventor_8ih_source.html">DGtalInventor.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a67a58bdea57f0223d380e5c20692fa77"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a67a58bdea57f0223d380e5c20692fa77" args="(std::ostream &amp;out, const Measure&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Measure&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Measure'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'Measure' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e210a0da2db0fe767f88859a7ec00ba"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a3e210a0da2db0fe767f88859a7ec00ba" args="(std::ostream &amp;out, const ContourHelper &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContourHelper &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'ContourHelper'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'ContourHelper' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ContourHelper_8ih_source.html#l00070">70</a> of file <a class="el" href="ContourHelper_8ih_source.html">ContourHelper.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aaae6ac82eda677f9a3fd33f34d201a1a"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="aaae6ac82eda677f9a3fd33f34d201a1a" args="(std::ostream &amp;out, ArithmeticalDSS3d&lt; TIterator, TInteger, connectivity &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TInteger , int connectivity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArithmeticalDSS3d&lt; TIterator, TInteger, connectivity &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'ArithmeticalDSS3d'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'ArithmeticalDSS3d' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ArithmeticalDSS3d_8h_source.html#l00286">286</a> of file <a class="el" href="ArithmeticalDSS3d_8h_source.html">ArithmeticalDSS3d.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordtype">object</span>.selfDisplay( out);
    <span class="keywordflow">return</span> out;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a7ce9095af66805bee2c7a9e284ae0a7c"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a7ce9095af66805bee2c7a9e284ae0a7c" args="(std::ostream &amp;out, const StraightLine&lt; TInteger &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StraightLine&lt; TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="StraightLine_8h_source.html#l00178">178</a> of file <a class="el" href="StraightLine_8h_source.html">StraightLine.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordtype">object</span>.selfDisplay( out );
    <span class="keywordflow">return</span> out;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a22c496ec3cf202f1e2befbedb3254351"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a22c496ec3cf202f1e2befbedb3254351" args="(std::ostream &amp;out, const Signal&lt; TValue &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Signal&lt; TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Signal'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'Signal' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Signal_8ih_source.html#l00607">607</a> of file <a class="el" href="Signal_8ih_source.html">Signal.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0be4c956dced55d1a11a088881e3ad16"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a0be4c956dced55d1a11a088881e3ad16" args="(std::ostream &amp;out, const SaturatedSegmentation&lt; SegmentComputer &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SegmentComputer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SaturatedSegmentation&lt; SegmentComputer &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'SaturatedSegmentation'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'SaturatedSegmentation' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a02149fb142666f65cc606e265a715373"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a02149fb142666f65cc606e265a715373" args="(std::ostream &amp;out, const DomainAdjacency&lt; TDomain, TAdjacency &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDomain , typename TAdjacency &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DomainAdjacency&lt; TDomain, TAdjacency &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'DomainAdjacency'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'DomainAdjacency' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DomainAdjacency_8ih_source.html#l00179">179</a> of file <a class="el" href="DomainAdjacency_8ih_source.html">DomainAdjacency.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aecc3405305cc1cc6d60be331cf84010e"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="aecc3405305cc1cc6d60be331cf84010e" args="(std::ostream &amp;out, const Shapes&lt; TDomain &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDomain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Shapes&lt; TDomain &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Shapes'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'Shapes' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DGtal_2shapes_2Shapes_8ih_source.html#l00263">263</a> of file <a class="el" href="DGtal_2shapes_2Shapes_8ih_source.html">DGtal/shapes/Shapes.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a77e224545933cc2f357fcf95dfac25e0"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a77e224545933cc2f357fcf95dfac25e0" args="(std::ostream &amp;out, ArithmeticalDSS&lt; TIterator, TInteger, connectivity &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TInteger , int connectivity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArithmeticalDSS&lt; TIterator, TInteger, connectivity &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'ArithmeticalDSS'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'ArithmeticalDSS' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ArithmeticalDSS_8h_source.html#l00848">848</a> of file <a class="el" href="ArithmeticalDSS_8h_source.html">ArithmeticalDSS.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out);
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9412fbec2409ca09fc2abba8b53501c2"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a9412fbec2409ca09fc2abba8b53501c2" args="(std::ostream &amp;out, const SurfelNeighborhood&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SurfelNeighborhood&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'SurfelNeighborhood'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'SurfelNeighborhood' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bbe9e883045906c9749d7f5274ff271"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a2bbe9e883045906c9749d7f5274ff271" args="(std::ostream &amp;out, const DigitalTopology&lt; TForegroundAdjacency, TBackgroundAdjacency &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TForegroundAdjacency , typename TBackgroundAdjacency &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DigitalTopology&lt; TForegroundAdjacency, TBackgroundAdjacency &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'DigitalTopology'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'DigitalTopology' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DigitalTopology_8ih_source.html#l00181">181</a> of file <a class="el" href="DigitalTopology_8ih_source.html">DigitalTopology.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="adbf9270f5f724d5e51d1356f3372783c"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="adbf9270f5f724d5e51d1356f3372783c" args="(std::ostream &amp;out, const IVViewer &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IVViewer &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'IVViewer'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'IVViewer' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="IVViewer_8ih_source.html#l00054">54</a> of file <a class="el" href="IVViewer_8ih_source.html">IVViewer.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a23142ad65da7c1f1bbc180c9417a0a9e"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a23142ad65da7c1f1bbc180c9417a0a9e" args="(std::ostream &amp;out, const DigitalSetBySTLVector&lt; Domain &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DigitalSetBySTLVector&lt; Domain &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'DigitalSetBySTLVector'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'DigitalSetBySTLVector' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DigitalSetBySTLVector_8ih_source.html#l00663">663</a> of file <a class="el" href="DigitalSetBySTLVector_8ih_source.html">DigitalSetBySTLVector.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7a49e73d156eaef47e93a20520f97e67"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a7a49e73d156eaef47e93a20520f97e67" args="(std::ostream &amp;out, const BinomialConvolver&lt; TConstIteratorOnPoints, TValue &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TConstIteratorOnPoints , typename TValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BinomialConvolver&lt; TConstIteratorOnPoints, TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'BinomialConvolver'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'BinomialConvolver' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="BinomialConvolver_8ih_source.html#l00335">335</a> of file <a class="el" href="BinomialConvolver_8ih_source.html">BinomialConvolver.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7a6f99a0d051afc09431083976c42d98"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a7a6f99a0d051afc09431083976c42d98" args="(std::ostream &amp;out, const Surfaces&lt; TKSpace &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Surfaces&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Surfaces'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'Surfaces' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00696">696</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a331bfa49e24a620921033079171d72b1"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a331bfa49e24a620921033079171d72b1" args="(std::ostream &amp;out, const Lattice&lt; TSpace &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Lattice&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Lattice'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'Lattice' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Lattice_8ih_source.html#l00362">362</a> of file <a class="el" href="Lattice_8ih_source.html">Lattice.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a83e62453a3f79b94019e2626feff5b4f"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a83e62453a3f79b94019e2626feff5b4f" args="(std::ostream &amp;out, const SignedKhalimskyCell&lt; dim, TInteger &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SignedKhalimskyCell&lt; dim, TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="KhalimskySpaceND_8ih_source.html#l00393">393</a> of file <a class="el" href="KhalimskySpaceND_8ih_source.html">KhalimskySpaceND.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  out &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; <span class="keywordtype">object</span>.myCoordinates[ 0 ];
  <span class="keywordflow">for</span> ( Dimension i = 1; i &lt; dim; ++i )
    out &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; <span class="keywordtype">object</span>.myCoordinates[ i ];
  out &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; ( <span class="keywordtype">object</span>.myPositive ? <span class="charliteral">&#39;+&#39;</span> : <span class="charliteral">&#39;-&#39;</span> );
  out &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7a27da9cd185ae063d9a8bd77d70510a"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a7a27da9cd185ae063d9a8bd77d70510a" args="(std::ostream &amp;out, const ImplicitBall&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImplicitBall&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'ImplicitBall'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'ImplicitBall' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImplicitBall_8ih_source.html#l00085">85</a> of file <a class="el" href="ImplicitBall_8ih_source.html">ImplicitBall.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa60540f21dc15c6580824e2e370a7600"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="aa60540f21dc15c6580824e2e370a7600" args="(std::ostream &amp;out, const TraceWriterTerm &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TraceWriterTerm &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'TraceWriterTerm'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'TraceWriterTerm' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="ad704eebb68f8627370551d327e8fe8b5"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="ad704eebb68f8627370551d327e8fe8b5" args="(std::ostream &amp;out, const StarShaped2D&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StarShaped2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'StarShaped2D'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'StarShaped2D' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="StarShaped2D_8ih_source.html#l00215">215</a> of file <a class="el" href="StarShaped2D_8ih_source.html">StarShaped2D.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="afd145e5bc5d37eeff4c4d983435c044d"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="afd145e5bc5d37eeff4c4d983435c044d" args="(std::ostream &amp;out, const Ellipse2D&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ellipse2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Ellipse2D'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'Ellipse2D' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Ellipse2D_8ih_source.html#l00236">236</a> of file <a class="el" href="Ellipse2D_8ih_source.html">Ellipse2D.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a62b53564776f9ad979781882fd1c3bf6"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a62b53564776f9ad979781882fd1c3bf6" args="(std::ostream &amp;out, const GridCurve&lt; TKSpace &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridCurve&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'GridCurve'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'GridCurve' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="GridCurve_8ih_source.html#l00269">269</a> of file <a class="el" href="GridCurve_8ih_source.html">GridCurve.ih</a>.</p>

<p>References <a class="el" href="GridCurve_8ih_source.html#l00208">DGtal::GridCurve&lt; TKSpace &gt;::selfDisplay()</a>.</p>
<div class="fragment"><pre class="fragment">{
  aObject.selfDisplay ( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abb0ae3e476260be1ddbbe6c881738e81"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="abb0ae3e476260be1ddbbe6c881738e81" args="(std::ostream &amp;out, const TraceWriterFile &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TraceWriterFile &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'TraceWriterFile'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'TraceWriterFile' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa1f6a42800cc6f4798ac838736790aa"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="aaa1f6a42800cc6f4798ac838736790aa" args="(std::ostream &amp;out, const GreedySegmentation&lt; SegmentComputer &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SegmentComputer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GreedySegmentation&lt; SegmentComputer &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'GreedySegmentation'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'GreedySegmentation' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a89c001da11ad7d8fec9a5bbc30fd3f87"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a89c001da11ad7d8fec9a5bbc30fd3f87" args="(std::ostream &amp;out, const SurfelAdjacency&lt; dim &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SurfelAdjacency&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'SurfelAdjacency'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'SurfelAdjacency' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="SurfelAdjacency_8ih_source.html#l00131">131</a> of file <a class="el" href="SurfelAdjacency_8ih_source.html">SurfelAdjacency.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a692c3dfd29a20f6461bd2014295980d6"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a692c3dfd29a20f6461bd2014295980d6" args="(std::ostream &amp;out, const FreemanChain&lt; TInteger &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FreemanChain&lt; TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>aObject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'FreemanChain'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'FreemanChain' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="FreemanChain_8ih_source.html#l01420">1420</a> of file <a class="el" href="FreemanChain_8ih_source.html">FreemanChain.ih</a>.</p>

<p>References <a class="el" href="FreemanChain_8ih_source.html#l00613">DGtal::FreemanChain&lt; TInteger &gt;::selfDisplay()</a>.</p>
<div class="fragment"><pre class="fragment">{
  aObject.selfDisplay ( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa1a0c72f3ea963c433d33b86d1fba535"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="aa1a0c72f3ea963c433d33b86d1fba535" args="(std::ostream &amp;out, const TraceWriter &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TraceWriter &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'TraceWriter'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'TraceWriter' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b85b590fdca0a2dbba91481b7cda794"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a4b85b590fdca0a2dbba91481b7cda794" args="(std::ostream &amp;out, const FP&lt; TIterator, TInteger, connectivity &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TInteger , int connectivity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FP&lt; TIterator, TInteger, connectivity &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'FP'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'FP' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="FP_8ih_source.html#l00525">525</a> of file <a class="el" href="FP_8ih_source.html">FP.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab4eff7ee02d8f7b17ad3d2e00d25c0d1"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="ab4eff7ee02d8f7b17ad3d2e00d25c0d1" args="(std::ostream &amp;out, const KhalimskySpaceND&lt; dim, TInteger &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KhalimskySpaceND&lt; dim, TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'KhalimskySpaceND'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'KhalimskySpaceND' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="KhalimskySpaceND_8ih_source.html#l01870">1870</a> of file <a class="el" href="KhalimskySpaceND_8ih_source.html">KhalimskySpaceND.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a38abf097f50d029195819d8f23770a33"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a38abf097f50d029195819d8f23770a33" args="(std::ostream &amp;out, const TwoStepLocalLengthEstimator&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TwoStepLocalLengthEstimator&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'TwoStepLocalLengthEstimator'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'TwoStepLocalLengthEstimator' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="TwoStepLocalLengthEstimator_8ih_source.html#l00154">154</a> of file <a class="el" href="TwoStepLocalLengthEstimator_8ih_source.html">TwoStepLocalLengthEstimator.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae5cfe3192eb33036ed5a6afdce4fa90c"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="ae5cfe3192eb33036ed5a6afdce4fa90c" args="(std::ostream &amp;out, const Trace &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Trace &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Trace'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'Trace' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Trace_8ih_source.html#l00231">231</a> of file <a class="el" href="Trace_8ih_source.html">Trace.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa29dbf2926d9b269c070197fe1335e3a"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="aa29dbf2926d9b269c070197fe1335e3a" args="(std::ostream &amp;out, const RosenProffittLocalLengthEstimator&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RosenProffittLocalLengthEstimator&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'RosenProffittLocalLengthEstimator'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'RosenProffittLocalLengthEstimator' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="ab58d2ea12ddf3ceb1b0d9fef20ae6875"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="ab58d2ea12ddf3ceb1b0d9fef20ae6875" args="(std::ostream &amp;out, const Display3D &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Display3D &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Display3D'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'Display3D' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Display3D_8ih_source.html#l00672">672</a> of file <a class="el" href="Display3D_8ih_source.html">Display3D.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay ( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a51f23a1fe0b52ef3d5d8d0475d631a71"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a51f23a1fe0b52ef3d5d8d0475d631a71" args="(std::ostream &amp;out, const ModuloComputer&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ModuloComputer&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Displays <code>object</code> on the output stream <code>out</code>.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">T</td><td>the type of integer for the modulo computer. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream </td></tr>
    <tr><td class="paramname">object</td><td>the object to display. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ModuloComputer_8h_source.html#l00208">208</a> of file <a class="el" href="ModuloComputer_8h_source.html">ModuloComputer.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordtype">object</span>.selfDisplay( out );
    <span class="keywordflow">return</span> out;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a351b036f5289769b5538eb91b68f4031"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a351b036f5289769b5538eb91b68f4031" args="(std::ostream &amp;thatStream, const Statistic&lt; RealNumberType &gt; &amp;that_object_to_display)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealNumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>thatStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Statistic&lt; RealNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>that_object_to_display</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Statistic'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thatStream</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">that_object_to_display</td><td>the object of class 'Statistic' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Statistic_8ih_source.html#l00421">421</a> of file <a class="el" href="Statistic_8ih_source.html">Statistic.ih</a>.</p>

<p>References <a class="el" href="Statistic_8ih_source.html#l00384">DGtal::Statistic&lt; RealNumberType &gt;::selfDisplay()</a>.</p>
<div class="fragment"><pre class="fragment">{
  that_object_to_display.selfDisplay( thatStream );
  <span class="keywordflow">return</span> thatStream;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abae347753ffeed62dd198ff01c4bb399"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="abae347753ffeed62dd198ff01c4bb399" args="(std::ostream &amp;out, const L1LengthEstimator&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const L1LengthEstimator&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'L1LengthEstimator'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'L1LengthEstimator' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="L1LengthEstimator_8ih_source.html#l00140">140</a> of file <a class="el" href="L1LengthEstimator_8ih_source.html">L1LengthEstimator.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aba020cbf0d508e7cecc26c88e71d2b7b"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="aba020cbf0d508e7cecc26c88e71d2b7b" args="(std::ostream &amp;out, const FPLengthEstimator&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FPLengthEstimator&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'FPLengthEstimator'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'FPLengthEstimator' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="FPLengthEstimator_8ih_source.html#l00154">154</a> of file <a class="el" href="FPLengthEstimator_8ih_source.html">FPLengthEstimator.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac3c6d87ade0e0da551f72c4e645771e1"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="ac3c6d87ade0e0da551f72c4e645771e1" args="(std::ostream &amp;out, const Board2D &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Board2D &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Board2D'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'Board2D' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Board2D_8ih_source.html#l00147">147</a> of file <a class="el" href="Board2D_8ih_source.html">Board2D.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a501422a3c732e50eec64ef075d5d9703"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a501422a3c732e50eec64ef075d5d9703" args="(std::ostream &amp;out, const experimental::ImageContainerByITKImage&lt; TDomain, TValue &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDomain , typename TValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const experimental::ImageContainerByITKImage&lt; TDomain, TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ImageContainerByITKImage_8ih_source.html#l00252">252</a> of file <a class="el" href="ImageContainerByITKImage_8ih_source.html">ImageContainerByITKImage.ih</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordtype">object</span>.selfDisplay( out );
    <span class="keywordflow">return</span> out;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="af807f7f242709d2a971623a7f7335bc2"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="af807f7f242709d2a971623a7f7335bc2" args="(std::ostream &amp;out, const GaussDigitizer&lt; TSpace, TEuclideanShape &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace , typename TEuclideanShape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GaussDigitizer&lt; TSpace, TEuclideanShape &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'GaussDigitizer'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'GaussDigitizer' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="GaussDigitizer_8ih_source.html#l00251">251</a> of file <a class="el" href="GaussDigitizer_8ih_source.html">GaussDigitizer.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="acd57220d9ba6549d53cd047448ec433b"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="acd57220d9ba6549d53cd047448ec433b" args="(std::ostream &amp;out, const NGon2D&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NGon2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'NGon2D'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'NGon2D' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="NGon2D_8ih_source.html#l00242">242</a> of file <a class="el" href="NGon2D_8ih_source.html">NGon2D.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab1e154c5c6b8bf237661f55811b280ce"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="ab1e154c5c6b8bf237661f55811b280ce" args="(std::ostream &amp;out, const CombinatorialDSS&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CombinatorialDSS&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'CombinatorialDSS'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'CombinatorialDSS' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="CombinatorialDSS_8ih_source.html#l00608">608</a> of file <a class="el" href="CombinatorialDSS_8ih_source.html">CombinatorialDSS.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a66f899fb94343dd458f3cf071ab5062c"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a66f899fb94343dd458f3cf071ab5062c" args="(std::ostream &amp;out, const KhalimskyCell&lt; dim, TInteger &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KhalimskyCell&lt; dim, TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="KhalimskySpaceND_8ih_source.html#l00127">127</a> of file <a class="el" href="KhalimskySpaceND_8ih_source.html">KhalimskySpaceND.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  out &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; <span class="keywordtype">object</span>.myCoordinates[ 0 ];
  <span class="keywordflow">for</span> ( Dimension i = 1; i &lt; dim; ++i )
    out &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; <span class="keywordtype">object</span>.myCoordinates[ i ];
  out &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aeb9eff1676e395814be1efb1837eb5ba"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="aeb9eff1676e395814be1efb1837eb5ba" args="(std::ostream &amp;out, const ImplicitHyperCube&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImplicitHyperCube&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'ImplicitHyperCube'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'ImplicitHyperCube' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImplicitHyperCube_8ih_source.html#l00085">85</a> of file <a class="el" href="ImplicitHyperCube_8ih_source.html">ImplicitHyperCube.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a14f71daf482381c86a9e3070e9c9644c"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a14f71daf482381c86a9e3070e9c9644c" args="(std::ostream &amp;out, const BLUELocalLengthEstimator&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BLUELocalLengthEstimator&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'BLUELocalLengthEstimator'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'BLUELocalLengthEstimator' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c685b28cb1a025847d30274b28d0edd"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a0c685b28cb1a025847d30274b28d0edd" args="(std::ostream &amp;out, const MeasureOfStraightLines &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeasureOfStraightLines &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'MeasureOfStraightLines'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'MeasureOfStraightLines' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="MeasureOfStraightLines_8ih_source.html#l00392">392</a> of file <a class="el" href="MeasureOfStraightLines_8ih_source.html">MeasureOfStraightLines.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a32e9d703ca58b80d140a0713632cbda4"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a32e9d703ca58b80d140a0713632cbda4" args="(std::ostream &amp;out, const CountedPtr&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CountedPtr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'CountedPtr'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'CountedPtr' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="CountedPtr_8ih_source.html#l00077">77</a> of file <a class="el" href="CountedPtr_8ih_source.html">CountedPtr.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab45a30fbad9ab649b675f951c75c02a0"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="ab45a30fbad9ab649b675f951c75c02a0" args="(std::ostream &amp;out, const DSSLengthEstimator&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DSSLengthEstimator&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'DSSLengthEstimator'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'DSSLengthEstimator' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DSSLengthEstimator_8ih_source.html#l00159">159</a> of file <a class="el" href="DSSLengthEstimator_8ih_source.html">DSSLengthEstimator.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab41e56e6538db4bd6d84a583d05aa0dc"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="ab41e56e6538db4bd6d84a583d05aa0dc" args="(std::ostream &amp;out, const Preimage2D&lt; Shape &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Shape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Preimage2D&lt; Shape &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Preimage2D'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'Preimage2D' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Preimage2D_8ih_source.html#l00262">262</a> of file <a class="el" href="Preimage2D_8ih_source.html">Preimage2D.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a609eff5e615033ac1984199d099023d6"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a609eff5e615033ac1984199d099023d6" args="(std::ostream &amp;out, const Point2ShapePredicate&lt; TSurface, isUpward, isClosed &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSurface , bool isUpward, bool isClosed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point2ShapePredicate&lt; TSurface, isUpward, isClosed &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Point2ShapePredicate'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'Point2ShapePredicate' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Point2ShapePredicate_8ih_source.html#l00111">111</a> of file <a class="el" href="Point2ShapePredicate_8ih_source.html">Point2ShapePredicate.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aaa78c16ab34385ecc35b1da67da693fb"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="aaa78c16ab34385ecc35b1da67da693fb" args="(std::ostream &amp;out, const DigitalSetBySTLSet&lt; Domain &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DigitalSetBySTLSet&lt; Domain &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'DigitalSetBySTLSet'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'DigitalSetBySTLSet' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DigitalSetBySTLSet_8ih_source.html#l00568">568</a> of file <a class="el" href="DigitalSetBySTLSet_8ih_source.html">DigitalSetBySTLSet.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac4d5198d8a044649b47cf6ccecf43549"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="ac4d5198d8a044649b47cf6ccecf43549" args="(std::ostream &amp;out, const Clock &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Clock &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Clock'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'Clock' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Clock_8h_source.html#l00177">177</a> of file <a class="el" href="Clock_8h_source.html">Clock.h</a>.</p>
<div class="fragment"><pre class="fragment">    {
      <span class="keywordtype">object</span>.selfDisplay( out );
      <span class="keywordflow">return</span> out;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aae2aad28cbae6a58095d02ff3fa5fbc6"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="aae2aad28cbae6a58095d02ff3fa5fbc6" args="(std::ostream &amp;out, const Object&lt; TDigitalTopology, TDigitalSet &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalTopology , typename TDigitalSet &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Object&lt; TDigitalTopology, TDigitalSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Object'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'Object' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Object_8ih_source.html#l00980">980</a> of file <a class="el" href="Object_8ih_source.html">Object.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa963a8f3bce2c1ebd26f685ca9bc3f0d"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="aa963a8f3bce2c1ebd26f685ca9bc3f0d" args="(std::ostream &amp;out, const MetricAdjacency&lt; TSpace, maxNorm1, TSpace::dimension &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace , Dimension maxNorm1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetricAdjacency&lt; TSpace, maxNorm1, TSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'MetricAdjacency'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'MetricAdjacency' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="MetricAdjacency_8ih_source.html#l00268">268</a> of file <a class="el" href="MetricAdjacency_8ih_source.html">MetricAdjacency.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abc5badd1a31cea58669461e54fb2e9cd"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="abc5badd1a31cea58669461e54fb2e9cd" args="(std::ostream &amp;out, const Ball2D&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ball2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Ball2D'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'Ball2D' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Ball2D_8ih_source.html#l00191">191</a> of file <a class="el" href="Ball2D_8ih_source.html">Ball2D.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae48f4d094a9375288d99c2ca0c9e6165"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="ae48f4d094a9375288d99c2ca0c9e6165" args="(std::ostream &amp;out, const CowPtr&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CowPtr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'CowPtr'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'CowPtr' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="CowPtr_8ih_source.html#l00077">77</a> of file <a class="el" href="CowPtr_8ih_source.html">CowPtr.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1110460d51a1259c4fd360616c67e72a"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a1110460d51a1259c4fd360616c67e72a" args="(std::ostream &amp;out, const AngleLinearMinimizer &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INLINE std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AngleLinearMinimizer &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'AngleLinearMinimizer'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'AngleLinearMinimizer' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="AngleLinearMinimizer_8ih_source.html#l00249">249</a> of file <a class="el" href="AngleLinearMinimizer_8ih_source.html">AngleLinearMinimizer.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a32d01b810419a09cc24a2e4fa05c66e6"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a32d01b810419a09cc24a2e4fa05c66e6" args="(std::ostream &amp;out, const OrderedAlphabet &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INLINE std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OrderedAlphabet &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'OrderedAlphabet'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'OrderedAlphabet' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="OrderedAlphabet_8ih_source.html#l00148">148</a> of file <a class="el" href="OrderedAlphabet_8ih_source.html">OrderedAlphabet.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aee2b7e1960351e49d925fb7a241aa892"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="aee2b7e1960351e49d925fb7a241aa892" args="(std::ostream &amp;out, const DigitalSetDomain&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DigitalSetDomain&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'DigitalSetDomain'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'DigitalSetDomain' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a4101846412f2ebb4d267f74b0eb62bbc"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a4101846412f2ebb4d267f74b0eb62bbc" args="(std::ostream &amp;out, const Expander&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Expander&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Expander'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'Expander' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2a53895055b003622553da7cb636570"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="ac2a53895055b003622553da7cb636570" args="(std::ostream &amp;out, const Viewer3D &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Viewer3D &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Viewer3D'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'Viewer3D' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Viewer3D_8ih_source.html#l00118">118</a> of file <a class="el" href="Viewer3D_8ih_source.html">Viewer3D.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab94d08e6ed6283cea5cf72d51316d329"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="ab94d08e6ed6283cea5cf72d51316d329" args="(std::ostream &amp;out, const ImplicitNorm1Ball&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImplicitNorm1Ball&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'ImplicitNorm1Ball'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'ImplicitNorm1Ball' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImplicitNorm1Ball_8ih_source.html#l00085">85</a> of file <a class="el" href="ImplicitNorm1Ball_8ih_source.html">ImplicitNorm1Ball.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abc47262779fe4c5a69fcea8354861ed4"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="abc47262779fe4c5a69fcea8354861ed4" args="(std::ostream &amp;out, const ImplicitRoundedHyperCube&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImplicitRoundedHyperCube&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'ImplicitRoundedHyperCube'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'ImplicitRoundedHyperCube' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImplicitRoundedHyperCube_8ih_source.html#l00085">85</a> of file <a class="el" href="ImplicitRoundedHyperCube_8ih_source.html">ImplicitRoundedHyperCube.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5031410a071126043e1dee8afa405aa3"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="a5031410a071126043e1dee8afa405aa3" args="(std::ostream &amp;out, const AccFlower2D&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AccFlower2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'AccFlower2D'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'AccFlower2D' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="AccFlower2D_8ih_source.html#l00237">237</a> of file <a class="el" href="AccFlower2D_8ih_source.html">AccFlower2D.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af4182e2d0d2b32617fe41632540b2828"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="af4182e2d0d2b32617fe41632540b2828" args="(std::ostream &amp;out, const Flower2D&lt; T &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Flower2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'Flower2D'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'Flower2D' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Flower2D_8ih_source.html#l00212">212</a> of file <a class="el" href="Flower2D_8ih_source.html">Flower2D.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae58b0d1dec58726723db23aa84a06bdb"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="ae58b0d1dec58726723db23aa84a06bdb" args="(std::ostream &amp;out, const HyperRectDomain&lt; TSpace &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HyperRectDomain&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'HyperRectDomain'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'HyperRectDomain' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="HyperRectDomain_8ih_source.html#l00485">485</a> of file <a class="el" href="HyperRectDomain_8ih_source.html">HyperRectDomain.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay ( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aacee1ffcfe75b25c14c2d3962ffe08ca"></a><!-- doxytag: member="DGtal::operator&lt;&lt;" ref="aacee1ffcfe75b25c14c2d3962ffe08ca" args="(std::ostream &amp;out, const PointVector&lt; dim, Component &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename Component &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointVector&lt; dim, Component &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator &lt;&lt;. </p>

</div>
</div>
<a class="anchor" id="a378df6c82574aff83d591a8748b80e1d"></a><!-- doxytag: member="DGtal::oppositeEndMaximalExtension" ref="a378df6c82574aff83d591a8748b80e1d" args="(SC &amp;s, const typename SC::ConstIterator &amp;begin, CirculatorType)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::oppositeEndMaximalExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CirculatorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialization for <a class="el" href="classDGtal_1_1Circulator.html" title="Aim: Provides an adapter for STL iterators that can iterate through the underlying data structure as ...">Circulator</a> type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00208">208</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                                {
  <span class="comment">//stop if the segment is the whole range</span>
  <span class="keyword">const</span> <span class="keyword">typename</span> SC::ConstIterator newBegin( s.end() ); 
  <span class="keywordflow">while</span> ( (s.extendOppositeEnd())
       &amp;&amp; (s.begin() != newBegin) ) {}
}
</pre></div>
</div>
</div>
<a class="anchor" id="a38f9cc978f49499b1cce5d1d17904816"></a><!-- doxytag: member="DGtal::oppositeEndMaximalExtension" ref="a38f9cc978f49499b1cce5d1d17904816" args="(SC &amp;s, const typename SC::ConstIterator &amp;begin)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::oppositeEndMaximalExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calls s.extendOppositeEnd() while possible </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of (bidirectional) segment computer </td></tr>
    <tr><td class="paramname">begin</td><td>any ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00222">222</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00197">oppositeEndMaximalExtension()</a>.</p>
<div class="fragment"><pre class="fragment">                                                                               {
  <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorCirculatorTraits&lt;typename SC::ConstIterator&gt;::Type Type; 
  <a class="code" href="namespaceDGtal.html#abdbcbec916407d99ff5c770a564f3baa">oppositeEndMaximalExtension</a>( s, begin, Type() ); 
}
</pre></div>
</div>
</div>
<a class="anchor" id="abdbcbec916407d99ff5c770a564f3baa"></a><!-- doxytag: member="DGtal::oppositeEndMaximalExtension" ref="abdbcbec916407d99ff5c770a564f3baa" args="(SC &amp;s, const typename SC::ConstIterator &amp;begin, IteratorType)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::oppositeEndMaximalExtension </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialization for Iterator type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00197">197</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00438">firstMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00686">lastMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00566">mostCenteredMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00222">oppositeEndMaximalExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00883">previousMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                              {
  <span class="comment">//extend one more time if s.begin() == begin</span>
  <span class="keywordflow">while</span> ( (s.begin() != begin)
       &amp;&amp; (s.extendOppositeEnd()) ) {}
  <span class="keywordflow">if</span> (s.begin() == begin) s.extendOppositeEnd();
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad401c0603f3ee18ff583b102258537ff"></a><!-- doxytag: member="DGtal::oppositeEndMaximalRetraction" ref="ad401c0603f3ee18ff583b102258537ff" args="(SC &amp;s, const typename SC::ConstIterator &amp;begin)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::oppositeEndMaximalRetraction </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calls s.retractOppositeEnd() while s.isOppositeEndExtendable() returns false </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">begin</td><td>any ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00334">334</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00883">previousMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> ( isNotEmpty&lt;typename SC::ConstIterator&gt;(s.begin(),begin) ) {
    <span class="keywordflow">while</span> ( (! s.isOppositeEndExtendable() ) 
          &amp;&amp;(s.retractOppositeEnd() ) ) {}  
  } <span class="keywordflow">else</span> {
    <span class="keywordflow">while</span> ( s.retractOppositeEnd() ) {} 
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a461a01d471e9b8ab99e1bbd2675179f2"></a><!-- doxytag: member="DGtal::previousMaximalSegment" ref="a461a01d471e9b8ab99e1bbd2675179f2" args="(SC &amp;s, const typename SC::ConstIterator &amp;end, DGtal::DynamicBidirectionalSegmentComputer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::previousMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the previous maximal segment of s (s is assumed to be maximal) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">end,end</td><td>ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie...">CDynamicBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DynamicSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00917">917</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00852">previousMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{ 
  <a class="code" href="namespaceDGtal.html#ac35b312417d30f4a3c2b16bef0e2c924">previousMaximalSegment</a>(s, end, <a class="code" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>() ); 
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac35b312417d30f4a3c2b16bef0e2c924"></a><!-- doxytag: member="DGtal::previousMaximalSegment" ref="ac35b312417d30f4a3c2b16bef0e2c924" args="(SC &amp;s, const typename SC::ConstIterator &amp;begin, DGtal::ForwardSegmentComputer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::previousMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the previous maximal segment of s (s is assumed to be maximal) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,any</td><td>begin ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer, ie. a model of CSegment that can exte...">CForwardSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>lastMaximalSegment of --s.begin() </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00852">852</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00652">lastMaximalSegment()</a>.</p>

<p>Referenced by <a class="el" href="SaturatedSegmentation_8ih_source.html#l00122">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initLastMaximalSegment()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00917">previousMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> ( isNotEmpty&lt;typename SC::ConstIterator&gt;(s.begin(),begin) )
    <a class="code" href="namespaceDGtal.html#a7f49157673c4175be11111f1aec05283">lastMaximalSegment</a>(s, --s.begin(), begin, s.end(), <a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="afa601b209cbe7f7453c63f9ae801edf0"></a><!-- doxytag: member="DGtal::previousMaximalSegment" ref="afa601b209cbe7f7453c63f9ae801edf0" args="(SC &amp;s, const typename SC::ConstIterator &amp;begin)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::previousMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the previous maximal segment of s (s is assumed to be maximal) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,any</td><td>begin ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00931">931</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00852">previousMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="namespaceDGtal.html#ac35b312417d30f4a3c2b16bef0e2c924">previousMaximalSegment</a>(s, begin, 
<span class="keyword">typename</span> <a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::SegmentComputerTraits&lt;SC&gt;::Category</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4510773e68134d8cebc17d5d869275c2"></a><!-- doxytag: member="DGtal::previousMaximalSegment" ref="a4510773e68134d8cebc17d5d869275c2" args="(SC &amp;s, const typename SC::ConstIterator &amp;begin, DGtal::BidirectionalSegmentComputer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::previousMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the previous maximal segment of s (s is assumed to be maximal) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,any</td><td>begin ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>lastMaximalSegment of --s.begin() </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00868">868</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00652">lastMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> ( isNotEmpty&lt;typename SC::ConstIterator&gt;(s.begin(),begin) )
    <a class="code" href="namespaceDGtal.html#a7f49157673c4175be11111f1aec05283">lastMaximalSegment</a>(s, --s.begin(), begin, s.end(), <a class="code" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0661af0aaa51ac8fe9691ef97d66ea23"></a><!-- doxytag: member="DGtal::previousMaximalSegment" ref="a0661af0aaa51ac8fe9691ef97d66ea23" args="(SC &amp;s, const typename SC::ConstIterator &amp;begin, DGtal::DynamicSegmentComputer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::previousMaximalSegment </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the previous maximal segment of s (s is assumed to be maximal) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,any</td><td>begin ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html" title="Aim: Defines the concept describing a dynamic segment computer, ie. a model of CSegment that can exte...">CDynamicSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00883">883</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00197">oppositeEndMaximalExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00334">oppositeEndMaximalRetraction()</a>.</p>
<div class="fragment"><pre class="fragment">{

  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::ConstIterator ConstIterator; 

  <span class="comment">//rectract</span>
  <a class="code" href="namespaceDGtal.html#ad401c0603f3ee18ff583b102258537ff">oppositeEndMaximalRetraction</a>(s, begin); 

  <span class="comment">//intersection test</span>
  ConstIterator i( s.end() ); --i; 
  <span class="comment">//if the intersection between the two </span>
  <span class="comment">// consecutive maximal segments is empty </span>
  <span class="keywordflow">if</span> ( i == s.begin() ) {
    <span class="keywordflow">if</span> ( isNotEmpty&lt;ConstIterator&gt;(i, begin) ) {
      --i; 
      s.init(i);  
    }
  }

  <span class="comment">//extend</span>
  <a class="code" href="namespaceDGtal.html#abdbcbec916407d99ff5c770a564f3baa">oppositeEndMaximalExtension</a>(s, begin);

}
</pre></div>
</div>
</div>
<a class="anchor" id="a7a8a1f84da3e6a36b8089ae35c4125d0"></a><!-- doxytag: member="DGtal::setDimensionsIn" ref="a7a8a1f84da3e6a36b8089ae35c4125d0" args="(const Container &amp;dimensions)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::bitset&lt; dim &gt; DGtal::setDimensionsIn </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a bitset having true for each dimension presents in dimensions. </dd></dl>

<p>Definition at line <a class="el" href="PointVector_8ih_source.html#l00042">42</a> of file <a class="el" href="PointVector_8ih_source.html">PointVector.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  std::bitset&lt;dim&gt; t1; 
  <span class="keywordflow">for</span> ( <span class="keyword">typename</span> Container::const_iterator it=dimensions.begin(); 
  it!=dimensions.end(); ++it )
    {
      ASSERT( *it&lt;dim );
      t1.set(*it);
    }
  <span class="keywordflow">return</span> t1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a86e2ce57d34daf05049b1701aadbdab3"></a><!-- doxytag: member="DGtal::setDimensionsNotIn" ref="a86e2ce57d34daf05049b1701aadbdab3" args="(const Container &amp;dimensions)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::bitset&lt; dim &gt; DGtal::setDimensionsNotIn </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a bitset having true for each dimension not presents in dimensions. </dd></dl>

<p>Definition at line <a class="el" href="PointVector_8ih_source.html#l00056">56</a> of file <a class="el" href="PointVector_8ih_source.html">PointVector.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  std::bitset&lt;dim&gt; t1; t1.set();
  <span class="keywordflow">for</span> ( <span class="keyword">typename</span> Container::const_iterator it=dimensions.begin(); 
  it!=dimensions.end(); ++it )
    {
      ASSERT( *it&lt;dim );
      t1.reset(*it);
    }
  <span class="keywordflow">return</span> t1;
}
</pre></div>
</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a70c28100eb4618dbb59a4080cbdf383b"></a><!-- doxytag: member="DGtal::andBF2" ref="a70c28100eb4618dbb59a4080cbdf383b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a> <a class="el" href="namespaceDGtal.html#a70c28100eb4618dbb59a4080cbdf383b">DGtal::andBF2</a> = <a class="el" href="structDGtal_1_1AndBoolFct2.html">AndBoolFct2</a>()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The object function and (2 bool args). </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00149">149</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

<p>Referenced by <a class="el" href="Expander_8ih_source.html#l00175">DGtal::Expander&lt; TObject &gt;::computeNextLayer()</a>.</p>

</div>
</div>
<a class="anchor" id="a3c1454fe50af31341c890919f93b76b6"></a><!-- doxytag: member="DGtal::false" ref="a3c1454fe50af31341c890919f93b76b6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">It also possible to remove the visualisation of the transparent clipping plane by adding boolean <a class="el" href="namespaceDGtal.html#a3c1454fe50af31341c890919f93b76b6">DGtal::false</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="3dvisu_8dox_source.html#l00359">359</a> of file <a class="el" href="3dvisu_8dox_source.html">3dvisu.dox</a>.</p>

<p>Referenced by <a class="el" href="Board2D_8cpp_source.html#l00054">DGtal::Board2D::Board2D()</a>, <a class="el" href="Expander_8ih_source.html#l00060">DGtal::Expander&lt; TObject &gt;::Expander()</a>, <a class="el" href="MostCenteredMaximalSegmentEstimator_8ih_source.html#l00054">DGtal::MostCenteredMaximalSegmentEstimator&lt; SegmentComputer, Functor &gt;::MostCenteredMaximalSegmentEstimator()</a>, <a class="el" href="GreedyDecomposition_8ih_source.html#l00055">DGtal::deprecated::GreedyDecomposition&lt; TSegment &gt;::SegmentIterator::SegmentIterator()</a>, and <a class="el" href="Statistic_8ih_source.html#l00052">DGtal::Statistic&lt; RealNumberType &gt;::Statistic()</a>.</p>

</div>
</div>
<a class="anchor" id="a8c0dbf38da6779899ca99fc25ec8b0be"></a><!-- doxytag: member="DGtal::falseBF0" ref="a8c0dbf38da6779899ca99fc25ec8b0be" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a40f198468aea6d0121b11cd49e599e92">BoolFunction0</a> <a class="el" href="namespaceDGtal.html#a8c0dbf38da6779899ca99fc25ec8b0be">DGtal::falseBF0</a> = <a class="el" href="structDGtal_1_1FalseBoolFct0.html">FalseBoolFct0</a>()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The object function (0 bool args) returning false. </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00092">92</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a154eac21029f20806b646b025b6d59a0"></a><!-- doxytag: member="DGtal::identityBF1" ref="a154eac21029f20806b646b025b6d59a0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a9a92f37472d9010932be3fe6d28f94cb">BoolFunction1</a> <a class="el" href="namespaceDGtal.html#a154eac21029f20806b646b025b6d59a0">DGtal::identityBF1</a> = <a class="el" href="structDGtal_1_1IdentityBoolFct1.html">IdentityBoolFct1</a>()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The object function identity (1 bool args). </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00111">111</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="af22fdd40c268d4270906236e3ce234cb"></a><!-- doxytag: member="DGtal::impliesBF2" ref="af22fdd40c268d4270906236e3ce234cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a> <a class="el" href="namespaceDGtal.html#af22fdd40c268d4270906236e3ce234cb">DGtal::impliesBF2</a> = <a class="el" href="structDGtal_1_1ImpliesBoolFct2.html">ImpliesBoolFct2</a>()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The object function implies (2 bool args). </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00164">164</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a31614f15cda0ab53c57cf414e48c149f"></a><!-- doxytag: member="DGtal::notBF1" ref="a31614f15cda0ab53c57cf414e48c149f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a9a92f37472d9010932be3fe6d28f94cb">BoolFunction1</a> <a class="el" href="namespaceDGtal.html#a31614f15cda0ab53c57cf414e48c149f">DGtal::notBF1</a> = <a class="el" href="structDGtal_1_1NotBoolFct1.html">NotBoolFct1</a>()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The object function NOT (1 bool args). </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00116">116</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7df3f0545c8e59b83394c60601c122e3"></a><!-- doxytag: member="DGtal::option" ref="a7df3f0545c8e59b83394c60601c122e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">It also possible to remove the visualisation of the transparent clipping plane by adding boolean <a class="el" href="namespaceDGtal.html#a7df3f0545c8e59b83394c60601c122e3">DGtal::option</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="3dvisu_8dox_source.html#l00359">359</a> of file <a class="el" href="3dvisu_8dox_source.html">3dvisu.dox</a>.</p>

</div>
</div>
<a class="anchor" id="a14f119bf8a5eb80a58870ebbd33bfb07"></a><!-- doxytag: member="DGtal::orBF2" ref="a14f119bf8a5eb80a58870ebbd33bfb07" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a> <a class="el" href="namespaceDGtal.html#a14f119bf8a5eb80a58870ebbd33bfb07">DGtal::orBF2</a> = <a class="el" href="structDGtal_1_1OrBoolFct2.html">OrBoolFct2</a>()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The object function or (2 bool args). </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00154">154</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a604c07ec391ad12a1f3fb6479993f112"></a><!-- doxytag: member="DGtal::trace" ref="a604c07ec391ad12a1f3fb6479993f112" args="(traceWriterTerm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Trace.html">Trace</a> <a class="el" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">DGtal::trace</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Common_8h_source.html#l00101">101</a> of file <a class="el" href="Common_8h_source.html">Common.h</a>.</p>

<p>Referenced by <a class="el" href="ImageContainerByHashTree_8ih_source.html#l00841">DGtal::experimental::ImageContainerByHashTree&lt; TDomain, TValue, THashKey &gt;::checkIntegrity()</a>, <a class="el" href="DistanceTransformation_8ih_source.html#l00066">DGtal::DistanceTransformation&lt; Image, p, IntegerLong &gt;::checkTypesValidity()</a>, <a class="el" href="DistanceTransformation_8ih_source.html#l00092">DGtal::DistanceTransformation&lt; Image, p, IntegerLong &gt;::compute()</a>, <a class="el" href="DistanceTransformation_8ih_source.html#l00159">DGtal::DistanceTransformation&lt; Image, p, IntegerLong &gt;::computeFirstStep()</a>, <a class="el" href="DistanceTransformation_8ih_source.html#l00193">DGtal::DistanceTransformation&lt; Image, p, IntegerLong &gt;::computeOtherSteps()</a>, <a class="el" href="ReverseDistanceTransformation_8ih_source.html#l00189">DGtal::ReverseDistanceTransformation&lt; Image, p, IntegerShort &gt;::computeSteps()</a>, <a class="el" href="shapeGenerator_8cpp_source.html#l00255">Exporter&lt; Set, Image &gt;::exportSignature()</a>, <a class="el" href="ImageContainerByHashTree_8ih_source.html#l00682">DGtal::experimental::ImageContainerByHashTree&lt; TDomain, TValue, THashKey &gt;::getAverageCollisions()</a>, <a class="el" href="ImageContainerByHashTree_8ih_source.html#l00064">DGtal::experimental::ImageContainerByHashTree&lt; TDomain, TValue, THashKey &gt;::ImageContainerByHashTree()</a>, <a class="el" href="LongvolReader_8ih_source.html#l00040">DGtal::LongvolReader&lt; TImageContainer &gt;::importLongvol()</a>, <a class="el" href="PNMReader_8ih_source.html#l00159">DGtal::PNMReader&lt; TImageContainer &gt;::importPGM3D()</a>, <a class="el" href="PNMReader_8ih_source.html#l00052">DGtal::PNMReader&lt; TImageContainer &gt;::importPGMImage()</a>, <a class="el" href="RawReader_8ih_source.html#l00040">DGtal::RawReader&lt; TImageContainer &gt;::importRaw8()</a>, <a class="el" href="VolReader_8ih_source.html#l00044">DGtal::VolReader&lt; TImageContainer &gt;::importVol()</a>, <a class="el" href="Viewer3D_8cpp_source.html#l00527">DGtal::Viewer3D::keyPressEvent()</a>, <a class="el" href="Board2D_8ih_source.html#l00066">DGtal::Board2D::operator&lt;&lt;()</a>, <a class="el" href="Viewer3D_8cpp_source.html#l00245">DGtal::Viewer3D::postSelection()</a>, <a class="el" href="shapeGenerator_8cpp_source.html#l00197">Exporter&lt; Set, Image &gt;::save()</a>, <a class="el" href="Board3DTo2D_8cpp_source.html#l00232">DGtal::Board3DTo2D::saveCairo()</a>, and <a class="el" href="Viewer3D_8cpp_source.html#l00226">DGtal::Viewer3D::sortSurfelFromCamera()</a>.</p>

</div>
</div>
<a class="anchor" id="ae801de7ee4d22c47257dc7e00e0c5dd7"></a><!-- doxytag: member="DGtal::traceWriterTerm" ref="ae801de7ee4d22c47257dc7e00e0c5dd7" args="(std::cerr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1TraceWriterTerm.html">TraceWriterTerm</a> <a class="el" href="namespaceDGtal.html#ae801de7ee4d22c47257dc7e00e0c5dd7">DGtal::traceWriterTerm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> Global variables </p>

<p>Definition at line <a class="el" href="Common_8h_source.html#l00100">100</a> of file <a class="el" href="Common_8h_source.html">Common.h</a>.</p>

</div>
</div>
<a class="anchor" id="aad0fa31bef8d6552db900af1809d787d"></a><!-- doxytag: member="DGtal::trueBF0" ref="aad0fa31bef8d6552db900af1809d787d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a40f198468aea6d0121b11cd49e599e92">BoolFunction0</a> <a class="el" href="namespaceDGtal.html#aad0fa31bef8d6552db900af1809d787d">DGtal::trueBF0</a> = <a class="el" href="structDGtal_1_1TrueBoolFct0.html">TrueBoolFct0</a>()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The object function (0 bool args) returning true. </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00087">87</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a29281e7462720aa5d454fa2355baa0f3"></a><!-- doxytag: member="DGtal::xorBF2" ref="a29281e7462720aa5d454fa2355baa0f3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a> <a class="el" href="namespaceDGtal.html#a29281e7462720aa5d454fa2355baa0f3">DGtal::xorBF2</a> = <a class="el" href="structDGtal_1_1XorBoolFct2.html">XorBoolFct2</a>()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The object function xor (2 bool args). </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00159">159</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Tue Sep 27 2011 12:41:25 for DGtal by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
