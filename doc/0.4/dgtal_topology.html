<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DGtal: Digital topology and digital objects</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DGtal&#160;<span id="projectnumber">0.4.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Digital topology and digital objects </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p>Documentation written by Jacques-Olivier Lachaud and Bertrand Kerautret.</p>
<p>This part of the manual describes how to define digital objects. Subset of a digital sets are not really objects as long as they do not have some adjacency relation which describes how points (pixels in 2D, voxels in 3D, <em>spels</em> in nD) are connected. Digital topology was introduced by Rosenfeld as a framework to describe consistently how objects are connected and how complements of objects are connected. It has lead him to define two different adjacencies relations, one for the foreground (object), one for the background (complement of object). For well chosen adjacency relations, we find again some classical results of topology in continuous domains. For instance, the Jordan property may hold for several couples of adjacencies.</p>
<p>The topology kernel of <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> allows to define adjacencies, topologies, objects, and operations with objects in a very generic framework. Some of these operations have been specialized for standard spaces and topologies, in order to keep operations as fast as possible.</p>
<p>Once a topology (class <a class="el" href="classDGtal_1_1DigitalTopology.html">DigitalTopology</a>) has been defined from two adjacencies (models of <a class="el" href="structDGtal_1_1CAdjacency.html">CAdjacency</a>), a digital object (class <a class="el" href="classDGtal_1_1Object.html">Object</a>) has a <em>border</em> which is the set of elements adjacent to its complement. The border is again a digital object. A digital object can also be seen as a graph, which can be traversed in many ways, although the breadth-first is often very useful (class <a class="el" href="classDGtal_1_1Expander.html">Expander</a>).</p>
<ol type="1">
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec1_ajdacency">Adjacency relations</a><ol type="a">
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec1s1">4- and 8- adjacencies in Z2</a></li>
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec1s2">6-, 18- and 26- adjacencies in Z3</a></li>
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec1s3">Metric adjacencies in Zn</a></li>
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec1s4">Concepts CAdjacency et CDomainAdjacency</a></li>
</ol>
</li>
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec2_digital_topology">Digital topology over a digital space</a></li>
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec3_digital_object">Digital objects</a><ol type="a">
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec3s1">Construction of digital objects</a></li>
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec3s2">Neighborhood of a point in an object</a></li>
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec3s3">Border of a digital object</a></li>
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec3s4">Connectedness and connected components</a></li>
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec3s5">Simple points</a></li>
</ol>
</li>
</ol>
<h2><a class="anchor" id="dgtal_topology_sec1_ajdacency"></a>
Adjacency relations</h2>
<p>An adjacency relation in a digital space <b>X</b> describes which points of the digital space are close to each other. Generally it is a reflexive and symmetric relation over the points of <b>X</b>. Interested readers can read the works of Azriel Rosenfeld and Gabor Herman to see a well-founded theory of digital spaces.</p>
<h3><a class="anchor" id="dgtal_topology_sec1s1"></a>
4- and 8- adjacencies in Z2</h3>
<p>In <img class="formulaInl" alt="$ Z^2 $" src="form_13.png"/>, two adjacencies are used. The so-called <b>4-adjacency</b> tells that a 2D point is adjacent to itself and to four other points (north, east, south, and west points). The so-called <b>8-adjacency</b> tells that a 2D point is adjacent to itself and to eight other points (the four points of the 4-adjacency relation added with four points in the diagonals). These two adjacencies relations are translation invariant, symmetric, reflexive. You can define them as follows with <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>:</p>
<div class="fragment"><pre class="fragment">   <span class="keyword">typedef</span> <span class="keywordtype">int</span> <a class="code" href="namespaceDGtal_1_1Z2i.html#a5d93c6632713d21e2662c93af3a941e6">Integer</a>;                <span class="comment">// choose your digital line here.</span>
   <span class="keyword">typedef</span> SpaceND&lt;2,Integer&gt; <a class="code" href="namespaceDGtal_1_1Z2i.html#adf7ebed7141fd4101a0eb93ed99145c5">Z2</a>;      <span class="comment">// Z^2</span>
   <span class="keyword">typedef</span> MetricAdjacency&lt;Z2,1&gt; <a class="code" href="namespaceDGtal_1_1Z2i.html#a4d25eff23463be573774eff2ac86a794">Adj4</a>; <span class="comment">// 4-adjacency type</span>
   <span class="keyword">typedef</span> MetricAdjacency&lt;Z2,2&gt; <a class="code" href="namespaceDGtal_1_1Z2i.html#aba773ccf268d50d2d75a9bc930b1b3b2">Adj8</a>; <span class="comment">// 8-adjacency type</span>
   Adj4 adj4;                          <span class="comment">// instance of 4-adjacency</span>
   Adj8 adj8;                          <span class="comment">// instance of 8-adjacency</span>
</pre></div><p>You can equivalently use the types <a class="el" href="namespaceDGtal_1_1Z2i.html#a4d25eff23463be573774eff2ac86a794">Z2i::Adj4</a> and <a class="el" href="namespaceDGtal_1_1Z2i.html#aba773ccf268d50d2d75a9bc930b1b3b2">Z2i::Adj8</a>, (namespace <a class="el" href="namespaceDGtal_1_1Z2i.html" title="Z2i this namespace gathers the standard of types for 2D imagery.">Z2i</a> in "DGtal/helpers/StdDefs.h"), defined on <code>SpaceND&lt;2,int&gt;</code>.</p>
<p>It is well known that if you choose the 4-adjacency for an object, one should choose the 8-adjacency for the background in order to get consistent topological properties. For instance a simple 4-connected digital close curve (of more than 4 points) splits the digital space into two 8-connected background components (digital Jordan theorem). The same is true if you choose the 8-adjacency relation for the object, the 4-adjacency should be choosed for the background. This is called the <b>digital Jordan theorem</b> (Rosenfeld).</p>
<div align="center">
<img src="DiskWithAdj4.png" alt="DiskWithAdj4.png"/>
<p><strong>Illustration of a Digital Object with the 4-adjacency</strong></p></div>
 <div align="center">
<img src="DiskWithAdj8.png" alt="DiskWithAdj8.png"/>
<p><strong>Illustration of a Digital Object with the 8-adjacency</strong></p></div>
 <h3><a class="anchor" id="dgtal_topology_sec1s2"></a>
6-, 18- and 26- adjacencies in Z3</h3>
<p>Similarly as the 4-,8- adjacencies in 3D, the name of the 6-, 18-, 26- adjacencies defined in Z3 comes from the number of proper adjacent points for each point. Seeing a digital 3D point as a cube, the 6-neighbors are the points sharing at least a face with the cube, the 18-neighbors are the ones sharing at least an edge, while the 26-neighbors are the ones sharing at least a vertex. These three adjacencies relations are translation invariant, symmetric, reflexive. You can define them as follows with <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>:</p>
<div class="fragment"><pre class="fragment">   <span class="keyword">typedef</span> <span class="keywordtype">int</span> Integer;                 <span class="comment">// choose your digital line here.</span>
   <span class="keyword">typedef</span> SpaceND&lt;3,Integer&gt; <a class="code" href="namespaceDGtal_1_1Z3i.html#a53d22fc69530a513baf89080684d8158">Z3</a>;       <span class="comment">// Z^3</span>
   <span class="keyword">typedef</span> MetricAdjacency&lt;Z3,1&gt; <a class="code" href="namespaceDGtal_1_1Z3i.html#a88c46bc17937d2a2d389c663e529ea9d">Adj6</a>;  <span class="comment">// 6-adjacency type</span>
   <span class="keyword">typedef</span> MetricAdjacency&lt;Z3,2&gt; <a class="code" href="namespaceDGtal_1_1Z3i.html#a02769c25d70f4f7e85fcee03b369e55c">Adj18</a>; <span class="comment">// 18-adjacency type</span>
   <span class="keyword">typedef</span> MetricAdjacency&lt;Z3,3&gt; <a class="code" href="namespaceDGtal_1_1Z3i.html#a44acb785a4616854c8fe13be68ed6e08">Adj26</a>; <span class="comment">// 26-adjacency type</span>
   Adj6 adj6;                           <span class="comment">// instance of 6-adjacency</span>
   Adj18 adj18;                         <span class="comment">// instance of 18-adjacency</span>
   Adj26 adj26;                         <span class="comment">// instance of 26-adjacency</span>
</pre></div><p>You can equivalently use the types <a class="el" href="namespaceDGtal_1_1Z3i.html#a88c46bc17937d2a2d389c663e529ea9d">Z3i::Adj6</a>, <a class="el" href="namespaceDGtal_1_1Z3i.html#a02769c25d70f4f7e85fcee03b369e55c">Z3i::Adj18</a> and <a class="el" href="namespaceDGtal_1_1Z3i.html#a44acb785a4616854c8fe13be68ed6e08">Z3i::Adj26</a>, (namespace <a class="el" href="namespaceDGtal_1_1Z3i.html" title="Z3i this namespace gathers the standard of types for 3D imagery.">Z3i</a> in "DGtal/helpers/StdDefs.h"), defined on <code>SpaceND&lt;3,int&gt;</code>.</p>
<h3><a class="anchor" id="dgtal_topology_sec1s3"></a>
Metric adjacencies in Zn</h3>
<p>Adjacencies based on metrics can be defined in arbitrary dimension. They all have the properties to be translation invariant, reflexive and symmetric. They include the standard 4-, 8-adjacencies in Z2 and 6-, 18-, and 26-adjacencies in Z3. Given a maximal 1-norm <code>n1</code>, two points <code>p1</code> and <code>p2</code> are adjacent if and only if <img class="formulaInl" alt="$ \| p2 - p1 \|_1 \le n1 $" src="form_14.png"/> and <img class="formulaInl" alt="$ \| p2 - p1 \|_\infty \le 1 $" src="form_15.png"/>. Metric adjacencies are implemented in the template class <a class="el" href="classDGtal_1_1MetricAdjacency.html" title="Aim: Describes digital adjacencies in digital spaces that are defined with the 1-norm and the infinit...">MetricAdjacency</a>. For now, only metric adjacencies in Z2 are specialized, so as to be (slightly) optimized.</p>
<div class="fragment"><pre class="fragment">   <span class="keyword">const</span> <span class="keywordtype">int</span> n = ...;                   <span class="comment">// choose your dimension.</span>
   <span class="keyword">typedef</span> <span class="keywordtype">int</span> Integer;                 <span class="comment">// choose your digital line here.</span>
   <span class="keyword">typedef</span> SpaceND&lt;n,int&gt; Zn;           <span class="comment">// Z^N</span>
   <span class="keyword">const</span> <span class="keywordtype">int</span> n1 = ...;                  <span class="comment">// choose your max 1-norm here.</span>
   <span class="keyword">typedef</span> MetricAdjacency&lt;Zn,n1&gt; MyAdj;<span class="comment">// your adjacency type.</span>
   Myadj myAdj;                         <span class="comment">// your instance.</span>
</pre></div><h3><a class="anchor" id="dgtal_topology_sec1s4"></a>
Concepts CAdjacency et CDomainAdjacency</h3>
<p>Adjacencies are used at many places as a basis for more complex operations. To keep genericity and efficiency, adjacencies should satisfy the concept <a class="el" href="structDGtal_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">CAdjacency</a>. They are specialized only at instanciation as argument to templates. A <a class="el" href="structDGtal_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">CAdjacency</a> concept should define the following inner types:</p>
<ul>
<li>Space: the space of the adjacency.</li>
<li>Point: the digital point type.</li>
<li>Adjacency: the type of the adjacency itself.</li>
</ul>
<p>It should also define the following methods:</p>
<ul>
<li>isAdjacentTo</li>
<li>isProperlyAdjacentTo</li>
<li>writeNeighborhood</li>
<li>writeProperNeighborhood</li>
</ul>
<p>Methods <code>writeNeighborhood</code> and <code>writeProperNeighborhood</code> are overloaded so as to substitute their own predicate with another user-given predicate. They are useful to restrict neighborhoods.</p>
<p>A <a class="el" href="structDGtal_1_1CDomainAdjacency.html" title="Aim: Refines the concept CAdjacency by telling that the adjacency is specific to a given domain of th...">CDomainAdjacency</a> refines a <a class="el" href="structDGtal_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">CAdjacency</a> by specifying a limiting domain for the adjacency. It adds the following inner types:</p>
<ul>
<li>Domain: the type of embedding domain.</li>
<li>Predicate: the type of the predicate "is in domain ?".</li>
</ul>
<p>It should also define the following methods:</p>
<ul>
<li>domain</li>
<li>predicate</li>
</ul>
<h2><a class="anchor" id="dgtal_topology_sec2_digital_topology"></a>
Digital topology over a digital space</h2>
<p>A digital topology is a couple of adjacencies, one for the foreground, one for the background. The template class <a class="el" href="classDGtal_1_1DigitalTopology.html" title="Aim: Represents a digital topology as a couple of adjacency relations.">DigitalTopology</a> can be used to create such a couple.</p>
<p>The following lines of code creates the classical (6,18) topology over <img class="formulaInl" alt="$ Z^3 $" src="form_16.png"/>.</p>
<div class="fragment"><pre class="fragment">   <span class="keyword">typedef</span> SpaceND&lt; 3,int &gt; Z3;
   <span class="keyword">typedef</span> MetricAdjacency&lt; Z3, 1 &gt; Adj6;
   <span class="keyword">typedef</span> MetricAdjacency&lt; Z3, 2 &gt; Adj18;
   <span class="keyword">typedef</span> DigitalTopology&lt; Adj6, Adj18 &gt; <a class="code" href="namespaceDGtal_1_1Z3i.html#ae1d67d49e26cdc9cd742554a32df5fea">DT6_18</a>;
  
   Adj6 adj6;
   Adj18 adj18;
   DT6_18 dt6_18( adj6, adj18, <a class="code" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083da731ee8276af4e05e2fe322cf2a4fd179">JORDAN_DT</a> );
</pre></div><p>The foreground adjacency is classically called <em>kappa</em> <img class="formulaInl" alt="$ \kappa $" src="form_17.png"/> while the background is called <em>lambda</em> <img class="formulaInl" alt="$ \lambda $" src="form_18.png"/> . Any topology has a reversed topology which is the topology <img class="formulaInl" alt="$ (\lambda,\kappa) $" src="form_19.png"/>.</p>
<p>A topology can be a <b>Jordan</b> couple. In this case, some objects of this space have nice properties. The reader is referred to the papers of Herman or to its book <b> Geometry of digital spaces </b>.</p>
<h2><a class="anchor" id="dgtal_topology_sec3_digital_object"></a>
Digital objects</h2>
<p>A digital object is a set of points together with a topology describing how points are close to each others. In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>, they are defined by the template class <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a>, parameterized by the topology (a <a class="el" href="classDGtal_1_1DigitalTopology.html" title="Aim: Represents a digital topology as a couple of adjacency relations.">DigitalTopology</a>) and a digital set of points (any model of <a class="el" href="structDGtal_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">CDigitalSet</a> like <a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim: A container class for storing sets of digital points within some given domain.">DigitalSetBySTLSet</a> or <a class="el" href="classDGtal_1_1DigitalSetBySTLVector.html" title="Aim: Realizes the concept CDigitalSet by using the STL container std::vector.">DigitalSetBySTLVector</a>).</p>
<p>The digital object stores its own set of points with a copy-on-write smart pointer. This means that a digital object can be copied without overhead, and may for instance be passed by value or returned. The input digital set given at construction specifies the domain of the object, which remains the same for the lifetime of the object.</p>
<h3><a class="anchor" id="dgtal_topology_sec3s1"></a>
Construction of digital objects</h3>
<p>A digital object is generally initialized with some given set. The type of the set can be chosen so as to leave to the user the choice of the best set container for the object. You may use the <a class="el" href="structDGtal_1_1DigitalSetSelector.html" title="Aim: Automatically defines an adequate digital set type according to the hints given by the user...">DigitalSetSelector</a> to let the compiler choose your digital set container at compilation time according to some preferences. The choice <a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim: A container class for storing sets of digital points within some given domain.">DigitalSetBySTLSet</a> is the most versatile and generally the most efficient. The choice <a class="el" href="classDGtal_1_1DigitalSetBySTLVector.html" title="Aim: Realizes the concept CDigitalSet by using the STL container std::vector.">DigitalSetBySTLVector</a> is only good for very small objects.</p>
<div class="fragment"><pre class="fragment">   ...
   <span class="keyword">typedef</span> Z3::Point Point;
   <span class="keyword">typedef</span> HyperRectDomain&lt; Z3 &gt; Domain; 
   <span class="keyword">typedef</span> Domain::ConstIterator DomainConstIterator; 
   <span class="keyword">typedef</span> DigitalSetSelector&lt; Domain, BIG_DS+HIGH_BEL_DS &gt;::Type <a class="code" href="namespaceDGtal_1_1Z2i.html#a371252c324e496cf8650757c1a2b4eb0">DigitalSet</a>;
   <span class="keyword">typedef</span> Object&lt;DT6_18, DigitalSet&gt; ObjectType;
  
   Point p1( -50, -50, -50 );
   Point p2( 50, 50, 50 );
   Domain domain( p1, p2 );
   Point c( 0, 0 );
   <span class="comment">// diamond of radius 30</span>
   DigitalSet diamond_set( domain );
   <span class="keywordflow">for</span> ( DomainConstIterator it = domain.begin(); it != domain.end(); ++it )
     {
       <span class="keywordflow">if</span> ( (*it - c ).norm1() &lt;= 30 ) diamond_set.insertNew(  it );
     }
   ObjectType diamond( dt6_18, diamond_set );
   <span class="comment">// The following line takes almost no time.</span>
   ObjectType diamond_clone( diamond );
   <span class="comment">// Since one of the objects is modified, the set is duplicated at the following line</span>
   diamond_clone.pointSet().erase( c );
</pre></div><p>Objects may also be initialized empty, so that you can easily use a container to store them. Of course, they are not valid in this case.</p>
<div class="fragment"><pre class="fragment">   ObjectType object;          <span class="comment">// valid</span>
   <a class="code" href="classvector.html">vector&lt;ObjectType&gt;</a> objects; <span class="comment">// valid</span>
</pre></div><h3><a class="anchor" id="dgtal_topology_sec3s2"></a>
Neighborhood of a point in an object</h3>
<p>An object proposes several methods to return the neighborhood of a given point of the object.</p>
<ul>
<li><a class="el" href="classDGtal_1_1Object.html#a12b692a12fc19a8cbd5aac7bb7a434ff">Object::neighborhood</a>, <a class="el" href="classDGtal_1_1Object.html#ad090874b31428a0745a8801f80ea069c">Object::properNeighborhood</a>: the neighborhoods are returned as objects (with a digital set type considered small).</li>
</ul>
<ul>
<li><a class="el" href="classDGtal_1_1Object.html#ac255de1c228d901493d2e957f11cd74c">Object::neighborhoodSize</a>, <a class="el" href="classDGtal_1_1Object.html#ab315a73a73178bdd7bed00c268e817ea">Object::properNeighborhoodSize</a>: prefer these methods if you only need the cardinal of the neighborhoods and not the neighborhoods itselves</li>
</ul>
<h3><a class="anchor" id="dgtal_topology_sec3s3"></a>
Border of a digital object</h3>
<p>Objects have a border, which are the points which touch the complement in the sense of background adjacency. A border of an object is itself an object, with the same topology as the object.</p>
<div class="fragment"><pre class="fragment">   ObjectType bdiamond = diamond.border(); <span class="comment">// one component</span>
   ObjectType bdiamond_clone = diamond_clone.border(); <span class="comment">// two components</span>
</pre></div><p>The resulting border can be visualized for instance by: (see <a href="3dBorderExtraction_8cpp-example.html">3dBorderExtraction.cpp</a>) </p>
<div class="fragment"><pre class="fragment">Viewer3D viewer;
 viewer.show(); 
 viewer&lt;&lt;  CustomColors3D(QColor(250, 250,250),QColor(250, 250,250));
 viewer &lt;&lt; bdiamond_clone;
 viewer &lt;&lt; bdiamond ;
 viewer &lt;&lt; ClippingPlane(1,1,0,5, <span class="keyword">false</span>)&lt;&lt; <a class="code" href="classDGtal_1_1Display3D.html#a96b45e0a0c762c14c0e5e27045d1ca04a5b467643d3e44661ac96d7c3be38548a">Viewer3D::updateDisplay</a>;
</pre></div><div align="center">
<img src="visuBorderExtraction.png" alt="visuBorderExtraction.png"/>
<p><strong>Border extraction visualisation</strong></p></div>
  see example <a href="3dBorderExtraction_8cpp-example.html">3dBorderExtraction.cpp</a></p>
<div align="center">
<img src="visuBorderExtraction2.png" alt="visuBorderExtraction2.png"/>
<p><strong>Border extraction visualisation from imported volume </strong></p></div>
  see example: <a href="3dBorderExtractionImg_8cpp-example.html">3dBorderExtractionImg.cpp</a></p>
<h3><a class="anchor" id="dgtal_topology_sec3s4"></a>
Connectedness and connected components</h3>
<p>The digital topology induces a connectedness relation on the object (transitive closure of the foreground adjacency) and a connectedness relation on the complement of the set (transitive closure of the background adjacency). Objects may be connected or not. The connectedness is stored with the object, if it is known. The method <a class="el" href="classDGtal_1_1Object.html#ace32f133c27358c6a6432b69e9396976">Object::connectedness</a> returns CONNECTED, DISCONNECTED or UNKNOWN depending on the connectedness of this object and if it has been computed. The method <a class="el" href="classDGtal_1_1Object.html#aca333c9ec8f912928cd31b5843ad93ac">Object::computeConnectedness</a> forces the computation. After this process, the connectedness is either CONNECTED or DISCONNECTED.</p>
<p>Furthermore, you can use the method <a class="el" href="classDGtal_1_1Object.html#ae78e7983e4a3b28696ccf96e1703eeb6">Object::writeComponents</a> to compute all the connected components of this object. It also updates the connectedness of this object to either CONNECTED or DISCONNECTED depending on the number of connected components. Each connected component is of course CONNECTED.</p>
<p>You may use writeComponents as follows:</p>
<div class="fragment"><pre class="fragment">   std::vector&lt; ObjectType &gt; objects;
   std::back_insert_iterator&lt; std::vector&lt; ObjectType &gt; &gt; inserter( objects );
   <span class="comment">// nbc == 1 since the boundary of the diamond is connected.</span>
   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbc = bdiamond.writeComponents( inserter );
   <span class="comment">// nbd == 2 since the boundary of the diamond minus its center is disconnected.</span>
   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbd = bdiamond_clone.writeComponents( inserter );
   <span class="comment">// objects.size() == 3</span>
</pre></div><p>You must be careful when using an output iterator writing in the same container as 'this' object (see <a class="el" href="classDGtal_1_1Object.html#ae78e7983e4a3b28696ccf96e1703eeb6">Object::writeComponents</a>).</p>
<h3><a class="anchor" id="dgtal_topology_sec3s5"></a>
Simple points</h3>
<p>A basic mechanism for simple points is implemented in the <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> class. It relies on the well-known definition of simple points of [Bertrand:1994], based on the number of connected components in a geodesic neighborhood of the point. It is valid in 2D and 3D. It should not be sufficient in nD, since toric connected components may appear. However, you can use it anyway as a kind of "extended" simplicity.</p>
<p>To test if a point is simple for an object, just call the method <a class="el" href="classDGtal_1_1Object.html#a0599b02eb63901e71563ef0e0d9e5ec9">Object::isSimple</a> with the point as parameter. To illustrate this, we give the full code for the homotopic thinning of a shape in 2D and 3D.</p>
<p>The file <a href="homotopicThinning3D_8cpp-example.html">homotopicThinning3D.cpp </a> illustrates the homotopic thinning on a 26_6 object.</p>
<p>First a digital object (with 6_26 adjacency) is defined from a digital set representing two rings : </p>
<div class="fragment"><pre class="fragment">  <span class="keyword">using namespace </span>Z3i;
  ...
  Point p1( -50, -50, -50 );
  Point p2( 50, 50, 50 );
  Domain domain( p1, p2 );
  
  Point ringCenter( 0, 0, 0 );  
  DigitalSet shape_set( domain );
  <span class="keywordflow">for</span> ( <a class="code" href="classDGtal_1_1HyperRectDomain.html#ad460a9309eb81ab5391a57f7d2a17055">Domain::ConstIterator</a> it = domain.begin(); it != domain.end(); ++it )
    {
      <span class="keywordflow">if</span> ( ((*it - ringCenter ).norm() &lt;= 25) &amp;&amp; ((*it - ringCenter ).norm() &gt;= 18)
           &amp;&amp; ( (((*it)[0] &lt;= 3)&amp;&amp; ((*it)[0] &gt;= -3))|| (((*it)[1] &lt;= 3)&amp;&amp; ((*it)[1] &gt;= -3)))){
        shape_set.insertNew( *it );
      }
    }  
  <a class="code" href="namespaceDGtal_1_1Z3i.html#af588ee809267ddd557bc719fbc190925">Object6_26</a> shape( <a class="code" href="namespaceDGtal_1_1Z3i.html#af91ab69d064d580789a2443f4420bb58">dt6_26</a>, shape_set );
</pre></div><p>Then the thinning is performed by testing if a point is simple:</p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> 
    {
      DigitalSet &amp; S = shape.pointSet();
      std::queue&lt;DigitalSet::Iterator&gt; Q;
      <span class="keywordflow">for</span> ( DigitalSet::Iterator it = S.begin(); it != S.end(); ++it )
        <span class="keywordflow">if</span> ( shape.isSimple( *it ) )
          Q.push( it );
      nb_simple = 0;
      <span class="keywordflow">while</span> ( ! Q.empty() )
        {
          DigitalSet::Iterator it = Q.front();
          Q.pop();
          <span class="keywordflow">if</span> ( shape.isSimple( *it ) )
            {
              cerr &lt;&lt; <span class="stringliteral">&quot;point simple &quot;</span> &lt;&lt; (*it) &lt;&lt; endl; 
              S.erase( *it );
              ++nb_simple;
            }
        }
      ++layer;
    }
  <span class="keywordflow">while</span> ( nb_simple != 0 );
</pre></div><p>Finally the result can simply be displayed using <a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a>: </p>
<div class="fragment"><pre class="fragment"> DigitalSet &amp; S = shape.pointSet();

  <span class="comment">// Display by using two different list to manage OpenGL transparency.</span>

  viewer &lt;&lt; SetMode3D( shape_set.styleName(), <span class="stringliteral">&quot;Paving&quot;</span> );
  viewer &lt;&lt; CustomColors3D(QColor(25,25,255, 255), QColor(25,25,255, 255));
  viewer &lt;&lt; S ; 

  viewer &lt;&lt; SetMode3D( shape_set.styleName(), <span class="stringliteral">&quot;PavingTransp&quot;</span> );
  viewer &lt;&lt; CustomColors3D(QColor(250, 0,0, 25), QColor(250, 0,0, 5));
  viewer &lt;&lt; shape_set;

  viewer.updateList();
</pre></div><p>We obtain the following result: </p>
<div align="center">
<img src="visuThinning.png" alt="visuThinning.png"/>
<p><strong>Resulting 3d thinning with the 6_26 object</strong></p></div>
  </div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Tue Sep 27 2011 12:41:24 for DGtal by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
