<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DGtal: DGtal::Surfaces&lt; TKSpace &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DGtal&#160;<span id="projectnumber">0.4.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceDGtal.html">DGtal</a>      </li>
      <li class="navelem"><a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a>  </div>
  <div class="headertitle">
<h1>DGtal::Surfaces&lt; TKSpace &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="DGtal::Surfaces" -->
<p>Aim: A utility class for constructing surfaces (i.e. set of (n-1)-cells).  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>&gt;</code></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef TKSpace&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef KSpace::Integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a91dd49aa1b8c90ceaf595448ce30ebb3">Integer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef KSpace::Point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef KSpace::Cell&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef KSpace::SCell&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef KSpace::DirIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#aea3655c1310aed70fc5fcedaef454d21">DirIterator</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a4a40685150ee27be46185eed33b49582">~Surfaces</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a80771c760a6b1ae094343a2e8011dad3">selfDisplay</a> (std::ostream &amp;out) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a93d3b1bb0ae25b25a2f02b32096c8ea4">isValid</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#ae3713d71a17ff1de88a33ff19b6c53d4">findABel</a> (const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const PointPredicate &amp;pp, unsigned int nbtries=1000)  throw (DGtal::InputException)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a265de9725038fb44bf386ca14d1e7b5d">findABel</a> (const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const PointPredicate &amp;pp, <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> x1, <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> x2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCellSet , typename PointPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#af59cc573fa6a5bb91ccd3ad36d0cc020">trackBoundary</a> (SCellSet &amp;surface, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a7d39d7e0346cb40b279d54a78f90d662">track2DBoundary</a> (std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;aSCellContour2D, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a1428cf57f465c7cfb2903f355e1597e4">track2DBoundary</a> (std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;aSCellContour2D, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> &amp;trackDir, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#add3b2e10ec95914bfde52452f43993f3">track2DBoundaryPoints</a> (std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &gt; &amp;aVectorOfPoints, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#ab4d9405ac313ea198569ffcf8e5c3b5b">extractAllPointContours4C</a> (std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &gt; &gt; &amp;aVectPointContour2D, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; 2 &gt; &amp;aSAdj)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a345390b81108e2f80d36e223b5dee817">extractAll2DSCellContours</a> (std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &gt; &amp;aVectSCellContour2D, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;aSurfelAdj, const PointPredicate &amp;pp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a5319797bafe542d55f080a28db7badee">extractAllConnectedSCell</a> (std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &gt; &amp;aVectConnectedSCell, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;aSurfelAdj, const PointPredicate &amp;pp, bool forceOrientCellExterior=<a class="el" href="namespaceDGtal.html#a3c1454fe50af31341c890919f93b76b6">false</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a8122e9334fa5c07d6c5d6e0d573780fc">orientSCellExterior</a> (std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;aVectOfSCell, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const PointPredicate &amp;pp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCellSet , typename PointPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a58c5cafb4c1a1970db02c975629ee965">trackClosedBoundary</a> (SCellSet &amp;surface, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CellSet , typename PointPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a797775b196e258c19be6aedfd16cbabc">uMakeBoundary</a> (CellSet &amp;aBoundary, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> aLowerBound, const <a class="el" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> aUpperBound)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCellSet , typename PointPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a1a3aa172b06e0a8e9d7e6c9b14495065">sMakeBoundary</a> (SCellSet &amp;aBoundary, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> aLowerBound, const <a class="el" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> aUpperBound)</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#af256c2b3c2af32a9b20e011748382e1b">Surfaces</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a8cab7368470487cee8c10921739f5f23">Surfaces</a> (const <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a31d72cf1ccdf33632636c890e5816d1d">operator=</a> (const <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> &amp;other)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TKSpace&gt;<br/>
 class DGtal::Surfaces&lt; TKSpace &gt;</h3>

<p>Aim: A utility class for constructing surfaces (i.e. set of (n-1)-cells). </p>
<p>Description of template class 'Surfaces' </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">TKSpace</td><td>the type of cellular grid space (e.g. a <a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex...">KhalimskySpaceND</a>).</td></tr>
  </table>
  </dd>
</dl>
<p>Note that many methods requires a surfel adjacency so as to know how connected surfels are linked (first by the interior or first by the exterior). Secondly, many methods are parameterized by a PointPredicate which describes the shape as a characteristic function. This is to be more generic than a simple DigitalSet. With this approach, shapes can be defined implicitly.</p>
<p>Essentially a backport from <a href="https://gforge.liris.cnrs.fr/projects/imagene">ImaGene</a>. </p>
<dl><dt><b>Examples: </b></dt><dd>
<p><a class="el" href="3dKSSurfaceExtraction_8cpp-example.html#_a3">3dKSSurfaceExtraction.cpp</a>, <a class="el" href="ctopo-2-3d_8cpp-example.html#_a12">ctopo-2-3d.cpp</a>, <a class="el" href="ctopo-2_8cpp-example.html#_a9">ctopo-2.cpp</a>, and <a class="el" href="freemanChainFromImage_8cpp-example.html#_a8">freemanChainFromImage.cpp</a>.</p>
</dd>
</dl>
<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00075">75</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a6e02ccfe37b82b2d278d066161f4d1d2"></a><!-- doxytag: member="DGtal::Surfaces::Cell" ref="a6e02ccfe37b82b2d278d066161f4d1d2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KSpace::Cell <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00082">82</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<a class="anchor" id="aea3655c1310aed70fc5fcedaef454d21"></a><!-- doxytag: member="DGtal::Surfaces::DirIterator" ref="aea3655c1310aed70fc5fcedaef454d21" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KSpace::DirIterator <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#aea3655c1310aed70fc5fcedaef454d21">DirIterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00084">84</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<a class="anchor" id="a91dd49aa1b8c90ceaf595448ce30ebb3"></a><!-- doxytag: member="DGtal::Surfaces::Integer" ref="a91dd49aa1b8c90ceaf595448ce30ebb3" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KSpace::Integer <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a91dd49aa1b8c90ceaf595448ce30ebb3">Integer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00080">80</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae254510c81f339dbb5bd4b33ed9f5f3e"></a><!-- doxytag: member="DGtal::Surfaces::KSpace" ref="ae254510c81f339dbb5bd4b33ed9f5f3e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TKSpace <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00079">79</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab58accd9ff51d3cb85f7f4d7e7ed80c5"></a><!-- doxytag: member="DGtal::Surfaces::Point" ref="ab58accd9ff51d3cb85f7f4d7e7ed80c5" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KSpace::Point <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00081">81</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5eaebd043923d70cecb81470431be557"></a><!-- doxytag: member="DGtal::Surfaces::SCell" ref="a5eaebd043923d70cecb81470431be557" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KSpace::SCell <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00083">83</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4a40685150ee27be46185eed33b49582"></a><!-- doxytag: member="DGtal::Surfaces::~Surfaces" ref="a4a40685150ee27be46185eed33b49582" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::~<a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor. </p>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00054">54</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
}
</pre></div>
</div>
</div>
<a class="anchor" id="af256c2b3c2af32a9b20e011748382e1b"></a><!-- doxytag: member="DGtal::Surfaces::Surfaces" ref="af256c2b3c2af32a9b20e011748382e1b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor. Forbidden by default (protected to avoid g++ warnings). </p>

</div>
</div>
<a class="anchor" id="a8cab7368470487cee8c10921739f5f23"></a><!-- doxytag: member="DGtal::Surfaces::Surfaces" ref="a8cab7368470487cee8c10921739f5f23" args="(const Surfaces &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a>&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the object to clone. Forbidden by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a345390b81108e2f80d36e223b5dee817"></a><!-- doxytag: member="DGtal::Surfaces::extractAll2DSCellContours" ref="a345390b81108e2f80d36e223b5dee817" args="(std::vector&lt; std::vector&lt; SCell &gt; &gt; &amp;aVectSCellContour2D, const KSpace &amp;aKSpace, const SurfelAdjacency&lt; KSpace::dimension &gt; &amp;aSurfelAdj, const PointPredicate &amp;pp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::extractAll2DSCellContours </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>aVectSCellContour2D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSurfelAdj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extract all contours as a vector containing the set of contours composed of SCell. Each contour is represented by a vector of signed surfels whose elements represents a boundary component of a digital shape defined by the predicate [pp]. The algorithms tracks surfels along the boundary of the shape.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aSCellContour2D</td><td>(modified) a vector of contour represented by a vector of cells (which are all surfels), containing the ordered list of the boundary component of [spelset].</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space.</td></tr>
    <tr><td class="paramname">aSurfelAdj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00419">419</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  std::set&lt;SCell&gt; bdry;
  <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> low = aKSpace.uFirst(aKSpace.uSpel(aKSpace.lowerBound()));
  <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> upp = aKSpace.uLast(aKSpace.uSpel(aKSpace.upperBound()));
  <a class="code" href="classDGtal_1_1Surfaces.html#a1a3aa172b06e0a8e9d7e6c9b14495065">sMakeBoundary</a>( bdry, aKSpace, pp, low, upp  );
  aVectSCellContour2D.clear();
  <span class="keywordflow">while</span>( ! bdry.empty() )
    {
      std::vector&lt;SCell&gt; aContour;
      <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> aCell = *(bdry.begin()); 
      <a class="code" href="classDGtal_1_1Surfaces.html#a7d39d7e0346cb40b279d54a78f90d662">track2DBoundary</a>( aContour, aKSpace, aSurfelAdj, pp, aCell );
      aVectSCellContour2D.push_back( aContour );
      <span class="comment">// removing cells from boundary;</span>
      <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; aContour.size(); i++ )
  {
    <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> sc = aContour.at(i);
    bdry.erase(sc);
  }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5319797bafe542d55f080a28db7badee"></a><!-- doxytag: member="DGtal::Surfaces::extractAllConnectedSCell" ref="a5319797bafe542d55f080a28db7badee" args="(std::vector&lt; std::vector&lt; SCell &gt; &gt; &amp;aVectConnectedSCell, const KSpace &amp;aKSpace, const SurfelAdjacency&lt; KSpace::dimension &gt; &amp;aSurfelAdj, const PointPredicate &amp;pp, bool forceOrientCellExterior=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::extractAllConnectedSCell </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>aVectConnectedSCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSurfelAdj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceOrientCellExterior</em> = <code><a class="el" href="namespaceDGtal.html#a3c1454fe50af31341c890919f93b76b6">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extract all surfel elements associated to each connected components of the given DigitalSet. The connected surfel set are given as result in a vector containing all components. The orientation of the resulting SCell indicates the exterior orientation according the positive axis.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aVectConnectedSCell</td><td>(modified) a vector containing for each connected components a vector of the sequence of connected SCells.</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space.</td></tr>
    <tr><td class="paramname">aSurfelAdj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape.</td></tr>
    <tr><td class="paramname">forceOrientCellExterior</td><td>if 'true', used to change the default cell orientation in order to get the direction of shape exterior (default =false). This is used only for displaying cells with <a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a>. This mechanism should evolve shortly. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00472">472</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  set&lt;SCell&gt; bdry;

  <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> low = aKSpace.uFirst(aKSpace.uSpel(aKSpace.lowerBound()));
  <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> upp = aKSpace.uLast(aKSpace.uSpel(aKSpace.upperBound()));
  <a class="code" href="classDGtal_1_1Surfaces.html#a1a3aa172b06e0a8e9d7e6c9b14495065">sMakeBoundary</a>( bdry, aKSpace, pp, low, upp  );
  aVectConnectedSCell.clear();
  <span class="keywordflow">while</span>(!bdry.empty()){
    set&lt;SCell&gt;  aConnectedSCellSet;
    <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> aCell = *(bdry.begin()); 
    <a class="code" href="classDGtal_1_1Surfaces.html#af59cc573fa6a5bb91ccd3ad36d0cc020">trackBoundary</a>(aConnectedSCellSet, aKSpace, aSurfelAdj, pp, aCell );
    <span class="comment">//transform into vector&lt;SCell&gt;</span>
    <a class="code" href="classvector.html">vector&lt;SCell&gt;</a> vCS;
    <span class="keywordflow">for</span>(<span class="keyword">typename</span> set&lt;SCell&gt;::iterator it = aConnectedSCellSet.begin(); it!= aConnectedSCellSet.end(); ++it){
      vCS.push_back(*it); 
      <span class="comment">// removing cells from boundary;      </span>
      bdry.erase(*it);
    }
    <span class="keywordflow">if</span>(forceOrientCellExterior){
      <a class="code" href="classDGtal_1_1Surfaces.html#a8122e9334fa5c07d6c5d6e0d573780fc">orientSCellExterior</a>(vCS, aKSpace, pp);
    }
    aVectConnectedSCell.push_back(vCS);
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab4d9405ac313ea198569ffcf8e5c3b5b"></a><!-- doxytag: member="DGtal::Surfaces::extractAllPointContours4C" ref="ab4d9405ac313ea198569ffcf8e5c3b5b" args="(std::vector&lt; std::vector&lt; Point &gt; &gt; &amp;aVectPointContour2D, const KSpace &amp;aKSpace, const PointPredicate &amp;pp, const SurfelAdjacency&lt; 2 &gt; &amp;aSAdj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::extractAllPointContours4C </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>aVectPointContour2D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSAdj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extract all 4-connected contours as a vector containing the sequence of contour Points. Each contour is represented by a vector of points defined by the sequence of pointels extracted from the boundary surfels. Calls extractAll2DSCellContours.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aVectPointContour2D</td><td>(modified) a vector of contour represented by a vector of cells (which are all surfels), containing the ordered list of the boundary component of [pp].</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape.</td></tr>
    <tr><td class="paramname">aSAdj</td><td>the surfel adjacency chosen for the tracking. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00510">510</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  aVectPointContour2D.clear();
  
  std::vector&lt; std::vector&lt;SCell&gt; &gt; vectContoursBdrySCell;
  <a class="code" href="classDGtal_1_1Surfaces.html#a345390b81108e2f80d36e223b5dee817">extractAll2DSCellContours</a>( vectContoursBdrySCell,
           aKSpace, aSAdj, pp );
  
  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt; vectContoursBdrySCell.size(); i++){
    std::vector&lt; Point &gt; aContour;
    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt; vectContoursBdrySCell.at(i).size(); j++){
      <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> sc = vectContoursBdrySCell.at(i).at(j);
      <span class="keywordtype">float</span> x = (float) 
  ( NumberTraits&lt;typename TKSpace::Integer&gt;::castToInt64_t( sc.myCoordinates[0] ) &gt;&gt; 1 );
      <span class="keywordtype">float</span> y = (float) 
  ( NumberTraits&lt;typename TKSpace::Integer&gt;::castToInt64_t( sc.myCoordinates[1] ) &gt;&gt; 1 );
      <span class="keywordtype">bool</span> xodd = ( sc.myCoordinates[ 0 ] &amp; 1 );
      <span class="keywordtype">bool</span> yodd = ( sc.myCoordinates[ 1 ] &amp; 1 );
      <span class="keywordtype">double</span> x0 = !xodd ? x  - 0.5 : (!aKSpace.sSign(sc)? x  - 0.5: x  + 0.5) ;
      <span class="keywordtype">double</span> y0 = !yodd ? y  - 0.5 : (!aKSpace.sSign(sc)? y  - 0.5: y + 0.5);
      <span class="keywordtype">double</span> x1 = !xodd ? x  - 0.5 : (aKSpace.sSign(sc)? x  - 0.5: x  + 0.5) ;
      <span class="keywordtype">double</span> y1 = !yodd ? y  - 0.5 : (aKSpace.sSign(sc)? y  - 0.5: y  + 0.5);      
      
      Point ptA(x0+0.5, y0-0.5);
      Point ptB(x1+0.5, y1-0.5) ;
      aContour.push_back(ptA);
      <span class="keywordflow">if</span>(sc== vectContoursBdrySCell.at(i).at(vectContoursBdrySCell.at(i).size()-1)){
  aContour.push_back(ptB);
      }
    }
    aVectPointContour2D.push_back(aContour);
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a265de9725038fb44bf386ca14d1e7b5d"></a><!-- doxytag: member="DGtal::Surfaces::findABel" ref="a265de9725038fb44bf386ca14d1e7b5d" args="(const KSpace &amp;K, const PointPredicate &amp;pp, Point x1, Point x2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::findABel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a>&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a>&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find a bel in some digital set given two hints (one point inside, one point outside).</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">K</td><td>any cellular grid space.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">x1</td><td>a point within the bounds of K and such that pp( x1 ) != pp( x2 ).</td></tr>
    <tr><td class="paramname">x2</td><td>a point within the bounds of K and such that pp( x1 ) != pp( x2 ).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a signed surfel separating a digital point in [dset] from a face adjacent digital point outside [dset] or throws an <a class="el" href="classDGtal_1_1InputException.html">InputException</a> if none was found after [nbtries] iterations. </dd></dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00100">100</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  BOOST_CONCEPT_ASSERT(( CPointPredicate&lt;PointPredicate&gt; ));
  <span class="comment">// (1) Checks the two candidates in the space.</span>
  <span class="keywordtype">bool</span> val_v1 = pp( x1 ); <span class="comment">// dset.find( x1 ) != dset.end();</span>
  ASSERT( val_v1 != pp( x2 ) );
  <span class="comment">// (2) Find two candidates on the same axis.</span>
  <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> d = 0;
  <span class="keywordtype">bool</span> alreadyOnSameAxis = <span class="keyword">true</span>;
  <span class="keywordflow">for</span> ( <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> i = 0; i &lt; K.dimension; ++i )
    {
      <span class="keywordflow">if</span> ( x1[ i ] != x2[ i ] )
        {
          <span class="keywordflow">for</span> ( <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> j = i + 1; j &lt; K.dimension; ++j )
            {
              <span class="keywordflow">if</span> ( x1[ j ] != x2[ j ] )
              {
                alreadyOnSameAxis = <span class="keyword">false</span>;
                <a class="code" href="classDGtal_1_1Surfaces.html#a91dd49aa1b8c90ceaf595448ce30ebb3">Integer</a> c = x2[ j ];
                x2[ j ] = x1[ j ];
                <span class="keywordtype">bool</span> val_v2 = pp( x2 ); <span class="comment">// dset.find( x2 ) != dset.end();</span>
                <span class="keywordflow">if</span> ( val_v2 != val_v1 )
                  { <span class="comment">// v2 is updated.</span>
                    d = i;
                  }
                <span class="keywordflow">else</span>
                  { <span class="comment">// v1 is updated.</span>
                    x1 = x2;
                    x2[ j ] = c;
                    d = j;
                  }
              } <span class="comment">// if ( x1[ j ] != x2[ j ] )</span>
            } <span class="comment">// for ( Dimension j = i + 1; j &lt; K.dimension; ++j )</span>
          <span class="keywordflow">if</span> ( alreadyOnSameAxis )
            d = i;
        } <span class="comment">// if ( x1[ i ] != x2[ i ] )</span>
    } <span class="comment">// for ( Dimension i = 0; i &lt; K.dimension; ++i )</span>

  <span class="comment">// (3) Check result.</span>
  <span class="keywordflow">for</span> ( <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> i = 0; i &lt; K.dimension; ++i )
    {
      <span class="keywordflow">if</span> ( ( i == d ) &amp;&amp; ( x1[ i ] == x2[ i ] ) )
  std::cerr &lt;&lt; <span class="stringliteral">&quot;[DGtal::Surfaces::findABel] Error 1a along &quot;</span> 
      &lt;&lt; i &lt;&lt; std::endl;
      <span class="keywordflow">if</span> ( ( i != d ) &amp;&amp; ( x1[ i ] != x2[ i ] ) )
  std::cerr &lt;&lt; <span class="stringliteral">&quot;[DGtal::Surfaces::findABel] Error 1b along &quot;</span>
      &lt;&lt; i &lt;&lt; std::endl;
    }
  
  <span class="comment">// (4) Dichotomy</span>
  Point xmid = x1;
  <span class="keywordflow">while</span> ( <span class="keyword">true</span> )
    {
      xmid[ d ] = ( x1[ d ] + x2[ d ] ) / 2;
      <span class="keywordflow">if</span> ( ( xmid[ d ] == x1[ d ] ) || ( xmid[ d ] == x2[ d ] ) )
  <span class="keywordflow">break</span>;
      <span class="keywordtype">bool</span> val_mid = pp( xmid ); <span class="comment">// dset.find( xmid ) != dset.end();</span>
      <span class="keywordflow">if</span> ( val_mid != val_v1 )
  x2[ d ] = xmid[ d ];
      <span class="keywordflow">else</span>
  x1[ d ] = xmid[ d ];
    }
  
  <span class="comment">// (5) Check result.</span>
  <span class="keywordflow">for</span> ( <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> i = 0; i &lt; K.dimension; ++i )
    {
      <span class="comment">// std::cerr &lt;&lt; &quot;i=&quot; &lt;&lt; i &lt;&lt; &quot; x1=&quot; &lt;&lt; x1[ i ] &lt;&lt; &quot; x2=&quot; &lt;&lt; x2[ i ]</span>
      <span class="comment">//     &lt;&lt; std::endl;</span>
      <span class="keywordflow">if</span> ( ( i == d ) &amp;&amp; ( x1[ i ] != x2[ i ] - 1 ) )
  std::cerr &lt;&lt; <span class="stringliteral">&quot;[DGtal::Surfaces::findABel] Error 2a along &quot;</span> 
      &lt;&lt; i &lt;&lt; std::endl;
      <span class="keywordflow">if</span> ( ( i != d ) &amp;&amp; ( x1[ i ] != x2[ i ] ) )
  std::cerr &lt;&lt; <span class="stringliteral">&quot;[DGtal::Surfaces::findABel] Error 2a along &quot;</span>
      &lt;&lt; i &lt;&lt; std::endl;
    }

  <span class="comment">// (6) Computes bel.</span>
  <span class="keywordflow">if</span> ( val_v1 )
    <span class="keywordflow">return</span> K.sIncident( K.sSpel( x1, K.POS ), d, true );
  <span class="keywordflow">else</span>
    <span class="keywordflow">return</span> K.sIncident( K.sSpel( x1, K.NEG ), d, true );
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae3713d71a17ff1de88a33ff19b6c53d4"></a><!-- doxytag: member="DGtal::Surfaces::findABel" ref="ae3713d71a17ff1de88a33ff19b6c53d4" args="(const KSpace &amp;K, const PointPredicate &amp;pp, unsigned int nbtries=1000)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::findABel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nbtries</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw (<a class="el" href="classDGtal_1_1InputException.html">DGtal::InputException</a>)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find a bel in some digital set by random tries then dichotomy.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">K</td><td>any cellular grid space.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">nbries</td><td>the maximum number of random tries (default 1000).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a signed surfel separating a digital point in [dset] from a face adjacent digital point outside [dset] or throws an <a class="el" href="classDGtal_1_1InputException.html">InputException</a> if none was found after [nbtries] iterations. </dd></dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00063">63</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  BOOST_CONCEPT_ASSERT(( CPointPredicate&lt;PointPredicate&gt; ));

  <a class="code" href="classDGtal_1_1InputException.html">DGtal::InputException</a> dgtalerror;
  Point sizes = K.upperBound() - K.lowerBound();
  Point x1 = K.lowerBound();
  Point x2;
  <span class="comment">// (1) Find two candidates in the space.</span>
  <span class="keywordtype">bool</span> val_v1 = pp( x1 ); <span class="comment">// dset.find( x1 ) != dset.end();</span>
  <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;
  <a class="code" href="classDGtal_1_1Surfaces.html#a91dd49aa1b8c90ceaf595448ce30ebb3">Integer</a> r;
  <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; nbtries; ++j )
    {
      <span class="keywordflow">for</span> ( <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> i = 0; i &lt; K.dimension; ++i )
  {
    r = rand();
    x2[ i ] = ( r % sizes[ i ] ) + K.min( i );
  }
      <span class="keywordtype">bool</span> val_v2 = pp( x2 ); <span class="comment">// dset.find( x2 ) != dset.end();</span>
      <span class="keywordflow">if</span> ( val_v2 != val_v1 )
  {
    found = <span class="keyword">true</span>;
    <span class="keywordflow">break</span>;
  }
    }
  <span class="keywordflow">if</span> ( ! found ) <span class="keywordflow">throw</span> dgtalerror;
  <span class="keywordflow">return</span> <a class="code" href="classDGtal_1_1Surfaces.html#ae3713d71a17ff1de88a33ff19b6c53d4">findABel</a>( K, pp, x1, x2 );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a93d3b1bb0ae25b25a2f02b32096c8ea4"></a><!-- doxytag: member="DGtal::Surfaces::isValid" ref="a93d3b1bb0ae25b25a2f02b32096c8ea4" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks the validity/consistency of the object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>'true' if the object is valid, 'false' otherwise. </dd></dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00683">683</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a31d72cf1ccdf33632636c890e5816d1d"></a><!-- doxytag: member="DGtal::Surfaces::operator=" ref="a31d72cf1ccdf33632636c890e5816d1d" args="(const Surfaces &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a>&amp; <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a>&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assignment. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the object to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference on 'this'. Forbidden by default. </dd></dl>

</div>
</div>
<a class="anchor" id="a8122e9334fa5c07d6c5d6e0d573780fc"></a><!-- doxytag: member="DGtal::Surfaces::orientSCellExterior" ref="a8122e9334fa5c07d6c5d6e0d573780fc" args="(std::vector&lt; SCell &gt; &amp;aVectOfSCell, const KSpace &amp;aKSpace, const PointPredicate &amp;pp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::orientSCellExterior </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aVectOfSCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Orient the SCell positively in the direction of the exterior of the DigitalSet aShape. It simply check if the direct incident Cell in the first upper dimension (obtain with sDirectIncident) belongs to the DigitalSet or not.</p>
<p>This method is used to change the default cell orientation in order to get the direction of shape exterior (default =false). This is used only for displaying cells with <a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a>. This mechanism should evolve shortly.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aVectOfSCell</td><td>(modified) a vector containing the SCell to be oriented positively in the direction of the exterior.</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00450">450</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">                                                                      {
  <span class="keywordflow">for</span>( <span class="keyword">typename</span> <a class="code" href="classvector.html">vector&lt;SCell&gt;::iterator</a> it = aVectOfSCell.begin();
       it!=aVectOfSCell.end(); it++){
    <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> incidUpperDim = aKSpace.sDirectIncident(*it, aKSpace.sOrthDir(*it)); 
    <span class="keywordflow">if</span>( pp( aKSpace.sCoords(incidUpperDim) )){
      aKSpace.sSetSign (*it, !aKSpace.sDirect(*it, aKSpace.sOrthDir(*it)) ); 
    }<span class="keywordflow">else</span>{
      aKSpace.sSetSign (*it, aKSpace.sDirect(*it, !aKSpace.sOrthDir(*it)) ); 
    }  
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a80771c760a6b1ae094343a2e8011dad3"></a><!-- doxytag: member="DGtal::Surfaces::selfDisplay" ref="a80771c760a6b1ae094343a2e8011dad3" args="(std::ostream &amp;out) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::selfDisplay </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes/Displays the object on an output stream. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00671">671</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  out &lt;&lt; <span class="stringliteral">&quot;[Surfaces]&quot;</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1a3aa172b06e0a8e9d7e6c9b14495065"></a><!-- doxytag: member="DGtal::Surfaces::sMakeBoundary" ref="a1a3aa172b06e0a8e9d7e6c9b14495065" args="(SCellSet &amp;aBoundary, const KSpace &amp;aKSpace, const PointPredicate &amp;pp, const Cell aLowerBound, const Cell aUpperBound)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename SCellSet , typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::sMakeBoundary </td>
          <td>(</td>
          <td class="paramtype">SCellSet &amp;&#160;</td>
          <td class="paramname"><em>aBoundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a>&#160;</td>
          <td class="paramname"><em>aLowerBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a>&#160;</td>
          <td class="paramname"><em>aUpperBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a set of signed surfels whose elements represents all the boundary components of a digital shape described by the predicate [pp].</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SCellSet</td><td>a model of a set of SCell (e.g., std::set&lt;SCell&gt;). </td></tr>
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aBoundary</td><td>(modified) a set of cells (which are all surfels), the boundary component of [aSpelSet].</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space. </td></tr>
    <tr><td class="paramname">aSurfelAdj</td><td>the surfel adjacency chosen for the tracking. </td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape.</td></tr>
    <tr><td class="paramname">aLowerBound</td><td>and </td></tr>
    <tr><td class="paramname">aUpperBound</td><td>Cell giving the bounds of the extracted boundary. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00631">631</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k;
  <span class="keywordtype">bool</span> in_here, in_further;
 
  <span class="keywordflow">for</span> ( k = 0; k &lt; aKSpace.dimension; ++k )
    {
      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> dir_low_uid = aLowerBound;
      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> dir_up_uid = aKSpace.uGetDecr(aUpperBound, k);
      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> p = dir_low_uid;
      <span class="keywordflow">do</span> 
  {
    in_here = pp( aKSpace.uCoords(p) );
    in_further = pp( aKSpace.uCoords(aKSpace.uGetIncr( p, k )) );
    <span class="keywordflow">if</span> ( in_here != in_further ) <span class="comment">// boundary element</span>
      { <span class="comment">// add it to the set.</span>
        aBoundary.insert( aKSpace.sIncident( aKSpace.signs( p, in_here ),
               k, true ));
      }
  }
      <span class="keywordflow">while</span> ( aKSpace.uNext( p, dir_low_uid, dir_up_uid ) );
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7d39d7e0346cb40b279d54a78f90d662"></a><!-- doxytag: member="DGtal::Surfaces::track2DBoundary" ref="a7d39d7e0346cb40b279d54a78f90d662" args="(std::vector&lt; SCell &gt; &amp;aSCellContour2D, const KSpace &amp;K, const SurfelAdjacency&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const SCell &amp;start_surfel)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::track2DBoundary </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSCellContour2D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a vector of signed surfels whose elements represents a 2D boundary component of a digital shape described by a PointPredicate. The algorithm tracks surfels along the boundary of the shape by starting from the given [start_surfel]. It only tracks the boundary of a 2D shape.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aSCellContour2D</td><td>(modified) a vector of cells (which are all surfels), containing the ordered list of the boundary component of [spelset] which touches [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space of dimension 2.</td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be between an element of [shape] and an element not in [shape]. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00244">244</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>

<p>References <a class="el" href="SurfelNeighborhood_8ih_source.html#l00343">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::getAdjacentOnPointPredicate()</a>, <a class="el" href="SurfelNeighborhood_8ih_source.html#l00086">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::init()</a>, and <a class="el" href="SurfelNeighborhood_8ih_source.html#l00099">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::setSurfel()</a>.</p>
<div class="fragment"><pre class="fragment">{
  BOOST_CONCEPT_ASSERT(( CPointPredicate&lt;PointPredicate&gt; ));
  ASSERT( K.dimension == 2 );

  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> b= start_surfel;  <span class="comment">// current surfel</span>
  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> bn; <span class="comment">// neighboring surfel</span>
  ASSERT( K.sIsSurfel( start_surfel ) );
  <span class="comment">// std::set&lt;SCell&gt; setSurface;</span>
  <span class="comment">// setSurface.insert(start_surfel);</span>
  aSCellContour2D.clear(); <span class="comment">// boundary being extracted.</span>
  aSCellContour2D.push_back(start_surfel);
  SurfelNeighborhood&lt;KSpace&gt; SN;
  SN.init( &amp;K, &amp;surfel_adj, start_surfel );
  SN.setSurfel( b );
  <span class="comment">// search along indirect orientation.</span>
  <span class="keywordtype">bool</span> hasPrevNeighbor =  <span class="keyword">true</span>;
  <span class="keywordflow">while</span> ( hasPrevNeighbor )
    {
      hasPrevNeighbor=<span class="keyword">false</span>;
      <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = *(K.sDirs( b ));
      SN.setSurfel( b );
      <span class="keywordflow">if</span> ( SN.getAdjacentOnPointPredicate( bn, pp, track_dir,  
             ! K.sDirect( b, track_dir ) ) )
  {
    <span class="keywordflow">if</span> ( bn != start_surfel )
      <span class="comment">// if ( setSurface.find( bn ) == setSurface.end() )</span>
      {
        hasPrevNeighbor=<span class="keyword">true</span>;
        aSCellContour2D.push_back( bn );
        <span class="comment">// setSurface.insert(bn);</span>
      }
  }
      b = bn;
    }
  <span class="comment">// since the contour is not necessary closed we search in the other direction.</span>
  reverse(aSCellContour2D.begin(), aSCellContour2D.end());
  <span class="keywordflow">if</span> ( b != start_surfel )
    { <span class="comment">// the contour is necessarily open.</span>
      b = start_surfel; 
      <span class="keywordtype">bool</span> hasNextNeighbor =  <span class="keyword">true</span>;
      <span class="keywordflow">while</span> ( hasNextNeighbor )
  {
    hasNextNeighbor=<span class="keyword">false</span>;
    <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = *(K.sDirs( b ));
    SN.setSurfel( b );
    <span class="keywordflow">if</span> ( SN.getAdjacentOnPointPredicate( bn, pp, track_dir, 
                 K.sDirect( b, track_dir ) ) )
      {
        <span class="comment">// if ( setSurface.find( bn ) == setSurface.end() )</span>
        <span class="comment">// {</span>
        aSCellContour2D.push_back( bn );
        hasNextNeighbor=<span class="keyword">true</span>;
        <span class="comment">// setSurface.insert(bn);</span>
        <span class="comment">// }</span>
      }
    b=bn;
  }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1428cf57f465c7cfb2903f355e1597e4"></a><!-- doxytag: member="DGtal::Surfaces::track2DBoundary" ref="a1428cf57f465c7cfb2903f355e1597e4" args="(std::vector&lt; SCell &gt; &amp;aSCellContour2D, const KSpace &amp;K, const Dimension &amp;trackDir, const SurfelAdjacency&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const SCell &amp;start_surfel)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::track2DBoundary </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSCellContour2D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> &amp;&#160;</td>
          <td class="paramname"><em>trackDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a vector of signed surfels whose elements represents a 2D boundary component of a digital shape described by a PointPredicate. The algorithms tracks surfels along the boundary of the shape by starting from the given [start_surfel], along the direction specified by [trackDir]. More precisely, it is the boundary of the slice of the shape along directions [trackDir] and the orthogonal direction of [start_surfel].</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aSCellContour2D</td><td>(modified) a vector of cells (which are all surfels), containing the ordered list of the boundary component of [spelset] which touches [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space (dimension is arbitrary).</td></tr>
    <tr><td class="paramname">trackDir</td><td>the initial track direction at [start_surfel], should be different from the orthogonal direction of [start_surfel].</td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be between an element of [shape] and an element not in [shape]. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00316">316</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>

<p>References <a class="el" href="SurfelNeighborhood_8ih_source.html#l00343">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::getAdjacentOnPointPredicate()</a>, <a class="el" href="SurfelNeighborhood_8ih_source.html#l00086">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::init()</a>, and <a class="el" href="SurfelNeighborhood_8ih_source.html#l00099">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::setSurfel()</a>.</p>
<div class="fragment"><pre class="fragment">{
  BOOST_CONCEPT_ASSERT(( CPointPredicate&lt;PointPredicate&gt; ));
  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> b= start_surfel;  <span class="comment">// current surfel</span>
  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> bn; <span class="comment">// neighboring surfel</span>
  ASSERT( K.sIsSurfel( start_surfel ) );
  <span class="comment">// std::set&lt;SCell&gt; setSurface;</span>
  <span class="comment">// setSurface.insert(start_surfel);</span>
  aSCellContour2D.clear(); <span class="comment">// boundary being extracted.</span>
  aSCellContour2D.push_back(start_surfel);
  SurfelNeighborhood&lt;KSpace&gt; SN;
  SN.init( &amp;K, &amp;surfel_adj, start_surfel );
  SN.setSurfel( b );
  <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> orthDir = K.sOrthDir( start_surfel );
  <span class="keywordtype">bool</span> hasPrevNeighbor =  <span class="keyword">true</span>;
  <span class="keywordflow">while</span> ( hasPrevNeighbor )
    {
      hasPrevNeighbor=<span class="keyword">false</span>;
      <span class="comment">// search a tracking direction compatible with track/orth direction</span>
      <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = K.sOrthDir( b ) == orthDir ? trackDir : orthDir;
      SN.setSurfel( b );
      <span class="keywordflow">if</span> ( SN.getAdjacentOnPointPredicate( bn, pp, track_dir,
             !K.sDirect( b, track_dir ) ) )
  {
    <span class="keywordflow">if</span> ( bn != start_surfel )
      <span class="comment">//    if ( setSurface.find( bn ) == setSurface.end() )</span>
      {
        hasPrevNeighbor=<span class="keyword">true</span>;
        aSCellContour2D.push_back( bn );
        <span class="comment">// setSurface.insert(bn);</span>
      }
  }
      b = bn;
    }
  <span class="comment">// since the contour is not necessary closed we search in the other direction.</span>
  reverse(aSCellContour2D.begin(), aSCellContour2D.end());
  <span class="keywordflow">if</span> ( b != start_surfel )
    { <span class="comment">// the contour is necessarily open.</span>
      b = start_surfel; 
      <span class="keywordtype">bool</span> hasNextNeighbor =  <span class="keyword">true</span>;
      <span class="keywordflow">while</span> ( hasNextNeighbor )
  {
    hasNextNeighbor=<span class="keyword">false</span>;
    <span class="comment">// search a tracking direction compatible with constant direction</span>
    <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = K.sOrthDir( b ) == orthDir ? trackDir : orthDir;
    SN.setSurfel( b );
    <span class="keywordflow">if</span> ( SN.getAdjacentOnPointPredicate( bn, pp, track_dir, 
                 K.sDirect( b, track_dir ) ) )
      {
        <span class="comment">// if ( setSurface.find( bn ) == setSurface.end() )</span>
        <span class="comment">// {</span>
        aSCellContour2D.push_back( bn );
        <span class="comment">// setSurface.insert(bn);</span>
        hasNextNeighbor=<span class="keyword">true</span>;
        <span class="comment">// }</span>
      }
    b=bn;
  }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="add3b2e10ec95914bfde52452f43993f3"></a><!-- doxytag: member="DGtal::Surfaces::track2DBoundaryPoints" ref="add3b2e10ec95914bfde52452f43993f3" args="(std::vector&lt; Point &gt; &amp;aVectorOfPoints, const KSpace &amp;K, const SurfelAdjacency&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const SCell &amp;start_surfel)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::track2DBoundaryPoints </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aVectorOfPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is only 2D.</p>
<p>This method uses random tries to find a first linel separating an interior pixel from an exterior one. It then follows direct orientations to extract the 4-connected set of points.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aVectorOfPoints</td><td>(returns) the sequence of points of the boundary component of the digitized shape containing [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space of dimension 2.</td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be between an element of [shape] and an element not in [shape]. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00388">388</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  aVectorOfPoints.clear();
  
  <span class="comment">// Getting the consecutive surfels of the 2D boundary</span>
  std::vector&lt;SCell&gt; vectBdrySCell;
  <a class="code" href="classDGtal_1_1Surfaces.html#a7d39d7e0346cb40b279d54a78f90d662">Surfaces&lt;KSpace&gt;::track2DBoundary</a>( vectBdrySCell,
             K, surfel_adj, pp, start_surfel );
  <span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;SCell&gt;::const_iterator SCellConstIterator;
  <span class="keywordflow">for</span> ( SCellConstIterator it = vectBdrySCell.begin(),
    it_end = vectBdrySCell.end(); 
  it != it_end; ++it )
    {
      <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track = *( K.sDirs( *it ) );
      <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> pointel = K.sIndirectIncident( *it, track );
      aVectorOfPoints.push_back( K.sCoords( pointel ) );
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="af59cc573fa6a5bb91ccd3ad36d0cc020"></a><!-- doxytag: member="DGtal::Surfaces::trackBoundary" ref="af59cc573fa6a5bb91ccd3ad36d0cc020" args="(SCellSet &amp;surface, const KSpace &amp;K, const SurfelAdjacency&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const SCell &amp;start_surfel)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename SCellSet , typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::trackBoundary </td>
          <td>(</td>
          <td class="paramtype">SCellSet &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a set of signed surfels whose elements represents a boundary component of a digital shape described by a PointPredicate. The algorithms tracks surfels along the boundary of the shape.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SCellSet</td><td>a model of a set of SCell (e.g., std::set&lt;SCell&gt;).</td></tr>
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>(modified) a set of cells (which are all surfels), the boundary component of [spelset] which touches [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space. </td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be between an element of [shape] and an element not in [shape]. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00189">189</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>

<p>References <a class="el" href="SurfelNeighborhood_8ih_source.html#l00343">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::getAdjacentOnPointPredicate()</a>, <a class="el" href="SurfelNeighborhood_8ih_source.html#l00086">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::init()</a>, and <a class="el" href="SurfelNeighborhood_8ih_source.html#l00099">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::setSurfel()</a>.</p>
<div class="fragment"><pre class="fragment">{
  BOOST_CONCEPT_ASSERT(( CPointPredicate&lt;PointPredicate&gt; ));

  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> b;  <span class="comment">// current surfel</span>
  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> bn; <span class="comment">// neighboring surfel</span>
  ASSERT( K.sIsSurfel( start_surfel ) );
  surface.clear(); <span class="comment">// boundary being extracted.</span>

  SurfelNeighborhood&lt;KSpace&gt; SN;
  SN.init( &amp;K, &amp;surfel_adj, start_surfel );
  std::queue&lt;SCell&gt; qbels;
  qbels.push( start_surfel );
  surface.insert( start_surfel );
  <span class="comment">// For all pending bels</span>
  <span class="keywordflow">while</span> ( ! qbels.empty() )
    {
      b = qbels.front();
      qbels.pop();
      SN.setSurfel( b );
      <span class="keywordflow">for</span> ( <a class="code" href="classDGtal_1_1Surfaces.html#aea3655c1310aed70fc5fcedaef454d21">DirIterator</a> q = K.sDirs( b ); q != 0; ++q )
  {
    <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = *q;
    <span class="comment">// ----- 1st pass with positive orientation ------</span>
    <span class="keywordflow">if</span> ( SN.getAdjacentOnPointPredicate( bn, pp, track_dir, <span class="keyword">true</span> ) )
      {
        <span class="keywordflow">if</span> ( surface.find( bn ) == surface.end() )
    {
      surface.insert( bn );
      qbels.push( bn );
    }
      }
    <span class="comment">// ----- 2nd pass with negative orientation ------</span>
    <span class="keywordflow">if</span> ( SN.getAdjacentOnPointPredicate( bn, pp, track_dir, <span class="keyword">false</span> ) )
      {
        <span class="keywordflow">if</span> ( surface.find( bn ) == surface.end() )
    {
      surface.insert( bn );
      qbels.push( bn );
    }
      }
  } <span class="comment">// for ( DirIterator q = K.sDirs( b ); q != 0; ++q )</span>
    } <span class="comment">// while ( ! qbels.empty() )</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a58c5cafb4c1a1970db02c975629ee965"></a><!-- doxytag: member="DGtal::Surfaces::trackClosedBoundary" ref="a58c5cafb4c1a1970db02c975629ee965" args="(SCellSet &amp;surface, const KSpace &amp;K, const SurfelAdjacency&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const SCell &amp;start_surfel)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename SCellSet , typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::trackClosedBoundary </td>
          <td>(</td>
          <td class="paramtype">SCellSet &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a set of signed surfels whose elements represents a boundary component of a digital shape described by a PointPredicate. The algorithms tracks surfels along the boundary of the shape. It follows only direct orientations, so that it is faster than trackBoundary but requires the object to be fully inside the space. Follows the idea of Artzy, Frieder and Herman algorithm [Artzy:1981-cgip], but in nD.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SCellSet</td><td>a model of a set of SCell (e.g., std::set&lt;SCell&gt;).</td></tr>
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>(modified) a set of cells (which are all surfels), the boundary component of [spelset] which touches [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space. </td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be between an element of [shape] and an element not in [shape]. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00554">554</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>

<p>References <a class="el" href="SurfelNeighborhood_8ih_source.html#l00343">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::getAdjacentOnPointPredicate()</a>, <a class="el" href="SurfelNeighborhood_8ih_source.html#l00086">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::init()</a>, and <a class="el" href="SurfelNeighborhood_8ih_source.html#l00099">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::setSurfel()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> b;  <span class="comment">// current surfel</span>
  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> bn; <span class="comment">// neighboring surfel</span>
  ASSERT( K.sIsSurfel( start_surfel ) );
  surface.clear(); <span class="comment">// boundary being extracted.</span>

  SurfelNeighborhood&lt;KSpace&gt; SN;
  SN.init( &amp;K, &amp;surfel_adj, start_surfel );
  std::queue&lt;SCell&gt; qbels;
  qbels.push( start_surfel );
  surface.insert( start_surfel );
  <span class="comment">// For all pending bels</span>
  <span class="keywordflow">while</span> ( ! qbels.empty() )
    {
      b = qbels.front();
      qbels.pop();
      SN.setSurfel( b );
      <span class="keywordflow">for</span> ( <a class="code" href="classDGtal_1_1Surfaces.html#aea3655c1310aed70fc5fcedaef454d21">DirIterator</a> q = K.sDirs( b ); q != 0; ++q )
  {
    <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = *q;
    <span class="comment">// ----- One pass, look for direct orientation ------</span>
    <span class="keywordflow">if</span> ( SN.getAdjacentOnPointPredicate( bn, pp, track_dir, 
                 K.sDirect( b, track_dir ) ) )
      {
        <span class="keywordflow">if</span> ( surface.find( bn ) == surface.end() )
    {
      surface.insert( bn );
      qbels.push( bn );
    }
      }
  } <span class="comment">// for ( DirIterator q = K.sDirs( b ); q != 0; ++q )</span>
    } <span class="comment">// while ( ! qbels.empty() )</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a797775b196e258c19be6aedfd16cbabc"></a><!-- doxytag: member="DGtal::Surfaces::uMakeBoundary" ref="a797775b196e258c19be6aedfd16cbabc" args="(CellSet &amp;aBoundary, const KSpace &amp;aKSpace, const PointPredicate &amp;pp, const Cell aLowerBound, const Cell aUpperBound)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename CellSet , typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::uMakeBoundary </td>
          <td>(</td>
          <td class="paramtype">CellSet &amp;&#160;</td>
          <td class="paramname"><em>aBoundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a>&#160;</td>
          <td class="paramname"><em>aLowerBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a>&#160;</td>
          <td class="paramname"><em>aUpperBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a set of unsigned surfels whose elements represents all the boundary components of a digital shape described by the predicate [pp].</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">CellSet</td><td>a model of a set of Cell (e.g., std::set&lt;Cell&gt;). </td></tr>
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aBoundary</td><td>(modified) a set of cells (which are all surfels), the boundary component of [aSpelSet].</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space. </td></tr>
    <tr><td class="paramname">aSurfelAdj</td><td>the surfel adjacency chosen for the tracking. </td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape.</td></tr>
    <tr><td class="paramname">aLowerBound</td><td>and </td></tr>
    <tr><td class="paramname">aUpperBound</td><td>Cell giving the bounds of the extracted boundary. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00597">597</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k;
  <span class="keywordtype">bool</span> in_here, in_further;
  <span class="keywordflow">for</span> ( k = 0; k &lt; aKSpace.dimension; ++k )
    {
      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> dir_low_uid = aLowerBound;
      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> dir_up_uid = aKSpace.uGetDecr(aUpperBound, k);
      
      
      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> p = dir_low_uid;
      <span class="keywordflow">do</span> 
  {
    in_here = pp( aKSpace.uCoords(p) );
    in_further = pp( aKSpace.uCoords(aKSpace.uGetIncr( p, k )) );
    <span class="keywordflow">if</span> ( in_here != in_further ) <span class="comment">// boundary element</span>
      { <span class="comment">// add it to the set.</span>
        aBoundary.insert( aKSpace.uIncident( p, k, <span class="keyword">true</span> ));
      }
  }
      <span class="keywordflow">while</span> ( aKSpace.uNext( p, dir_low_uid, dir_up_uid ) );
    }
}
</pre></div>
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Surfaces_8h_source.html">Surfaces.h</a></li>
<li><a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Tue Sep 27 2011 12:41:28 for DGtal by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
