<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: DGtal::ConvexityHelper&lt; dim, TInteger, TInternalInteger &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('structDGtal_1_1ConvexityHelper.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">DGtal::ConvexityHelper&lt; dim, TInteger, TInternalInteger &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Aim: Provides a set of functions to facilitate the computation of convex hulls and polytopes, as well as shortcuts to build cell complex representing a Delaunay complex.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ConvexityHelper_8h_source.html">DGtal/geometry/volumes/ConvexityHelper.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DGtal::ConvexityHelper&lt; dim, TInteger, TInternalInteger &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="structDGtal_1_1ConvexityHelper__inherit__graph.svg" width="231" height="148"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad380b949243419e4b5fabe43bffee2e0" id="r_ad380b949243419e4b5fabe43bffee2e0"><td class="memItemLeft" align="right" valign="top">typedef TInteger&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad380b949243419e4b5fabe43bffee2e0">Integer</a></td></tr>
<tr class="memitem:a1dd70c507242e3ead97785077ab7f9f8" id="r_a1dd70c507242e3ead97785077ab7f9f8"><td class="memItemLeft" align="right" valign="top">typedef TInternalInteger&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1dd70c507242e3ead97785077ab7f9f8">InternalInteger</a></td></tr>
<tr class="memitem:afe8cac6f8d5afa382692903c464632c9" id="r_afe8cac6f8d5afa382692903c464632c9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classDGtal_1_1SpaceND.html">SpaceND</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, <a class="el" href="#ad380b949243419e4b5fabe43bffee2e0">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe8cac6f8d5afa382692903c464632c9">Space</a></td></tr>
<tr class="memitem:a3dc92942e3a6bed2067f60ac0aa99f88" id="r_a3dc92942e3a6bed2067f60ac0aa99f88"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classDGtal_1_1SpaceND.html#a34beb5f81d0848e8ae393f39a1422ebc">Space::Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a></td></tr>
<tr class="memitem:a7db043d3453f1ffa0903c2f4c7cd8d87" id="r_a7db043d3453f1ffa0903c2f4c7cd8d87"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classDGtal_1_1SpaceND.html#ae194f4dfc28465ea14b437c066e69604">Space::Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7db043d3453f1ffa0903c2f4c7cd8d87">Vector</a></td></tr>
<tr class="memitem:a4e6cf430725ebe7d5536067c59c1f9a9" id="r_a4e6cf430725ebe7d5536067c59c1f9a9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classDGtal_1_1SpaceND.html#a615c8017e5750e191610f48dcf968bb5">Space::RealPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e6cf430725ebe7d5536067c59c1f9a9">RealPoint</a></td></tr>
<tr class="memitem:a543a4cc392a17f54107de302ab43b307" id="r_a543a4cc392a17f54107de302ab43b307"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classDGtal_1_1SpaceND.html#ac103823b62d88adef786537c9c2a77fb">Space::RealVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a543a4cc392a17f54107de302ab43b307">RealVector</a></td></tr>
<tr class="memitem:aff80f51adcc33e67115b84ccec7a1a9d" id="r_aff80f51adcc33e67115b84ccec7a1a9d"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff80f51adcc33e67115b84ccec7a1a9d">Size</a></td></tr>
<tr class="memitem:a9f0157a9eafaf366e11c4efd515c6de8" id="r_a9f0157a9eafaf366e11c4efd515c6de8"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f0157a9eafaf366e11c4efd515c6de8">Index</a></td></tr>
<tr class="memitem:ab80376ba7f51b5156ba26eb9e91f364e" id="r_ab80376ba7f51b5156ba26eb9e91f364e"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="#a9f0157a9eafaf366e11c4efd515c6de8">Index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab80376ba7f51b5156ba26eb9e91f364e">IndexRange</a></td></tr>
<tr class="memitem:afc3a1ef390f6664bdf70bc1c52f32a62" id="r_afc3a1ef390f6664bdf70bc1c52f32a62"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc3a1ef390f6664bdf70bc1c52f32a62">PointRange</a></td></tr>
<tr class="memitem:ab7d9bd9a99bba5cb39b8b04cba3fb51c" id="r_ab7d9bd9a99bba5cb39b8b04cba3fb51c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structDGtal_1_1ConvexHullIntegralKernel.html">ConvexHullIntegralKernel</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, <a class="el" href="#ad380b949243419e4b5fabe43bffee2e0">Integer</a>, <a class="el" href="#a1dd70c507242e3ead97785077ab7f9f8">InternalInteger</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7d9bd9a99bba5cb39b8b04cba3fb51c">LatticeConvexHullKernel</a></td></tr>
<tr class="memitem:a6c9f1ad880860633843ead77adc35d07" id="r_a6c9f1ad880860633843ead77adc35d07"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structDGtal_1_1ConvexHullRationalKernel.html">ConvexHullRationalKernel</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, <a class="el" href="#ad380b949243419e4b5fabe43bffee2e0">Integer</a>, <a class="el" href="#a1dd70c507242e3ead97785077ab7f9f8">InternalInteger</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c9f1ad880860633843ead77adc35d07">RealConvexHullKernel</a></td></tr>
<tr class="memitem:a2c8fd125483a923334d5cecaa3d07c05" id="r_a2c8fd125483a923334d5cecaa3d07c05"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structDGtal_1_1DelaunayIntegralKernel.html">DelaunayIntegralKernel</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, <a class="el" href="#ad380b949243419e4b5fabe43bffee2e0">Integer</a>, <a class="el" href="#a1dd70c507242e3ead97785077ab7f9f8">InternalInteger</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c8fd125483a923334d5cecaa3d07c05">LatticeDelaunayKernel</a></td></tr>
<tr class="memitem:af74aa57b8fe7b365773d7b9730467b3d" id="r_af74aa57b8fe7b365773d7b9730467b3d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structDGtal_1_1DelaunayRationalKernel.html">DelaunayRationalKernel</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, <a class="el" href="#ad380b949243419e4b5fabe43bffee2e0">Integer</a>, <a class="el" href="#a1dd70c507242e3ead97785077ab7f9f8">InternalInteger</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af74aa57b8fe7b365773d7b9730467b3d">RealDelaunayKernel</a></td></tr>
<tr class="memitem:af47e8b71056789970556433d41788138" id="r_af47e8b71056789970556433d41788138"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; <a class="el" href="#afe8cac6f8d5afa382692903c464632c9">Space</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af47e8b71056789970556433d41788138">LatticePolytope</a></td></tr>
<tr class="memitem:a6c9e0e8e7c870660573b627f3afa1a28" id="r_a6c9e0e8e7c870660573b627f3afa1a28"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; <a class="el" href="#afe8cac6f8d5afa382692903c464632c9">Space</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c9e0e8e7c870660573b627f3afa1a28">RationalPolytope</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2fe85eb80b944c815453c928e90122d1" id="r_a2fe85eb80b944c815453c928e90122d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fe85eb80b944c815453c928e90122d1">BOOST_STATIC_ASSERT</a> (<a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a> &gt; 1)</td></tr>
<tr class="memitem:a3c0458667843659bb49f161d162ce9c1" id="r_a3c0458667843659bb49f161d162ce9c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c0458667843659bb49f161d162ce9c1">BOOST_CONCEPT_ASSERT</a> ((<a class="el" href="structDGtal_1_1concepts_1_1CInteger.html">concepts::CInteger</a>&lt; TInteger &gt;))</td></tr>
<tr class="memitem:aceb5b57048ca82b32ec1cd818d65f65c" id="r_aceb5b57048ca82b32ec1cd818d65f65c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aceb5b57048ca82b32ec1cd818d65f65c">BOOST_CONCEPT_ASSERT</a> ((<a class="el" href="structDGtal_1_1concepts_1_1CInteger.html">concepts::CInteger</a>&lt; TInternalInteger &gt;))</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr id="pub-static-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Lattice convex hull services</div></td></tr>
<tr class="memitem:af88821410e5a9327537ee884249d7034" id="r_af88821410e5a9327537ee884249d7034"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#af47e8b71056789970556433d41788138">LatticePolytope</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af88821410e5a9327537ee884249d7034">computeLatticePolytope</a> (const <a class="el" href="#afc3a1ef390f6664bdf70bc1c52f32a62">PointRange</a> &amp;input_points, bool remove_duplicates=true, bool make_minkowski_summable=false)</td></tr>
<tr class="memitem:a04169b86b5cbe5cacce6537040f428ac" id="r_a04169b86b5cbe5cacce6537040f428ac"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#afc3a1ef390f6664bdf70bc1c52f32a62">PointRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04169b86b5cbe5cacce6537040f428ac">computeConvexHullVertices</a> (const <a class="el" href="#afc3a1ef390f6664bdf70bc1c52f32a62">PointRange</a> &amp;input_points, bool remove_duplicates=true)</td></tr>
<tr class="memitem:aebe6bd050526a9d387cb5db806f3f355" id="r_aebe6bd050526a9d387cb5db806f3f355"><td class="memTemplParams" colspan="2">template&lt;typename TSurfaceMesh&gt; </td></tr>
<tr class="memitem:aebe6bd050526a9d387cb5db806f3f355 template"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebe6bd050526a9d387cb5db806f3f355">computeConvexHullBoundary</a> (TSurfaceMesh &amp;mesh, const <a class="el" href="#afc3a1ef390f6664bdf70bc1c52f32a62">PointRange</a> &amp;input_points, bool remove_duplicates=true)</td></tr>
<tr class="memitem:aa24dbd82ee2d96fd42e44dde11f71ea8" id="r_aa24dbd82ee2d96fd42e44dde11f71ea8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa24dbd82ee2d96fd42e44dde11f71ea8">computeConvexHullBoundary</a> (<a class="el" href="classDGtal_1_1PolygonalSurface.html">PolygonalSurface</a>&lt; <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &gt; &amp;polysurf, const <a class="el" href="#afc3a1ef390f6664bdf70bc1c52f32a62">PointRange</a> &amp;input_points, bool remove_duplicates=true)</td></tr>
<tr class="memitem:a7f27945d82a9b55537ad5b49c3e70b1c" id="r_a7f27945d82a9b55537ad5b49c3e70b1c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f27945d82a9b55537ad5b49c3e70b1c">computeConvexHullCellComplex</a> (<a class="el" href="structDGtal_1_1ConvexCellComplex.html">ConvexCellComplex</a>&lt; <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &gt; &amp;cell_complex, const <a class="el" href="#afc3a1ef390f6664bdf70bc1c52f32a62">PointRange</a> &amp;input_points, bool remove_duplicates=true)</td></tr>
<tr class="memitem:a299c2da4588ed410b579774d6105fd3c" id="r_a299c2da4588ed410b579774d6105fd3c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#af47e8b71056789970556433d41788138">LatticePolytope</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a299c2da4588ed410b579774d6105fd3c">computeSimplex</a> (const <a class="el" href="#afc3a1ef390f6664bdf70bc1c52f32a62">PointRange</a> &amp;input_points, bool remove_duplicates=true)</td></tr>
<tr class="memitem:a87114a82134eb84357435e3a18fe4bb1" id="r_a87114a82134eb84357435e3a18fe4bb1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#af47e8b71056789970556433d41788138">LatticePolytope</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87114a82134eb84357435e3a18fe4bb1">computeDegeneratedLatticePolytope</a> (<a class="el" href="#afc3a1ef390f6664bdf70bc1c52f32a62">PointRange</a> &amp;input_points)</td></tr>
<tr class="memitem:a2e72ce3d62b44089e2e22152e4d3bf0d" id="r_a2e72ce3d62b44089e2e22152e4d3bf0d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#afc3a1ef390f6664bdf70bc1c52f32a62">PointRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e72ce3d62b44089e2e22152e4d3bf0d">computeDegeneratedConvexHullVertices</a> (<a class="el" href="#afc3a1ef390f6664bdf70bc1c52f32a62">PointRange</a> &amp;input_points)</td></tr>
<tr class="memitem:acf0712e736c29abed972506333b048ba" id="r_acf0712e736c29abed972506333b048ba"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#af47e8b71056789970556433d41788138">LatticePolytope</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf0712e736c29abed972506333b048ba">compute3DTriangle</a> (const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;a, const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;b, const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;c, bool make_minkowski_summable=false)</td></tr>
<tr class="memitem:a9af49cd1f33718562bb6dda976d938eb" id="r_a9af49cd1f33718562bb6dda976d938eb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#af47e8b71056789970556433d41788138">LatticePolytope</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9af49cd1f33718562bb6dda976d938eb">compute3DOpenTriangle</a> (const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;a, const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;b, const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;c, bool make_minkowski_summable=false)</td></tr>
<tr class="memitem:a6993e5f812474cafa35e030dd288de9c" id="r_a6993e5f812474cafa35e030dd288de9c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#af47e8b71056789970556433d41788138">LatticePolytope</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6993e5f812474cafa35e030dd288de9c">computeDegeneratedTriangle</a> (const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;a, const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;b, const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;c)</td></tr>
<tr class="memitem:a631da3c93606979b8f651fb27da991a1" id="r_a631da3c93606979b8f651fb27da991a1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#af47e8b71056789970556433d41788138">LatticePolytope</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a631da3c93606979b8f651fb27da991a1">computeSegment</a> (const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;a, const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;b)</td></tr>
<tr class="memitem:aa70821b1ec8bd2fc6749f536f3386c5c" id="r_aa70821b1ec8bd2fc6749f536f3386c5c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#af47e8b71056789970556433d41788138">LatticePolytope</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa70821b1ec8bd2fc6749f536f3386c5c">computeOpenSegment</a> (const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;a, const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;b)</td></tr>
<tr id="pub-static-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Lattice Delaunay services</div></td></tr>
<tr class="memitem:a19314769e3ba486f8751bbdce97d3a5c" id="r_a19314769e3ba486f8751bbdce97d3a5c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19314769e3ba486f8751bbdce97d3a5c">computeDelaunayCellComplex</a> (<a class="el" href="structDGtal_1_1ConvexCellComplex.html">ConvexCellComplex</a>&lt; <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &gt; &amp;cell_complex, const <a class="el" href="#afc3a1ef390f6664bdf70bc1c52f32a62">PointRange</a> &amp;input_points, bool remove_duplicates=true)</td></tr>
<tr id="pub-static-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Rational convex hull services</div></td></tr>
<tr class="memitem:a7379862326baa896c4ea93a05f8147bd" id="r_a7379862326baa896c4ea93a05f8147bd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a6c9e0e8e7c870660573b627f3afa1a28">RationalPolytope</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7379862326baa896c4ea93a05f8147bd">computeRationalPolytope</a> (const std::vector&lt; <a class="el" href="#a4e6cf430725ebe7d5536067c59c1f9a9">RealPoint</a> &gt; &amp;input_points, <a class="el" href="#ad380b949243419e4b5fabe43bffee2e0">Integer</a> denominator, bool remove_duplicates=true, bool make_minkowski_summable=false)</td></tr>
<tr class="memitem:ab5167e5428cd248f8381c0f1d2899822" id="r_ab5167e5428cd248f8381c0f1d2899822"><td class="memTemplParams" colspan="2">template&lt;typename TSurfaceMesh&gt; </td></tr>
<tr class="memitem:ab5167e5428cd248f8381c0f1d2899822 template"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5167e5428cd248f8381c0f1d2899822">computeConvexHullBoundary</a> (TSurfaceMesh &amp;mesh, const std::vector&lt; <a class="el" href="#a4e6cf430725ebe7d5536067c59c1f9a9">RealPoint</a> &gt; &amp;input_points, double precision=1024.0, bool remove_duplicates=true)</td></tr>
<tr class="memitem:a242379823d41a6a2514ee696e00785d1" id="r_a242379823d41a6a2514ee696e00785d1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a242379823d41a6a2514ee696e00785d1">computeConvexHullBoundary</a> (<a class="el" href="classDGtal_1_1PolygonalSurface.html">PolygonalSurface</a>&lt; <a class="el" href="#a4e6cf430725ebe7d5536067c59c1f9a9">RealPoint</a> &gt; &amp;polysurf, const std::vector&lt; <a class="el" href="#a4e6cf430725ebe7d5536067c59c1f9a9">RealPoint</a> &gt; &amp;input_points, double precision=1024.0, bool remove_duplicates=true)</td></tr>
<tr class="memitem:afce39494f87458a7eff21a4d9c3c253f" id="r_afce39494f87458a7eff21a4d9c3c253f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afce39494f87458a7eff21a4d9c3c253f">computeConvexHullCellComplex</a> (<a class="el" href="structDGtal_1_1ConvexCellComplex.html">ConvexCellComplex</a>&lt; <a class="el" href="#a4e6cf430725ebe7d5536067c59c1f9a9">RealPoint</a> &gt; &amp;cell_complex, const std::vector&lt; <a class="el" href="#a4e6cf430725ebe7d5536067c59c1f9a9">RealPoint</a> &gt; &amp;input_points, double precision=1024.0, bool remove_duplicates=true)</td></tr>
<tr id="pub-static-methods-3" class="groupHeader"><td colspan="2"><div class="groupHeader">Real Delaunay services</div></td></tr>
<tr class="memitem:a1f766bc6da6bc3a783d673255d311cd1" id="r_a1f766bc6da6bc3a783d673255d311cd1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f766bc6da6bc3a783d673255d311cd1">computeDelaunayCellComplex</a> (<a class="el" href="structDGtal_1_1ConvexCellComplex.html">ConvexCellComplex</a>&lt; <a class="el" href="#a4e6cf430725ebe7d5536067c59c1f9a9">RealPoint</a> &gt; &amp;cell_complex, const std::vector&lt; <a class="el" href="#a4e6cf430725ebe7d5536067c59c1f9a9">RealPoint</a> &gt; &amp;input_points, double precision=1024.0, bool remove_duplicates=true)</td></tr>
<tr id="pub-static-methods-4" class="groupHeader"><td colspan="2"><div class="groupHeader">Utility services</div></td></tr>
<tr class="memitem:a1dcc1a6135fa3dd99a3856314ad839dd" id="r_a1dcc1a6135fa3dd99a3856314ad839dd"><td class="memTemplParams" colspan="2">template&lt;typename QHull&gt; </td></tr>
<tr class="memitem:a1dcc1a6135fa3dd99a3856314ad839dd template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1dcc1a6135fa3dd99a3856314ad839dd">computeFacetAndRidgeVertices</a> (const QHull &amp;hull, std::vector&lt; <a class="el" href="#ab80376ba7f51b5156ba26eb9e91f364e">IndexRange</a> &gt; &amp;cell_vertices, std::map&lt; typename QHull::Ridge, <a class="el" href="#a9f0157a9eafaf366e11c4efd515c6de8">Index</a> &gt; &amp;r2f, std::vector&lt; <a class="el" href="#ab80376ba7f51b5156ba26eb9e91f364e">IndexRange</a> &gt; &amp;face_vertices)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a556209b9719d1be518d335b6821bf549" id="r_a556209b9719d1be518d335b6821bf549"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a556209b9719d1be518d335b6821bf549">dimension</a> = <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt;<br />
struct DGtal::ConvexityHelper&lt; dim, TInteger, TInternalInteger &gt;</div><p>Aim: Provides a set of functions to facilitate the computation of convex hulls and polytopes, as well as shortcuts to build cell complex representing a Delaunay complex. </p>
<p>Description of template class '<a class="el" href="structDGtal_1_1ConvexityHelper.html" title="Aim: Provides a set of functions to facilitate the computation of convex hulls and polytopes,...">ConvexityHelper</a>' </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>the dimension of the space where points and further objects live.</td></tr>
    <tr><td class="paramname">TInteger</td><td>the integral type used to define the digital space, a model of <a class="el" href="structDGtal_1_1concepts_1_1CInteger.html" title="Aim: Concept checking for Integer Numbers. More precisely, this concept is a refinement of both CEucl...">concepts::CInteger</a>. It sets the coordinate type of input lattice points as well as output integral convex hulls and lattice polytopes.</td></tr>
    <tr><td class="paramname">TInternalInteger</td><td>the integer type that is used for internal computations of above/below plane tests, a model of <a class="el" href="structDGtal_1_1concepts_1_1CInteger.html" title="Aim: Concept checking for Integer Numbers. More precisely, this concept is a refinement of both CEucl...">concepts::CInteger</a>. Must be at least as precise as TCoordinateInteger.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="moduleQuickHull.html">QuickHull algorithm in arbitrary dimension for convex hull and Delaunay cell complex computation</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="geometry_2tools_2exampleLatticeBallDelaunay3D_8cpp-example.html#_a5">geometry/tools/exampleLatticeBallDelaunay3D.cpp</a>, <a class="el" href="geometry_2tools_2exampleRationalBallDelaunay3D_8cpp-example.html#_a6">geometry/tools/exampleRationalBallDelaunay3D.cpp</a>, <a class="el" href="geometry_2volumes_2exampleBoundedLatticePolytopeCount2D_8cpp-example.html#_a2">geometry/volumes/exampleBoundedLatticePolytopeCount2D.cpp</a>, <a class="el" href="geometry_2volumes_2exampleBoundedLatticePolytopeCount3D_8cpp-example.html#_a2">geometry/volumes/exampleBoundedLatticePolytopeCount3D.cpp</a>, and <a class="el" href="geometry_2volumes_2exampleBoundedLatticePolytopeCount4D_8cpp-example.html#_a2">geometry/volumes/exampleBoundedLatticePolytopeCount4D.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ConvexityHelper_8h_source.html#l00154">154</a> of file <a class="el" href="ConvexityHelper_8h_source.html">ConvexityHelper.h</a>.</p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a9f0157a9eafaf366e11c4efd515c6de8" name="a9f0157a9eafaf366e11c4efd515c6de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0157a9eafaf366e11c4efd515c6de8">&#9670;&#160;</a></span>Index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;<a class="el" href="fullConvexitySphereGeodesics_8cpp.html#ab053a8ae7537e4f87fa9a46962f7617a">::Index</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvexityHelper_8h_source.html#l00171">171</a> of file <a class="el" href="ConvexityHelper_8h_source.html">ConvexityHelper.h</a>.</p>

</div>
</div>
<a id="ab80376ba7f51b5156ba26eb9e91f364e" name="ab80376ba7f51b5156ba26eb9e91f364e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80376ba7f51b5156ba26eb9e91f364e">&#9670;&#160;</a></span>IndexRange</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; <a class="el" href="#a9f0157a9eafaf366e11c4efd515c6de8">Index</a> &gt; <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::IndexRange</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvexityHelper_8h_source.html#l00172">172</a> of file <a class="el" href="ConvexityHelper_8h_source.html">ConvexityHelper.h</a>.</p>

</div>
</div>
<a id="ad380b949243419e4b5fabe43bffee2e0" name="ad380b949243419e4b5fabe43bffee2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad380b949243419e4b5fabe43bffee2e0">&#9670;&#160;</a></span>Integer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TInteger <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;<a class="el" href="examplePlaneProbingParallelepipedEstimator_8cpp.html#ad31c3eca44cf6770809bc47f2b456212">::Integer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvexityHelper_8h_source.html#l00163">163</a> of file <a class="el" href="ConvexityHelper_8h_source.html">ConvexityHelper.h</a>.</p>

</div>
</div>
<a id="a1dd70c507242e3ead97785077ab7f9f8" name="a1dd70c507242e3ead97785077ab7f9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd70c507242e3ead97785077ab7f9f8">&#9670;&#160;</a></span>InternalInteger</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TInternalInteger <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;<a class="el" href="greedy-plane-segmentation-ex2_8cpp.html#aec66eb43935379dd86245097a9c70bac">::InternalInteger</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvexityHelper_8h_source.html#l00164">164</a> of file <a class="el" href="ConvexityHelper_8h_source.html">ConvexityHelper.h</a>.</p>

</div>
</div>
<a id="ab7d9bd9a99bba5cb39b8b04cba3fb51c" name="ab7d9bd9a99bba5cb39b8b04cba3fb51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d9bd9a99bba5cb39b8b04cba3fb51c">&#9670;&#160;</a></span>LatticeConvexHullKernel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structDGtal_1_1ConvexHullIntegralKernel.html">ConvexHullIntegralKernel</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, <a class="el" href="#ad380b949243419e4b5fabe43bffee2e0">Integer</a>, <a class="el" href="#a1dd70c507242e3ead97785077ab7f9f8">InternalInteger</a> &gt; <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::LatticeConvexHullKernel</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvexityHelper_8h_source.html#l00175">175</a> of file <a class="el" href="ConvexityHelper_8h_source.html">ConvexityHelper.h</a>.</p>

</div>
</div>
<a id="a2c8fd125483a923334d5cecaa3d07c05" name="a2c8fd125483a923334d5cecaa3d07c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8fd125483a923334d5cecaa3d07c05">&#9670;&#160;</a></span>LatticeDelaunayKernel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structDGtal_1_1DelaunayIntegralKernel.html">DelaunayIntegralKernel</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, <a class="el" href="#ad380b949243419e4b5fabe43bffee2e0">Integer</a>, <a class="el" href="#a1dd70c507242e3ead97785077ab7f9f8">InternalInteger</a> &gt; <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::LatticeDelaunayKernel</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvexityHelper_8h_source.html#l00179">179</a> of file <a class="el" href="ConvexityHelper_8h_source.html">ConvexityHelper.h</a>.</p>

</div>
</div>
<a id="af47e8b71056789970556433d41788138" name="af47e8b71056789970556433d41788138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47e8b71056789970556433d41788138">&#9670;&#160;</a></span>LatticePolytope</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">BoundedLatticePolytope</a>&lt; <a class="el" href="#afe8cac6f8d5afa382692903c464632c9">Space</a> &gt; <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::LatticePolytope</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvexityHelper_8h_source.html#l00182">182</a> of file <a class="el" href="ConvexityHelper_8h_source.html">ConvexityHelper.h</a>.</p>

</div>
</div>
<a id="a3dc92942e3a6bed2067f60ac0aa99f88" name="a3dc92942e3a6bed2067f60ac0aa99f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc92942e3a6bed2067f60ac0aa99f88">&#9670;&#160;</a></span>Point</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classDGtal_1_1SpaceND.html#a34beb5f81d0848e8ae393f39a1422ebc">Space::Point</a> <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;<a class="el" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">::Point</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvexityHelper_8h_source.html#l00166">166</a> of file <a class="el" href="ConvexityHelper_8h_source.html">ConvexityHelper.h</a>.</p>

</div>
</div>
<a id="afc3a1ef390f6664bdf70bc1c52f32a62" name="afc3a1ef390f6664bdf70bc1c52f32a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3a1ef390f6664bdf70bc1c52f32a62">&#9670;&#160;</a></span>PointRange</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &gt; <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;<a class="el" href="digitalPolyhedronBuilder3D_8cpp.html#a7e851e605c414ed13c6604af4bba8107">::PointRange</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvexityHelper_8h_source.html#l00173">173</a> of file <a class="el" href="ConvexityHelper_8h_source.html">ConvexityHelper.h</a>.</p>

</div>
</div>
<a id="a6c9e0e8e7c870660573b627f3afa1a28" name="a6c9e0e8e7c870660573b627f3afa1a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9e0e8e7c870660573b627f3afa1a28">&#9670;&#160;</a></span>RationalPolytope</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope</a>&lt; <a class="el" href="#afe8cac6f8d5afa382692903c464632c9">Space</a> &gt; <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::RationalPolytope</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvexityHelper_8h_source.html#l00183">183</a> of file <a class="el" href="ConvexityHelper_8h_source.html">ConvexityHelper.h</a>.</p>

</div>
</div>
<a id="a6c9f1ad880860633843ead77adc35d07" name="a6c9f1ad880860633843ead77adc35d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9f1ad880860633843ead77adc35d07">&#9670;&#160;</a></span>RealConvexHullKernel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structDGtal_1_1ConvexHullRationalKernel.html">ConvexHullRationalKernel</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, <a class="el" href="#ad380b949243419e4b5fabe43bffee2e0">Integer</a>, <a class="el" href="#a1dd70c507242e3ead97785077ab7f9f8">InternalInteger</a> &gt; <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::RealConvexHullKernel</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvexityHelper_8h_source.html#l00177">177</a> of file <a class="el" href="ConvexityHelper_8h_source.html">ConvexityHelper.h</a>.</p>

</div>
</div>
<a id="af74aa57b8fe7b365773d7b9730467b3d" name="af74aa57b8fe7b365773d7b9730467b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74aa57b8fe7b365773d7b9730467b3d">&#9670;&#160;</a></span>RealDelaunayKernel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structDGtal_1_1DelaunayRationalKernel.html">DelaunayRationalKernel</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, <a class="el" href="#ad380b949243419e4b5fabe43bffee2e0">Integer</a>, <a class="el" href="#a1dd70c507242e3ead97785077ab7f9f8">InternalInteger</a> &gt; <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::RealDelaunayKernel</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvexityHelper_8h_source.html#l00181">181</a> of file <a class="el" href="ConvexityHelper_8h_source.html">ConvexityHelper.h</a>.</p>

</div>
</div>
<a id="a4e6cf430725ebe7d5536067c59c1f9a9" name="a4e6cf430725ebe7d5536067c59c1f9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6cf430725ebe7d5536067c59c1f9a9">&#9670;&#160;</a></span>RealPoint</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classDGtal_1_1SpaceND.html#a615c8017e5750e191610f48dcf968bb5">Space::RealPoint</a> <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;<a class="el" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">::RealPoint</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvexityHelper_8h_source.html#l00168">168</a> of file <a class="el" href="ConvexityHelper_8h_source.html">ConvexityHelper.h</a>.</p>

</div>
</div>
<a id="a543a4cc392a17f54107de302ab43b307" name="a543a4cc392a17f54107de302ab43b307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543a4cc392a17f54107de302ab43b307">&#9670;&#160;</a></span>RealVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classDGtal_1_1SpaceND.html#ac103823b62d88adef786537c9c2a77fb">Space::RealVector</a> <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::RealVector</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvexityHelper_8h_source.html#l00169">169</a> of file <a class="el" href="ConvexityHelper_8h_source.html">ConvexityHelper.h</a>.</p>

</div>
</div>
<a id="aff80f51adcc33e67115b84ccec7a1a9d" name="aff80f51adcc33e67115b84ccec7a1a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff80f51adcc33e67115b84ccec7a1a9d">&#9670;&#160;</a></span>Size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;<a class="el" href="testHalfEdgeDataStructure_8cpp.html#a1aba5499fd29449181365ce424303a10">::Size</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvexityHelper_8h_source.html#l00170">170</a> of file <a class="el" href="ConvexityHelper_8h_source.html">ConvexityHelper.h</a>.</p>

</div>
</div>
<a id="afe8cac6f8d5afa382692903c464632c9" name="afe8cac6f8d5afa382692903c464632c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8cac6f8d5afa382692903c464632c9">&#9670;&#160;</a></span>Space</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classDGtal_1_1SpaceND.html">SpaceND</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, <a class="el" href="#ad380b949243419e4b5fabe43bffee2e0">Integer</a> &gt; <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;<a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a38dfaf1641eab4d3fb805df4b52ab10d">::Space</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvexityHelper_8h_source.html#l00165">165</a> of file <a class="el" href="ConvexityHelper_8h_source.html">ConvexityHelper.h</a>.</p>

</div>
</div>
<a id="a7db043d3453f1ffa0903c2f4c7cd8d87" name="a7db043d3453f1ffa0903c2f4c7cd8d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db043d3453f1ffa0903c2f4c7cd8d87">&#9670;&#160;</a></span>Vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classDGtal_1_1SpaceND.html#ae194f4dfc28465ea14b437c066e69604">Space::Vector</a> <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;<a class="el" href="examplePlaneProbingParallelepipedEstimator_8cpp.html#a23c0623485ed9af765bab12ac424843c">::Vector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvexityHelper_8h_source.html#l00167">167</a> of file <a class="el" href="ConvexityHelper_8h_source.html">ConvexityHelper.h</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a3c0458667843659bb49f161d162ce9c1" name="a3c0458667843659bb49f161d162ce9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0458667843659bb49f161d162ce9c1">&#9670;&#160;</a></span>BOOST_CONCEPT_ASSERT() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::BOOST_CONCEPT_ASSERT </td>
          <td>(</td>
          <td class="paramtype">(<a class="el" href="structDGtal_1_1concepts_1_1CInteger.html">concepts::CInteger</a>&lt; TInteger &gt;)</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aceb5b57048ca82b32ec1cd818d65f65c" name="aceb5b57048ca82b32ec1cd818d65f65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb5b57048ca82b32ec1cd818d65f65c">&#9670;&#160;</a></span>BOOST_CONCEPT_ASSERT() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::BOOST_CONCEPT_ASSERT </td>
          <td>(</td>
          <td class="paramtype">(<a class="el" href="structDGtal_1_1concepts_1_1CInteger.html">concepts::CInteger</a>&lt; TInternalInteger &gt;)</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2fe85eb80b944c815453c928e90122d1" name="a2fe85eb80b944c815453c928e90122d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe85eb80b944c815453c928e90122d1">&#9670;&#160;</a></span>BOOST_STATIC_ASSERT()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::BOOST_STATIC_ASSERT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9af49cd1f33718562bb6dda976d938eb" name="a9af49cd1f33718562bb6dda976d938eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af49cd1f33718562bb6dda976d938eb">&#9670;&#160;</a></span>compute3DOpenTriangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af47e8b71056789970556433d41788138">LatticePolytope</a> <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::compute3DOpenTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>make_minkowski_summable</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the lattice polytope enclosing an open triangle in dimension 3. Takes care of degeneracies (non distinct points or alignment).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>any point </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">b</td><td>any point </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">c</td><td>any point</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">make_minkowski_summable</td><td>Other constraints are added so that we can perform axis aligned Minkowski sums on this polytope. Useful for checking full convexity (see moduleDigitalConvexity).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tightiest bounded lattice polytope (i.e. H-representation) including the given open triangle (i.e. without edges and vertices).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Implemented only in 3D. </dd></dl>

</div>
</div>
<a id="acf0712e736c29abed972506333b048ba" name="acf0712e736c29abed972506333b048ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf0712e736c29abed972506333b048ba">&#9670;&#160;</a></span>compute3DTriangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af47e8b71056789970556433d41788138">LatticePolytope</a> <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::compute3DTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>make_minkowski_summable</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the lattice polytope enclosing a triangle in dimension 3. Takes care of degeneracies (non distinct points or alignment).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>any point </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">b</td><td>any point </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">c</td><td>any point</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">make_minkowski_summable</td><td>Other constraints are added so that we can perform axis aligned Minkowski sums on this polytope. Useful for checking full convexity (see moduleDigitalConvexity).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tightiest bounded lattice polytope (i.e. H-representation) including the given triangle.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Implemented only in 3D. </dd></dl>

</div>
</div>
<a id="aa24dbd82ee2d96fd42e44dde11f71ea8" name="aa24dbd82ee2d96fd42e44dde11f71ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24dbd82ee2d96fd42e44dde11f71ea8">&#9670;&#160;</a></span>computeConvexHullBoundary() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::computeConvexHullBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PolygonalSurface.html">PolygonalSurface</a>&lt; <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>polysurf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#afc3a1ef390f6664bdf70bc1c52f32a62">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>remove_duplicates</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes a polygonal surface representation of the boundary of the convex hull of the given lattice points.</p>
<dl class="section note"><dt>Note</dt><dd>Since it builds a surface, this method is thus 3D.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">polysurf</td><td>the output polygonal surface that represents the boundary of the convex hull of the given range of points. Its euler characteristic should be 0 in even dimension, 2 in odd dimension.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_points</td><td>the range of input lattice points.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remove_duplicates</td><td>should be set to 'true' if the input data has duplicates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the input points were full dimensional and the output surface is correct, otherwise return 'false'. </dd></dl>

</div>
</div>
<a id="a242379823d41a6a2514ee696e00785d1" name="a242379823d41a6a2514ee696e00785d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242379823d41a6a2514ee696e00785d1">&#9670;&#160;</a></span>computeConvexHullBoundary() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::computeConvexHullBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PolygonalSurface.html">PolygonalSurface</a>&lt; <a class="el" href="#a4e6cf430725ebe7d5536067c59c1f9a9">RealPoint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>polysurf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="#a4e6cf430725ebe7d5536067c59c1f9a9">RealPoint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>input_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>precision</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1024.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>remove_duplicates</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes a polygonal surface representation of the boundary of the rational polytope that approximates the convex hull of the given real points.</p>
<dl class="section note"><dt>Note</dt><dd>Since it builds a surface, this method is thus 3D.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">polysurf</td><td>the output polygonal surface mesh that represents the boundary of the convex hull of the given range of points.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_points</td><td>the range of input real points.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precision</td><td>the scaling factor that is used to multiply each real coordinate before rounding it to an integer, a kind of common denominator if you think of the result as a rational number.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remove_duplicates</td><td>should be set to 'true' if the input data has duplicates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the input points were full dimensional and the output mesh is correct, otherwise return 'false'. </dd></dl>

</div>
</div>
<a id="aebe6bd050526a9d387cb5db806f3f355" name="aebe6bd050526a9d387cb5db806f3f355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe6bd050526a9d387cb5db806f3f355">&#9670;&#160;</a></span>computeConvexHullBoundary() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
<div class="memtemplate">
template&lt;typename TSurfaceMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::computeConvexHullBoundary </td>
          <td>(</td>
          <td class="paramtype">TSurfaceMesh &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#afc3a1ef390f6664bdf70bc1c52f32a62">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>remove_duplicates</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes a surface mesh representation of the boundary of the convex hull of the given lattice points.</p>
<dl class="section note"><dt>Note</dt><dd>Since it builds a surface, this method is thus 3D.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSurfaceMesh</td><td>any model of surface that can be initialized with a range of input positions (cast as real coordinates) and a range of index ranges giving for each face its range of incident vertices. For instance, you may use class <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">mesh</td><td>the output surface mesh that represents the boundary of the convex hull of the given range of points.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_points</td><td>the range of input lattice points.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remove_duplicates</td><td>should be set to 'true' if the input data has duplicates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the input points were full dimensional and the output mesh is correct, otherwise return 'false'. </dd></dl>

</div>
</div>
<a id="ab5167e5428cd248f8381c0f1d2899822" name="ab5167e5428cd248f8381c0f1d2899822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5167e5428cd248f8381c0f1d2899822">&#9670;&#160;</a></span>computeConvexHullBoundary() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
<div class="memtemplate">
template&lt;typename TSurfaceMesh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::computeConvexHullBoundary </td>
          <td>(</td>
          <td class="paramtype">TSurfaceMesh &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="#a4e6cf430725ebe7d5536067c59c1f9a9">RealPoint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>input_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>precision</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1024.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>remove_duplicates</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes a surface mesh representation of the boundary of the rational polytope that approximates the convex hull of the given real points.</p>
<dl class="section note"><dt>Note</dt><dd>Since it builds a surface, this method is thus 3D.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSurfaceMesh</td><td>any model of surface that can be initialized with a range of input positions (cast as real coordinates) and a range of index ranges giving for each face its range of incident vertices. For instance, you may use class <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">mesh</td><td>the output surface mesh that represents the boundary of the convex hull of the given range of points.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_points</td><td>the range of input real points.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precision</td><td>the scaling factor that is used to multiply each real coordinate before rounding it to an integer, a kind of common denominator if you think of the result as a rational number.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remove_duplicates</td><td>should be set to 'true' if the input data has duplicates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the input points were full dimensional and the output mesh is correct, otherwise return 'false'. </dd></dl>

</div>
</div>
<a id="a7f27945d82a9b55537ad5b49c3e70b1c" name="a7f27945d82a9b55537ad5b49c3e70b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f27945d82a9b55537ad5b49c3e70b1c">&#9670;&#160;</a></span>computeConvexHullCellComplex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::computeConvexHullCellComplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ConvexCellComplex.html">ConvexCellComplex</a>&lt; <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cell_complex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#afc3a1ef390f6664bdf70bc1c52f32a62">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>remove_duplicates</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes a cell complex representing the convex hull of the given lattice points, formed of one maximal dimension cell and as many cells of codimension 1 as the number of facets of the convex hull.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">cell_complex</td><td>the output cell complex that represents the convex hull of the given lattice points.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_points</td><td>the range of input lattice points.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remove_duplicates</td><td>should be set to 'true' if the input data has duplicates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the input points were full dimensional and the output complex is correct, otherwise return 'false'. </dd></dl>

</div>
</div>
<a id="afce39494f87458a7eff21a4d9c3c253f" name="afce39494f87458a7eff21a4d9c3c253f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce39494f87458a7eff21a4d9c3c253f">&#9670;&#160;</a></span>computeConvexHullCellComplex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::computeConvexHullCellComplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ConvexCellComplex.html">ConvexCellComplex</a>&lt; <a class="el" href="#a4e6cf430725ebe7d5536067c59c1f9a9">RealPoint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cell_complex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="#a4e6cf430725ebe7d5536067c59c1f9a9">RealPoint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>input_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>precision</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1024.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>remove_duplicates</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes a cell complex representing the convex hull of the given real points, formed of one maximal dimension cell and as many cells of codimension 1 as the number of facets of the convex hull.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">cell_complex</td><td>the output cell complex that represents the convex hull of the given real points.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_points</td><td>the range of input real points.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precision</td><td>the scaling factor that is used to multiply each real coordinate before rounding it to an integer, a kind of common denominator if you think of the result as a rational number.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remove_duplicates</td><td>should be set to 'true' if the input data has duplicates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the input points were full dimensional and the output complex is correct, otherwise return 'false'. </dd></dl>

</div>
</div>
<a id="a04169b86b5cbe5cacce6537040f428ac" name="a04169b86b5cbe5cacce6537040f428ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04169b86b5cbe5cacce6537040f428ac">&#9670;&#160;</a></span>computeConvexHullVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#afc3a1ef390f6664bdf70bc1c52f32a62">PointRange</a> <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::computeConvexHullVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#afc3a1ef390f6664bdf70bc1c52f32a62">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>remove_duplicates</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes and returns the vertices of the tightiest lattice polytope enclosing all the given input lattice points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_points</td><td>the range of input lattice points.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remove_duplicates</td><td>should be set to 'true' if the input data has duplicates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vertices of the tightiest bounded lattice polytope including the given range of points, or an empty range if the dimension is greater than 3 and the given range of points is not full. </dd></dl>

</div>
</div>
<a id="a2e72ce3d62b44089e2e22152e4d3bf0d" name="a2e72ce3d62b44089e2e22152e4d3bf0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e72ce3d62b44089e2e22152e4d3bf0d">&#9670;&#160;</a></span>computeDegeneratedConvexHullVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#afc3a1ef390f6664bdf70bc1c52f32a62">PointRange</a> <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::computeDegeneratedConvexHullVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afc3a1ef390f6664bdf70bc1c52f32a62">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input_points</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the vertices of the tightiest lattice polytope enclosing a range of distinct points, arranged such that they do not form a full dimensional polytope.</p>
<dl class="section note"><dt>Note</dt><dd>Called internally by ConvexityHelper::computeLatticePolytopeVertices.</dd>
<dd>
This function works for dimension no greater than 3.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">input_points</td><td>a range of distinct points, which may be changed by the method. More precisely a point may be added (in 3D) to complete the set of points so that it forms a full dimensional polytope.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vertices of the tightiest bounded lattice polytope including the given range of points, or an empty set of vertices if the given range of points was not full dimensional and dimension was greater than 3. </dd></dl>

</div>
</div>
<a id="a87114a82134eb84357435e3a18fe4bb1" name="a87114a82134eb84357435e3a18fe4bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87114a82134eb84357435e3a18fe4bb1">&#9670;&#160;</a></span>computeDegeneratedLatticePolytope()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af47e8b71056789970556433d41788138">LatticePolytope</a> <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::computeDegeneratedLatticePolytope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afc3a1ef390f6664bdf70bc1c52f32a62">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input_points</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the lattice polytope enclosing a range of distinct points, arranged such that they do not form a full dimensional polytope.</p>
<dl class="section note"><dt>Note</dt><dd>Called internally by <a class="el" href="#af88821410e5a9327537ee884249d7034">ConvexityHelper::computeLatticePolytope</a> and <a class="el" href="#a299c2da4588ed410b579774d6105fd3c">ConvexityHelper::computeSimplex</a>.</dd>
<dd>
This function works for dimension no greater than 3.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">input_points</td><td>a range of distinct points, which may be changed by the method. More precisely a point may be added (in 3D) to complete the set of points so that it forms a full dimensional polytope.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tightiest bounded lattice polytope (i.e. H-representation) including the given range of points, or an empty polytope if the given range of points was not full dimensional and dimension was greater than 3. </dd></dl>

</div>
</div>
<a id="a6993e5f812474cafa35e030dd288de9c" name="a6993e5f812474cafa35e030dd288de9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6993e5f812474cafa35e030dd288de9c">&#9670;&#160;</a></span>computeDegeneratedTriangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af47e8b71056789970556433d41788138">LatticePolytope</a> <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::computeDegeneratedTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the lattice polytope enclosing a degenerated triangle. The points must be aligned (or non distinct).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>any point </td></tr>
    <tr><td class="paramname">b</td><td>any point </td></tr>
    <tr><td class="paramname">c</td><td>any point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tightiest bounded lattice polytope (i.e. H-representation) including the given range of points. </dd></dl>

</div>
</div>
<a id="a19314769e3ba486f8751bbdce97d3a5c" name="a19314769e3ba486f8751bbdce97d3a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19314769e3ba486f8751bbdce97d3a5c">&#9670;&#160;</a></span>computeDelaunayCellComplex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::computeDelaunayCellComplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ConvexCellComplex.html">ConvexCellComplex</a>&lt; <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cell_complex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#afc3a1ef390f6664bdf70bc1c52f32a62">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>remove_duplicates</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the Delaunay cell complex associated to the given range of input points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">cell_complex</td><td>the output cell complex that represents the Delaunay complex of the given lattice points.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_points</td><td>the range of input lattice points.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remove_duplicates</td><td>should be set to 'true' if the input data has duplicates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the input points were full dimensional and the output complex is correct, otherwise return 'false'.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The Delaunay cell complex may not be simplicial if some points are cospherical. </dd></dl>

<p class="reference">Referenced by <a class="el" href="exampleLatticeBallDelaunay3D_8cpp_source.html#l00060">main()</a>.</p>

</div>
</div>
<a id="a1f766bc6da6bc3a783d673255d311cd1" name="a1f766bc6da6bc3a783d673255d311cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f766bc6da6bc3a783d673255d311cd1">&#9670;&#160;</a></span>computeDelaunayCellComplex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::computeDelaunayCellComplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ConvexCellComplex.html">ConvexCellComplex</a>&lt; <a class="el" href="#a4e6cf430725ebe7d5536067c59c1f9a9">RealPoint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cell_complex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="#a4e6cf430725ebe7d5536067c59c1f9a9">RealPoint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>input_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>precision</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1024.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>remove_duplicates</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the Delaunay cell complex associated to the given range of input real points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">cell_complex</td><td>the output cell complex that represents the Delaunay complex of the given lattice points.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_points</td><td>the range of input real points.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precision</td><td>the scaling factor that is used to multiply each real coordinate before rounding it to an integer, a kind of common denominator if you think of the result as a rational number.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remove_duplicates</td><td>should be set to 'true' if the input data has duplicates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the input points were full dimensional and the output complex is correct, otherwise return 'false'.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The Delaunay cell complex may not be simplicial if some points are cospherical. </dd></dl>

</div>
</div>
<a id="a1dcc1a6135fa3dd99a3856314ad839dd" name="a1dcc1a6135fa3dd99a3856314ad839dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dcc1a6135fa3dd99a3856314ad839dd">&#9670;&#160;</a></span>computeFacetAndRidgeVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
<div class="memtemplate">
template&lt;typename QHull&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::computeFacetAndRidgeVertices </td>
          <td>(</td>
          <td class="paramtype">const QHull &amp;</td>          <td class="paramname"><span class="paramname"><em>hull</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="#ab80376ba7f51b5156ba26eb9e91f364e">IndexRange</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cell_vertices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; typename QHull::Ridge, <a class="el" href="#a9f0157a9eafaf366e11c4efd515c6de8">Index</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>r2f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="#ab80376ba7f51b5156ba26eb9e91f364e">IndexRange</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>face_vertices</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">QHull</td><td>any <a class="el" href="structDGtal_1_1QuickHull.html" title="Aim: Implements the quickhull algorithm by Barber et al. barber1996, a famous arbitrary dimensional c...">QuickHull</a> concrete type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hull</td><td>a computed <a class="el" href="structDGtal_1_1QuickHull.html" title="Aim: Implements the quickhull algorithm by Barber et al. barber1996, a famous arbitrary dimensional c...">QuickHull</a> object</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cell_vertices</td><td>the vector giving for each cell the indices of its vertices.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r2f</td><td>the map giving for each ridge (i.e. the pair of cells defining each face) the index of its corresponding face.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">face_vertices</td><td>the vector giving for each face the indices of its vertices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">hull.status() &gt;= Status::VerticesCompleted</span> and <span class="tt">hull.status() &lt;= Status::AllCompleted</span> </dd></dl>

</div>
</div>
<a id="af88821410e5a9327537ee884249d7034" name="af88821410e5a9327537ee884249d7034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88821410e5a9327537ee884249d7034">&#9670;&#160;</a></span>computeLatticePolytope()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af47e8b71056789970556433d41788138">LatticePolytope</a> <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::computeLatticePolytope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#afc3a1ef390f6664bdf70bc1c52f32a62">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>remove_duplicates</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>make_minkowski_summable</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes and returns a halfspace representation of the tightiest lattice polytope enclosing all the given input lattice points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_points</td><td>the range of input lattice points.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remove_duplicates</td><td>should be set to 'true' if the input data has duplicates.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">make_minkowski_summable</td><td>Other constraints are added so that we can perform axis aligned Minkowski sums on this polytope. Useful for checking full convexity (see moduleDigitalConvexity).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tightiest bounded lattice polytope (i.e. H-representation) including the given range of points, or an empty range if the dimension is greater than 3 and the given range of points is not full. </dd></dl>

<p class="reference">Referenced by <a class="el" href="PConvexity_8h_source.html#l00155">DGtal::detail::RecursivePConvexity&lt; dim - 1, Integer &gt;::convexityMeasure()</a>, and <a class="el" href="PConvexity_8h_source.html#l00100">DGtal::detail::RecursivePConvexity&lt; dim - 1, Integer &gt;::is0Convex()</a>.</p>

</div>
</div>
<a id="aa70821b1ec8bd2fc6749f536f3386c5c" name="aa70821b1ec8bd2fc6749f536f3386c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70821b1ec8bd2fc6749f536f3386c5c">&#9670;&#160;</a></span>computeOpenSegment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af47e8b71056789970556433d41788138">LatticePolytope</a> <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::computeOpenSegment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the lattice polytope enclosing an open segment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>any point </td></tr>
    <tr><td class="paramname">b</td><td>any point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tightiest bounded lattice polytope (i.e. H-representation) including the open segment <span class="tt">]a,b[</span>. It is always Minkowski summable.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Implemented only in 3D. </dd></dl>

</div>
</div>
<a id="a7379862326baa896c4ea93a05f8147bd" name="a7379862326baa896c4ea93a05f8147bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7379862326baa896c4ea93a05f8147bd">&#9670;&#160;</a></span>computeRationalPolytope()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6c9e0e8e7c870660573b627f3afa1a28">RationalPolytope</a> <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::computeRationalPolytope </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="#a4e6cf430725ebe7d5536067c59c1f9a9">RealPoint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>input_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad380b949243419e4b5fabe43bffee2e0">Integer</a></td>          <td class="paramname"><span class="paramname"><em>denominator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>remove_duplicates</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>make_minkowski_summable</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes and returns a halfspace representation of the tightiest rational polytope enclosing all the given input real points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_points</td><td>the range of input real points.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">denominator</td><td>the denominator used in all rational approximations of points with real value coordinates, the higher the more precise.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remove_duplicates</td><td>should be set to 'true' if the input data has duplicates.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">make_minkowski_summable</td><td>Other constraints are added so that we can perform axis aligned Minkowski sums on this polytope. Useful for checking full convexity (see moduleDigitalConvexity).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tightiest bounded lattice polytope (i.e. H-representation) including the given range of points, or an empty polytope if the given range of points was not full dimensional. </dd></dl>

</div>
</div>
<a id="a631da3c93606979b8f651fb27da991a1" name="a631da3c93606979b8f651fb27da991a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631da3c93606979b8f651fb27da991a1">&#9670;&#160;</a></span>computeSegment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af47e8b71056789970556433d41788138">LatticePolytope</a> <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::computeSegment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a3dc92942e3a6bed2067f60ac0aa99f88">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the lattice polytope enclosing a segment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>any point </td></tr>
    <tr><td class="paramname">b</td><td>any point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tightiest bounded lattice polytope (i.e. H-representation) including the closed segment <span class="tt">[a,b]</span>. It is always Minkowski summable.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Implemented only in 3D. </dd></dl>

</div>
</div>
<a id="a299c2da4588ed410b579774d6105fd3c" name="a299c2da4588ed410b579774d6105fd3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299c2da4588ed410b579774d6105fd3c">&#9670;&#160;</a></span>computeSimplex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af47e8b71056789970556433d41788138">LatticePolytope</a> <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::computeSimplex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#afc3a1ef390f6664bdf70bc1c52f32a62">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>remove_duplicates</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the lattice polytope enclosing a range of at most dimension+1 distinct points.</p>
<dl class="section note"><dt>Note</dt><dd>Called internally by <a class="el" href="#af88821410e5a9327537ee884249d7034">ConvexityHelper::computeLatticePolytope</a>.</dd>
<dd>
This function works for arbitrary full dimensional simplex. If the set of points is not full dimensional, it is able to build a non full dimensional simplex for dimensions &lt;= 3.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">input_points</td><td>a range of points, with at most dimension+1 distinct points.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remove_duplicates</td><td>should be set to 'true' if the input data has duplicates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tightiest bounded lattice polytope (i.e. H-representation) including the given range of points, or an empty polytope if the given range of points was not full dimensional and dimension was greater than 3. </dd></dl>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Field Documentation</h2>
<a id="a556209b9719d1be518d335b6821bf549" name="a556209b9719d1be518d335b6821bf549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556209b9719d1be518d335b6821bf549">&#9670;&#160;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename TInteger = DGtal::int32_t, typename TInternalInteger = DGtal::int64_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> <a class="el" href="structDGtal_1_1ConvexityHelper.html">DGtal::ConvexityHelper</a>&lt; <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a>, TInteger, TInternalInteger &gt;::dimension = <a class="el" href="testImageContainerByHashTree_8cpp.html#a4bf6a1e750d841477978a43a04c4f062">dim</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvexityHelper_8h_source.html#l00161">161</a> of file <a class="el" href="ConvexityHelper_8h_source.html">ConvexityHelper.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="ConvexityHelper_8h_source.html">ConvexityHelper.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceDGtal.html">DGtal</a></li><li class="navelem"><a href="structDGtal_1_1ConvexityHelper.html">ConvexityHelper</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for DGtal by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
