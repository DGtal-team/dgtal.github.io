<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Heat Kernel Laplace&ndash;Beltrami Operator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;1.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Heat Kernel Laplace&ndash;Beltrami Operator </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sectHeatIntro">Continuous Laplace&ndash;Beltrami operator</a></li>
<li class="level1"><a href="#subBelkin">The Laplace&ndash;Beltrami operator from the Heat Equation</a></li>
<li class="level1"><a href="#secDiscre">The Discretization on Digital Surfaces</a></li>
<li class="level1"><a href="#secHowToHeatLaplace">Hands on the Operator in DGtal</a></li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Caissard Thomas</dd></dl>
<h1><a class="anchor" id="sectHeatIntro"></a>
Continuous Laplace–Beltrami operator</h1>
<p >Let \(M\) be a smooth manifold. The linear operator \(\Delta : C^2(\partial
M) \rightarrow C^2(\partial M)\) (where \(C^2(\partial M)\) is the set of twice differentiable function acting on \(\partial M\)) defined by </p><p class="formulaDsp">
\[ \Delta u = \nabla^2 u = \nabla \cdot \nabla u, \]
</p>
<p> is called the Laplace&ndash;Beltrami operator. </p><dl class="section note"><dt>Note</dt><dd>The sign of the operator is arbitrary, and one may found in the litterature the alternative definition \(-\nabla \cdot \nabla u\) for \(\Delta u\).</dd></dl>
<p>For example, in \( \mathbb{R}^d \), the operator is the sum of the second derivatives: </p><p class="formulaDsp">
\[ \Delta_{\mathbb{R}^d} u(x) = \sum_i
\frac{\partial^2}{\partial x_i^2}u(x). \]
</p>
<p> This operator can be expressed in local coordinates system on a manifold given the metric tensor \(g_{ij}\): </p><p class="formulaDsp">
\[ \Delta
u = \frac{1}{\sqrt{g}} \partial_i \left( \sqrt{|g|}g^{ij}\partial_j u \right),
\]
</p>
<p> with the Einstein notation implied (meaning that repeated indexes are summed over), \( \sqrt{|g|}\) is the absolute value of the determinant of \( g_{ij}
\) and \( \partial_i = \frac{\partial}{\partial x^i}\) is the basis of the tangent plane \(T_p M\) at a point \(p\).</p>
<p >The operator can also be written in a coordinate-free manner using the exterior calculus theory. Given a function \(w\) (ie. a 0-form) we have </p><p class="formulaDsp">
\[ \Delta w =
\star d \star d w, \]
</p>
<p> where \(\star\) is the hodge operator and \( d \) the exterior derivative.</p>
<h1><a class="anchor" id="subBelkin"></a>
The Laplace–Beltrami operator from the Heat Equation</h1>
<p >Let \(g : \partial M \times (0, T) \rightarrow \mathbb{R}\) be a time-dependent function which solves the partial differential equation called the heat equation: </p><p class="formulaDsp">
\[ \Delta g(x, t) = \frac{\partial}{\partial t}g(x, t), \]
</p>
<p> with initial condition \(u = g(\cdot, 0) : \partial M \rightarrow \mathbb{R}\) which is the initial temperature distribution.</p>
<div class="image">
<img src="heat_diffusion_manifold.png" alt=""/>
<div class="caption">
The heat diffusion on a manifold. The heat kernel is represented in green, the geodesic distance in blue.</div></div>
<p >An exact solution is: </p><p class="formulaDsp">
\[ \int_{y\in \partial M} p(t, x, y) u(y) dy, \]
</p>
<p> where \(p \in C^\infty(\mathbb{R}^+ \times \partial M \times \partial M)\) is the heat kernel <a class="el" href="citelist.html#CITEREF_rosenberg">[98]</a>.</p>
<p >There is a wide range of studies on the behavior of \(p\) when \(t\) tends to zero (called small time asymptotics of diffusion process). Early works include the famous Varadhan formula <a class="el" href="citelist.html#CITEREF_varadhan">[114]</a> on closed manifolds with or without borders later extended by Molchanov <a class="el" href="citelist.html#CITEREF_molchanov">[89]</a> on a wider class of shapes: </p><p class="formulaDsp">
\[ p(t,x,y) \mathrel{\mathop{\sim}\limits_{t \rightarrow 0}} \frac{e^{-
\frac{d(x,y)^2}{4 t}}}{(4\pi t)^{\frac{d}{2}}} \]
</p>
<p> where \(d(\cdot,\cdot)\) corresponds to the intrinsic geodesic distance. This approximation is not robust in practice and very sensitive to both geodesic distance approximation and numerical errors <a class="el" href="citelist.html#CITEREF_Crane2013">[39]</a>. Fortunately we know from Belkin et al. <a class="el" href="citelist.html#CITEREF_BelkinN08">[10]</a> that in small time asymptotics, the geodesic distance can be approximated by the \(l_2\) distance: </p><p class="formulaDsp">
\[ p(t,x,y)
\mathrel{\mathop{\sim}\limits_{t \rightarrow 0}} \tilde{p}(t,x,y) := \frac{e^{ -
\frac{||x - y||^2}{4t} }}{(4 \pi t)^{\frac{d}{2}}}, \]
</p>
<p> which leads to the following approximated solution of the heat equation: </p><p class="formulaDsp">
\[ g(x,t) = \int_{y \in
\partial M} \tilde{p}(t,x,y) u(y)dy. \]
</p>
<p >By injecting the approximation into the heat equation we obtain: </p><p class="formulaDsp">
\[ \Delta g(x,
t) = \frac{\partial}{\partial t} \int_{ y\in \partial M } \tilde{p}(t, x, y)
u(y)dy. \]
</p>
<p> Using a finite difference on \(t\), and the basic property that the integral of the heat kernel must be one: </p><p class="formulaDsp">
\[ \Delta g(x, t) = \lim\limits_{t
\rightarrow 0} \frac{1}{t} \int_{y\in \partial M } \tilde{p}(t, x, y) (u(y) -
u(x))dy. \]
</p>
<h1><a class="anchor" id="secDiscre"></a>
The Discretization on Digital Surfaces</h1>
<p >We adapt the formulation of Belkin et al. on digital surfaces (see <a class="el" href="citelist.html#CITEREF_CaissardDGCI2017">[17]</a>). In the continuous heat kernel formulation, the parameter \(t\) must tend to zero. On digital surfaces, we set \(t\) as a function of the grid step \(h\), denoted \(t_h\), that tends to zero as \(h\) tends to zero.</p>
<dl class="section note"><dt>Note</dt><dd>Typically the time parameter is set to \(t_h = k \cdot h^{\alpha}\) with \(\alpha\) positive and \(k\) is a constant depending on the input shape.</dd></dl>
<p>The discretization on digital surfaces is </p><p class="formulaDsp">
\[ (\Delta_{DIGI} \, f)({\mathbf{s}})
:= \frac{1}{t_h(4 \pi t_h)^{\frac{d}{2}}} \sum_{\mathbf{r}\in \mathbb{F}^d }
e^{- \frac{||\dot{\mathbf{r}}
        - \dot{\mathbf{s}}||^2}{4t_h}}  [f(\dot{{\mathbf{r}}})
    - f(\dot{{\mathbf{s}}})]\mu(\mathbf{r}), \]
</p>
<p> where \(\mathbb{F}^d\) is the set of elements dimension \(d\) (for example surfels in a 2D surface embedded in 3D), \(\dot{\mathbf{r}}\) (resp. \(\dot{\mathbf{s}}\)) is the centroid of the surfel \(\mathbf{r}\) (resp. \(\mathbf{s}\)), and \(\mu(\mathbf{r})\) is equal to the dot product between an estimated normal and the trivial normal orthogonal to the surfel \(\mathbf{s}\). We typically use the Integral Invariant estimator for normal computation.</p>
<h1><a class="anchor" id="secHowToHeatLaplace"></a>
Hands on the Operator in DGtal</h1>
<p >This section provides an overview on how to use the Heat Laplace in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>. The operator is embedded inside the DEC structure of <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>. The following code comes from the file <a class="el" href="exampleHeatLaplace_8cpp_source.html">exampleHeatLaplace.cpp</a>. We demonstrate the usage of the heat operator on a function defined on the unit sphere. The laplace operator in spherical coordinates on the unit sphere is </p><p class="formulaDsp">
\[ \Delta = \frac{1}{
\sin^2(\theta) } \frac{\partial^2}{\partial \theta^2} + \frac{1}{\sin(\phi)}
\frac{\partial}{\partial \phi}( \sin(\phi) \frac{\partial}{\partial \phi} ) \]
</p>
<p> We choose the function \(f(x,y,z) = x^2\). Its Laplacian is then \( \Delta
f(r, \theta, \phi) = 2 \cos(\theta)^2 ( 2 \cos(\phi)^2 - \sin(\phi)^2 ) + 2(
\sin(\theta)^2 - cos(\theta)^2 ) \).</p>
<p >You must first compute the boundary of the surface, that is here for example the set of surfels of the boundary of the unit sphere.</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> GaussDigitizer&lt;Z3i::Space, Shape&gt; Digitizer;</div>
<div class="line"> </div>
<div class="line">  Digitizer digitizer;</div>
<div class="line">  digitizer.attach(shape);</div>
<div class="line">  digitizer.init(shape.getLowerBound() + <a class="code hl_typedef" href="namespaceDGtal_1_1Z3i.html#ae17e112888e54316e9523b52d2b78245">Z3i::Vector</a>(-1,-1,-1), shape.getUpperBound() + <a class="code hl_typedef" href="namespaceDGtal_1_1Z3i.html#ae17e112888e54316e9523b52d2b78245">Z3i::Vector</a>(1,1,1), options.h);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_typedef" href="namespaceDGtal_1_1Z3i.html#a39a69f8da09f1094df563ca067927c61">Z3i::Domain</a> <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a> = digitizer.getDomain();</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_typedef" href="namespaceDGtal_1_1Z3i.html#a4c1b0b50dafb838783bc2347a840147d">Z3i::KSpace</a> kspace;</div>
<div class="line">  <span class="keywordtype">bool</span> ok = kspace.init(<a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.lowerBound(), <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.upperBound(), <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">if</span>( !ok ) std::cerr &lt;&lt; <span class="stringliteral">&quot;KSpace init failed&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_typedef" href="classDGtal_1_1KhalimskySpaceND.html#a0a02413be83a0f38f23ed5cb45c2bcc4">KSpace::SurfelSet</a> <a class="code hl_typedef" href="greedy-plane-segmentation-ex2_8cpp.html#a9e248ca0929052a040e6dfa7018611c2">SurfelSet</a>;</div>
<div class="line">  <span class="keyword">typedef</span> SetOfSurfels&lt; KSpace, SurfelSet &gt; MySetOfSurfels;</div>
<div class="line">  <span class="keyword">typedef</span> DigitalSurface&lt; MySetOfSurfels &gt; <a class="code hl_typedef" href="greedy-plane-segmentation-ex2_8cpp.html#a03d731f44ed1110acdbefdc2357f84cf">MyDigitalSurface</a>;</div>
<div class="line">  <span class="keyword">typedef</span> SurfelAdjacency&lt;KSpace::dimension&gt; MySurfelAdjacency;</div>
<div class="line"> </div>
<div class="line">  MySurfelAdjacency surfAdj( <span class="keyword">true</span> ); <span class="comment">// interior in all directions.</span></div>
<div class="line">  MySetOfSurfels theSetOfSurfels( kspace, surfAdj );</div>
<div class="line">  <a class="code hl_function" href="classDGtal_1_1Surfaces.html#af61619b3dbd948aea387202369bddd6f">Surfaces&lt;KSpace&gt;::sMakeBoundary</a>( theSetOfSurfels.surfelSet(),</div>
<div class="line">                   kspace, digitizer,</div>
<div class="line">                   <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.lowerBound(),</div>
<div class="line">                   <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.upperBound() );</div>
<div class="line">  <a class="code hl_class" href="classDGtal_1_1DigitalSurface.html">MyDigitalSurface</a> digSurf( theSetOfSurfels );</div>
<div class="ttc" id="aclassDGtal_1_1DigitalSurface_html"><div class="ttname"><a href="classDGtal_1_1DigitalSurface.html">DGtal::DigitalSurface</a></div><div class="ttdoc">Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...</div><div class="ttdef"><b>Definition:</b> <a href="DigitalSurface_8h_source.html#l00139">DigitalSurface.h:140</a></div></div>
<div class="ttc" id="aclassDGtal_1_1KhalimskySpaceND_html_a0a02413be83a0f38f23ed5cb45c2bcc4"><div class="ttname"><a href="classDGtal_1_1KhalimskySpaceND.html#a0a02413be83a0f38f23ed5cb45c2bcc4">DGtal::KhalimskySpaceND::SurfelSet</a></div><div class="ttdeci">std::set&lt; SCell &gt; SurfelSet</div><div class="ttdoc">Preferred type for defining a set of surfels (always signed cells).</div><div class="ttdef"><b>Definition:</b> <a href="KhalimskySpaceND_8h_source.html#l00450">KhalimskySpaceND.h:450</a></div></div>
<div class="ttc" id="aclassDGtal_1_1Surfaces_html_af61619b3dbd948aea387202369bddd6f"><div class="ttname"><a href="classDGtal_1_1Surfaces.html#af61619b3dbd948aea387202369bddd6f">DGtal::Surfaces::sMakeBoundary</a></div><div class="ttdeci">static void sMakeBoundary(SCellSet &amp;aBoundary, const KSpace &amp;aKSpace, const PointPredicate &amp;pp, const Point &amp;aLowerBound, const Point &amp;aUpperBound)</div></div>
<div class="ttc" id="agreedy-plane-segmentation-ex2_8cpp_html_a03d731f44ed1110acdbefdc2357f84cf"><div class="ttname"><a href="greedy-plane-segmentation-ex2_8cpp.html#a03d731f44ed1110acdbefdc2357f84cf">MyDigitalSurface</a></div><div class="ttdeci">DigitalSurface&lt; MyDigitalSurfaceContainer &gt; MyDigitalSurface</div><div class="ttdef"><b>Definition:</b> <a href="greedy-plane-segmentation-ex2_8cpp_source.html#l00092">greedy-plane-segmentation-ex2.cpp:92</a></div></div>
<div class="ttc" id="agreedy-plane-segmentation-ex2_8cpp_html_a9e248ca0929052a040e6dfa7018611c2"><div class="ttname"><a href="greedy-plane-segmentation-ex2_8cpp.html#a9e248ca0929052a040e6dfa7018611c2">SurfelSet</a></div><div class="ttdeci">MyDigitalSurface::SurfelSet SurfelSet</div><div class="ttdef"><b>Definition:</b> <a href="greedy-plane-segmentation-ex2_8cpp_source.html#l00095">greedy-plane-segmentation-ex2.cpp:95</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z3i_html_a39a69f8da09f1094df563ca067927c61"><div class="ttname"><a href="namespaceDGtal_1_1Z3i.html#a39a69f8da09f1094df563ca067927c61">DGtal::Z3i::Domain</a></div><div class="ttdeci">HyperRectDomain&lt; Space &gt; Domain</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00172">StdDefs.h:172</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z3i_html_a4c1b0b50dafb838783bc2347a840147d"><div class="ttname"><a href="namespaceDGtal_1_1Z3i.html#a4c1b0b50dafb838783bc2347a840147d">DGtal::Z3i::KSpace</a></div><div class="ttdeci">KhalimskySpaceND&lt; 3, Integer &gt; KSpace</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00146">StdDefs.h:146</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z3i_html_ae17e112888e54316e9523b52d2b78245"><div class="ttname"><a href="namespaceDGtal_1_1Z3i.html#ae17e112888e54316e9523b52d2b78245">DGtal::Z3i::Vector</a></div><div class="ttdeci">Space::Vector Vector</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00169">StdDefs.h:169</a></div></div>
<div class="ttc" id="atestProjection_8cpp_html_a1f1a69f8d8b037b72c2160ed12b3ef51"><div class="ttname"><a href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a></div><div class="ttdeci">Domain domain</div><div class="ttdef"><b>Definition:</b> <a href="testProjection_8cpp_source.html#l00088">testProjection.cpp:88</a></div></div>
</div><!-- fragment --><p >Then, we need to compute the estimated area of a surfel, i.e. the quantity \(
\mu \). We use the Integral Invariant estimator to compute the estimated normals of the surfels (see <a class="el" href="moduleIntegralInvariant.html">Integral invariant curvature estimator 2D/3D</a>). We use the same parameter \( \alpha = 1 / 3\) for Integral Invariant and our Laplace&ndash;Beltrami estimator.</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> CanonicSCellEmbedder&lt;KSpace&gt; CanonicSCellEmbedder;</div>
<div class="line">  CanonicSCellEmbedder canonicSCellEmbedder(kspace);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typedef</span> functors::IINormalDirectionFunctor&lt;Space&gt; MyIINormalFunctor;</div>
<div class="line">  <span class="keyword">typedef</span> IntegralInvariantCovarianceEstimator&lt;KSpace, Digitizer, MyIINormalFunctor&gt; MyIINormalEstimator;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> radius = options.normal_radius * pow(options.h, 1. / 3.);</div>
<div class="line"> </div>
<div class="line">  MyIINormalFunctor normalFunctor;</div>
<div class="line">  normalFunctor.init(options.h, radius);</div>
<div class="line"> </div>
<div class="line">  MyIINormalEstimator normalEstimator(normalFunctor);</div>
<div class="line">  normalEstimator.attach(kspace, digitizer);</div>
<div class="line">  normalEstimator.setParams(radius / options.h);</div>
<div class="line"> </div>
<div class="line">  normalEstimator.init(options.h, digSurf.begin(), digSurf.end());</div>
</div><!-- fragment --><p >The DEC structure is initialized using the normal estimator (if no normal estimators is given, the surface area will be one as default, which leads to a poor estimation of the laplace operator)</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> DiscreteExteriorCalculus&lt;2, 3, EigenLinearAlgebraBackend&gt; Calculus;</div>
<div class="line">  <span class="keyword">typedef</span> DiscreteExteriorCalculusFactory&lt;EigenLinearAlgebraBackend&gt; CalculusFactory;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> Calculus calculus = CalculusFactory::createFromNSCells&lt;2&gt;(digSurf.begin(), digSurf.end(), normalEstimator, options.h);</div>
</div><!-- fragment --><p >As we compute the laplace operator on surfels, the input function is represented by a 2-form in the dec structure.</p>
<dl class="section note"><dt>Note</dt><dd>The order of the input surfels is not the same as the internal order of DEC. You must use getCellIndex from DEC to retrieve the internal order of a cell.</dd></dl>
<div class="fragment"><div class="line">  Calculus::DualForm0 input_func(calculus);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keyword">auto</span> itb = digSurf.begin(), ite = digSurf.end(); itb != ite; itb++)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> Calculus::Index i_calc = calculus.getCellIndex( kspace.unsigns( *itb ) );</div>
<div class="line">    input_func.myContainer( i_calc ) = input_function( options.h * canonicSCellEmbedder( *itb ) );</div>
<div class="line">  }</div>
</div><!-- fragment --><p >We can now construct the Laplace operator. It is a DualIdentity of 2-forms, i.e. a linear operator acting on 2-forms represented internally by a sparse matrix. The function heatLaplace of DEC is templated by the duality of the operator. If you want to compute the operator on 0-forms (on points), you must pass PRIMAL as template parameter. We use here the dual operator. The function takes as input the grid size \( h \), the time parameter for the convolution \( t_h \) and a variance multiplier for the integration \( K \).</p>
<dl class="section note"><dt>Note</dt><dd>As mentionned earlier, the time parameter is generaly set to \( t_h = k
\cdot h^\alpha \) where \(k\) is a constant depending on the input shape which roughly corresponds to the size of the Gaussian kernel in the euclidean space (here \(k = 0.1\) for the unit sphere).</dd></dl>
<p>The integration is done within the cut locus range: we only sum points which euclidean distance is inferior to \( K \sigma = K \sqrt{2t} \) (where \(\sigma\) is the variance of the Gaussian function). Indeed it is known that almost all the mass under a Gaussian in contained within a few multiples of \( \sigma \) (typically two or three time \(\sigma\)).</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> t = options.convolution_radius * pow(options.h, 2. / 3.);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a> = log( - log1p( t ) ) + 2.;</div>
<div class="line">  <span class="keyword">const</span> Calculus::DualIdentity0 laplace = calculus.heatLaplace&lt;<a class="code hl_enumvalue" href="namespaceDGtal.html#ab8007ddbb5627666913e18c3b951745dac649578cee4b5463ded5048fdaa47a41">DUAL</a>&gt;(options.h, t, <a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>);</div>
<div class="ttc" id="anamespaceDGtal_html_ab8007ddbb5627666913e18c3b951745dac649578cee4b5463ded5048fdaa47a41"><div class="ttname"><a href="namespaceDGtal.html#ab8007ddbb5627666913e18c3b951745dac649578cee4b5463ded5048fdaa47a41">DGtal::DUAL</a></div><div class="ttdeci">@ DUAL</div><div class="ttdef"><b>Definition:</b> <a href="Duality_8h_source.html#l00063">Duality.h:62</a></div></div>
<div class="ttc" id="atestCubicalComplex_8cpp_html_a2b87ed989d2519d025bd5d4fbcbac062"><div class="ttname"><a href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a></div><div class="ttdeci">KSpace K</div><div class="ttdef"><b>Definition:</b> <a href="testCubicalComplex_8cpp_source.html#l00062">testCubicalComplex.cpp:62</a></div></div>
</div><!-- fragment --><p >Finally, the result is computed with a simple matrix multiplication</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> Eigen::VectorXd laplace_result = (laplace * input_func).myContainer;</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Nov 27 2022 15:16:00 for DGtal by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
