<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: DGtal::functions Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceDGtal.html">DGtal</a></li><li class="navelem"><a class="el" href="namespaceDGtal_1_1functions.html">functions</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DGtal::functions Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>functions</code> namespace gathers all <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> functionsxs.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceDGtal_1_1functions_1_1Hull2D"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html">Hull2D</a></td></tr>
<tr class="memdesc:namespaceDGtal_1_1functions_1_1Hull2D"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html" title="Hull2D namespace gathers useful functions to compute and return the convex hull or the alpha-shape of...">Hull2D</a> namespace gathers useful functions to compute and return the convex hull or the alpha-shape of a range of 2D points. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceDGtal_1_1functions_1_1setops"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1setops.html">setops</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a82988f18c989530f73dab774abe12c90"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:a82988f18c989530f73dab774abe12c90"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a82988f18c989530f73dab774abe12c90">isEqual</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a82988f18c989530f73dab774abe12c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbef166c5a788624eff4f09e596c09f5"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:adbef166c5a788624eff4f09e596c09f5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#adbef166c5a788624eff4f09e596c09f5">isEqual</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:adbef166c5a788624eff4f09e596c09f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e98eb410830e5ca846260e66bff422"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:ac7e98eb410830e5ca846260e66bff422"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#ac7e98eb410830e5ca846260e66bff422">isSubset</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:ac7e98eb410830e5ca846260e66bff422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad171e7dc7973f3fc0ee8363712059124"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ad171e7dc7973f3fc0ee8363712059124"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#ad171e7dc7973f3fc0ee8363712059124">isSubset</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:ad171e7dc7973f3fc0ee8363712059124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97099c06241a42dce86a53230b665d7"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:ac97099c06241a42dce86a53230b665d7"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#ac97099c06241a42dce86a53230b665d7">assignDifference</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:ac97099c06241a42dce86a53230b665d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b91c6c5fb3c893dd709f4e90e9eff93"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a0b91c6c5fb3c893dd709f4e90e9eff93"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a0b91c6c5fb3c893dd709f4e90e9eff93">assignDifference</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a0b91c6c5fb3c893dd709f4e90e9eff93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5faa4fb283d3dd8b530f1aa46e1303"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:adc5faa4fb283d3dd8b530f1aa46e1303"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#adc5faa4fb283d3dd8b530f1aa46e1303">makeDifference</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:adc5faa4fb283d3dd8b530f1aa46e1303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba16c21435994b725465e08cb77a9fb"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:acba16c21435994b725465e08cb77a9fb"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#acba16c21435994b725465e08cb77a9fb">makeDifference</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:acba16c21435994b725465e08cb77a9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58ca694e397fb84d77c53aba2134887"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:ac58ca694e397fb84d77c53aba2134887"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#ac58ca694e397fb84d77c53aba2134887">assignUnion</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:ac58ca694e397fb84d77c53aba2134887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4932db4b89711ecfc43c950766c8a3c2"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a4932db4b89711ecfc43c950766c8a3c2"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a4932db4b89711ecfc43c950766c8a3c2">assignUnion</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a4932db4b89711ecfc43c950766c8a3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af848d0d5748af67bcb76b3d5e1f616cd"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:af848d0d5748af67bcb76b3d5e1f616cd"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#af848d0d5748af67bcb76b3d5e1f616cd">makeUnion</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:af848d0d5748af67bcb76b3d5e1f616cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af462fb1f5ceade012f0e97831e3d8e64"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:af462fb1f5ceade012f0e97831e3d8e64"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#af462fb1f5ceade012f0e97831e3d8e64">makeUnion</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:af462fb1f5ceade012f0e97831e3d8e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3360043e7032e9a8eaf2ef0fde60afd"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:af3360043e7032e9a8eaf2ef0fde60afd"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#af3360043e7032e9a8eaf2ef0fde60afd">assignIntersection</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:af3360043e7032e9a8eaf2ef0fde60afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03568b922cfd14ec380c2b297af70dff"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a03568b922cfd14ec380c2b297af70dff"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a03568b922cfd14ec380c2b297af70dff">assignIntersection</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a03568b922cfd14ec380c2b297af70dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de7a7bd0c7511d57569c794cff3a113"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:a8de7a7bd0c7511d57569c794cff3a113"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a8de7a7bd0c7511d57569c794cff3a113">makeIntersection</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a8de7a7bd0c7511d57569c794cff3a113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d93770c72e70791aa57c47d22c982b9"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a6d93770c72e70791aa57c47d22c982b9"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a6d93770c72e70791aa57c47d22c982b9">makeIntersection</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a6d93770c72e70791aa57c47d22c982b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65694ad895f3f4cb42c54213fce7295a"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:a65694ad895f3f4cb42c54213fce7295a"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a65694ad895f3f4cb42c54213fce7295a">assignSymmetricDifference</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a65694ad895f3f4cb42c54213fce7295a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e5c37c5f1aaade38460038220ce4fd"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a20e5c37c5f1aaade38460038220ce4fd"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a20e5c37c5f1aaade38460038220ce4fd">assignSymmetricDifference</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a20e5c37c5f1aaade38460038220ce4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f0a6573a95aa152c8b8320baee6884"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:a03f0a6573a95aa152c8b8320baee6884"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a03f0a6573a95aa152c8b8320baee6884">makeSymmetricDifference</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a03f0a6573a95aa152c8b8320baee6884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd11e737e0c019de78553ae847a5724"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:aacd11e737e0c019de78553ae847a5724"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#aacd11e737e0c019de78553ae847a5724">makeSymmetricDifference</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:aacd11e737e0c019de78553ae847a5724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4fa6a6be77e4813577c8a2b3572299"><td class="memTemplParams" colspan="2">template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </td></tr>
<tr class="memitem:a6e4fa6a6be77e4813577c8a2b3572299"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a6e4fa6a6be77e4813577c8a2b3572299">checkOnePoint</a> (const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;aDSS)</td></tr>
<tr class="separator:a6e4fa6a6be77e4813577c8a2b3572299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b421081da133e4069fe9cbddf33aa54"><td class="memTemplParams" colspan="2">template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </td></tr>
<tr class="memitem:a6b421081da133e4069fe9cbddf33aa54"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a6b421081da133e4069fe9cbddf33aa54">checkPointsPosition</a> (const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;aDSS)</td></tr>
<tr class="separator:a6b421081da133e4069fe9cbddf33aa54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e697b1094865df340ba6206354f7c37"><td class="memTemplParams" colspan="2">template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </td></tr>
<tr class="memitem:a1e697b1094865df340ba6206354f7c37"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a1e697b1094865df340ba6206354f7c37">checkPointsRemainder</a> (const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;aDSS)</td></tr>
<tr class="separator:a1e697b1094865df340ba6206354f7c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612e2adbf3983c441753beb63fd55f86"><td class="memTemplParams" colspan="2">template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </td></tr>
<tr class="memitem:a612e2adbf3983c441753beb63fd55f86"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a612e2adbf3983c441753beb63fd55f86">checkAll</a> (const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;aDSS)</td></tr>
<tr class="separator:a612e2adbf3983c441753beb63fd55f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c21293d6efa82afb1b20db4d7a794a7"><td class="memTemplParams" colspan="2">template&lt;typename Position , typename Coordinate , typename PointVector , typename OutputIterator , typename PositionFunctor , typename TruncationFunctor1 , typename TruncationFunctor2 &gt; </td></tr>
<tr class="memitem:a2c21293d6efa82afb1b20db4d7a794a7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a2c21293d6efa82afb1b20db4d7a794a7">smartCHNextVertex</a> (const Position &amp;positionBound, const Coordinate &amp;remainderBound, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;X, Coordinate &amp;rX, const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;Y, const Coordinate &amp;rY, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;V, Coordinate &amp;rV, OutputIterator ito, const PositionFunctor &amp;pos, const TruncationFunctor1 &amp;f1, const TruncationFunctor2 &amp;f2)</td></tr>
<tr class="memdesc:a2c21293d6efa82afb1b20db4d7a794a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure that computes the next (lower or upper) vertex of the left hull of a DSS.  <a href="#a2c21293d6efa82afb1b20db4d7a794a7">More...</a><br /></td></tr>
<tr class="separator:a2c21293d6efa82afb1b20db4d7a794a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b66e9e7682c0f900bcbeabcac96b7b"><td class="memTemplParams" colspan="2">template&lt;typename PointVector , typename Coordinate , typename Position , typename PositionFunctor , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a07b66e9e7682c0f900bcbeabcac96b7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a07b66e9e7682c0f900bcbeabcac96b7b">smartCH</a> (const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;aFirstPoint, const Coordinate &amp;aRemainderBound, const Position &amp;aPositionBound, const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;aStep, const Coordinate &amp;aRStep, const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;aShift, const Coordinate &amp;aRShift, const PositionFunctor &amp;aPositionFunctor, OutputIterator uIto, OutputIterator lIto)</td></tr>
<tr class="memdesc:a07b66e9e7682c0f900bcbeabcac96b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure that computes the lower and upper left hull of a DSS of first point <em>aFirstPoint</em>, length <em>aPositionBound</em>, contained in a digital straight line described by <em>aRStep</em>, <em>aRShift</em> and <em>aRemainderBound</em>.  <a href="#a07b66e9e7682c0f900bcbeabcac96b7b">More...</a><br /></td></tr>
<tr class="separator:a07b66e9e7682c0f900bcbeabcac96b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc99490ec12ae9e68c03c08d473e8692"><td class="memTemplParams" colspan="2">template&lt;typename DSL , typename OutputIterator &gt; </td></tr>
<tr class="memitem:adc99490ec12ae9e68c03c08d473e8692"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="testCombinDSS_8cpp.html#a609ee1808a3b4f883fb28df65e9a2ed6">DSL::Vector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#adc99490ec12ae9e68c03c08d473e8692">smartCH</a> (const DSL &amp;aDSL, const typename <a class="el" href="testCubicalComplex_8cpp.html#a15e9592ccc512dc691b46185e6814758">DSL::Point</a> &amp;aFirstPoint, const typename DSL::Position &amp;aLength, OutputIterator uIto, OutputIterator lIto)</td></tr>
<tr class="memdesc:adc99490ec12ae9e68c03c08d473e8692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure that computes the lower and upper left hull of a DSS of first point <em>aFirstPoint</em>, length <em>aLength</em>, contained in a DSL <em>aDSL</em> [Roussillon 2014 : <a class="el" href="citelist.html#CITEREF_RoussillonDGCI2014">[74]</a>].  <a href="#adc99490ec12ae9e68c03c08d473e8692">More...</a><br /></td></tr>
<tr class="separator:adc99490ec12ae9e68c03c08d473e8692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184e90763c4747a4b7c71a58e1bf4bfe"><td class="memTemplParams" colspan="2">template&lt;typename PointVector , typename Position , typename OutputIterator , typename TruncationFunctor1 , typename TruncationFunctor2 , typename PositionFunctor &gt; </td></tr>
<tr class="memitem:a184e90763c4747a4b7c71a58e1bf4bfe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a184e90763c4747a4b7c71a58e1bf4bfe">smartCHPreviousVertex</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;X, const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;Y, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;V, const Position &amp;aFirstPosition, const Position &amp;aLastPosition, OutputIterator ito, const PositionFunctor &amp;pos, const TruncationFunctor1 &amp;f1, const TruncationFunctor2 &amp;f2)</td></tr>
<tr class="memdesc:a184e90763c4747a4b7c71a58e1bf4bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure that computes the previous vertex of the left hull of a DSS of main direction vector <em>V</em> , first upper leaning point <em>U</em> and first positive Bezout point <em>L</em>. The computation stops as soon as a computed vertex is located before <em>aLastPosition</em>.  <a href="#a184e90763c4747a4b7c71a58e1bf4bfe">More...</a><br /></td></tr>
<tr class="separator:a184e90763c4747a4b7c71a58e1bf4bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa754ac3d17216563354db61d905a545c"><td class="memTemplParams" colspan="2">template&lt;typename PointVector , typename Position , typename PositionFunctor , typename OutputIterator &gt; </td></tr>
<tr class="memitem:aa754ac3d17216563354db61d905a545c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#aa754ac3d17216563354db61d905a545c">reversedSmartCH</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> U, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> L, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> V, const Position &amp;aFirstPosition, const Position &amp;aLastPosition, const PositionFunctor &amp;aPositionFunctor, OutputIterator uIto, OutputIterator lIto)</td></tr>
<tr class="memdesc:aa754ac3d17216563354db61d905a545c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure that computes the lower and upper left hull of the left subsegment of a greater DSS characterized by the first upper leaning point <em>U</em>, the first positive Bezout point <em>L</em> and its direction vector <em>V</em>. Note that the so-called left subsegment is bounded on the one hand by the first point of the DSS located at <em>aFirstPosition</em> and on the other hand by the point located at position <em>aLastPosition</em>.  <a href="#aa754ac3d17216563354db61d905a545c">More...</a><br /></td></tr>
<tr class="separator:aa754ac3d17216563354db61d905a545c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d6f1219d53ecefb73b55c386e0d54a"><td class="memTemplParams" colspan="2">template&lt;typename DSS , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a42d6f1219d53ecefb73b55c386e0d54a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="testCombinDSS_8cpp.html#a609ee1808a3b4f883fb28df65e9a2ed6">DSS::Vector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a42d6f1219d53ecefb73b55c386e0d54a">reversedSmartCH</a> (const DSS &amp;aDSS, const typename DSS::Position &amp;aPositionBound, OutputIterator uIto, OutputIterator lIto)</td></tr>
<tr class="memdesc:a42d6f1219d53ecefb73b55c386e0d54a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure that computes the lower and upper left hull of the left subsegment of a greater DSS <em>aDSS</em>. Note that the so-called left subsegment is bounded on the one hand by the first point of <em>aDSS</em> and on the other hand by the point located at position <em>aPositionBound</em> [Roussillon 2014 : <a class="el" href="citelist.html#CITEREF_RoussillonDGCI2014">[74]</a>].  <a href="#a42d6f1219d53ecefb73b55c386e0d54a">More...</a><br /></td></tr>
<tr class="separator:a42d6f1219d53ecefb73b55c386e0d54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b68d329aa1461a0847a18e99247885"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a18b68d329aa1461a0847a18e99247885"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a18b68d329aa1461a0847a18e99247885">power</a> (const T &amp;aVal, const unsigned int exponent)</td></tr>
<tr class="separator:a18b68d329aa1461a0847a18e99247885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dff4e7a37ef5122f124d830b4b177a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a48dff4e7a37ef5122f124d830b4b177a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a48dff4e7a37ef5122f124d830b4b177a">roundToUpperPowerOfTwo</a> (const T &amp;n)</td></tr>
<tr class="separator:a48dff4e7a37ef5122f124d830b4b177a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95dcf36f806f7fc15626ca6b1c27d22"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af95dcf36f806f7fc15626ca6b1c27d22"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#af95dcf36f806f7fc15626ca6b1c27d22">abs</a> (const T &amp;a)</td></tr>
<tr class="separator:af95dcf36f806f7fc15626ca6b1c27d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e2160844093488cdd738354027daa1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac8e2160844093488cdd738354027daa1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#ac8e2160844093488cdd738354027daa1">square</a> (T x)</td></tr>
<tr class="separator:ac8e2160844093488cdd738354027daa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4828e0475cb9aa8dceefa94f0ab4d168"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4828e0475cb9aa8dceefa94f0ab4d168"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a4828e0475cb9aa8dceefa94f0ab4d168">cube</a> (T x)</td></tr>
<tr class="separator:a4828e0475cb9aa8dceefa94f0ab4d168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72edc3d9d652158c3d02a6a11386f249"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer , typename CellConstIterator , typename CellMapIteratorPriority &gt; </td></tr>
<tr class="memitem:a72edc3d9d652158c3d02a6a11386f249"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a72edc3d9d652158c3d02a6a11386f249">collapse</a> (<a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;<a class="el" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, CellConstIterator S_itB, CellConstIterator S_itE, const CellMapIteratorPriority &amp;priority, bool hintIsSClosed=false, bool hintIsKClosed=false, bool verbose=false)</td></tr>
<tr class="separator:a72edc3d9d652158c3d02a6a11386f249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8066d9f6db356f21fac91f53ffdde53d"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer , typename BdryCellOutputIterator , typename InnerCellOutputIterator &gt; </td></tr>
<tr class="memitem:a8066d9f6db356f21fac91f53ffdde53d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a8066d9f6db356f21fac91f53ffdde53d">filterCellsWithinBounds</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;<a class="el" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, const typename <a class="el" href="testCubicalComplex_8cpp.html#a15e9592ccc512dc691b46185e6814758">TKSpace::Point</a> &amp;kLow, const typename <a class="el" href="testCubicalComplex_8cpp.html#a15e9592ccc512dc691b46185e6814758">TKSpace::Point</a> &amp;kUp, BdryCellOutputIterator itBdry, InnerCellOutputIterator itInner)</td></tr>
<tr class="separator:a8066d9f6db356f21fac91f53ffdde53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef7985dddac727bde1206dfb29ef2be"><td class="memTemplParams" colspan="2">template&lt;typename TObject , typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:a9ef7985dddac727bde1206dfb29ef2be"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; TObject &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a9ef7985dddac727bde1206dfb29ef2be">objectFromSpels</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;C)</td></tr>
<tr class="separator:a9ef7985dddac727bde1206dfb29ef2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2d27eacf401fb9f784a1569b3ded7c"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:a4f2d27eacf401fb9f784a1569b3ded7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDGtal.html#a319e1944935b8331846f54001a63525f">NeighborhoodConfiguration</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a4f2d27eacf401fb9f784a1569b3ded7c">getSpelNeighborhoodConfigurationOccupancy</a> (const TComplex &amp;input_complex, const typename <a class="el" href="testCubicalComplex_8cpp.html#a15e9592ccc512dc691b46185e6814758">TComplex::Point</a> &amp;center, const std::unordered_map&lt; typename <a class="el" href="testCubicalComplex_8cpp.html#a15e9592ccc512dc691b46185e6814758">TComplex::Point</a>, <a class="el" href="namespaceDGtal.html#a319e1944935b8331846f54001a63525f">NeighborhoodConfiguration</a> &gt; &amp;mapPointToMask)</td></tr>
<tr class="separator:a4f2d27eacf401fb9f784a1569b3ded7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96aab076fc2c3bd049f041f5867be7a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CountedPtr.html">DGtal::CountedPtr</a>&lt; boost::dynamic_bitset&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a96aab076fc2c3bd049f041f5867be7a5">loadTable</a> (const std::string &amp;input_filename, const unsigned int known_size, const bool compressed=true)</td></tr>
<tr class="separator:a96aab076fc2c3bd049f041f5867be7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a55ef824ab5ca8afab45ff04c801693"><td class="memTemplParams" colspan="2">template&lt;unsigned int dimension = 3&gt; </td></tr>
<tr class="memitem:a7a55ef824ab5ca8afab45ff04c801693"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CountedPtr.html">DGtal::CountedPtr</a>&lt; boost::dynamic_bitset&lt;&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a7a55ef824ab5ca8afab45ff04c801693">loadTable</a> (const std::string &amp;input_filename, const bool compressed=true)</td></tr>
<tr class="separator:a7a55ef824ab5ca8afab45ff04c801693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e5d9a4e591d68db5f9aa942191a9db"><td class="memTemplParams" colspan="2">template&lt;typename TPoint &gt; </td></tr>
<tr class="memitem:ab2e5d9a4e591d68db5f9aa942191a9db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CountedPtr.html">DGtal::CountedPtr</a>&lt; std::unordered_map&lt; TPoint, <a class="el" href="namespaceDGtal.html#a319e1944935b8331846f54001a63525f">NeighborhoodConfiguration</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#ab2e5d9a4e591d68db5f9aa942191a9db">mapZeroPointNeighborhoodToConfigurationMask</a> ()</td></tr>
<tr class="separator:ab2e5d9a4e591d68db5f9aa942191a9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924114c3907d5c86e064a513779d24a8"><td class="memTemplParams" colspan="2">template&lt;typename TObject , typename TMap &gt; </td></tr>
<tr class="memitem:a924114c3907d5c86e064a513779d24a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a924114c3907d5c86e064a513779d24a8">generateSimplicityTable</a> (const typename TObject::DigitalTopology &amp;dt, TMap &amp;map)</td></tr>
<tr class="separator:a924114c3907d5c86e064a513779d24a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc0eb12f18205fd5335ef3068753109"><td class="memTemplParams" colspan="2">template&lt;typename TVoxelComplex , typename TMap &gt; </td></tr>
<tr class="memitem:a1fc0eb12f18205fd5335ef3068753109"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a1fc0eb12f18205fd5335ef3068753109">generateVoxelComplexTable</a> (TMap &amp;map, std::function&lt; bool(const TVoxelComplex &amp;, const typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TVoxelComplex::Cell</a> &amp;) &gt; skelFunction)</td></tr>
<tr class="separator:a1fc0eb12f18205fd5335ef3068753109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2a4664af776ca513141edb552a4461"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:a8f2a4664af776ca513141edb552a4461"><td class="memTemplItemLeft" align="right" valign="top">TComplex&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a8f2a4664af776ca513141edb552a4461">asymetricThinningScheme</a> (TComplex &amp;vc, std::function&lt; std::pair&lt; typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a>, typename TComplex::Data &gt;(const typename TComplex::Clique &amp;) &gt; Select, std::function&lt; bool(const TComplex &amp;, const typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a> &amp;) &gt; Skel, bool verbose=false)</td></tr>
<tr class="separator:a8f2a4664af776ca513141edb552a4461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d491155b4e945e904080855a3bae28"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:a46d491155b4e945e904080855a3bae28"><td class="memTemplItemLeft" align="right" valign="top">TComplex&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a46d491155b4e945e904080855a3bae28">persistenceAsymetricThinningScheme</a> (TComplex &amp;vc, std::function&lt; std::pair&lt; typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a>, typename TComplex::Data &gt;(const typename TComplex::Clique &amp;) &gt; Select, std::function&lt; bool(const TComplex &amp;, const typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a> &amp;) &gt; Skel, <a class="el" href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e">uint32_t</a> persistence, bool verbose=false)</td></tr>
<tr class="separator:a46d491155b4e945e904080855a3bae28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96220e2a64c64f8380043319b6c5e329"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:a96220e2a64c64f8380043319b6c5e329"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a>, typename TComplex::Data &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a96220e2a64c64f8380043319b6c5e329">selectFirst</a> (const typename TComplex::Clique &amp;clique)</td></tr>
<tr class="separator:a96220e2a64c64f8380043319b6c5e329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa469c81c1af173fe1758bba410f4a940"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:aa469c81c1af173fe1758bba410f4a940"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a>, typename TComplex::Data &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#aa469c81c1af173fe1758bba410f4a940">selectRandom</a> (const typename TComplex::Clique &amp;clique)</td></tr>
<tr class="separator:aa469c81c1af173fe1758bba410f4a940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ff3e47b9d4cb74977f0d493f548184"><td class="memTemplParams" colspan="2">template&lt;typename TComplex , typename TRandomGenerator &gt; </td></tr>
<tr class="memitem:ab4ff3e47b9d4cb74977f0d493f548184"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a>, typename TComplex::Data &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#ab4ff3e47b9d4cb74977f0d493f548184">selectRandom</a> (const typename TComplex::Clique &amp;clique, TRandomGenerator &amp;gen)</td></tr>
<tr class="separator:ab4ff3e47b9d4cb74977f0d493f548184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8833a616f9e288f432a67eea853217d9"><td class="memTemplParams" colspan="2">template&lt;typename TDistanceTransform , typename TComplex &gt; </td></tr>
<tr class="memitem:a8833a616f9e288f432a67eea853217d9"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a>, typename TComplex::Data &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a8833a616f9e288f432a67eea853217d9">selectMaxValue</a> (const TDistanceTransform &amp;dist_map, const typename TComplex::Clique &amp;clique)</td></tr>
<tr class="separator:a8833a616f9e288f432a67eea853217d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a335e8f7956c3188e031a8d83a5ea7"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:ad1a335e8f7956c3188e031a8d83a5ea7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#ad1a335e8f7956c3188e031a8d83a5ea7">skelUltimate</a> (const TComplex &amp;vc, const typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a> &amp;cell)</td></tr>
<tr class="separator:ad1a335e8f7956c3188e031a8d83a5ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b08e83670143586a55950e050aa6ad"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:a73b08e83670143586a55950e050aa6ad"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a73b08e83670143586a55950e050aa6ad">skelEnd</a> (const TComplex &amp;vc, const typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a> &amp;cell)</td></tr>
<tr class="separator:a73b08e83670143586a55950e050aa6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8e89624580d0a7c6ecebbb8a3d072d"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:a4e8e89624580d0a7c6ecebbb8a3d072d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a4e8e89624580d0a7c6ecebbb8a3d072d">skelSimple</a> (const TComplex &amp;vc, const typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a> &amp;cell)</td></tr>
<tr class="separator:a4e8e89624580d0a7c6ecebbb8a3d072d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147a79d431e108b58dd715c876da90ec"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:a147a79d431e108b58dd715c876da90ec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a147a79d431e108b58dd715c876da90ec">skelIsthmus</a> (const TComplex &amp;vc, const typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a> &amp;cell)</td></tr>
<tr class="separator:a147a79d431e108b58dd715c876da90ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affff269feb515ccbb61fed6df33bd403"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:affff269feb515ccbb61fed6df33bd403"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#affff269feb515ccbb61fed6df33bd403">oneIsthmus</a> (const TComplex &amp;vc, const typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a> &amp;cell)</td></tr>
<tr class="separator:affff269feb515ccbb61fed6df33bd403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86a0dd4add6c1b9f567908893b4a69d"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:ad86a0dd4add6c1b9f567908893b4a69d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#ad86a0dd4add6c1b9f567908893b4a69d">twoIsthmus</a> (const TComplex &amp;vc, const typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a> &amp;cell)</td></tr>
<tr class="separator:ad86a0dd4add6c1b9f567908893b4a69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d911a3be8b0751f42bc11e96d3af1b"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:a23d911a3be8b0751f42bc11e96d3af1b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a23d911a3be8b0751f42bc11e96d3af1b">skelWithTable</a> (const boost::dynamic_bitset&lt;&gt; &amp;table, const std::unordered_map&lt; typename <a class="el" href="testCubicalComplex_8cpp.html#a15e9592ccc512dc691b46185e6814758">TComplex::Point</a>, unsigned int &gt; &amp;pointToMaskMap, const TComplex &amp;vc, const typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a> &amp;cell)</td></tr>
<tr class="separator:a23d911a3be8b0751f42bc11e96d3af1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dba32b69179583e300225bf4227a381"><td class="memTemplParams" colspan="2">template&lt;typename TObject &gt; </td></tr>
<tr class="memitem:a4dba32b69179583e300225bf4227a381"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a4dba32b69179583e300225bf4227a381">isZeroSurface</a> (const TObject &amp;small_obj)</td></tr>
<tr class="separator:a4dba32b69179583e300225bf4227a381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c782738287493c15465124d3516d4ec"><td class="memTemplParams" colspan="2">template&lt;typename TObject &gt; </td></tr>
<tr class="memitem:a5c782738287493c15465124d3516d4ec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a5c782738287493c15465124d3516d4ec">isOneSurface</a> (const TObject &amp;small_obj)</td></tr>
<tr class="separator:a5c782738287493c15465124d3516d4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafaf8919cafd89499a5a3206f969735b"><td class="memTemplParams" colspan="2">template&lt;typename TObject &gt; </td></tr>
<tr class="memitem:aafaf8919cafd89499a5a3206f969735b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; TObject &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#aafaf8919cafd89499a5a3206f969735b">connectedComponents</a> (const TObject &amp;input_obj, bool verbose)</td></tr>
<tr class="separator:aafaf8919cafd89499a5a3206f969735b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><code>functions</code> namespace gathers all <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> functionsxs. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="af95dcf36f806f7fc15626ca6b1c27d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95dcf36f806f7fc15626ca6b1c27d22">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T DGtal::functions::abs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the absolute value of an instance of type T.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of elements to compare (model of <a class="el" href="structboost_1_1LessThanComparable.html" title="Go to http://www.sgi.com/tech/stl/LessThanComparable.html.">boost::LessThanComparable</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the absolute value |a|. </dd></dl>

<p class="definition">Definition at line <a class="el" href="BasicMathFunctions_8h_source.html#l00116">116</a> of file <a class="el" href="BasicMathFunctions_8h_source.html">BasicMathFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    {</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;      BOOST_CONCEPT_ASSERT((<a class="code" href="structboost_1_1LessThanComparable.html">boost::LessThanComparable&lt;T&gt;</a>));</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;      <span class="keywordflow">if</span> (a&lt;0) </div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        <span class="keywordflow">return</span> -a;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        <span class="keywordflow">return</span> a;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    }</div><div class="ttc" id="structboost_1_1LessThanComparable_html"><div class="ttname"><a href="structboost_1_1LessThanComparable.html">boost::LessThanComparable</a></div><div class="ttdoc">Go to http://www.sgi.com/tech/stl/LessThanComparable.html.</div><div class="ttdef"><b>Definition:</b> <a href="Boost_8dox_source.html#l00048">Boost.dox:48</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac97099c06241a42dce86a53230b665d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97099c06241a42dce86a53230b665d7">&#9670;&nbsp;</a></span>assignDifference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container&amp; DGtal::functions::assignDifference </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set difference operation. Updates the set S1 as S1 - S2. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, <em>S1</em> - <em>S2</em> as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l00896">896</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;    {</div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;        ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;        ( <span class="keywordtype">bool</span>, isOrdered = ordered </div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;          || ( isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value ) );</div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#aa8b448648a8af77b80fe9a62651041f4">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#aa8b448648a8af77b80fe9a62651041f4">        ::assignDifference</a>( S1, S2 );</div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;    }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html_aa8b448648a8af77b80fe9a62651041f4"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#aa8b448648a8af77b80fe9a62651041f4">DGtal::detail::SetFunctionsImpl::assignDifference</a></div><div class="ttdeci">static Container &amp; assignDifference(Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00292">SetFunctions.h:292</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l00292">DGtal::detail::SetFunctionsImpl&lt; Container, associative, ordered &gt;::assignDifference()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SetFunctions_8h_source.html#l00965">makeDifference()</a>, and <a class="el" href="SetFunctions_8h_source.html#l01272">DGtal::functions::setops::operator-=()</a>.</p>

</div>
</div>
<a id="a0b91c6c5fb3c893dd709f4e90e9eff93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b91c6c5fb3c893dd709f4e90e9eff93">&#9670;&nbsp;</a></span>assignDifference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container&amp; DGtal::functions::assignDifference </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set difference operation. Updates the set S1 as S1 - S2. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, <em>S1</em> - <em>S2</em> as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l00918">918</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;    {</div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;        ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;        ( <span class="keywordtype">bool</span>, isOrdered = isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#aa8b448648a8af77b80fe9a62651041f4">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#aa8b448648a8af77b80fe9a62651041f4">        ::assignDifference</a>( S1, S2 );</div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;    }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html_aa8b448648a8af77b80fe9a62651041f4"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#aa8b448648a8af77b80fe9a62651041f4">DGtal::detail::SetFunctionsImpl::assignDifference</a></div><div class="ttdeci">static Container &amp; assignDifference(Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00292">SetFunctions.h:292</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l00292">DGtal::detail::SetFunctionsImpl&lt; Container, associative, ordered &gt;::assignDifference()</a>.</p>

</div>
</div>
<a id="af3360043e7032e9a8eaf2ef0fde60afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3360043e7032e9a8eaf2ef0fde60afd">&#9670;&nbsp;</a></span>assignIntersection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container&amp; DGtal::functions::assignIntersection </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set intersection operation. Updates the set <em>S1</em> as \( S1 \cap S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, \( S1 \cap S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l01082">1082</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;    {</div><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;        ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;        ( <span class="keywordtype">bool</span>, isOrdered = ordered </div><div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;          || ( isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value ) );</div><div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;</div><div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#af6b7ddeea2845c7b2197529e45d359a0">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#af6b7ddeea2845c7b2197529e45d359a0">        ::assignIntersection</a>( S1, S2 );</div><div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;    }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html_af6b7ddeea2845c7b2197529e45d359a0"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#af6b7ddeea2845c7b2197529e45d359a0">DGtal::detail::SetFunctionsImpl::assignIntersection</a></div><div class="ttdeci">static Container &amp; assignIntersection(Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00340">SetFunctions.h:340</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l00340">DGtal::detail::SetFunctionsImpl&lt; Container, associative, ordered &gt;::assignIntersection()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SetFunctions_8h_source.html#l01149">makeIntersection()</a>, and <a class="el" href="SetFunctions_8h_source.html#l01346">DGtal::functions::setops::operator&amp;=()</a>.</p>

</div>
</div>
<a id="a03568b922cfd14ec380c2b297af70dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03568b922cfd14ec380c2b297af70dff">&#9670;&nbsp;</a></span>assignIntersection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container&amp; DGtal::functions::assignIntersection </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set intersection operation. Updates the set <em>S1</em> as \( S1 \cap S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, \( S1 \cap S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l01104">1104</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;    {</div><div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;        ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;        ( <span class="keywordtype">bool</span>, isOrdered = isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;</div><div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#af6b7ddeea2845c7b2197529e45d359a0">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#af6b7ddeea2845c7b2197529e45d359a0">        ::assignIntersection</a>( S1, S2 );</div><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;    }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html_af6b7ddeea2845c7b2197529e45d359a0"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#af6b7ddeea2845c7b2197529e45d359a0">DGtal::detail::SetFunctionsImpl::assignIntersection</a></div><div class="ttdeci">static Container &amp; assignIntersection(Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00340">SetFunctions.h:340</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l00340">DGtal::detail::SetFunctionsImpl&lt; Container, associative, ordered &gt;::assignIntersection()</a>.</p>

</div>
</div>
<a id="a65694ad895f3f4cb42c54213fce7295a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65694ad895f3f4cb42c54213fce7295a">&#9670;&nbsp;</a></span>assignSymmetricDifference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container&amp; DGtal::functions::assignSymmetricDifference </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set symmetric difference operation. Updates the set <em>S1</em> as \( S1 \Delta S2 \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, \( S1 \Delta S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l01176">1176</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;    {</div><div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;        ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;        ( <span class="keywordtype">bool</span>, isOrdered = ordered </div><div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;          || ( isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value ) );</div><div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;</div><div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#a52124e468c2ef88c6c93cdd7ceb84d21">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#a52124e468c2ef88c6c93cdd7ceb84d21">        ::assignSymmetricDifference</a>( S1, S2 );</div><div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;    }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html_a52124e468c2ef88c6c93cdd7ceb84d21"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#a52124e468c2ef88c6c93cdd7ceb84d21">DGtal::detail::SetFunctionsImpl::assignSymmetricDifference</a></div><div class="ttdeci">static Container &amp; assignSymmetricDifference(Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00365">SetFunctions.h:365</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l00365">DGtal::detail::SetFunctionsImpl&lt; Container, associative, ordered &gt;::assignSymmetricDifference()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SetFunctions_8h_source.html#l01243">makeSymmetricDifference()</a>, and <a class="el" href="SetFunctions_8h_source.html#l01378">DGtal::functions::setops::operator^=()</a>.</p>

</div>
</div>
<a id="a20e5c37c5f1aaade38460038220ce4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e5c37c5f1aaade38460038220ce4fd">&#9670;&nbsp;</a></span>assignSymmetricDifference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container&amp; DGtal::functions::assignSymmetricDifference </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set symmetric difference operation. Updates the set <em>S1</em> as \( S1 \Delta S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, \( S1 \Delta S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l01198">1198</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;    {</div><div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;        ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;        ( <span class="keywordtype">bool</span>, isOrdered = isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;</div><div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#a52124e468c2ef88c6c93cdd7ceb84d21">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#a52124e468c2ef88c6c93cdd7ceb84d21">        ::assignSymmetricDifference</a>( S1, S2 );</div><div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;    }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html_a52124e468c2ef88c6c93cdd7ceb84d21"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#a52124e468c2ef88c6c93cdd7ceb84d21">DGtal::detail::SetFunctionsImpl::assignSymmetricDifference</a></div><div class="ttdeci">static Container &amp; assignSymmetricDifference(Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00365">SetFunctions.h:365</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l00365">DGtal::detail::SetFunctionsImpl&lt; Container, associative, ordered &gt;::assignSymmetricDifference()</a>.</p>

</div>
</div>
<a id="ac58ca694e397fb84d77c53aba2134887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac58ca694e397fb84d77c53aba2134887">&#9670;&nbsp;</a></span>assignUnion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container&amp; DGtal::functions::assignUnion </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set union operation. Updates the set <em>S1</em> as \( S1 \cup S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, \( S1 \cup S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l00990">990</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;    {</div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;        ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;        ( <span class="keywordtype">bool</span>, isOrdered = ordered </div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;          || ( isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value ) );</div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#af20946f574a308bc5fdc2b0e03ea9687">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#af20946f574a308bc5fdc2b0e03ea9687">        ::assignUnion</a>( S1, S2 );</div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;    }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html_af20946f574a308bc5fdc2b0e03ea9687"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#af20946f574a308bc5fdc2b0e03ea9687">DGtal::detail::SetFunctionsImpl::assignUnion</a></div><div class="ttdeci">static Container &amp; assignUnion(Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00316">SetFunctions.h:316</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l00316">DGtal::detail::SetFunctionsImpl&lt; Container, associative, ordered &gt;::assignUnion()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SetFunctions_8h_source.html#l01057">makeUnion()</a>, and <a class="el" href="SetFunctions_8h_source.html#l01317">DGtal::functions::setops::operator|=()</a>.</p>

</div>
</div>
<a id="a4932db4b89711ecfc43c950766c8a3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4932db4b89711ecfc43c950766c8a3c2">&#9670;&nbsp;</a></span>assignUnion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container&amp; DGtal::functions::assignUnion </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set union operation. Updates the set <em>S1</em> as \( S1 \cup S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, \( S1 \cup S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l01012">1012</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;    {</div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;        ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;        ( <span class="keywordtype">bool</span>, isOrdered = isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;</div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#af20946f574a308bc5fdc2b0e03ea9687">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#af20946f574a308bc5fdc2b0e03ea9687">        ::assignUnion</a>( S1, S2 );</div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;    }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html_af20946f574a308bc5fdc2b0e03ea9687"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#af20946f574a308bc5fdc2b0e03ea9687">DGtal::detail::SetFunctionsImpl::assignUnion</a></div><div class="ttdeci">static Container &amp; assignUnion(Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00316">SetFunctions.h:316</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l00316">DGtal::detail::SetFunctionsImpl&lt; Container, associative, ordered &gt;::assignUnion()</a>.</p>

</div>
</div>
<a id="a8f2a4664af776ca513141edb552a4461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2a4664af776ca513141edb552a4461">&#9670;&nbsp;</a></span>asymetricThinningScheme()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TComplex DGtal::functions::asymetricThinningScheme </td>
          <td>(</td>
          <td class="paramtype">TComplex &amp;&#160;</td>
          <td class="paramname"><em>vc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; std::pair&lt; typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a>, typename TComplex::Data &gt;(const typename TComplex::Clique &amp;) &gt;&#160;</td>
          <td class="paramname"><em>Select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const TComplex &amp;, const typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a> &amp;) &gt;&#160;</td>
          <td class="paramname"><em>Skel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a612e2adbf3983c441753beb63fd55f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612e2adbf3983c441753beb63fd55f86">&#9670;&nbsp;</a></span>checkAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::checkAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;&#160;</td>
          <td class="paramname"><em>aDSS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether a DSS is valid or not. NB: in logarithmic time (in order to check that a and b are relatively prime) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDSS</td><td>any DSS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if valid, 'false' otherwise. </dd></dl>

</div>
</div>
<a id="a6e4fa6a6be77e4813577c8a2b3572299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4fa6a6be77e4813577c8a2b3572299">&#9670;&nbsp;</a></span>checkOnePoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::checkOnePoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;&#160;</td>
          <td class="paramname"><em>aDSS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks the validity of the DSS when it contains only one point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDSS</td><td>any DSS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>the DSS contains only one point </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the DSS is valid, 'false' otherwise. </dd></dl>

</div>
</div>
<a id="a6b421081da133e4069fe9cbddf33aa54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b421081da133e4069fe9cbddf33aa54">&#9670;&nbsp;</a></span>checkPointsPosition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::checkPointsPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;&#160;</td>
          <td class="paramname"><em>aDSS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that the difference between two extremal upper (resp. lower) leaning points is equal to the direction vector (a,b) scaled by an integer. Checks that there is no pattern between end points and extremal leaning points. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDSS</td><td>any DSS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>the DSS contains more than one point, ie a and b are not both null. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if ok, 'false' otherwise. </dd></dl>

</div>
</div>
<a id="a1e697b1094865df340ba6206354f7c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e697b1094865df340ba6206354f7c37">&#9670;&nbsp;</a></span>checkPointsRemainder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::checkPointsRemainder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;&#160;</td>
          <td class="paramname"><em>aDSS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks the consistency between the parameters and the leaning points: first and last upper leaning points should have a remainder equal to mu while firsta and last lower leaning points should have a remainder equal to mu + omega - 1. Moreover, front and back points should have a remainder lying within the range [mu, mu+omega[. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDSS</td><td>any DSS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>the DSS contains more than one point, ie a and b are not both null. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if this property is fulfilled, 'false' otherwise. </dd></dl>

</div>
</div>
<a id="a72edc3d9d652158c3d02a6a11386f249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72edc3d9d652158c3d02a6a11386f249">&#9670;&nbsp;</a></span>collapse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer , typename CellConstIterator , typename CellMapIteratorPriority &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5">uint64_t</a> DGtal::functions::collapse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CellConstIterator&#160;</td>
          <td class="paramname"><em>S_itB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CellConstIterator&#160;</td>
          <td class="paramname"><em>S_itE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CellMapIteratorPriority &amp;&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hintIsSClosed</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hintIsKClosed</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collapse a user-specified part of complex <em>K</em>, collapsing cells following priority [priority], in a decreasing sequence until no more collapse is feasible. The range [<em>S_itb</em>,<em>S_itE</em>) provides the starting cells, generally (but not compulsory) maximal cells. The resulting complex is guaranteed to keep the same homotopy type (a kind of topology equivalence).</p>
<dl class="section note"><dt>Note</dt><dd>Cells whose data has been marked as FIXED are not removed.</dd>
<dd>
Only cells that are in the closure of [<em>S_itb</em>,<em>S_itE</em>) may be removed, and only if they are not marked as FIXED.</dd></dl>
<dl class="section user"><dt>Advanced:</dt><dd>If you use a DefaultCellMapIteratorPriority object as <em>priority</em>, then the VALUE part of each cell data defines the priority (the highest value the soonest are these cells collapsed). You may thus fill these cell values before calling this method.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
    <tr><td class="paramname">CellConstIterator</td><td>any forward const iterator on Cell.</td></tr>
    <tr><td class="paramname">CellMapIteratorPriority</td><td>any type defining a method 'bool operator()( const Cell&amp;, const Cell&amp;) const'. Defines the order in which cells are collapsed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>DefaultCellMapIteratorPriority</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">K</td><td>the complex that is collapsed. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">S_itB</td><td>the start of a range of cells which is included in [K]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">S_itE</td><td>the end of a range of cells which is included in [K]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">priority</td><td>the object that assign a priority to each cell. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">hintIsSClosed</td><td>indicates if [<em>S_itb</em>,<em>S_ite</em>) is a closed set (faster in this case). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">hintIsKClosed</td><td>indicates that complex <em>K</em> is closed. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">verbose</td><td>outputs some information during processing when 'true'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of cells removed from complex <em>K</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cubical-complex-collapse_8cpp.html">topology/cubical-complex-collapse.cpp</a> </dd></dl>

</div>
</div>
<a id="aafaf8919cafd89499a5a3206f969735b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafaf8919cafd89499a5a3206f969735b">&#9670;&nbsp;</a></span>connectedComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TObject &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; TObject &gt; DGtal::functions::connectedComponents </td>
          <td>(</td>
          <td class="paramtype">const TObject &amp;&#160;</td>
          <td class="paramname"><em>input_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get all connected components of the input object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TObject</td><td><a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> Type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_obj</td><td>input object </td></tr>
    <tr><td class="paramname">verbose</td><td>flag to be verbose at execution</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of TObject containing the different connected components of the object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ObjectBoostGraphInterface_8h_source.html">ObjectBoostGraphInterface.h</a> </dd></dl>

</div>
</div>
<a id="a4828e0475cb9aa8dceefa94f0ab4d168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4828e0475cb9aa8dceefa94f0ab4d168">&#9670;&nbsp;</a></span>cube()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T DGtal::functions::cube </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value x * x * x </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>a type with the multiply operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>any value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value x * x * x </dd></dl>

<p class="definition">Definition at line <a class="el" href="BasicMathFunctions_8h_source.html#l00144">144</a> of file <a class="el" href="BasicMathFunctions_8h_source.html">BasicMathFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    { <span class="keywordflow">return</span> x * x * x; }</div></div><!-- fragment -->
</div>
</div>
<a id="a8066d9f6db356f21fac91f53ffdde53d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8066d9f6db356f21fac91f53ffdde53d">&#9670;&nbsp;</a></span>filterCellsWithinBounds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer , typename BdryCellOutputIterator , typename InnerCellOutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::filterCellsWithinBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="testCubicalComplex_8cpp.html#a15e9592ccc512dc691b46185e6814758">TKSpace::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>kLow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="testCubicalComplex_8cpp.html#a15e9592ccc512dc691b46185e6814758">TKSpace::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>kUp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BdryCellOutputIterator&#160;</td>
          <td class="paramname"><em>itBdry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerCellOutputIterator&#160;</td>
          <td class="paramname"><em>itInner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the cells of the given complex <em>K</em> that lies on the boundary or inside the parallelepiped specified by bounds <em>kLow</em> and <em>kUp</em>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
    <tr><td class="paramname">BdryCellOutputIterator</td><td>any output iterator on TCubicalComplex::Cell. </td></tr>
    <tr><td class="paramname">InnerCellOutputIterator</td><td>any output iterator on TCubicalComplex::Cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>any cubical complex.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kLow</td><td>any Khalimsky coordinate representing the lowest possible cell.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kUp</td><td>any Khalimsky coordinate representing the uppermost possible cell.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">itBdry</td><td>An output iterator on Cell that outputs all the cells of <em>K</em> that lie on the boundary of the parallelepiped specified by bounds <em>kLow</em> and <em>kUp</em>.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">itInner</td><td>An output iterator on Cell that outputs all the cells of <em>K</em> that lie in the interior of the parallelepiped specified by bounds <em>kLow</em> and <em>kUp</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Complexity is linear in the number of cells of <em>K</em> (but the constant is also linear in the dimension of <em>K</em>). </dd></dl>

</div>
</div>
<a id="a924114c3907d5c86e064a513779d24a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924114c3907d5c86e064a513779d24a8">&#9670;&nbsp;</a></span>generateSimplicityTable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TObject , typename TMap &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::generateSimplicityTable </td>
          <td>(</td>
          <td class="paramtype">const typename TObject::DigitalTopology &amp;&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMap &amp;&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a digital topology <em>dt</em>, generates tables that tells if the central point is simple for the specified configuration. The configuration is determined by a sequence of bits, the first bit for the point in the neighborhood, the second bit for the second point, etc. When set to one, the point is in the neighborhood.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TObject</td><td>the type of object whose simpleness we wish to precompute. Includes the topology. </td></tr>
    <tr><td class="paramname">TMap</td><td>the type used to store the mapping configuration -&gt; bool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>an instance of the digital topology. </td></tr>
    <tr><td class="paramname">map</td><td>(modified) the mapping configuration -&gt; bool. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="NeighborhoodTablesGenerators_8h_source.html#l00071">71</a> of file <a class="el" href="NeighborhoodTablesGenerators_8h_source.html">NeighborhoodTablesGenerators.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  {</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    <span class="keyword">typedef</span> <span class="keyword">typename</span> TObject::DigitalSet <a class="code" href="namespaceDGtal_1_1Z2i.html#a371252c324e496cf8650757c1a2b4eb0">DigitalSet</a>;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">TObject::Point</a> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">DigitalSet::Domain</a> <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a>;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classDGtal_1_1HyperRectDomain__Iterator.html">Domain::ConstIterator</a> DomainConstIterator;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> p1 = Point::diagonal( -1 );</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> p2 = Point::diagonal(  1 );</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> c = Point::diagonal( 0 );</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>( p1, p2 );</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <a class="code" href="namespaceDGtal_1_1Z2i.html#a371252c324e496cf8650757c1a2b4eb0">DigitalSet</a> shapeSet( <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a> );</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    TObject shape( dt, shapeSet );</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    <span class="keywordflow">for</span> ( DomainConstIterator it = <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.begin(); it != <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.end(); ++it )</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;      <span class="keywordflow">if</span> ( *it != c ) ++k;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    ASSERT( ( k &lt; 32 )</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        &amp;&amp; <span class="stringliteral">&quot;[generateSimplicityTable] number of configurations is too high.&quot;</span> );</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbCfg = 1 &lt;&lt; k;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    <span class="keywordflow">for</span> ( NeighborhoodConfiguration cfg = 0; cfg &lt; nbCfg; ++cfg )</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    {</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;      <span class="keywordflow">if</span> ( ( cfg % 1000 ) == 0 )</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;      {</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;        <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad8efd553b31277903be115e7aa256f74">progressBar</a>( (<span class="keywordtype">double</span>) cfg, (<span class="keywordtype">double</span>) nbCfg );</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;      }</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;      shape.pointSet().clear();</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;      shape.pointSet().insert( c );</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;      <a class="code" href="namespaceDGtal.html#a319e1944935b8331846f54001a63525f">NeighborhoodConfiguration</a> mask = 1;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;      <span class="keywordflow">for</span> ( DomainConstIterator it = <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.begin(); it != <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.end(); ++it )</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;      {</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        <span class="keywordflow">if</span> ( *it != c )</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        {</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;          <span class="keywordflow">if</span> ( cfg &amp; mask ) shape.pointSet().insert( *it );</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;          mask &lt;&lt;= 1;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        }</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;      }</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;      <span class="keywordtype">bool</span> simple = shape.isSimple( c );</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;      map[ cfg ] = simple;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    }</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  }</div><div class="ttc" id="namespaceDGtal_1_1Z2i_html_a371252c324e496cf8650757c1a2b4eb0"><div class="ttname"><a href="namespaceDGtal_1_1Z2i.html#a371252c324e496cf8650757c1a2b4eb0">DGtal::Z2i::DigitalSet</a></div><div class="ttdeci">DigitalSetSelector&lt; Domain, BIG_DS+HIGH_BEL_DS &gt;::Type DigitalSet</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00100">StdDefs.h:100</a></div></div>
<div class="ttc" id="testSimpleRandomAccessRangeFromPoint_8cpp_html_acd532b318489cd93df57e0b3d136d050"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a></div><div class="ttdeci">HyperRectDomain&lt; Space &gt; Domain</div><div class="ttdef"><b>Definition:</b> <a href="testSimpleRandomAccessRangeFromPoint_8cpp_source.html#l00044">testSimpleRandomAccessRangeFromPoint.cpp:44</a></div></div>
<div class="ttc" id="classDGtal_1_1Trace_html_ad8efd553b31277903be115e7aa256f74"><div class="ttname"><a href="classDGtal_1_1Trace.html#ad8efd553b31277903be115e7aa256f74">DGtal::Trace::progressBar</a></div><div class="ttdeci">void progressBar(const double currentValue, const double maximalValue)</div></div>
<div class="ttc" id="namespaceDGtal_html_a8fc7012708b0416880a5c8b12dfdf9dd"><div class="ttname"><a href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">DGtal::trace</a></div><div class="ttdeci">Trace trace</div><div class="ttdef"><b>Definition:</b> <a href="Common_8h_source.html#l00144">Common.h:144</a></div></div>
<div class="ttc" id="namespaceDGtal_html_a319e1944935b8331846f54001a63525f"><div class="ttname"><a href="namespaceDGtal.html#a319e1944935b8331846f54001a63525f">DGtal::NeighborhoodConfiguration</a></div><div class="ttdeci">uint32_t NeighborhoodConfiguration</div><div class="ttdef"><b>Definition:</b> <a href="NeighborhoodConfigurationsHelper_8h_source.html#l00043">NeighborhoodConfigurationsHelper.h:43</a></div></div>
<div class="ttc" id="testProjection_8cpp_html_a1f1a69f8d8b037b72c2160ed12b3ef51"><div class="ttname"><a href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a></div><div class="ttdeci">Domain domain</div><div class="ttdef"><b>Definition:</b> <a href="testProjection_8cpp_source.html#l00088">testProjection.cpp:88</a></div></div>
<div class="ttc" id="testClone2_8cpp_html_a15e9592ccc512dc691b46185e6814758"><div class="ttname"><a href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a></div><div class="ttdeci">MyPointD Point</div><div class="ttdef"><b>Definition:</b> <a href="testClone2_8cpp_source.html#l00383">testClone2.cpp:383</a></div></div>
<div class="ttc" id="classDGtal_1_1HyperRectDomain__Iterator_html"><div class="ttname"><a href="classDGtal_1_1HyperRectDomain__Iterator.html">DGtal::HyperRectDomain_Iterator</a></div><div class="ttdef"><b>Definition:</b> <a href="HyperRectDomain__Iterator_8h_source.html#l00158">HyperRectDomain_Iterator.h:158</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="testProjection_8cpp_source.html#l00088">domain</a>, <a class="el" href="classDGtal_1_1Trace.html#ad8efd553b31277903be115e7aa256f74">DGtal::Trace::progressBar()</a>, and <a class="el" href="Common_8h_source.html#l00144">DGtal::trace</a>.</p>

</div>
</div>
<a id="a1fc0eb12f18205fd5335ef3068753109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc0eb12f18205fd5335ef3068753109">&#9670;&nbsp;</a></span>generateVoxelComplexTable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TVoxelComplex , typename TMap &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::generateVoxelComplexTable </td>
          <td>(</td>
          <td class="paramtype">TMap &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const TVoxelComplex &amp;, const typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TVoxelComplex::Cell</a> &amp;) &gt;&#160;</td>
          <td class="paramname"><em>skelFunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a table mapping the number of configuration of a 26 topology voxel neighborhood, and the boolean result of a predicate function applied to the central point for each configuration. The configuration is determined by a sequence of bits, the first bit for the point in the neighborhood, the second bit for the second point, etc. When set to one, the point is in the neighborhood.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TVoxelComplex</td><td>the type of the <a class="el" href="classDGtal_1_1VoxelComplex.html" title="This class represents a voxel complex living in some Khalimsky space. Voxel complexes are derived fro...">VoxelComplex</a> whose property we wish to precompute.</td></tr>
    <tr><td class="paramname">TMap</td><td>the type used to store the mapping configuration -&gt; bool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>(modified) the mapping configuration -&gt; bool. </td></tr>
    <tr><td class="paramname">skelFunction</td><td>a predicate function related to the property we want to check. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="NeighborhoodTablesGenerators_8h_source.html#l00132">132</a> of file <a class="el" href="NeighborhoodTablesGenerators_8h_source.html">NeighborhoodTablesGenerators.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    {</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;      <span class="keyword">using</span> <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> = <a class="code" href="namespaceDGtal_1_1Z3i.html#a39a69f8da09f1094df563ca067927c61">DGtal::Z3i::Domain</a>;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;      <span class="keyword">using</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> = <span class="keyword">typename</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Domain::Point</a> ;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;      <span class="keyword">using</span> <a class="code" href="namespaceDGtal_1_1Z2i.html#a371252c324e496cf8650757c1a2b4eb0">DigitalSet</a> = DigitalSetByAssociativeContainer&lt;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a>, std::unordered_set&lt; Point &gt; &gt;;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;      <span class="keyword">using</span> DomainConstIterator = <span class="keyword">typename</span> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">Domain::ConstIterator</a> ;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;      <span class="keyword">using</span> <a class="code" href="classDGtal_1_1KhalimskySpaceND.html">KSpace</a> = <span class="keyword">typename</span> <a class="code" href="sphereCotangentLaplaceOperator_8cpp.html#a55d0319fc69f55ae6fba7a8dd4d6f3e8">TVoxelComplex::KSpace</a>;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;      <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> p1 = Point::diagonal( -1 );</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;      <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> p2 = Point::diagonal(  1 );</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;      <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> c = Point::diagonal( 0 );</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;      <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>( p1, p2 );</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;      <a class="code" href="namespaceDGtal_1_1Z2i.html#a371252c324e496cf8650757c1a2b4eb0">DigitalSet</a> shapeSet( <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a> );</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;      <span class="keywordflow">for</span> ( DomainConstIterator it = <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.begin(); it != <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.end(); ++it )</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        <span class="keywordflow">if</span> ( *it != c ) ++k;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;      ASSERT( ( k &lt; 32 )</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;          &amp;&amp; <span class="stringliteral">&quot;[generateVoxelComplexTable] number of configurations is too high.&quot;</span> );</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbCfg = 1 &lt;&lt; k;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;      <a class="code" href="classDGtal_1_1KhalimskySpaceND.html">KSpace</a> ks;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;      <span class="comment">// Pad KSpace domain.</span></div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;      ks.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a15dcbcaae831dd1c36090e6336c177d4">init</a>(<a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.lowerBound() + Point::diagonal( -1 ) ,</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;          <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.upperBound() + Point::diagonal( 1 ),</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;          <span class="keyword">true</span>);</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;      TVoxelComplex vc(ks);</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;      vc.construct(shapeSet);</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;      <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cfg = 0; cfg &lt; nbCfg; ++cfg ){</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        <span class="keywordflow">if</span> ( ( cfg % 1000 ) == 0 )</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;          <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad8efd553b31277903be115e7aa256f74">progressBar</a>( (<span class="keywordtype">double</span>) cfg, (<span class="keywordtype">double</span>) nbCfg );</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        vc.clear();</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        vc.insertVoxelPoint(c);</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mask = 1;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;        <span class="keywordflow">for</span> ( DomainConstIterator it = <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.begin(); it != <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.end(); ++it ){</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;          <span class="keywordflow">if</span> ( *it != c ) {</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;            <span class="keywordflow">if</span> ( cfg &amp; mask ) vc.insertVoxelPoint( *it );</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;            mask &lt;&lt;= 1;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;          }</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;        }</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;kcell = vc.space().uSpel(c);</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;        <span class="keywordtype">bool</span> predicate_output = skelFunction(vc, kcell);</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;        map[ cfg ] = predicate_output;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;      }</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    }</div><div class="ttc" id="namespaceDGtal_1_1Z2i_html_a371252c324e496cf8650757c1a2b4eb0"><div class="ttname"><a href="namespaceDGtal_1_1Z2i.html#a371252c324e496cf8650757c1a2b4eb0">DGtal::Z2i::DigitalSet</a></div><div class="ttdeci">DigitalSetSelector&lt; Domain, BIG_DS+HIGH_BEL_DS &gt;::Type DigitalSet</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00100">StdDefs.h:100</a></div></div>
<div class="ttc" id="testSimpleRandomAccessRangeFromPoint_8cpp_html_acd532b318489cd93df57e0b3d136d050"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a></div><div class="ttdeci">HyperRectDomain&lt; Space &gt; Domain</div><div class="ttdef"><b>Definition:</b> <a href="testSimpleRandomAccessRangeFromPoint_8cpp_source.html#l00044">testSimpleRandomAccessRangeFromPoint.cpp:44</a></div></div>
<div class="ttc" id="classDGtal_1_1Trace_html_ad8efd553b31277903be115e7aa256f74"><div class="ttname"><a href="classDGtal_1_1Trace.html#ad8efd553b31277903be115e7aa256f74">DGtal::Trace::progressBar</a></div><div class="ttdeci">void progressBar(const double currentValue, const double maximalValue)</div></div>
<div class="ttc" id="greedy-plane-segmentation-ex2_8cpp_html_a6d06fad433cff067dfcbbbf16d6e2dbf"><div class="ttname"><a href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a></div><div class="ttdeci">MyDigitalSurface::ConstIterator ConstIterator</div><div class="ttdef"><b>Definition:</b> <a href="greedy-plane-segmentation-ex2_8cpp_source.html#l00093">greedy-plane-segmentation-ex2.cpp:93</a></div></div>
<div class="ttc" id="namespaceDGtal_html_a8fc7012708b0416880a5c8b12dfdf9dd"><div class="ttname"><a href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">DGtal::trace</a></div><div class="ttdeci">Trace trace</div><div class="ttdef"><b>Definition:</b> <a href="Common_8h_source.html#l00144">Common.h:144</a></div></div>
<div class="ttc" id="namespaceDGtal_1_1Z3i_html_a39a69f8da09f1094df563ca067927c61"><div class="ttname"><a href="namespaceDGtal_1_1Z3i.html#a39a69f8da09f1094df563ca067927c61">DGtal::Z3i::Domain</a></div><div class="ttdeci">HyperRectDomain&lt; Space &gt; Domain</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00172">StdDefs.h:172</a></div></div>
<div class="ttc" id="testProjection_8cpp_html_a1f1a69f8d8b037b72c2160ed12b3ef51"><div class="ttname"><a href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a></div><div class="ttdeci">Domain domain</div><div class="ttdef"><b>Definition:</b> <a href="testProjection_8cpp_source.html#l00088">testProjection.cpp:88</a></div></div>
<div class="ttc" id="classDGtal_1_1KhalimskySpaceND_html_a15dcbcaae831dd1c36090e6336c177d4"><div class="ttname"><a href="classDGtal_1_1KhalimskySpaceND.html#a15dcbcaae831dd1c36090e6336c177d4">DGtal::KhalimskySpaceND::init</a></div><div class="ttdeci">bool init(const Point &amp;lower, const Point &amp;upper, bool isClosed)</div><div class="ttdoc">Specifies the upper and lower bounds for the maximal cells in this space.</div></div>
<div class="ttc" id="sphereCotangentLaplaceOperator_8cpp_html_a55d0319fc69f55ae6fba7a8dd4d6f3e8"><div class="ttname"><a href="sphereCotangentLaplaceOperator_8cpp.html#a55d0319fc69f55ae6fba7a8dd4d6f3e8">KSpace</a></div><div class="ttdeci">Z3i::KSpace KSpace</div><div class="ttdef"><b>Definition:</b> <a href="sphereCotangentLaplaceOperator_8cpp_source.html#l00070">sphereCotangentLaplaceOperator.cpp:70</a></div></div>
<div class="ttc" id="testClone2_8cpp_html_a15e9592ccc512dc691b46185e6814758"><div class="ttname"><a href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a></div><div class="ttdeci">MyPointD Point</div><div class="ttdef"><b>Definition:</b> <a href="testClone2_8cpp_source.html#l00383">testClone2.cpp:383</a></div></div>
<div class="ttc" id="classDGtal_1_1KhalimskySpaceND_html"><div class="ttname"><a href="classDGtal_1_1KhalimskySpaceND.html">DGtal::KhalimskySpaceND</a></div><div class="ttdoc">Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex,...</div><div class="ttdef"><b>Definition:</b> <a href="KhalimskySpaceND_8h_source.html#l00064">KhalimskySpaceND.h:64</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="testProjection_8cpp_source.html#l00088">domain</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a15dcbcaae831dd1c36090e6336c177d4">DGtal::KhalimskySpaceND&lt; dim, TInteger &gt;::init()</a>, <a class="el" href="classDGtal_1_1Trace.html#ad8efd553b31277903be115e7aa256f74">DGtal::Trace::progressBar()</a>, and <a class="el" href="Common_8h_source.html#l00144">DGtal::trace</a>.</p>

</div>
</div>
<a id="a4f2d27eacf401fb9f784a1569b3ded7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2d27eacf401fb9f784a1569b3ded7c">&#9670;&nbsp;</a></span>getSpelNeighborhoodConfigurationOccupancy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDGtal.html#a319e1944935b8331846f54001a63525f">NeighborhoodConfiguration</a> DGtal::functions::getSpelNeighborhoodConfigurationOccupancy </td>
          <td>(</td>
          <td class="paramtype">const TComplex &amp;&#160;</td>
          <td class="paramname"><em>input_complex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="testCubicalComplex_8cpp.html#a15e9592ccc512dc691b46185e6814758">TComplex::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; typename <a class="el" href="testCubicalComplex_8cpp.html#a15e9592ccc512dc691b46185e6814758">TComplex::Point</a>, <a class="el" href="namespaceDGtal.html#a319e1944935b8331846f54001a63525f">NeighborhoodConfiguration</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapPointToMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the occupancy configuration of the neighborhood of a point in a cubical complex. The neighborhood size is considered 3^D for dimension D of the point (ie 3x3x3 cube for 3D point).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TComplex</td><td>Complex type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_complex</td><td>input complex. Used to check what points are occupied. </td></tr>
    <tr><td class="paramname">center</td><td>of the neighborhood. It doesn't matter if center belongs or not to <b>input_complex</b>. </td></tr>
    <tr><td class="paramname">mapPointToMask</td><td>map[Point]-&gt;configuration, where Point is inside a DxD cube centered in {0,0,..} in ND.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This doesn't work with KSpace coordinates, these must be converted to digital coordinates before: </dd></dl>
<dl class="section see"><dt>See also</dt><dd>KhalimskySpaceND::uCoords(3,cell) </dd>
<dd>
mapPointToBitMask</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bit configuration </dd></dl>

</div>
</div>
<a id="a82988f18c989530f73dab774abe12c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82988f18c989530f73dab774abe12c90">&#9670;&nbsp;</a></span>isEqual() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::isEqual </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equality test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff <em>S1</em> is equal to <em>S2</em> (i.e. <em>S1</em> is a subset of <em>S2</em> and <em>S2</em> is a subset of <em>S1</em>).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l00789">789</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;      {</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;        BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;        BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;          ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;        BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;          ( <span class="keywordtype">bool</span>, isOrdered = ordered </div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;            || ( isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value ) );</div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;        </div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#a2a4c1329404b3c25a2bb1aaa62876310">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#a2a4c1329404b3c25a2bb1aaa62876310">          ::isEqual</a>( S1, S2 );</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;      }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html_a2a4c1329404b3c25a2bb1aaa62876310"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#a2a4c1329404b3c25a2bb1aaa62876310">DGtal::detail::SetFunctionsImpl::isEqual</a></div><div class="ttdeci">static bool isEqual(const Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00243">SetFunctions.h:243</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l00243">DGtal::detail::SetFunctionsImpl&lt; Container, associative, ordered &gt;::isEqual()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CubicalComplexFunctions_8h_source.html#l00293">DGtal::operator!=()</a>, and <a class="el" href="CubicalComplexFunctions_8h_source.html#l00266">DGtal::operator==()</a>.</p>

</div>
</div>
<a id="adbef166c5a788624eff4f09e596c09f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbef166c5a788624eff4f09e596c09f5">&#9670;&nbsp;</a></span>isEqual() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::isEqual </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equality test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff <em>S1</em> is equal to <em>S2</em> (i.e. <em>S1</em> is a subset of <em>S2</em> and <em>S2</em> is a subset of <em>S1</em>).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l00815">815</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;      {</div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;        BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;        BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;          ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;        BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;          ( <span class="keywordtype">bool</span>, isOrdered = isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;        </div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#a2a4c1329404b3c25a2bb1aaa62876310">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#a2a4c1329404b3c25a2bb1aaa62876310">          ::isEqual</a>( S1, S2 );</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;      }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html_a2a4c1329404b3c25a2bb1aaa62876310"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#a2a4c1329404b3c25a2bb1aaa62876310">DGtal::detail::SetFunctionsImpl::isEqual</a></div><div class="ttdeci">static bool isEqual(const Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00243">SetFunctions.h:243</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l00243">DGtal::detail::SetFunctionsImpl&lt; Container, associative, ordered &gt;::isEqual()</a>.</p>

</div>
</div>
<a id="a5c782738287493c15465124d3516d4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c782738287493c15465124d3516d4ec">&#9670;&nbsp;</a></span>isOneSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TObject &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::isOneSurface </td>
          <td>(</td>
          <td class="paramtype">const TObject &amp;&#160;</td>
          <td class="paramname"><em>small_obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if input object is a simple closed curve. <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> must be:</p><ul>
<li>Connected.</li>
<li>Each voxel is a <a class="el" href="namespaceDGtal_1_1functions.html#a4dba32b69179583e300225bf4227a381">isZeroSurface</a>.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceDGtal_1_1functions.html#a4dba32b69179583e300225bf4227a381">isZeroSurface</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TObject</td><td><a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> Type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">small_obj</td><td>input object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="reference">Referenced by <a class="el" href="testVoxelComplex_8cpp_source.html#l00544">TEST_CASE_METHOD()</a>.</p>

</div>
</div>
<a id="ac7e98eb410830e5ca846260e66bff422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e98eb410830e5ca846260e66bff422">&#9670;&nbsp;</a></span>isSubset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::isSubset </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inclusion test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff <em>S1</em> is a subset of <em>S2</em>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l00845">845</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;      {</div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;        BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;        BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;          ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;        BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;          ( <span class="keywordtype">bool</span>, isOrdered = ordered </div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;            || ( isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value ) );</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;        </div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#a42cc0b923c1613303fdf884e312fef80">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#a42cc0b923c1613303fdf884e312fef80">          ::isSubset</a>( S1, S2 );</div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;      }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html_a42cc0b923c1613303fdf884e312fef80"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#a42cc0b923c1613303fdf884e312fef80">DGtal::detail::SetFunctionsImpl::isSubset</a></div><div class="ttdeci">static bool isSubset(const Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00268">SetFunctions.h:268</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l00268">DGtal::detail::SetFunctionsImpl&lt; Container, associative, ordered &gt;::isSubset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CubicalComplexFunctions_8h_source.html#l00317">DGtal::operator&lt;=()</a>, and <a class="el" href="CubicalComplexFunctions_8h_source.html#l00340">DGtal::operator&gt;=()</a>.</p>

</div>
</div>
<a id="ad171e7dc7973f3fc0ee8363712059124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad171e7dc7973f3fc0ee8363712059124">&#9670;&nbsp;</a></span>isSubset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::isSubset </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inclusion test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff <em>S1</em> is a subset of <em>S2</em>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l00869">869</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;      {</div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;        BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;        BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;          ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;        BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;          ( <span class="keywordtype">bool</span>, isOrdered = isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;        </div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#a42cc0b923c1613303fdf884e312fef80">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#a42cc0b923c1613303fdf884e312fef80">          ::isSubset</a>( S1, S2 );</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;      }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html_a42cc0b923c1613303fdf884e312fef80"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html#a42cc0b923c1613303fdf884e312fef80">DGtal::detail::SetFunctionsImpl::isSubset</a></div><div class="ttdeci">static bool isSubset(const Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00268">SetFunctions.h:268</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l00268">DGtal::detail::SetFunctionsImpl&lt; Container, associative, ordered &gt;::isSubset()</a>.</p>

</div>
</div>
<a id="a4dba32b69179583e300225bf4227a381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dba32b69179583e300225bf4227a381">&#9670;&nbsp;</a></span>isZeroSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TObject &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::isZeroSurface </td>
          <td>(</td>
          <td class="paramtype">const TObject &amp;&#160;</td>
          <td class="paramname"><em>small_obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the object contains, exclusively, two disconnected voxels.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1Object.html#a4aae59f1144ced95ccf25eb08cf77ea0">Object::computeConnectedness</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TObject</td><td><a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> Type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">small_obj</td><td>input object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="reference">Referenced by <a class="el" href="testVoxelComplex_8cpp_source.html#l00544">TEST_CASE_METHOD()</a>.</p>

</div>
</div>
<a id="a96aab076fc2c3bd049f041f5867be7a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96aab076fc2c3bd049f041f5867be7a5">&#9670;&nbsp;</a></span>loadTable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CountedPtr.html">DGtal::CountedPtr</a>&lt; boost::dynamic_bitset&lt;&gt; &gt; DGtal::functions::loadTable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>known_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>compressed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load existing look up table existing in file_name, precalculated tables can be accessed including the header: "DGtal/topology/tables/NeighborhoodTables.h"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_filename</td><td>plain text containing the bool table. </td></tr>
    <tr><td class="paramname">known_size</td><td>of the bitset, for 2D = 256 (2^8), 3D = 67108864 (2^26) </td></tr>
    <tr><td class="paramname">compressed</td><td>true if table to read has been compressed with zlib.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>smart ptr of map[neighbor_configuration] -&gt; bool</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The tables were calculated using the generateTableXXX examples. Compressed files of the tables are distributed in the source code. At build or install time, the header "DGtal/topology/tables/NeighborhoodTables.h" is generated. It has const strings variables with the file names of the tables. </dd></dl>

<p class="reference">Referenced by <a class="el" href="testNeighborhoodConfigurations_8cpp_source.html#l00103">SCENARIO()</a>, and <a class="el" href="testNeighborhoodConfigurations_8cpp_source.html#l00251">TEST_CASE_METHOD()</a>.</p>

</div>
</div>
<a id="a7a55ef824ab5ca8afab45ff04c801693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a55ef824ab5ca8afab45ff04c801693">&#9670;&nbsp;</a></span>loadTable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int dimension = 3&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CountedPtr.html">DGtal::CountedPtr</a>&lt; boost::dynamic_bitset&lt;&gt; &gt; DGtal::functions::loadTable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>compressed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load existing look up table existing in file_name, precalculated tables can be accessed including the header: "DGtal/topology/tables/NeighborhoodTables.h"</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dimension</td><td>of the space input_filename table refers. 2 or 3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_filename</td><td>plain text containing the bool table. </td></tr>
    <tr><td class="paramname">compressed</td><td>true if table to read has been compressed with zlib.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>smart ptr of map[neighbor_configuration] -&gt; bool</dd></dl>
<dl class="section see"><dt>See also</dt><dd>NeighborhoodConfigurations::loadTable </dd></dl>

</div>
</div>
<a id="adc5faa4fb283d3dd8b530f1aa46e1303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5faa4fb283d3dd8b530f1aa46e1303">&#9670;&nbsp;</a></span>makeDifference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeDifference </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set difference operation. Returns the difference of <em>S1</em> - <em>S2</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set <em>S1</em> - <em>S2</em>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l00946">946</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;    {</div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;      Container S( S1 );</div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;      assignDifference&lt;Container, ordered&gt;( S, S2 );</div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;      <span class="keywordflow">return</span> S;</div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;    }</div></div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="SetFunctions_8h_source.html#l01288">DGtal::functions::setops::operator-()</a>.</p>

</div>
</div>
<a id="acba16c21435994b725465e08cb77a9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba16c21435994b725465e08cb77a9fb">&#9670;&nbsp;</a></span>makeDifference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeDifference </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set difference operation. Returns the difference of <em>S1</em> - <em>S2</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set <em>S1</em> - <em>S2</em>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l00965">965</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;    {</div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;      Container S( S1 );</div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;      <a class="code" href="namespaceDGtal_1_1functions.html#ac97099c06241a42dce86a53230b665d7">assignDifference</a>( S, S2 );</div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;      <span class="keywordflow">return</span> S;</div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;    }</div><div class="ttc" id="namespaceDGtal_1_1functions_html_ac97099c06241a42dce86a53230b665d7"><div class="ttname"><a href="namespaceDGtal_1_1functions.html#ac97099c06241a42dce86a53230b665d7">DGtal::functions::assignDifference</a></div><div class="ttdeci">Container &amp; assignDifference(Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00896">SetFunctions.h:896</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l00896">assignDifference()</a>.</p>

</div>
</div>
<a id="a8de7a7bd0c7511d57569c794cff3a113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de7a7bd0c7511d57569c794cff3a113">&#9670;&nbsp;</a></span>makeIntersection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeIntersection </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set intersection operation. Returns the set \( S1 \cap S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set \( S1 \cap S2 \).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l01131">1131</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;    {</div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;      Container S( S1 );</div><div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;      assignIntersection&lt;Container, ordered&gt;( S, S2 );</div><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;      <span class="keywordflow">return</span> S;</div><div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;    }</div></div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="SetFunctions_8h_source.html#l01332">DGtal::functions::setops::operator &amp;()</a>.</p>

</div>
</div>
<a id="a6d93770c72e70791aa57c47d22c982b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d93770c72e70791aa57c47d22c982b9">&#9670;&nbsp;</a></span>makeIntersection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeIntersection </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set intersection operation. Returns the set \( S1 \cap S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set \( S1 \cap S2 \).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l01149">1149</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;    {</div><div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;      Container S( S1 );</div><div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;      <a class="code" href="namespaceDGtal_1_1functions.html#af3360043e7032e9a8eaf2ef0fde60afd">assignIntersection</a>( S, S2 );</div><div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;      <span class="keywordflow">return</span> S;</div><div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;    }</div><div class="ttc" id="namespaceDGtal_1_1functions_html_af3360043e7032e9a8eaf2ef0fde60afd"><div class="ttname"><a href="namespaceDGtal_1_1functions.html#af3360043e7032e9a8eaf2ef0fde60afd">DGtal::functions::assignIntersection</a></div><div class="ttdeci">Container &amp; assignIntersection(Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l01082">SetFunctions.h:1082</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l01082">assignIntersection()</a>.</p>

</div>
</div>
<a id="a03f0a6573a95aa152c8b8320baee6884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f0a6573a95aa152c8b8320baee6884">&#9670;&nbsp;</a></span>makeSymmetricDifference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeSymmetricDifference </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set symmetric difference operation. Returns the set \( S1 \Delta S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set \( S1 \Delta S2 \).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l01225">1225</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;    {</div><div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;      Container S( S1 );</div><div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;      assignSymmetricDifference&lt;Container, ordered&gt;( S, S2 );</div><div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;      <span class="keywordflow">return</span> S;</div><div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;    }</div></div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="SetFunctions_8h_source.html#l01362">DGtal::functions::setops::operator^()</a>.</p>

</div>
</div>
<a id="aacd11e737e0c019de78553ae847a5724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd11e737e0c019de78553ae847a5724">&#9670;&nbsp;</a></span>makeSymmetricDifference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeSymmetricDifference </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set symmetric difference operation. Returns the set \( S1 \Delta S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set \( S1 \Delta S2 \).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l01243">1243</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;    {</div><div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;      Container S( S1 );</div><div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;      <a class="code" href="namespaceDGtal_1_1functions.html#a65694ad895f3f4cb42c54213fce7295a">assignSymmetricDifference</a>( S, S2 );</div><div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;      <span class="keywordflow">return</span> S;</div><div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;    }</div><div class="ttc" id="namespaceDGtal_1_1functions_html_a65694ad895f3f4cb42c54213fce7295a"><div class="ttname"><a href="namespaceDGtal_1_1functions.html#a65694ad895f3f4cb42c54213fce7295a">DGtal::functions::assignSymmetricDifference</a></div><div class="ttdeci">Container &amp; assignSymmetricDifference(Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l01176">SetFunctions.h:1176</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l01176">assignSymmetricDifference()</a>.</p>

</div>
</div>
<a id="af848d0d5748af67bcb76b3d5e1f616cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af848d0d5748af67bcb76b3d5e1f616cd">&#9670;&nbsp;</a></span>makeUnion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeUnion </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set union operation. Returns the set \( S1 \cup S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set \( S1 \cup S2 \).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l01039">1039</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;    {</div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;      Container S( S1 );</div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;      assignUnion&lt;Container, ordered&gt;( S, S2 );</div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;      <span class="keywordflow">return</span> S;</div><div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;    }</div></div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="SetFunctions_8h_source.html#l01303">DGtal::functions::setops::operator|()</a>.</p>

</div>
</div>
<a id="af462fb1f5ceade012f0e97831e3d8e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af462fb1f5ceade012f0e97831e3d8e64">&#9670;&nbsp;</a></span>makeUnion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeUnion </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set union operation. Returns the set \( S1 \cup S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set \( S1 \cup S2 \).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l01057">1057</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;    {</div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;      Container S( S1 );</div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;      <a class="code" href="namespaceDGtal_1_1functions.html#ac58ca694e397fb84d77c53aba2134887">assignUnion</a>( S, S2 );</div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;      <span class="keywordflow">return</span> S;</div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;    }</div><div class="ttc" id="namespaceDGtal_1_1functions_html_ac58ca694e397fb84d77c53aba2134887"><div class="ttname"><a href="namespaceDGtal_1_1functions.html#ac58ca694e397fb84d77c53aba2134887">DGtal::functions::assignUnion</a></div><div class="ttdeci">Container &amp; assignUnion(Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00990">SetFunctions.h:990</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l00990">assignUnion()</a>.</p>

</div>
</div>
<a id="ab2e5d9a4e591d68db5f9aa942191a9db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e5d9a4e591d68db5f9aa942191a9db">&#9670;&nbsp;</a></span>mapZeroPointNeighborhoodToConfigurationMask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CountedPtr.html">DGtal::CountedPtr</a>&lt; std::unordered_map&lt;TPoint, <a class="el" href="namespaceDGtal.html#a319e1944935b8331846f54001a63525f">NeighborhoodConfiguration</a> &gt; &gt; DGtal::functions::mapZeroPointNeighborhoodToConfigurationMask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps any point in the neighborhood of point Zero (0,..,0) to its corresponding configuration bit mask. This is a helper to use with tables. The order of the configuration is lexicographic, starting in {-1, -1, ...}. </p><dl class="section note"><dt>Note</dt><dd>the neighborhood is considered to be all points p which ||p-zero|| &lt;= 1</dd></dl>
<p>Example: Point{ -1, -1, -1 } = 1; // corresponding to mask x x 0000 0001 Point{ 0, -1, -1 } = 2; // corresponding to mask x x 0000 0010 Point{ 1, 1, 1 } = 2^26; // x 0010 x x x x x x</p>
<dl class="section note"><dt>Note</dt><dd>NeighborhoodConfiguration is type uint 32 bits, so the max dimension supported is 3.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1HyperRectDomain__Iterator.html#a314ab049fbcc38ac76af74ebdad5422b">HyperRectDomain_Iterator::nextLexicographicOrder</a> </dd>
<dd>
<a class="el" href="testNeighborhoodConfigurations_8cpp.html">testNeighborhoodConfigurations.cpp</a> shows the complete mapping.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TPoint</td><td>type of point to create map and input the desired dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>map[Point]-&gt;configuration smart pointer. </dd></dl>

</div>
</div>
<a id="a9ef7985dddac727bde1206dfb29ef2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef7985dddac727bde1206dfb29ef2be">&#9670;&nbsp;</a></span>objectFromSpels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TObject , typename TKSpace , typename TCellContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;TObject&gt; DGtal::functions::objectFromSpels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create object from the spels in the complex.</p>
<p>User has to provide a 3D TObject type with its associated DigitalSet and <a class="el" href="classDGtal_1_1DigitalTopology.html" title="Aim: Represents a digital topology as a couple of adjacency relations.">DigitalTopology</a>.</p>
<p>Given a dimension n, spels are the n-cells, equivalently, spels are the grid-points in Z^n.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TObject</td><td>with its associdated DigitalSet and <a class="el" href="classDGtal_1_1DigitalTopology.html" title="Aim: Represents a digital topology as a couple of adjacency relations.">DigitalTopology</a> </td></tr>
    <tr><td class="paramname">TKSpace</td><td>kspace type of the input <a class="el" href="classDGtal_1_1CubicalComplex.html" title="Aim: This class represents an arbitrary cubical complex living in some Khalimsky space....">CubicalComplex</a>. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>cell container type of the input <a class="el" href="classDGtal_1_1CubicalComplex.html" title="Aim: This class represents an arbitrary cubical complex living in some Khalimsky space....">CubicalComplex</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>input <a class="el" href="classDGtal_1_1CubicalComplex.html" title="Aim: This class represents an arbitrary cubical complex living in some Khalimsky space....">CubicalComplex</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unique_ptr of created object with the pointset containing the spels of the complex. </dd></dl>

</div>
</div>
<a id="affff269feb515ccbb61fed6df33bd403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affff269feb515ccbb61fed6df33bd403">&#9670;&nbsp;</a></span>oneIsthmus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::oneIsthmus </td>
          <td>(</td>
          <td class="paramtype">const TComplex &amp;&#160;</td>
          <td class="paramname"><em>vc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a> &amp;&#160;</td>
          <td class="paramname"><em>cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if input cell is a 1-isthmus. A voxel is a 1-isthmus if, after a thinning, its proper neighborhood is made only by two voxels, ie, it is a 0-Surface <a class="el" href="namespaceDGtal_1_1functions.html#a4dba32b69179583e300225bf4227a381">isZeroSurface</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceDGtal_1_1functions.html#a4dba32b69179583e300225bf4227a381">isZeroSurface</a> </dd>
<dd>
<a class="el" href="classDGtal_1_1Object.html#a5dfbef899715f5f0d81e02ad63504892">Object::properNeighborhood</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TComplex</td><td><a class="el" href="classDGtal_1_1VoxelComplex.html" title="This class represents a voxel complex living in some Khalimsky space. Voxel complexes are derived fro...">VoxelComplex</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vc</td><td>input complex. </td></tr>
    <tr><td class="paramname">cell</td><td>apply function on input cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="reference">Referenced by <a class="el" href="testVoxelComplex_8cpp_source.html#l00735">TEST_CASE_METHOD()</a>.</p>

</div>
</div>
<a id="a46d491155b4e945e904080855a3bae28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d491155b4e945e904080855a3bae28">&#9670;&nbsp;</a></span>persistenceAsymetricThinningScheme()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TComplex DGtal::functions::persistenceAsymetricThinningScheme </td>
          <td>(</td>
          <td class="paramtype">TComplex &amp;&#160;</td>
          <td class="paramname"><em>vc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; std::pair&lt; typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a>, typename TComplex::Data &gt;(const typename TComplex::Clique &amp;) &gt;&#160;</td>
          <td class="paramname"><em>Select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const TComplex &amp;, const typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a> &amp;) &gt;&#160;</td>
          <td class="paramname"><em>Skel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e">uint32_t</a>&#160;</td>
          <td class="paramname"><em>persistence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18b68d329aa1461a0847a18e99247885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b68d329aa1461a0847a18e99247885">&#9670;&nbsp;</a></span>power()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T DGtal::functions::power </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>aVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute exponentiation by squaring of a scalar <em>aVal</em> of type <em>T</em> by the exponent <em>exponent</em> (unsigned int). The computation is done in \( O(\log(exponent))\) multiplications. </p><dl class="section note"><dt>Note</dt><dd>This function is better than std::pow on unsigned int exponents and integer value type since it performs exact computations (no cast to float or doubles).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aVal</td><td>the value </td></tr>
    <tr><td class="paramname">exponent</td><td>the exponent </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>scalar value type (must have '*' operator). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>aVal^exponent</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceDGtal_1_1functions.html#ac8e2160844093488cdd738354027daa1">square</a>, <a class="el" href="namespaceDGtal_1_1functions.html#a4828e0475cb9aa8dceefa94f0ab4d168">cube</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="BasicMathFunctions_8h_source.html#l00073">73</a> of file <a class="el" href="BasicMathFunctions_8h_source.html">BasicMathFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    {</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=exponent;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;      T p(aVal);</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;      </div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;      <span class="keywordflow">if</span> (exponent == 0) { <span class="keywordflow">return</span> 1;    }</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;      </div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;      T result = NumberTraits&lt;T&gt;::ONE;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;      <span class="keywordflow">while</span> (q != 0) </div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        {</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;          <span class="keywordflow">if</span> (q % 2 == 1) {    <span class="comment">// q is odd</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;            result *= p;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;            q--;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;          }</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;          p *= p;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;          q /= 2;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        }</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;      <span class="keywordflow">return</span> result;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="aa754ac3d17216563354db61d905a545c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa754ac3d17216563354db61d905a545c">&#9670;&nbsp;</a></span>reversedSmartCH() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointVector , typename Position , typename PositionFunctor , typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> DGtal::functions::reversedSmartCH </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>aFirstPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>aLastPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PositionFunctor &amp;&#160;</td>
          <td class="paramname"><em>aPositionFunctor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>uIto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>lIto</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Procedure that computes the lower and upper left hull of the left subsegment of a greater DSS characterized by the first upper leaning point <em>U</em>, the first positive Bezout point <em>L</em> and its direction vector <em>V</em>. Note that the so-called left subsegment is bounded on the one hand by the first point of the DSS located at <em>aFirstPosition</em> and on the other hand by the point located at position <em>aLastPosition</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>last upper convex hull vertex </td></tr>
    <tr><td class="paramname">L</td><td>last lower convex hull vertex </td></tr>
    <tr><td class="paramname">V</td><td>last valid Bezout vector (main direction vector) </td></tr>
    <tr><td class="paramname">aFirstPosition</td><td>position of the first point of the subsegment </td></tr>
    <tr><td class="paramname">aLastPosition</td><td>position of the last point of the subsegment </td></tr>
    <tr><td class="paramname">aPositionFunctor</td><td>position functor, which returns the position of any given point/vector </td></tr>
    <tr><td class="paramname">uIto</td><td>output iterator used to store the vertices of the upper convex hull </td></tr>
    <tr><td class="paramname">lIto</td><td>output iterator used to store the vertices of the lower convex hull</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a></td><td>a model of 2d point/vector </td></tr>
    <tr><td class="paramname">Position</td><td>a model of integer for the position of the point in the bounding DSS </td></tr>
    <tr><td class="paramname">PositionFunctor</td><td>a model of unary functor that returns the position of a point/vector </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of output iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last direction vector, ie. the rational slope of minimal denominator </dd></dl>

<p class="reference">Referenced by <a class="el" href="testArithmeticalDSSConvexHull_8cpp_source.html#l00499">basicTest2()</a>, and <a class="el" href="testArithmeticalDSSConvexHull_8cpp_source.html#l00629">reversedSmartCHSubsegment()</a>.</p>

</div>
</div>
<a id="a42d6f1219d53ecefb73b55c386e0d54a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d6f1219d53ecefb73b55c386e0d54a">&#9670;&nbsp;</a></span>reversedSmartCH() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DSS , typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="testCombinDSS_8cpp.html#a609ee1808a3b4f883fb28df65e9a2ed6">DSS::Vector</a> DGtal::functions::reversedSmartCH </td>
          <td>(</td>
          <td class="paramtype">const DSS &amp;&#160;</td>
          <td class="paramname"><em>aDSS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DSS::Position &amp;&#160;</td>
          <td class="paramname"><em>aPositionBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>uIto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>lIto</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Procedure that computes the lower and upper left hull of the left subsegment of a greater DSS <em>aDSS</em>. Note that the so-called left subsegment is bounded on the one hand by the first point of <em>aDSS</em> and on the other hand by the point located at position <em>aPositionBound</em> [Roussillon 2014 : <a class="el" href="citelist.html#CITEREF_RoussillonDGCI2014">[74]</a>]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDSS</td><td>bounding DSS </td></tr>
    <tr><td class="paramname">aPositionBound</td><td>position of the last point of the subsegment (should be located after the first point of <em>aDSS</em>). </td></tr>
    <tr><td class="paramname">uIto</td><td>output iterator used to store the vertices of the upper convex hull </td></tr>
    <tr><td class="paramname">lIto</td><td>output iterator used to store the vertices of the lower convex hull</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DSS</td><td>a model of arithmetical DSS </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of output iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last direction vector, ie. the rational slope of minimal denominator </dd></dl>

</div>
</div>
<a id="a48dff4e7a37ef5122f124d830b4b177a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48dff4e7a37ef5122f124d830b4b177a">&#9670;&nbsp;</a></span>roundToUpperPowerOfTwo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T DGtal::functions::roundToUpperPowerOfTwo </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the next higher power of two of the given argument n of type T.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the element T </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an element of type T (casted to unsigned integer). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next higher power of two. </dd></dl>

<p class="definition">Definition at line <a class="el" href="BasicMathFunctions_8h_source.html#l00102">102</a> of file <a class="el" href="BasicMathFunctions_8h_source.html">BasicMathFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;                                         {</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;      <span class="keywordflow">return</span> (T)  1 &lt;&lt; (1+<a class="code" href="structDGtal_1_1Bits.html#a25b5f464fec0d951d75f1fe10a07f0ea">DGtal::Bits::mostSignificantBit</a>( (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) n-1 ) );</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    }</div><div class="ttc" id="structDGtal_1_1Bits_html_a25b5f464fec0d951d75f1fe10a07f0ea"><div class="ttname"><a href="structDGtal_1_1Bits.html#a25b5f464fec0d951d75f1fe10a07f0ea">DGtal::Bits::mostSignificantBit</a></div><div class="ttdeci">static unsigned int mostSignificantBit(DGtal::uint8_t n)</div><div class="ttdef"><b>Definition:</b> <a href="Bits_8h_source.html#l00343">Bits.h:343</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="Bits_8h_source.html#l00343">DGtal::Bits::mostSignificantBit()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Viewer3D_8h_source.html#l01291">DGtal::Viewer3D&lt; TSpace, TKSpace &gt;::GLTextureImage::GLTextureImage()</a>.</p>

</div>
</div>
<a id="a96220e2a64c64f8380043319b6c5e329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96220e2a64c64f8380043319b6c5e329">&#9670;&nbsp;</a></span>selectFirst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a>, typename TComplex::Data&gt; DGtal::functions::selectFirst </td>
          <td>(</td>
          <td class="paramtype">const typename TComplex::Clique &amp;&#160;</td>
          <td class="paramname"><em>clique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select first voxel of input clique.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TComplex</td><td>input <a class="el" href="classDGtal_1_1CubicalComplex.html" title="Aim: This class represents an arbitrary cubical complex living in some Khalimsky space....">CubicalComplex</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clique</td><td>from where cell is chosen.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first voxel of clique. </dd></dl>

</div>
</div>
<a id="a8833a616f9e288f432a67eea853217d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8833a616f9e288f432a67eea853217d9">&#9670;&nbsp;</a></span>selectMaxValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDistanceTransform , typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a>, typename TComplex::Data&gt; DGtal::functions::selectMaxValue </td>
          <td>(</td>
          <td class="paramtype">const TDistanceTransform &amp;&#160;</td>
          <td class="paramname"><em>dist_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TComplex::Clique &amp;&#160;</td>
          <td class="paramname"><em>clique</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select cell from clique that has max value looking at the input dist_map. The points in the dist_map and in the clique must refer to the same position.</p>
<p>If you need to have a std::function&lt;bool(const Clique &amp;)&gt; signature (for using it in thinning algorithms), use a lambda: subsitute skelRandom (for example) for: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> selectDistMax =</div><div class="line">[&amp;dist_map](<span class="keyword">const</span> Clique &amp; clique){</div><div class="line">    <span class="keywordflow">return</span> selectMaxDistance&lt;TDistMap, TComplex&gt;(dist_map, clique);</div><div class="line">}</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDistanceTransform</td><td>Container type for the distance map. </td></tr>
    <tr><td class="paramname">TComplex</td><td>input <a class="el" href="classDGtal_1_1CubicalComplex.html" title="Aim: This class represents an arbitrary cubical complex living in some Khalimsky space....">CubicalComplex</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dist_map</td><td>container holding the values. </td></tr>
    <tr><td class="paramname">clique</td><td>from where cell is chosen.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cell from input clique with highest value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DistanceTransformation_8h_source.html" title="Linear in time distance transformation.">DistanceTransformation.h</a> </dd></dl>

</div>
</div>
<a id="aa469c81c1af173fe1758bba410f4a940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa469c81c1af173fe1758bba410f4a940">&#9670;&nbsp;</a></span>selectRandom() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a>, typename TComplex::Data&gt; DGtal::functions::selectRandom </td>
          <td>(</td>
          <td class="paramtype">const typename TComplex::Clique &amp;&#160;</td>
          <td class="paramname"><em>clique</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select random voxel from input clique.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TComplex</td><td>input <a class="el" href="classDGtal_1_1CubicalComplex.html" title="Aim: This class represents an arbitrary cubical complex living in some Khalimsky space....">CubicalComplex</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clique</td><td>from where cell is chosen.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>random voxel from input clique. </dd></dl>

</div>
</div>
<a id="ab4ff3e47b9d4cb74977f0d493f548184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ff3e47b9d4cb74977f0d493f548184">&#9670;&nbsp;</a></span>selectRandom() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex , typename TRandomGenerator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a>, typename TComplex::Data&gt; DGtal::functions::selectRandom </td>
          <td>(</td>
          <td class="paramtype">const typename TComplex::Clique &amp;&#160;</td>
          <td class="paramname"><em>clique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRandomGenerator &amp;&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select random voxel from input clique.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TComplex</td><td><a class="el" href="classDGtal_1_1CubicalComplex.html" title="Aim: This class represents an arbitrary cubical complex living in some Khalimsky space....">CubicalComplex</a> </td></tr>
    <tr><td class="paramname">TRandomGenerator</td><td>RandomGenerator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clique</td><td>from where cell is chosen </td></tr>
    <tr><td class="paramname">gen</td><td>random generator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>random voxel from input clique. </dd></dl>

</div>
</div>
<a id="a73b08e83670143586a55950e050aa6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b08e83670143586a55950e050aa6ad">&#9670;&nbsp;</a></span>skelEnd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::skelEnd </td>
          <td>(</td>
          <td class="paramtype">const TComplex &amp;&#160;</td>
          <td class="paramname"><em>vc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a> &amp;&#160;</td>
          <td class="paramname"><em>cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if input cell only has one neighbor, using <a class="el" href="classDGtal_1_1Object.html#a18f5ffbef2e9f8076e5a686c8bf93a37">Object::topology</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TComplex</td><td><a class="el" href="classDGtal_1_1VoxelComplex.html" title="This class represents a voxel complex living in some Khalimsky space. Voxel complexes are derived fro...">VoxelComplex</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vc</td><td>input voxel complex. </td></tr>
    <tr><td class="paramname">cell</td><td>c apply function on this voxel cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if voxel cell only has neighbor. </dd></dl>

</div>
</div>
<a id="a147a79d431e108b58dd715c876da90ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147a79d431e108b58dd715c876da90ec">&#9670;&nbsp;</a></span>skelIsthmus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::skelIsthmus </td>
          <td>(</td>
          <td class="paramtype">const TComplex &amp;&#160;</td>
          <td class="paramname"><em>vc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a> &amp;&#160;</td>
          <td class="paramname"><em>cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if input cell is a 1 or 2 Isthmus.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TComplex</td><td><a class="el" href="classDGtal_1_1VoxelComplex.html" title="This class represents a voxel complex living in some Khalimsky space. Voxel complexes are derived fro...">VoxelComplex</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vc</td><td>input complex. </td></tr>
    <tr><td class="paramname">cell</td><td>apply function on input cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>oneIsthmus || twoIsthmus</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceDGtal_1_1functions.html#affff269feb515ccbb61fed6df33bd403">oneIsthmus</a> </dd>
<dd>
<a class="el" href="namespaceDGtal_1_1functions.html#ad86a0dd4add6c1b9f567908893b4a69d">twoIsthmus</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="testVoxelComplex_8cpp_source.html#l00735">TEST_CASE_METHOD()</a>.</p>

</div>
</div>
<a id="a4e8e89624580d0a7c6ecebbb8a3d072d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8e89624580d0a7c6ecebbb8a3d072d">&#9670;&nbsp;</a></span>skelSimple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::skelSimple </td>
          <td>(</td>
          <td class="paramtype">const TComplex &amp;&#160;</td>
          <td class="paramname"><em>vc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a> &amp;&#160;</td>
          <td class="paramname"><em>cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if input cell is simple using <a class="el" href="classDGtal_1_1VoxelComplex.html#ac4bb0bb6a7b8b1c7117f1b5982d658d3">VoxelComplex::isSimple</a> interface to <a class="el" href="classDGtal_1_1Object.html#ae9ea876b5d762b4445e757ba7be42633">Object::isSimple</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1VoxelComplex.html#ac4bb0bb6a7b8b1c7117f1b5982d658d3">VoxelComplex::isSimple</a> </dd>
<dd>
<a class="el" href="classDGtal_1_1Object.html#ae9ea876b5d762b4445e757ba7be42633">Object::isSimple</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TComplex</td><td><a class="el" href="classDGtal_1_1VoxelComplex.html" title="This class represents a voxel complex living in some Khalimsky space. Voxel complexes are derived fro...">VoxelComplex</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vc</td><td>input complex. </td></tr>
    <tr><td class="paramname">cell</td><td>apply function on input cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if voxel is simple. </dd></dl>

</div>
</div>
<a id="ad1a335e8f7956c3188e031a8d83a5ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a335e8f7956c3188e031a8d83a5ea7">&#9670;&nbsp;</a></span>skelUltimate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::skelUltimate </td>
          <td>(</td>
          <td class="paramtype">const TComplex &amp;&#160;</td>
          <td class="paramname"><em>vc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a> &amp;&#160;</td>
          <td class="paramname"><em>cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Always returns false. Used in thinning schemes to calculate an ultimate skeleton. An ultimate skeleton only keeps voxels that don't change the topology.</p>
<dl class="section note"><dt>Note</dt><dd>The number of cells of a thinning using this function is the same as the number of connected components of an object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceDGtal_1_1functions.html#a8f2a4664af776ca513141edb552a4461">asymetricThinningScheme</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TComplex</td><td><a class="el" href="classDGtal_1_1VoxelComplex.html" title="This class represents a voxel complex living in some Khalimsky space. Voxel complexes are derived fro...">VoxelComplex</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vc</td><td>input voxel complex. </td></tr>
    <tr><td class="paramname">cell</td><td>c apply function on this voxel cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>always false. </dd></dl>

</div>
</div>
<a id="a23d911a3be8b0751f42bc11e96d3af1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d911a3be8b0751f42bc11e96d3af1b">&#9670;&nbsp;</a></span>skelWithTable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::skelWithTable </td>
          <td>(</td>
          <td class="paramtype">const boost::dynamic_bitset&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; typename <a class="el" href="testCubicalComplex_8cpp.html#a15e9592ccc512dc691b46185e6814758">TComplex::Point</a>, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointToMaskMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TComplex &amp;&#160;</td>
          <td class="paramname"><em>vc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a> &amp;&#160;</td>
          <td class="paramname"><em>cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic predicate to use external tables[configuration]-&gt;bool with skel functions. Can be adapted to any table using lambdas.</p>
<dl class="section see"><dt>See also</dt><dd>LookUpTableFunctions.h </dd>
<dd>
tests/topology/testVoxelComplex.h</dd></dl>
<p>If you need to have a std::function&lt;bool(const Complex &amp; vc, const Cell &amp; c )&gt; signature (for using it in thinning algorithms), use a lambda to capture values: subsitute skelIsthmus (for example) for: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> skelWithTableIsthmus =</div><div class="line">[&amp;table, &amp;pointToMaskMap](<span class="keyword">const</span> Complex &amp; vc, <span class="keyword">const</span> <a class="code" href="structDGtal_1_1KhalimskyCell.html">Cell</a> &amp; cell){</div><div class="line">    <span class="keywordflow">return</span> skelWithTable&lt;TComplex&gt;(table, pointToMaskMap, vc, cell);</div><div class="line">}</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TComplex</td><td>input <a class="el" href="classDGtal_1_1CubicalComplex.html" title="Aim: This class represents an arbitrary cubical complex living in some Khalimsky space....">CubicalComplex</a> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>[configuration]-&gt;bool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>VoxelComplex::loadTable </dd>
<dd>
LookUpTableFunctions.h::loadTable</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointToMaskMap</td><td>map[neighborhood points] to a bit mask. Used to get the neighborhood configuration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1VoxelComplex.html#a39e31553d04a93cc980643c43cacf4b1">VoxelComplex::pointToMask</a> </dd>
<dd>
LookUpTableFunctions.h::mapPointToBitMask</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vc</td><td>input complex.</td></tr>
    <tr><td class="paramname">cell</td><td>input cell, center from where the neighborhood [configuration] will be checked. Note that only neighborhood are checked to belong to the complex, not the input cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool from selected table[configuration]. </dd></dl>

<p class="reference">Referenced by <a class="el" href="testVoxelComplex_8cpp_source.html#l00808">TEST_CASE_METHOD()</a>.</p>

</div>
</div>
<a id="a07b66e9e7682c0f900bcbeabcac96b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b66e9e7682c0f900bcbeabcac96b7b">&#9670;&nbsp;</a></span>smartCH() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointVector , typename Coordinate , typename Position , typename PositionFunctor , typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> DGtal::functions::smartCH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;&#160;</td>
          <td class="paramname"><em>aFirstPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coordinate &amp;&#160;</td>
          <td class="paramname"><em>aRemainderBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>aPositionBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;&#160;</td>
          <td class="paramname"><em>aStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coordinate &amp;&#160;</td>
          <td class="paramname"><em>aRStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;&#160;</td>
          <td class="paramname"><em>aShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coordinate &amp;&#160;</td>
          <td class="paramname"><em>aRShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PositionFunctor &amp;&#160;</td>
          <td class="paramname"><em>aPositionFunctor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>uIto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>lIto</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Procedure that computes the lower and upper left hull of a DSS of first point <em>aFirstPoint</em>, length <em>aPositionBound</em>, contained in a digital straight line described by <em>aRStep</em>, <em>aRShift</em> and <em>aRemainderBound</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aFirstPoint</td><td>first point of the DSS </td></tr>
    <tr><td class="paramname">aRemainderBound</td><td>difference between the intercept mu of the bounding DSL and the remainder of the first point. </td></tr>
    <tr><td class="paramname">aPositionBound</td><td>(strictly positive) length of the DSS </td></tr>
    <tr><td class="paramname">aStep</td><td>first step of the DSL </td></tr>
    <tr><td class="paramname">aRStep</td><td>remainder of the first step, ie. parameter \( a \) of the bounding DSL </td></tr>
    <tr><td class="paramname">aShift</td><td>shift vector of the DSL </td></tr>
    <tr><td class="paramname">aRShift</td><td>remainder of the shift vector, ie. parameter \( omega \) of the bounding DSL. </td></tr>
    <tr><td class="paramname">aPositionFunctor</td><td>position functor, which returns the position of any given point/vector </td></tr>
    <tr><td class="paramname">uIto</td><td>output iterator used to store the vertices of the upper convex hull </td></tr>
    <tr><td class="paramname">lIto</td><td>output iterator used to store the vertices of the lower convex hull</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last direction vector, ie. the rational slope of minimal denominator of the DSS</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a></td><td>a model of 2d point/vector </td></tr>
    <tr><td class="paramname">Coordinate</td><td>a model of integer for the coordinates of the point/vector </td></tr>
    <tr><td class="paramname">Position</td><td>a model of integer for locating points in the DSS </td></tr>
    <tr><td class="paramname">PositionFunctor</td><td>a model of unary functor that returns the position of a point/vector </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of output iterator </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="testArithmeticalDSSConvexHull_8cpp_source.html#l00061">basicTest()</a>, <a class="el" href="testArithmeticalDSSConvexHull_8cpp_source.html#l00196">comparisonLeftHull()</a>, and <a class="el" href="testArithmeticalDSSConvexHull_8cpp_source.html#l00318">smartCHSubsegment()</a>.</p>

</div>
</div>
<a id="adc99490ec12ae9e68c03c08d473e8692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc99490ec12ae9e68c03c08d473e8692">&#9670;&nbsp;</a></span>smartCH() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DSL , typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="testCombinDSS_8cpp.html#a609ee1808a3b4f883fb28df65e9a2ed6">DSL::Vector</a> DGtal::functions::smartCH </td>
          <td>(</td>
          <td class="paramtype">const DSL &amp;&#160;</td>
          <td class="paramname"><em>aDSL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="testCubicalComplex_8cpp.html#a15e9592ccc512dc691b46185e6814758">DSL::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aFirstPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DSL::Position &amp;&#160;</td>
          <td class="paramname"><em>aLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>uIto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>lIto</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Procedure that computes the lower and upper left hull of a DSS of first point <em>aFirstPoint</em>, length <em>aLength</em>, contained in a DSL <em>aDSL</em> [Roussillon 2014 : <a class="el" href="citelist.html#CITEREF_RoussillonDGCI2014">[74]</a>]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDSL</td><td>bounding DSL </td></tr>
    <tr><td class="paramname">aFirstPoint</td><td>first point of the DSS </td></tr>
    <tr><td class="paramname">aLength</td><td>(strictly positive) length of the DSS </td></tr>
    <tr><td class="paramname">uIto</td><td>output iterator used to store the vertices of the upper convex hull </td></tr>
    <tr><td class="paramname">lIto</td><td>output iterator used to store the vertices of the lower convex hull</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last direction vector, ie. the rational slope of minimal denominator</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DSL</td><td>a model of arithmetical DSL </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of output iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c21293d6efa82afb1b20db4d7a794a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c21293d6efa82afb1b20db4d7a794a7">&#9670;&nbsp;</a></span>smartCHNextVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Position , typename Coordinate , typename PointVector , typename OutputIterator , typename PositionFunctor , typename TruncationFunctor1 , typename TruncationFunctor2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::smartCHNextVertex </td>
          <td>(</td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>positionBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coordinate &amp;&#160;</td>
          <td class="paramname"><em>remainderBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coordinate &amp;&#160;</td>
          <td class="paramname"><em>rX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coordinate &amp;&#160;</td>
          <td class="paramname"><em>rY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coordinate &amp;&#160;</td>
          <td class="paramname"><em>rV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>ito</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PositionFunctor &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TruncationFunctor1 &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TruncationFunctor2 &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Procedure that computes the next (lower or upper) vertex of the left hull of a DSS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positionBound</td><td>position of the last point of the DSS </td></tr>
    <tr><td class="paramname">remainderBound</td><td>remainder of the lower leaning points contained in the DSS </td></tr>
    <tr><td class="paramname">X</td><td>(returned) last vertex of the considered side </td></tr>
    <tr><td class="paramname">rX</td><td>(returned) remainder of <em>X</em> </td></tr>
    <tr><td class="paramname">Y</td><td>last vertex of the opposite side </td></tr>
    <tr><td class="paramname">rY</td><td>remainder of <em>Y</em> </td></tr>
    <tr><td class="paramname">V</td><td>(returned) last direction vector (unimodular with (<em>X</em> - <em>Y</em>)) </td></tr>
    <tr><td class="paramname">rV</td><td>(returned) remainder of <em>V</em> (not null) </td></tr>
    <tr><td class="paramname">ito</td><td>output iterator used to store the new vertex lying on the same side as <em>X</em> </td></tr>
    <tr><td class="paramname">pos</td><td>position functor, which returns the position of any given point/vector </td></tr>
    <tr><td class="paramname">f1</td><td>first floor function (for the vertex) </td></tr>
    <tr><td class="paramname">f2</td><td>second floor function (for the direction vector)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the last vertex of the left hull has been reached, 'false' otherwise.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Position</td><td>a model of integer for locating points in the DSS </td></tr>
    <tr><td class="paramname"><a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a></td><td>a model of 2d point/vector </td></tr>
    <tr><td class="paramname">Coordinate</td><td>a model of integer for the coordinates of the point/vector </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of output iterator </td></tr>
    <tr><td class="paramname">PositionFunctor</td><td>a model of unary functor that returns the position of a point/vector </td></tr>
    <tr><td class="paramname">TruncationFunctor1</td><td>a model of unary functor that implements an integer division </td></tr>
    <tr><td class="paramname">TruncationFunctor2</td><td>a model of unary functor that implements an integer division </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a184e90763c4747a4b7c71a58e1bf4bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184e90763c4747a4b7c71a58e1bf4bfe">&#9670;&nbsp;</a></span>smartCHPreviousVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointVector , typename Position , typename OutputIterator , typename TruncationFunctor1 , typename TruncationFunctor2 , typename PositionFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::smartCHPreviousVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>aFirstPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>aLastPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>ito</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PositionFunctor &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TruncationFunctor1 &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TruncationFunctor2 &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Procedure that computes the previous vertex of the left hull of a DSS of main direction vector <em>V</em> , first upper leaning point <em>U</em> and first positive Bezout point <em>L</em>. The computation stops as soon as a computed vertex is located before <em>aLastPosition</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>(returned) first vertex of the left hull on the considered side </td></tr>
    <tr><td class="paramname">Y</td><td>first vertex of the left hull on the opposite side </td></tr>
    <tr><td class="paramname">V</td><td>(returned) previous direction vector </td></tr>
    <tr><td class="paramname">aFirstPosition</td><td>position of the first point of the subsegment </td></tr>
    <tr><td class="paramname">aLastPosition</td><td>position of the last point of the subsegment </td></tr>
    <tr><td class="paramname">ito</td><td>output iterator used to store the vertices of the left hull lying on the same side as <em>X</em> </td></tr>
    <tr><td class="paramname">pos</td><td>position functor, which returns the position of any given point/vector </td></tr>
    <tr><td class="paramname">f1</td><td>integer divisor for the direction vector update </td></tr>
    <tr><td class="paramname">f2</td><td>integer divisor for the vertex update</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a></td><td>a model of couple of coordinates </td></tr>
    <tr><td class="paramname">Position</td><td>a model of integer for the position of the points </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of output iterator </td></tr>
    <tr><td class="paramname">TruncationFunctor1</td><td>a model of functor for the integer division </td></tr>
    <tr><td class="paramname">TruncationFunctor2</td><td>a model of functor for the integer division </td></tr>
    <tr><td class="paramname">PositionFunctor</td><td>a model of functor returning the position of a point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the last vertex has been reached, 'false' otherwise </dd></dl>

</div>
</div>
<a id="ac8e2160844093488cdd738354027daa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e2160844093488cdd738354027daa1">&#9670;&nbsp;</a></span>square()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T DGtal::functions::square </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value x * x </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>a type with the multiply operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>any value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value x * x </dd></dl>

<p class="definition">Definition at line <a class="el" href="BasicMathFunctions_8h_source.html#l00133">133</a> of file <a class="el" href="BasicMathFunctions_8h_source.html">BasicMathFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    { <span class="keywordflow">return</span> x * x; }</div></div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="Point2ScalarFunctors_8h_source.html#l00069">DGtal::functors::HatPointFunction&lt; TPoint, TScalar &gt;::operator()()</a>, and <a class="el" href="Point2ScalarFunctors_8h_source.html#l00097">DGtal::functors::BallConstantPointFunction&lt; TPoint, TScalar &gt;::operator()()</a>.</p>

</div>
</div>
<a id="ad86a0dd4add6c1b9f567908893b4a69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86a0dd4add6c1b9f567908893b4a69d">&#9670;&nbsp;</a></span>twoIsthmus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::twoIsthmus </td>
          <td>(</td>
          <td class="paramtype">const TComplex &amp;&#160;</td>
          <td class="paramname"><em>vc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">TComplex::Cell</a> &amp;&#160;</td>
          <td class="paramname"><em>cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if input cell is a 2-isthmus. A voxel is a 2-isthmus if, after a thinning, its proper neighborhood is a 1-Surface <a class="el" href="namespaceDGtal_1_1functions.html#a5c782738287493c15465124d3516d4ec">isOneSurface</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceDGtal_1_1functions.html#a5c782738287493c15465124d3516d4ec">isOneSurface</a> </dd>
<dd>
<a class="el" href="classDGtal_1_1Object.html#a5dfbef899715f5f0d81e02ad63504892">Object::properNeighborhood</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TComplex</td><td><a class="el" href="classDGtal_1_1VoxelComplex.html" title="This class represents a voxel complex living in some Khalimsky space. Voxel complexes are derived fro...">VoxelComplex</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vc</td><td>input complex. </td></tr>
    <tr><td class="paramname">cell</td><td>apply function on input cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="reference">Referenced by <a class="el" href="testVoxelComplex_8cpp_source.html#l00735">TEST_CASE_METHOD()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 27 2019 12:04:34 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
