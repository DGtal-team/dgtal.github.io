<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Affine geometry of points and vectors</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;2.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('moduleAffineGeometry.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Affine geometry of points and vectors </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Jacques-Olivier Lachaud</dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.0</dd></dl>
<p>Part of the <a class="el" href="packageGeometry.html">Geometry package</a>.</p>
<p>This part of the manual describes how to perform some elementary affine geometry computations: affine dimension of a set of points, subset of maximum affine dimension, completion of a partial basis, computation of an orthogonal vector. This module is notably used in <a class="el" href="structDGtal_1_1QuickHull.html" title="Aim: Implements the quickhull algorithm by Barber et al. barber1996, a famous arbitrary dimensional c...">QuickHull</a> algorithm.</p>
<p>The following programs are related to this documentation: <a class="el" href="testAffineGeometry_8cpp.html">testAffineGeometry.cpp</a> <a class="el" href="exampleAffineGeometry_8cpp.html">exampleAffineGeometry.cpp</a> <a class="el" href="testAffineBasis_8cpp.html">testAffineBasis.cpp</a></p>
<p>See <a class="el" href="moduleQuickHull.html">QuickHull algorithm in arbitrary dimension for convex hull and Delaunay cell complex computation</a></p>
<h1 class="doxsection"><a class="anchor" id="dgtal_affgeom_sec1"></a>
Generic functions for affine geometry</h1>
<p><a class="el" href="structA.html">A</a> set of generic functions is provided in header <span class="tt"><a class="el" href="AffineGeometry_8h_source.html">DGtal/geometry/tools/AffineGeometry.h</a></span> for several affine geometry computations. They can be conveniently used since they deduce automatically the type of their parameters. All these functions support number types for points and vectors that are either integers (<a class="el" href="namespaceDGtal.html#a16d5d6c3faf5a8cb1d67a41634513404" title="signed 32-bit integer.">int32_t</a>, <a class="el" href="namespaceDGtal.html#a45f076335dc184c6b7267b006362f5aa" title="signed 94-bit integer.">int64_t</a>, <a class="el" href="namespaceDGtal.html#ab1ab4623f30a6a2f84f80936b4b24e6f">BigInteger</a>) or floating-point numbers (float, double). The computations are <b>exact</b> when types are <b>integral</b> (up to integer overflow), while a <b>tolerance</b> can be provided for floating-point numbers (default tolerance: between -1e-12 and 1e-12 is zero).</p>
<p><b> Affine dimension and affine subset </b></p>
<ul>
<li><a class="el" href="namespaceDGtal_1_1functions.html#a2c824ceec41116e7aeb7adc31790ee58">functions::computeAffineDimension( const std::vector&lt; TPoint &gt;&amp; X,
  const double tolerance )</a> Given a range of points <em class="arg">X</em>, returns the affine dimension of its spanned affine subspace.</li>
<li><a class="el" href="namespaceDGtal_1_1functions.html#ac89edee5061b26eccbb99f5892f2785f">functions::computeAffineSubset( const std::vector&lt; TPoint &gt;&amp; X,
  const double tolerance )</a> Given a range of points <em class="arg">X</em>, returns a subset of these points that form an affine basis of <em class="arg">X</em>. Equivalently it is a simplex whose affine space spans all the points of <em class="arg">X</em>.</li>
<li><a class="el" href="namespaceDGtal_1_1functions.html#a0de6e8e8febd0c0e702941aae849583d">functions::computeAffineSubset( const std::vector&lt;TPoint&gt;&amp; X, const
  TIndexRange&amp; I, const double tolerance )</a> Given a range of points <em class="arg">X</em> and a subset of it given by indices <em class="arg">I</em>, returns a subset of these points that form an affine basis of <em class="arg">X</em>[I]. Equivalently it is a simplex whose affine space spans all the points of <em class="arg">X</em>[I].</li>
</ul>
<p><b> Affine basis and independent vectors </b></p>
<p>The computed bases are in row echelon form (see <a href="https://en.wikipedia.org/wiki/Row_echelon_form">Wikipedia </a>), potentially reduced if components are real-value and nnot integers, except when using completeBasis where the last vector may be asked to be orthogonal to all the others.</p>
<ul>
<li><a class="el" href="namespaceDGtal_1_1functions.html#a30c294205208734c7c225a5bcd3a52f5">functions::getAffineBasis( TInputPoint&amp; o, std::vector&lt; TPoint &gt;&amp;
  basis, const std::vector&lt; TInputPoint &gt;&amp; X, const double tolerance )</a> Given a range of points <em class="arg">X</em>, outputs a point and a range of vectors forming an affine basis containing <em class="arg">X</em>.</li>
<li><a class="el" href="namespaceDGtal_1_1functions.html#a425ef3d60cdbb96371b930c788bda760">functions::getAffineBasis( TInputPoint&amp; o, std::vector&lt; TPoint &gt;&amp;
  basis, const std::vector&lt; TInputPoint &gt;&amp; X, const TIndexRange&amp; I,
  const double tolerance )</a> Given a range of points <em class="arg">X</em> and the indices <em class="arg">I</em> of points in <em class="arg">X</em> which form an affine subset of <em class="arg">X</em>, returns a point and a range of vectors forming an affine basis containing <em class="arg">X</em>.</li>
<li><a class="el" href="namespaceDGtal_1_1functions.html#a7900f5ff00193be1ca0f75ad281ab986">functions::computeIndependentVector( const std::vector&lt; TPoint &gt;&amp;
  basis, const double tolerance )</a> Given a partial basis of vectors, returns a returns a canonic unit vector that is independent.</li>
<li><a class="el" href="namespaceDGtal_1_1functions.html#a88db7bc56059fe613108efa44008b539">functions::getCompleteBasis( std::vector&lt; TPoint &gt;&amp; basis, bool
  normal_vector, const double tolerance )</a> Complete the vectors <em class="arg">basis</em> with independent vectors so as to form a basis of the space. When <em class="arg">normal_vector</em> is true, the last added vector is guaranteed to be <b>orthogonal</b> to all the previous vectors, otherwise it is just an independent canonic vector.</li>
</ul>
<p><b> Affine basis of codimension 1 </b></p>
<ul>
<li><a class="el" href="namespaceDGtal_1_1functions.html#a116c996f7f5280d44e138e3b7549cb9f">functions::getOrthogonalLatticeBasis( std::vector&lt; TPoint &gt;&amp; B,
  const TInputPoint&amp; N, bool shortened )</a> Given a lattice vector <em class="arg">N</em>, returns a possible basis for its orthogonal d-1 dimensional lattice. The returned basis is guaranteed to span all the lattice points contained in the vector space orthogonal to <em class="arg">N</em>. If <span class="tt">shortened</span> is false, the basis is in row echelon form, otherwise the vectors are shortened by pairwise linear combinations.</li>
</ul>
<p><b> Orthogonal vector to basis of codimension 1 </b></p>
<ul>
<li><a class="el" href="namespaceDGtal_1_1functions.html#abf13f0eeaaf6bbd4c367376b3ad4a85c">functions::computeOrthogonalVectorToBasis( const
  std::vector&lt;TPoint&gt;&amp; basis )</a> Given <span class="tt">d-1</span> independent vectors <em class="arg">basis</em> in dD, returns a vector that is orthogonal to each of them.</li>
<li><a class="el" href="namespaceDGtal_1_1functions.html#a4507c561989e491885b3b39fc0bd47d7">functions::getOrthogonalVector( TPoint&amp; w, const std::vector&lt;
  TInputPoint &gt;&amp; X, const TIndexRange&amp; I, const double tolerance )</a> Given a range of points <em class="arg">X</em>, a range of indices <em class="arg">I</em> specifying the affine subset of interest, returns a vector that is orthogonal to this affine subset, if it is d-1-dimensional.</li>
<li><a class="el" href="namespaceDGtal_1_1functions.html#ad9470ebd53573c4c86a168680f581eb2">functions::getOrthogonalVector( TPoint&amp; w, const std::vector&lt;
  TInputPoint &gt;&amp; X, const double tolerance )</a> Given a range of points <em class="arg">X</em>, returns a vector that is orthogonal to this affine set, if it is d-1-dimensional.</li>
</ul>
<p><b> Utilities </b></p>
<ul>
<li><a class="el" href="namespaceDGtal_1_1functions.html#afb73caf8786b82dd56b4e2a179f1f9e8">functions::computeSimplifiedVector( const TPoint&amp; v )</a> Given a vector, returns the aligned vector with its component simplified by the gcd of all components (when the components are integers) or the aligned vector with a maximum oo-norm of 1 (when the components are floating-point numbers).</li>
</ul>
<p>This example (similar to <a class="el" href="exampleAffineGeometry_8cpp.html">exampleAffineGeometry.cpp</a>) shows how to process the affine geometry of a set of points that is not full dimensional.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/base/Common.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/kernel/PointVector.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/tools/AffineGeometry.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; std::ostream&amp;</div>
<div class="line"><a class="code hl_function" href="namespaceDGtal.html#a75322b203241e20a106afb814182df80">operator&lt;&lt;</a>( std::ostream&amp; out, <span class="keyword">const</span> std::vector&lt; T &gt;&amp; <span class="keywordtype">object</span> )</div>
<div class="line">{ <span class="comment">// to display vector&lt;T&gt;</span></div>
<div class="line">  out &lt;&lt; <span class="stringliteral">&quot;[&quot;</span>;</div>
<div class="line">  <span class="keywordflow">for</span> ( <span class="keyword">auto</span> t : <span class="keywordtype">object</span> ) out &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; t;</div>
<div class="line">  out &lt;&lt; <span class="stringliteral">&quot; ]&quot;</span>;</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceDGtal.html">DGtal</a>;</div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="testBits_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1PointVector.html">PointVector&lt; 3, int64_t&gt;</a> <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>;</div>
<div class="line">  std::vector&lt; Point &gt; X = {</div>
<div class="line">    <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>{21, -29, -21}, <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>{-6, 14, 8}, <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>{-19, 1, 9},</div>
<div class="line">    <a class="code hl_class" href="classDGtal_1_1SpaceND.html">Point</a>{39, 16, -12}, <a class="code hl_class" href="classDGtal_1_1SpaceND.html">Point</a>{-26, 29, 23}, <a class="code hl_class" href="classDGtal_1_1SpaceND.html">Point</a>{-4, 45, 19},</div>
<div class="line">    <a class="code hl_class" href="classDGtal_1_1SpaceND.html">Point</a>{6, 31, 9}, <a class="code hl_class" href="classDGtal_1_1SpaceND.html">Point</a>{9, 6, -2}, <a class="code hl_class" href="classDGtal_1_1SpaceND.html">Point</a>{8, 49, 15}</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Dimension is &quot;</span> &lt;&lt; Point::dimension &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;X = &quot;</span> &lt;&lt; X &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Expected dimension of affine set of points X is &quot;</span></div>
<div class="line">            &lt;&lt; (Point::dimension-1) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;AffineDim(X) = &quot;</span> &lt;&lt; <a class="code hl_function" href="namespaceDGtal_1_1functions.html#a2c824ceec41116e7aeb7adc31790ee58">functions::computeAffineDimension</a>( X ) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">  <span class="keyword">auto</span> I = <a class="code hl_function" href="namespaceDGtal_1_1functions.html#ac89edee5061b26eccbb99f5892f2785f">functions::computeAffineSubset</a>( X );</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;AffineSubset(X) = &quot;</span> &lt;&lt; I &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">  <a class="code hl_class" href="classDGtal_1_1SpaceND.html">Point</a> o;</div>
<div class="line">  std::vector&lt;Point&gt; B;</div>
<div class="line">  <a class="code hl_function" href="namespaceDGtal_1_1functions.html#a30c294205208734c7c225a5bcd3a52f5">functions::getAffineBasis</a>( o, B, X, I );</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;AffineBasis(X) =: p+B = &quot;</span> &lt;&lt; o &lt;&lt; <span class="stringliteral">&quot; + &quot;</span> &lt;&lt; B &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">  <span class="keyword">auto</span> e = <a class="code hl_function" href="namespaceDGtal_1_1functions.html#a7900f5ff00193be1ca0f75ad281ab986">functions::computeIndependentVector</a>( B );</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Independent(X) =: e = &quot;</span> &lt;&lt; e &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">  <a class="code hl_class" href="classDGtal_1_1SpaceND.html">Point</a> n = <a class="code hl_function" href="namespaceDGtal_1_1functions.html#abf13f0eeaaf6bbd4c367376b3ad4a85c">functions::computeOrthogonalVectorToBasis</a>( B );</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Orthogonal(X) =: n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">  <a class="code hl_class" href="classDGtal_1_1SpaceND.html">Point</a> ns = <a class="code hl_function" href="namespaceDGtal_1_1functions.html#afb73caf8786b82dd56b4e2a179f1f9e8">functions::computeSimplifiedVector</a>( n );</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Orthogonal(X)/gcd =: ns = &quot;</span> &lt;&lt; ns &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;  </div>
<div class="line">  <span class="keywordflow">for</span> ( <span class="keyword">auto</span> i = 0; i &lt; B.size(); i++ )</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;B[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] . ns = &quot;</span> &lt;&lt; B[i] &lt;&lt; <span class="stringliteral">&quot; . &quot;</span> &lt;&lt; ns</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; == &quot;</span> &lt;&lt; B[i].dot(ns) &lt;&lt; <span class="stringliteral">&quot; (should be 0)\n&quot;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="aclassDGtal_1_1PointVector_html"><div class="ttname"><a href="classDGtal_1_1PointVector.html">DGtal::PointVector</a></div><div class="ttdoc">Aim: Implements basic operations that will be used in Point and Vector classes.</div><div class="ttdef"><b>Definition</b> <a href="PointVector_8h_source.html#l00592">PointVector.h:593</a></div></div>
<div class="ttc" id="aclassDGtal_1_1SpaceND_html"><div class="ttname"><a href="classDGtal_1_1SpaceND.html">DGtal::Point</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1functions_html_a2c824ceec41116e7aeb7adc31790ee58"><div class="ttname"><a href="namespaceDGtal_1_1functions.html#a2c824ceec41116e7aeb7adc31790ee58">DGtal::functions::computeAffineDimension</a></div><div class="ttdeci">DGtal::int64_t computeAffineDimension(const std::vector&lt; TPoint &gt; &amp;X, const double tolerance=1e-12)</div><div class="ttdef"><b>Definition</b> <a href="AffineGeometry_8h_source.html#l01068">AffineGeometry.h:1068</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1functions_html_a30c294205208734c7c225a5bcd3a52f5"><div class="ttname"><a href="namespaceDGtal_1_1functions.html#a30c294205208734c7c225a5bcd3a52f5">DGtal::functions::getAffineBasis</a></div><div class="ttdeci">void getAffineBasis(TInputPoint &amp;o, std::vector&lt; TPoint &gt; &amp;basis, const std::vector&lt; TInputPoint &gt; &amp;X, const double tolerance=1e-12)</div><div class="ttdef"><b>Definition</b> <a href="AffineGeometry_8h_source.html#l01145">AffineGeometry.h:1145</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1functions_html_a7900f5ff00193be1ca0f75ad281ab986"><div class="ttname"><a href="namespaceDGtal_1_1functions.html#a7900f5ff00193be1ca0f75ad281ab986">DGtal::functions::computeIndependentVector</a></div><div class="ttdeci">TPoint computeIndependentVector(const std::vector&lt; TPoint &gt; &amp;basis, const double tolerance=1e-12)</div><div class="ttdef"><b>Definition</b> <a href="AffineGeometry_8h_source.html#l01202">AffineGeometry.h:1202</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1functions_html_abf13f0eeaaf6bbd4c367376b3ad4a85c"><div class="ttname"><a href="namespaceDGtal_1_1functions.html#abf13f0eeaaf6bbd4c367376b3ad4a85c">DGtal::functions::computeOrthogonalVectorToBasis</a></div><div class="ttdeci">static TPoint computeOrthogonalVectorToBasis(const std::vector&lt; TPoint &gt; &amp;basis)</div><div class="ttdef"><b>Definition</b> <a href="AffineGeometry_8h_source.html#l01262">AffineGeometry.h:1262</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1functions_html_ac89edee5061b26eccbb99f5892f2785f"><div class="ttname"><a href="namespaceDGtal_1_1functions.html#ac89edee5061b26eccbb99f5892f2785f">DGtal::functions::computeAffineSubset</a></div><div class="ttdeci">std::vector&lt; std::size_t &gt; computeAffineSubset(const std::vector&lt; TPoint &gt; &amp;X, const double tolerance=1e-12)</div><div class="ttdef"><b>Definition</b> <a href="AffineGeometry_8h_source.html#l01089">AffineGeometry.h:1089</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1functions_html_afb73caf8786b82dd56b4e2a179f1f9e8"><div class="ttname"><a href="namespaceDGtal_1_1functions.html#afb73caf8786b82dd56b4e2a179f1f9e8">DGtal::functions::computeSimplifiedVector</a></div><div class="ttdeci">TPoint computeSimplifiedVector(const TPoint &amp;v)</div><div class="ttdef"><b>Definition</b> <a href="AffineGeometry_8h_source.html#l01394">AffineGeometry.h:1394</a></div></div>
<div class="ttc" id="anamespaceDGtal_html"><div class="ttname"><a href="namespaceDGtal.html">DGtal</a></div><div class="ttdoc">DGtal is the top-level namespace which contains all DGtal functions and types.</div><div class="ttdef"><b>Definition</b> <a href="ClosedIntegerHalfPlane_8h_source.html#l00048">ClosedIntegerHalfPlane.h:49</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a75322b203241e20a106afb814182df80"><div class="ttname"><a href="namespaceDGtal.html#a75322b203241e20a106afb814182df80">DGtal::operator&lt;&lt;</a></div><div class="ttdeci">std::ostream &amp; operator&lt;&lt;(std::ostream &amp;out, const ClosedIntegerHalfPlane&lt; TSpace &gt; &amp;object)</div></div>
<div class="ttc" id="atestBits_8cpp_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="testBits_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>Definition</b> <a href="testBits_8cpp_source.html#l00056">testBits.cpp:56</a></div></div>
<div class="ttc" id="atestClone2_8cpp_html_a4075d279133f1952978300b7e135f83d"><div class="ttname"><a href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a></div><div class="ttdeci">MyPointD Point</div><div class="ttdef"><b>Definition</b> <a href="testClone2_8cpp_source.html#l00381">testClone2.cpp:381</a></div></div>
</div><!-- fragment --><p>outputs </p><pre class="fragment">Dimension is 3
X = [ (-5, -25, 0) (19, 22, 7) (0, -19, 0) (-20, -17, 10) (20, 5, 0) (0, -6, 5) (9, 23, 12) (-14, -41, -2) (22, 10, 1) (34, -38, -23) (12, 11, 6) ]
Expected dimension of affine set of points X is 2
AffineDim(X) = 2
AffineSubset(X) = [ 0 1 2 ]
AffineBasis(X) =: p+B = (-5, -25, 0) + [ (24, 47, 7) (0, -13, -5) ]
Independent(X) =: e = (1, 0, 0)
Orthogonal(X) =: n = (-6, 5, -13)
Orthogonal(X)/gcd =: ns = (-6, 5, -13)
B[0] . ns = (24, 47, 7) . (-6, 5, -13) == 0 (should be 0)
B[1] . ns = (0, -13, -5) . (-6, 5, -13) == 0 (should be 0)
</pre><h1 class="doxsection"><a class="anchor" id="dgtal_affgeom_sec2"></a>
Using class AffineGeometry directly</h1>
<p>If you need to finetune how affine geometry computations are performed, you may use the static methods of class <a class="el" href="structDGtal_1_1AffineGeometry.html" title="Aim: Utility class to determine the affine geometry of an input set of points. It provides exact resu...">AffineGeometry</a> directly. The advantage is that you can specify a type for computations that is <b>more</b> <b>precise</b> than the type of input data.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1SpaceND.html">SpaceND&lt;3, int&gt;</a> <a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a38dfaf1641eab4d3fb805df4b52ab10d">Space</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_typedef" href="classDGtal_1_1SpaceND.html#a34beb5f81d0848e8ae393f39a1422ebc">Space::Point</a>    <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1SpaceND.html">SpaceND&lt;3, int64_t&gt;</a> ComputationSpace;</div>
<div class="line"><span class="keyword">typedef</span> ComputationSpace::Point  ComputationPoint;</div>
<div class="line">...</div>
<div class="line">typedef <a class="code hl_struct" href="structDGtal_1_1AffineGeometry.html">AffineGeometry&lt;ComputationPoint&gt;</a> Affine;</div>
<div class="line"> </div>
<div class="line">std::vector&lt;Point&gt; X = { <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>{1, 0, 0}, <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>{2, 1, 0}, <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>{3, 2, 0},</div>
<div class="line">                         <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>{3, 1, 1}, <a class="code hl_class" href="classDGtal_1_1SpaceND.html">Point</a>{5, 2, 2}, <a class="code hl_class" href="classDGtal_1_1SpaceND.html">Point</a>{4, 2, 1} };</div>
<div class="line"><span class="keyword">auto</span> I = Affine::affineSubset( X ); </div>
<div class="line"><span class="keyword">auto</span> B = Affine::affineBasis( X );  </div>
<div class="line"><span class="keyword">auto</span> d = Affine::affineDimension( X ); </div>
<div class="line"></div>
<div class="ttc" id="aclassDGtal_1_1SpaceND_html_a34beb5f81d0848e8ae393f39a1422ebc"><div class="ttname"><a href="classDGtal_1_1SpaceND.html#a34beb5f81d0848e8ae393f39a1422ebc">DGtal::SpaceND::Point</a></div><div class="ttdeci">PointVector&lt; dim, Integer &gt; Point</div><div class="ttdoc">Points in DGtal::SpaceND.</div><div class="ttdef"><b>Definition</b> <a href="SpaceND_8h_source.html#l00110">SpaceND.h:110</a></div></div>
<div class="ttc" id="astructDGtal_1_1AffineGeometry_html"><div class="ttname"><a href="structDGtal_1_1AffineGeometry.html">DGtal::AffineGeometry</a></div><div class="ttdoc">Aim: Utility class to determine the affine geometry of an input set of points. It provides exact resu...</div><div class="ttdef"><b>Definition</b> <a href="AffineGeometry_8h_source.html#l00453">AffineGeometry.h:454</a></div></div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_a38dfaf1641eab4d3fb805df4b52ab10d"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a38dfaf1641eab4d3fb805df4b52ab10d">Space</a></div><div class="ttdeci">SpaceND&lt; 2 &gt; Space</div><div class="ttdef"><b>Definition</b> <a href="testSimpleRandomAccessRangeFromPoint_8cpp_source.html#l00042">testSimpleRandomAccessRangeFromPoint.cpp:42</a></div></div>
</div><!-- fragment --><p>The same services are provided as <a class="el" href="structDGtal_1_1AffineGeometry.html" title="Aim: Utility class to determine the affine geometry of an input set of points. It provides exact resu...">AffineGeometry</a> static methods:</p>
<p><b> affine dimension and affine subset </b></p>
<ul>
<li><a class="el" href="structDGtal_1_1AffineGeometry.html#a8da2acf0dee5d99380c711b9ff8d3857">AffineGeometry::affineDimension( const std::vector&lt;TInputPoint&gt;&amp;
    X, const double tolerance )</a> Given a range of points <em class="arg">X</em>, returns the affine dimension of its spanned affine subspace.</li>
<li><a class="el" href="structDGtal_1_1AffineGeometry.html#afefa5251791364012e4679866fb03060">AffineGeometry::affineSubset( const std::vector&lt;TInputPoint&gt;&amp; X,
    const double tolerance )</a> Given a range of points <em class="arg">X</em>, returns a subset of these points that form an affine basis of <em class="arg">X</em>. Equivalently it is a simplex whose affine space spans all the points of <em class="arg">X</em>.</li>
<li><a class="el" href="structDGtal_1_1AffineGeometry.html#a49f839d7be8e24d30825b113f621a3cf">AffineGeometry::affineSubset( const std::vector&lt;TInputPoint&gt;&amp; X,
    const TIndexRange&amp; I, const double tolerance )</a> Given a range of points <em class="arg">X</em> and a subset of it given by indices <em class="arg">I</em>, returns a subset of these points that form an affine basis of <em class="arg">X</em>[I]. Equivalently it is a simplex whose affine space spans all the points of <em class="arg">X</em>[I].</li>
</ul>
<p><b> affine basis and independent vectors </b></p>
<p>The computed bases are in row echelon form (see <a href="https://en.wikipedia.org/wiki/Row_echelon_form">Wikipedia </a>), even reduced row echelon form if components are real-valued and not integers, except when using completeBasis where the last vector may be asked to be orthogonal to all the others.</p>
<ul>
<li><a class="el" href="structDGtal_1_1AffineGeometry.html#af2d8922e8978e1d10393d5f977cb0ce9">AffineGeometry::affineBasis( const std::vector&lt;TInputPoint&gt;&amp; X,
    const double tolerance )</a> Given a range of points <em class="arg">X</em>, returns a point and a range of vectors forming an affine basis containing <em class="arg">X</em>.</li>
<li><a class="el" href="structDGtal_1_1AffineGeometry.html#a0b18d52df1140be631ce8be5082d783b">AffineGeometry::affineBasis( const std::vector&lt;TInputPoint&gt;&amp; X,
    const TIndexRange&amp; I, const double tolerance )</a> Given a range of points <em class="arg">X</em> and a range of indices <em class="arg">I</em> describing its subset of interest, returns a point and a range of vectors forming an affine basis containing the subset <span class="tt">X[I]</span>.</li>
<li><a class="el" href="structDGtal_1_1AffineGeometry.html#a5207865de1aa8b219c6f80ae1e52e132">AffineGeometry::independentVector</a> Given a partial basis of vectors, returns a new vector that is independent.</li>
<li><a class="el" href="structDGtal_1_1AffineGeometry.html#ac0c30b8df1e2a6b4bedb3678f8c1e9fd">AffineGeometry::completeBasis</a> Complete the vectors <em class="arg">basis</em> with independent vectors so as to form a basis of the space. When <em class="arg">normal_vector</em> is true, the last added vector is guaranteed to be <b>orthogonal</b> to all the previous vectors.</li>
</ul>
<p><b> orthogonal vector to basis of codimension 1 </b></p>
<ul>
<li><a class="el" href="structDGtal_1_1AffineGeometry.html#a66f8def43abb8f93304e58c5effc64d4">AffineGeometry::orthogonalVector</a> Given <span class="tt">d-1</span> independent vectors in dD, returns a vector that is orthogonal to each of them.</li>
</ul>
<p><b> utilities </b></p>
<p>Reducing a vector onto a basis is a Gaussian elimination but slightly modified to handle integers (in case of lattice points and vectors).</p>
<ul>
<li><a class="el" href="structDGtal_1_1AffineGeometry.html#ada7e0e7e86f41876fffb64c9f974a108">AffineGeometry::reductionOnBasis</a> Reduces the vector <em class="arg">v</em> on the (partial or not) basis of vectors <em class="arg">basis</em>, and returns the part of <em class="arg">v</em> that cannot be expressed as a linear combination of vectors of <em class="arg">basis</em>, and hence a null vector if <em class="arg">v</em> is a linear combination of the vectors of the basis.</li>
<li><a class="el" href="structDGtal_1_1AffineGeometry.html#a32fbc413d4562fac8e5032d361392cb6">AffineGeometry::reduceVector</a> Reduces vector <em class="arg">w</em> by the vector <em class="arg">b</em>, and returns the coefficients \( (\alpha,\beta) \) for reduction such that \( \alpha w - \beta b \) is the returned reduced vector, \( \alpha \ge 0 \).</li>
<li><a class="el" href="structDGtal_1_1AffineGeometry.html#accebfe1d45c06eb31bbb93492be59cfb">AffineGeometry::simplifiedVector</a> Given a vector, returns the aligned vector with its component simplified by the gcd of all components (when the components are integers) or the aligned vector with unit L2-norm (when the components are floating-point numbers).</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="dgtal_affgeom_sec3"></a>
Projecting points onto an affine basis</h1>
<p><a class="el" href="structDGtal_1_1AffineBasis.html" title="Aim: Utility class to determine the affine geometry of an input set of points. It provides exact resu...">AffineBasis</a> is a convenience class that represents an affine basis (integral or not) in a form chosen by the user: either <em>echelon</em> <em>reduced</em> (<a class="el" href="structDGtal_1_1AffineBasis.html#aa87533328905f62e960caa977c708375aa5a2c42235cd132cf861c4c66379c45a" title="echelon matrix">AffineBasis::Type::ECHELON_REDUCED</a>) or <em>LLL</em> <em>reduced</em> (<a class="el" href="structDGtal_1_1AffineBasis.html#aa87533328905f62e960caa977c708375aa5a2c42235cd132cf861c4c66379c45a" title="echelon matrix">AffineBasis::Type::ECHELON_REDUCED</a>). It is mostly useful for projecting points and vectors onto it, and providing a system of coordinates on the affine space.</p>
<dl class="section warning"><dt>Warning</dt><dd>For now, you cannot project onto the basis when it is LLL-reduced (<a class="el" href="structDGtal_1_1AffineBasis.html#aa87533328905f62e960caa977c708375a958112918d9eecec07d8f56b978f0a1b" title="delta-LLL reduced matrix">AffineBasis::Type::LLL_REDUCED</a>). Use <a class="el" href="structDGtal_1_1AffineBasis.html#aa87533328905f62e960caa977c708375aa5a2c42235cd132cf861c4c66379c45a" title="echelon matrix">AffineBasis::Type::ECHELON_REDUCED</a> instead.</dd></dl>
<p><b> Constructors </b></p>
<p>You can construct an affine basis from a set of points or from an origin and arbitrary vectors, while choosing its form in <a class="el" href="structDGtal_1_1AffineBasis.html#aa87533328905f62e960caa977c708375">AffineBasis::Type</a>.</p>
<ul>
<li><a class="el" href="structDGtal_1_1AffineBasis.html#ae2cab3a013030cefe8a90542baf0c792">AffineBasis::AffineBasis( const double tolerance )</a> Constructs the canonic basis</li>
<li><a class="el" href="structDGtal_1_1AffineBasis.html#a4c780976630af5babb2ea304f6e6e9e5">AffineBasis::AffineBasis( const std::vector&lt; TInputPoint &gt;&amp;
    points, AffineBasis::Type type, const double delta, const double
    tolerance )</a> Constructs an affine basis spanning the set of points.</li>
<li><a class="el" href="structDGtal_1_1AffineBasis.html#a001d39c4c3b3d79d3d176d7861386ecc">AffineBasis::AffineBasis( const TInputPoint&amp; origin, const
    std::vector&lt;TInputPoint&gt;&amp; basis, AffineBasis::Type type, bool
    is_reduced, const double delta, const double tolerance )</a> Constructs an affine basis spanning the given vectors and going through the given origin.</li>
<li>AffineBasis::AffineBasis( const TInputPoint&amp; origin, const
    TInputPoint&amp; normal, AffineBasis::Type type, const double delta,
    const double tolerance ) Creates an affine basis of codimension 1, going through <em class="arg">origin</em> and orthogonal to the lattice vector <em class="arg">normal</em>.</li>
</ul>
<p><b> Standard services </b></p>
<ul>
<li><a class="el" href="structDGtal_1_1AffineBasis.html#a2230aaa5e3519d25c87b729064afc9e8">AffineBasis::dimension()</a> returns the dimension of the spanned affine subspace.</li>
<li><a class="el" href="structDGtal_1_1AffineBasis.html#a22496d1306e12ec874f3b42e4ae84965">AffineBasis::origin()</a> returns a point on the spanned affine subspace.</li>
<li><a class="el" href="structDGtal_1_1AffineBasis.html#adfda3f9e58176af09836584a387c4bf8">AffineBasis::basis()</a> returns the vectors spanning the affine subspace.</li>
</ul>
<p><b> Geometric services </b></p>
<ul>
<li><a class="el" href="structDGtal_1_1AffineBasis.html#a03d5a9199da8994a47ec2a61e4edf9ed">AffineBasis::isParallel</a> returns 'true' iff the vectors <em class="arg">w</em> lies in this affine space.</li>
<li><a class="el" href="structDGtal_1_1AffineBasis.html#afa520247341db345e01f23eb1fa2e25d">AffineBasis::isOnAffineSpace</a> returns 'true' iff the point <em class="arg">p</em> lies in this affine space.</li>
</ul>
<p><b> Projection services </b></p>
<ul>
<li><a class="el" href="structDGtal_1_1AffineBasis.html#a1dc9cf9a917097860ddb9ba3f613eba6">AffineBasis::decompose</a> Decomposes a point <em class="arg">p</em> into a tuple  \(    (d,L,R) \), such that: \( d (p - o) = L \cdot B + R \), where R is independent from this basis \( B=(b_0, \ldots, b_i) \), with origin <em class="arg">o</em>. <em class="arg">d</em> is a scalar, \( L/d \) are the rational coordinates of \( (p-o) \) in the basis, <em class="arg">R</em> is the remainer vector. Note that <em class="arg">R</em> is not null whenever <em class="arg">p</em> does not belong to the affine space.</li>
<li><a class="el" href="structDGtal_1_1AffineBasis.html#a581be8e0a94e671848465db63e61f9c5">AffineBasis::decomposeVector</a> Same as above but for a vector (ignores the origin).</li>
<li><a class="el" href="structDGtal_1_1AffineBasis.html#ac606a28fecd51af02aba85e26de73152">AffineBasis::recompose</a> and <a class="el" href="structDGtal_1_1AffineBasis.html#a0a4c1dc1b7945dbf9efa7fcc69706e5d">AffineBasis::recomposeVector</a> are the inverse functions of the two previous ones.</li>
<li><a class="el" href="structDGtal_1_1AffineBasis.html#ab01deea3713827abd2ce63855690899d">AffineBasis::projectPoints</a> Projects a range of points onto the affine basis and outputs it. It also returns the maximum dilation of projected rational coordinates which was used to create lattice coordinates.</li>
</ul>
<p>The example below shows how to use <a class="el" href="structDGtal_1_1AffineBasis.html" title="Aim: Utility class to determine the affine geometry of an input set of points. It provides exact resu...">AffineBasis</a> to project 4D points onto a 2D affine subspace.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1SpaceND.html">SpaceND&lt; 4, int64_t &gt;</a>            Space4;</div>
<div class="line"><span class="keyword">typedef</span> Space4::Point                    Point4;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1SpaceND.html">SpaceND&lt; 2, int64_t &gt;</a>            Space2;</div>
<div class="line"><span class="keyword">typedef</span> Space2::Point                    Point2;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_struct" href="structDGtal_1_1AffineBasis.html">AffineBasis&lt; Point4 &gt;</a>            Basis;</div>
<div class="line">...</div>
<div class="line">std::vector&lt; Point4 &gt; V = { <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>{ 3, 4, 0, 2 }, <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>{ -2, -1, 5, -7 } };</div>
<div class="line">Point4 o( 1,4,2,-1 );</div>
<div class="line">std::vector&lt; Point4 &gt; X = { o, o + V[0], o + V[1], o + 3*V[0] - V[1], o - V[0] + V[1] };</div>
<div class="line">Basis B( X, Basis::Type::SHORTEST_ECHELON_REDUCED ); <span class="comment">// affine basis of dimension 2</span></div>
<div class="line">std::vector&lt; Point2 &gt;     proj_X;</div>
<div class="line"><span class="keyword">auto</span> d = B.projectPoints( proj_X, X ); <span class="comment">// proj_X contains the projection of X onto B</span></div>
<div class="line"><span class="comment">// d is the dilatation factor, hence proj_X/d corresponds to rational coordinates</span></div>
<div class="ttc" id="astructDGtal_1_1AffineBasis_html"><div class="ttname"><a href="structDGtal_1_1AffineBasis.html">DGtal::AffineBasis</a></div><div class="ttdoc">Aim: Utility class to determine the affine geometry of an input set of points. It provides exact resu...</div><div class="ttdef"><b>Definition</b> <a href="AffineBasis_8h_source.html#l00111">AffineBasis.h:112</a></div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="testAffineBasis_8cpp.html">testAffineBasis.cpp</a></dd></dl>
<h1 class="doxsection"><a class="anchor" id="dgtal_affgeom_sec4"></a>
Notes</h1>
<p>Several functions that works with lattice vectors use functions specialized to integer computations (defined in <span class="tt"><a class="el" href="IntegerMatrixFunctions_8h_source.html">math/linalg/IntegerMatrixFunctions.h</a></span>:</p>
<ul>
<li><a class="el" href="namespaceDGtal_1_1functions.html#ad54876a0a2fddc6d6ff16e3d16a1573a">functions::getDeterminantBareiss( TInternalNumber&amp; result,
  const SimpleMatrix&lt;TComponent, TN, TN&gt;&amp; matrix )</a></li>
<li><a class="el" href="namespaceDGtal_1_1functions.html#a573b60e94a05886ee1330af9ce188f88">functions::getDeterminantBareiss( TInternalNumber&amp; result,
  const std::vector&lt; std::vector&lt; TComponent &gt; &gt;&amp; matrix )</a></li>
<li><a class="el" href="namespaceDGtal_1_1functions.html#aad4913367298c2c3cb0d08057142af01">functions::computeLLLBasis( const std::vector&lt; std::vector&lt;
  TComponent&gt;&gt;&amp; B, TDouble delta )</a></li>
<li><a class="el" href="namespaceDGtal_1_1functions.html#a3802e14e412c8a814c59d2fc72f86366">functions::reduceBasisWithLLL( std::vector&lt; std::vector&lt;
  TComponent&gt;&gt;&amp; B, TDouble delta )</a></li>
<li><a class="el" href="namespaceDGtal_1_1functions.html#abae9d125fc12cc65370221cd961edf64">functions::computeOrthogonalLattice( std::vector&lt; TComponent &gt; N )</a></li>
<li><a class="el" href="namespaceDGtal_1_1functions.html#a0f5c845c246207a7e78ae5b5b5427abf">functions::shortenVectors( std::vector&lt; TComponent &gt;&amp; u, std::vector&lt; TComponent &gt;&amp; v )</a></li>
<li><a class="el" href="namespaceDGtal_1_1functions.html#a6d0dcd27a6ff2d2d7a7861958d7ae635">functions::shortenBasis( std::vector&lt; std::vector&lt; TComponent &gt; &gt;&amp; B )</a></li>
<li><a class="el" href="namespaceDGtal_1_1functions.html#ab51b001a5358f8a2d070751416278e62">functions::makePrimitive( std::vector&lt; TComponent &gt;&amp; N )</a></li>
<li><a class="el" href="namespaceDGtal_1_1functions.html#aea3c7aa302da86e7dac9b6eacafc22d2">functions::extendedGcd( TComponent&amp; x, TComponent&amp; y, TComponent a,TComponent b )</a></li>
<li><a class="el" href="namespaceDGtal_1_1functions.html#a14f0f7e61fc62ee6dccd7eac22f2f2d8">functions::extendedGcd( std::vector&lt;TComponent&gt; &amp;C, const std::vector&lt;TComponent&gt; &amp;A )</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="index.html">DGtal - Digital Geometry Tools and Algorithms Library.</a></li><li class="navelem"><a href="packageGeometry.html">Geometry package</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for DGtal by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
