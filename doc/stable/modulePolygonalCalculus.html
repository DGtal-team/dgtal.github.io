<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Discrete differential calculus on polygonal surfaces</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;1.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Discrete differential calculus on polygonal surfaces </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sectPolygonalCalculusIntro">Introduction</a></li>
<li class="level1"><a href="#sectPolygonalCalculus2">Per face operators</a><ul><li class="level2"><a href="#susub1">Basic operators</a><ul><li class="level3"><a href="#subderiv">Derivative operators</a></li>
<li class="level3"><a href="#subdflat">Flat/Sharp and Projection Operators</a></li>
</ul>
</li>
<li class="level2"><a href="#sublap">Inner Product and Laplace-Beltrami Operators</a></li>
<li class="level2"><a href="#sectcovOPL">Operators on directional fields and Connection Laplacian</a><ul><li class="level3"><a href="#sectcovOP">Covariant Gradient and Projection</a></li>
<li class="level3"><a href="#sectVL">Vector Laplacian</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#sectPolygonalCalculusGlo">Global calculus</a></li>
<li class="level1"><a href="#secLap">Example: Solving a Laplace problem</a><ul><li class="level2"><a href="#Global">Vector Calculus</a></li>
</ul>
</li>
<li class="level1"><a href="#sectMisc">Miscellaneous</a><ul><li class="level2"><a href="#sectPolygonalCalculusHP">Cache mechanisms and high-performance computing</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>David Coeurjolly, Baptiste GENEST</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.3</dd></dl>
<p>Part of package <a class="el" href="packageDEC.html">DEC package</a>.</p>
<p >In this documentation page, we detail the operators and tools for differential calculus computations on generic polygonal surfaces (<a class="el" href="classDGtal_1_1PolygonalCalculus.html" title="Implements differential operators on polygonal surfaces from .">PolygonalCalculus</a> class). Such polygonal surfaces could be generic meshes (with non-planar, non-convex faces), or an embeddeing of a digital surface.</p>
<p >The overall idea, compared to the <a class="el" href="moduleDECIntroduction.html">Discrete exterior calculus</a> approach, is to define per face operators which can be later combined to define global ones.</p>
<p >This module documents the operators defined in <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[43]</a>. An additional documentation page showcasing classical use cases of these operators for geometry processing on digital surfaces will be added.</p>
<dl class="section note"><dt>Note</dt><dd>The sign convention for the divergence and the Laplacian operator is opposite to the one of <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[43]</a>. This is to match the usual mathematical convention that the Laplacian (and the Laplacian-Beltrami) has negative eigenvalues (and is the sum of second derivatives in the cartesian grid). It also follows the formal adjointness of exterior derivative and opposite of divergence as relation \( \langle \mathrm{d} u, v \rangle = - \langle u,
\mathrm{div} v \rangle \). See also <a href="https://en.wikipedia.org/wiki/Laplace–Beltrami_operator">https://en.wikipedia.org/wiki/Laplace–Beltrami_operator</a></dd>
<dd>
All illustrations below have been obtained using the DGtal+<a href="https://polyscope.run">polyscope</a> examples <a class="el" href="dgtalCalculus_8cpp_source.html">dgtalCalculus.cpp</a>, <a class="el" href="dgtalCalculus-single_8cpp_source.html">dgtalCalculus-single.cpp</a> and <a class="el" href="dgtalCalculus-poisson_8cpp_source.html">dgtalCalculus-poisson.cpp</a>. To build these examples, enable the <code>BUILD_POLYSCOPE_EXAMPLES</code> variable (e.g. <code>cmake .. -DBUILD_POLYSCOPE_EXAMPLES=ON</code>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The implementation heavily relies on implicit operators with many Eigen based small matrice constructions, which has a huge overhead in Debug mode. Please consider to build the examples in Release (<em>e.g.</em> <code>CMAKE_BUILD_TYPE</code> variable) for high performance on large geometrical objects.</dd></dl>
<h1><a class="anchor" id="sectPolygonalCalculusIntro"></a>
Introduction</h1>
<p >The main idea of <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[43]</a> is to define discrete operators per face, which can be combined to obtain a global operator acting on meshes. For vertex valued scalar or vector fields, this class implements elementary differential operators (gradient, derivatives, sharp/flat, Laplace-Beltrami...) which can be combined to define more complex ones, or to be used when solving variational geometry processing problems on meshes or digital surfaces.</p>
<p >The operators detailed <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[43]</a> extend Mimetic Finite Difference and Virtual Element Method operators to arbitrary 3d polygons and discrete surfaces.</p>
<h1><a class="anchor" id="sectPolygonalCalculus2"></a>
Per face operators</h1>
<p >Let us consider a single (non-planar, non-convex) face example. Using</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>SurfMesh = SurfaceMesh&lt;Z3i::RealPoint,Z3i::RealVector&gt;;</div>
<div class="line"><span class="keyword">using namespace </span>Z3i;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//Vertices</span></div>
<div class="line">std::vector&lt;RealPoint&gt; positions={ {0,0,0},{20,0,0},{20,10,0},{10,8,5}, {0,15,1} };</div>
<div class="line"><span class="comment">//Single face</span></div>
<div class="line">std::vector&lt;std::vector&lt;size_t&gt;&gt; faces={{ 0,1,2,3,4 }};</div>
<div class="line"> </div>
<div class="line">mesh = SurfMesh(positions.begin(),positions.end(),faces.begin(),faces.end());</div>
<div class="line">  </div>
<div class="line">PolygonalCalculus&lt;SurfMesh&gt; calculus(mesh);</div>
</div><!-- fragment --><p >we obtain a <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> instance with a unique face and its associated <a class="el" href="classDGtal_1_1PolygonalCalculus.html" title="Implements differential operators on polygonal surfaces from .">PolygonalCalculus</a> object.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Example   </th><th class="markdownTableHeadNone">Example    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><div class="image">
<img src="face.png" alt=""/>
</div>
   </td><td class="markdownTableBodyNone"><div class="image">
<img src="face_rot.png" alt=""/>
</div>
   </td></tr>
</table>
<p >Let us add a scalar function on vertices. For instance, using Eigen syntax, we can use;</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="classDGtal_1_1PolygonalCalculus.html#af2b61b0f1effab17c35094e4c2ae29cd">PolygonalCalculus&lt;SurfMesh&gt;::Vector</a> phi(5); <span class="comment">//5 vertices</span></div>
<div class="line">phi &lt;&lt; 1.0, 2.0, 0.0, 5.0 ,1.5;</div>
<div class="ttc" id="aclassDGtal_1_1PolygonalCalculus_html_af2b61b0f1effab17c35094e4c2ae29cd"><div class="ttname"><a href="classDGtal_1_1PolygonalCalculus.html#af2b61b0f1effab17c35094e4c2ae29cd">DGtal::PolygonalCalculus::Vector</a></div><div class="ttdeci">LinAlg::DenseVector Vector</div><div class="ttdoc">Type of Vector.</div><div class="ttdef"><b>Definition:</b> <a href="PolygonalCalculus_8h_source.html#l00096">PolygonalCalculus.h:96</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>As the face is nonconvex / nonplanar, the vertex scalar quantity interpolation and the rendering in polyscope may be a bit odd.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Phi   </th><th class="markdownTableHeadNone">Interpolated phi    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><div class="image">
<img src="face_phi.png" alt=""/>
</div>
   </td><td class="markdownTableBodyNone"><div class="image">
<img src="face_phi_interp.png" alt=""/>
</div>
   </td></tr>
</table>
<p >When constructing a PolygonalCalculus&lt;SurfMesh&gt; instance, you can provide an external function to embed the vertex positions. By default, the positions of the surface mesh vertices (<em>positions</em> <em>in</em> the previous example) is used. If you want to update the embedding (could be useful on digital surfaces), the user can specify the mapping <code>(Face,Vertex)-&gt;RealPoint</code>. Please refer to <a class="el" href="classDGtal_1_1PolygonalCalculus.html#aa2edd0f5bb50ed4fe0ae8a6c8144a130">PolygonalCalculus&lt;SurfMesh&gt;::setEmbedder</a> for an example.</p>
<dl class="section note"><dt>Note</dt><dd>As the Face id is a parameter of the embedder, a given vertex can have different embeddings for all its incident faces.</dd></dl>
<h2><a class="anchor" id="susub1"></a>
Basic operators</h2>
<p >We first describe some standard per face operators. Note that for all extrinsic operators that require the vertex position in \(
\mathbb{R}^3 \), the embedder is used. For these quantities, vector/point are encoded as Eigen 3x1 vectors and collections of n points as an \( n\times 3\) matrix.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operator   </th><th class="markdownTableHeadNone">Output   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>calculus.X(f)</code>   </td><td class="markdownTableBodyNone">\( n_f\times 3\)   </td><td class="markdownTableBodyNone">positions of the face vertices (n_f points in \( \mathbb{R}^3 \))    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>calculus.E(f)</code>   </td><td class="markdownTableBodyNone">\( n_f\times 3\)   </td><td class="markdownTableBodyNone">the edge vectors of the face (n_f vectors in \( \mathbb{R}^3 \))    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>calculus.A(f)</code>   </td><td class="markdownTableBodyNone">\( n_f\times n_f\)   </td><td class="markdownTableBodyNone">averaging operator that averages some values on vertices to values on edges (vectors \((p_{i+1}-p_{i})\in\mathbb{R}^3\))    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>calculus.B(f)</code>   </td><td class="markdownTableBodyNone">\( n_f\times 3\)   </td><td class="markdownTableBodyNone">the edge mid-points of the face (n_f points in \( \mathbb{R}^3 \))    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>calculus.vectorArea(f)</code>   </td><td class="markdownTableBodyNone">\( n_f\) vector   </td><td class="markdownTableBodyNone">the corrected vector area of the face (uses the embedder)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>calculus.faceArea(f)</code>   </td><td class="markdownTableBodyNone">scalar   </td><td class="markdownTableBodyNone">the corrected face area (uses the embedder)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>calculus.faceNormalVector(f)</code>   </td><td class="markdownTableBodyNone">vector in \(\mathbb{R}^3\)   </td><td class="markdownTableBodyNone">the corrected (unitary) normal vector of the face (uses the embedder)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>calculus.faceNormalAsDGtalVector(f)</code>   </td><td class="markdownTableBodyNone">RealVector   </td><td class="markdownTableBodyNone">the corrected (unitary) normal vector of the face (uses the embedder)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>calculus.centroid(f)</code>   </td><td class="markdownTableBodyNone">vector in \(\mathbb{R}^3\)   </td><td class="markdownTableBodyNone">the corrected centroid of the face    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>calculus.centroidAsDGtalVector(f)</code>   </td><td class="markdownTableBodyNone">RealVector   </td><td class="markdownTableBodyNone">the corrected centroid of the face   </td></tr>
</table>
<h3><a class="anchor" id="subderiv"></a>
Derivative operators</h3>
<p >Derivative operators act on a scalar field defined on the vertex of the face.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operator   </th><th class="markdownTableHeadNone">Output   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>calculus.D(f)</code>   </td><td class="markdownTableBodyNone">\( n_f\times n_f\)   </td><td class="markdownTableBodyNone">derivative operator (d0 in DEC) mapping scalar values on vertices to values on edges (vertex scalars to a 1-form)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>calculus.gradient(f)</code>   </td><td class="markdownTableBodyNone">\( 3 \times n_f\)   </td><td class="markdownTableBodyNone">the gradient operator for vertex valued scalar functions of the face f    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>calculus.coGradient(f)</code>   </td><td class="markdownTableBodyNone">\( 3 \times n_f\)   </td><td class="markdownTableBodyNone">the co-gradient operator for vertex valued scalar functions of the face f   </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">A*phi   </th><th class="markdownTableHeadNone">D*phi (discrete 1-form)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><div class="image">
<img src="A_phi.png" alt=""/>
</div>
   </td><td class="markdownTableBodyNone"><div class="image">
<img src="D_phi.png" alt=""/>
</div>
   </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">gradient   </th><th class="markdownTableHeadNone">co-gradient   </th><th class="markdownTableHeadNone">corrected normal    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><div class="image">
<img src="gradient.png" alt=""/>
</div>
   </td><td class="markdownTableBodyNone"><div class="image">
<img src="cogradient.png" alt=""/>
</div>
   </td><td class="markdownTableBodyNone"><div class="image">
<img src="normal.png" alt=""/>
</div>
   </td></tr>
</table>
<h3><a class="anchor" id="subdflat"></a>
Flat/Sharp and Projection Operators</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operator   </th><th class="markdownTableHeadNone">Output   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>calculus.flat(f)</code>   </td><td class="markdownTableBodyNone">\( n_f\times 3\)   </td><td class="markdownTableBodyNone">Flat operator that maps an ambient vector to a local discrete 1-form    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>calculus.sharp(f)</code>   </td><td class="markdownTableBodyNone">\( 3 \times n_f\)   </td><td class="markdownTableBodyNone">Sharp operator that maps a discrete 1-form to an ambient vector    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>calculus.P(f)</code>   </td><td class="markdownTableBodyNone">\( n_f \times n_f\)   </td><td class="markdownTableBodyNone">Projection operator acting on a discrete 1-form that removes the associated non-tangential part of the vector reconstructed using the sharp operator   </td></tr>
</table>
<p >Discrete flat and sharp operators match with the DEC operators (see <a class="el" href="moduleDECIntroduction.html">Discrete exterior calculus</a>). For short, the flat operator embeds an ambient vector as a discrete 1-form (roughly values on the face edges) while the sharp operator pull-back a 1-form to reconstruct a vector in \(\mathbb{R}^3\). These operators are rank 2 and \( sharp_f flat_f s = s\) for any vector \(s\) in the face tangent plane, but \( flat_f sharp_f v = v\) for any vector v does not hold (due to rank deficiencies of the matrices). This is quantified by the projection operator \(P\) (see <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[43]</a> for structural lemmas, e.g. \( normal_f\cdot (sharp_f flat_f s)=0\quad \forall s\in$\mathbb{R}^3\)...).</p>
<p >For interested readers, <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[43]</a> has a discussion about the relationship between these operators and the classical DEC or FEM ones.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">a vector in \(\mathbb{R}^3\)   </th><th class="markdownTableHeadNone">a vector in \(\mathbb{R}^3\)   </th><th class="markdownTableHeadNone">Flat (1-form)   </th><th class="markdownTableHeadNone">Sharp of the flat (green vector)   </th><th class="markdownTableHeadNone">Sharp and normal vector (orange vector)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><div class="image">
<img src="face_vec.png" alt=""/>
</div>
   </td><td class="markdownTableBodyNone"><div class="image">
<img src="face_vec1.png" alt=""/>
</div>
   </td><td class="markdownTableBodyNone"><div class="image">
<img src="face_flat1form.png" alt=""/>
</div>
   </td><td class="markdownTableBodyNone"><div class="image">
<img src="face_sharp.png" alt=""/>
</div>
   </td><td class="markdownTableBodyNone"><div class="image">
<img src="face_sharpnorm.png" alt=""/>
</div>
   </td></tr>
</table>
<h2><a class="anchor" id="sublap"></a>
Inner Product and Laplace-Beltrami Operators</h2>
<p >For 0-forms, the inner product is the classical one induced by the \( l_2\) norm. For 1-forms, the inner product is given by <a class="el" href="classDGtal_1_1PolygonalCalculus.html#abc85984a071c6c8acec5871252b497c9">PolygonalCalculus&lt;SurfMesh&gt;::M()</a> (useful to define the Laplace-Beltrami operator).</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operator   </th><th class="markdownTableHeadNone">Output   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>calculus.M(f,lambda)</code>   </td><td class="markdownTableBodyNone">\( n_f\times n_f\)   </td><td class="markdownTableBodyNone">Inner product operator on discrete 1-forms operator (lambda is a regularization parameter, see <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[43]</a>)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>calculus.laplaceBeltrami(f,lambda)</code>   </td><td class="markdownTableBodyNone">\( n_f \times n_f\)   </td><td class="markdownTableBodyNone">Laplace-Beltrami operator \( D^tMD \) (lambda is a regularization parameter, see <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[43]</a>), the matrix is PSD   </td></tr>
</table>
<h2><a class="anchor" id="sectcovOPL"></a>
Operators on directional fields and Connection Laplacian</h2>
<p >In this section, we describe operators acting on directional fields (Levi-Civita connection, covariant gradient of a vector field &ndash;first-order derivative on VF&ndash;, and connection laplacian). Pleas refer to <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[43]</a>, section 5, for details.</p>
<p >As an example, these operators can be used to interpolate vector fields as illustrated in <a class="el" href="moduleVectorsInHeat.html">Vector Heat Method using discrete polygonal calculus</a>.</p>
<div class="image">
<img src="transport_to_face.png" alt=""/>
<div class="caption">
Transport of a vertex based vector field to face tangent plane</div></div>
<h3><a class="anchor" id="sectcovOP"></a>
Covariant Gradient and Projection</h3>
<p >Since these operators are themselves matrices they cannot be constructed in the same way as the others ( Operator builder Matrix * function restricted to face Vector ), you need the specify the local vector field as well, in the same format as in <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[43]</a>, i.e.  </p><p class="formulaDsp">
\begin{eqnarray*}
    u_{f} = [u_{v_1}^t \ldots u_{v_{nf}}^t]^t
\end{eqnarray*}
</p>
<p> where \(u_{v_i}\) are the intrinsic vectors at each adjacent vertex expressed in their own tangent basis.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operator   </th><th class="markdownTableHeadNone">Output   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>calculus.covariantGradient(f,uf)</code>   </td><td class="markdownTableBodyNone">\( 2\times 2\)   </td><td class="markdownTableBodyNone">Covariant Gradient defined for intrinsic vector valued 0-forms at face f    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>calculus.covariantProjection(f,uf)</code>   </td><td class="markdownTableBodyNone">\( n_f \times 2\)   </td><td class="markdownTableBodyNone">Covariant Projection operator defined for intrinsic vector valued 0-forms at face f   </td></tr>
</table>
<h3><a class="anchor" id="sectVL"></a>
Vector Laplacian</h3>
<p >Using the same format for vector fields as above, we can define a Vector Laplacian operator per face. </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operator   </th><th class="markdownTableHeadNone">Output   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>calculus.connectionLaplacian(f,lambda)</code>   </td><td class="markdownTableBodyNone">\( 2n_f\times 2n_f\)   </td><td class="markdownTableBodyNone">Vector Laplacian defined as the associated Matrix with the Dirichlet energy for vector valued 0-forms (lambda is a regularization parameter, see <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[43]</a>) at face f, PSD matrix   </td></tr>
</table>
<h1><a class="anchor" id="sectPolygonalCalculusGlo"></a>
Global calculus</h1>
<p >Given a scalar function defined on a generic surface mesh vertices, all previously mentioned operators can be applied to obtain consistent quantities on the overall mesh. For instance, from the <a class="el" href="dgtalCalculus_8cpp_source.html">dgtalCalculus.cpp</a> example using <a class="el" href="classDGtal_1_1Shortcuts.html" title="Aim: This class is used to simplify shape and surface creation. With it, you can create new shapes an...">Shortcuts</a> and <a class="el" href="classDGtal_1_1ShortcutsGeometry.html" title="Aim: This class is used to simplify shape and surface creation. With it, you can create new shapes an...">ShortcutsGeometry</a> to set up the surface:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Surface   </th><th class="markdownTableHeadNone">Phi   </th><th class="markdownTableHeadNone">Gradient   </th><th class="markdownTableHeadNone">Gradient+co-gradient    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><div class="image">
<img src="init.png" alt=""/>
</div>
   </td><td class="markdownTableBodyNone"><div class="image">
<img src="goursat_phi.png" alt=""/>
</div>
   </td><td class="markdownTableBodyNone"><div class="image">
<img src="goursat_grad.png" alt=""/>
</div>
   </td><td class="markdownTableBodyNone"><div class="image">
<img src="goursat_gradcograd.png" alt=""/>
</div>
   </td></tr>
</table>
<p >To solve some global PDE (e.g. Laplace/Poisson problems, see below), one can combine the local operators into a global one, gathering the contributions of each face.</p>
<p >For example, the <a class="el" href="classDGtal_1_1PolygonalCalculus.html#a9e371e89d60a14b67c560763133b342c">PolygonalCalculus&lt;SurfMesh&gt;::globalLaplaceBeltrami()</a> method outputs a global (sparse) Laplace-Beltrami operator which can later be used for diffusion.</p>
<p >You can also retrieve the global mass matrix via <a class="el" href="classDGtal_1_1PolygonalCalculus.html#ac73d777d276a934c23759a20a3b55838">PolygonalCalculus::globalLumpedMassMatrix</a>, which is used to define an inner product for 0-forms (i.e. scalar functions), as well as its inverse <a class="el" href="classDGtal_1_1PolygonalCalculus.html#a6f6bdfce2e62d44c05af3ef5c864d2c2">PolygonalCalculus::globalInverseLumpedMassMatrix()</a>, generally used when one solves a weak problem and wishes to get a pointwise per-vertex solution.</p>
<h1><a class="anchor" id="secLap"></a>
Example: Solving a Laplace problem</h1>
<p >Let suppose we want to solve the following Laplace problem for data interpolation:  </p><p class="formulaDsp">
\begin{eqnarray*}
        \Delta_\Omega u&amp; = 0  \\ 
        &amp; s.t. u = g \text{ on } \partial\Omega
\end{eqnarray*}
</p>
<p >We want to solve that problem on a polygonal mesh \(\Omega\) (digital surface here) with a boundary and some scalar values attached to boundary vertices, or sampled on the object surface.</p>
<p >Furthermore, the discrete version of the Laplace problem boils down to a simple linear problem using on the discrete Laplace-Beltrami sparse matrix.</p>
<p >We also use class <a class="el" href="classDGtal_1_1DirichletConditions.html" title="Aim: A helper class to solve a system with Dirichlet boundary conditions.">DirichletConditions</a> to enforce Dirichlet boundary conditions on the system.</p>
<p >The overall code is: </p><div class="fragment"><div class="line">  <span class="keyword">typedef</span> PolygonalCalculus&lt;SH3::RealPoint,SH3::RealVector&gt; PolyDEC;</div>
<div class="line">  <span class="keyword">typedef</span> DirichletConditions&lt; EigenLinearAlgebraBackend &gt;  DC;</div>
<div class="line">  PolyDEC calculus(surfmesh);</div>
<div class="line">  PolyDEC::SparseMatrix L = calculus.globalLaplaceBeltrami();</div>
<div class="line">  PolyDEC::Form g = calculus.form0();</div>
<div class="line">  DC::IntegerVector b = DC::IntegerVector::Zero( g.rows() );</div>
<div class="line">  </div>
<div class="line">  <span class="comment">//We set values on the boundary</span></div>
<div class="line">  <span class="keyword">auto</span> boundaryEdges = surfmesh.computeManifoldBoundaryEdges();</div>
<div class="line">  std::cout&lt;&lt; <span class="stringliteral">&quot;Number of boundary edges= &quot;</span>&lt;&lt;boundaryEdges.size()&lt;&lt;std::endl;</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">auto</span> pihVertex=[&amp;](<span class="keyword">const</span> <a class="code hl_typedef" href="structDGtal_1_1SurfaceMesh.html#ac8fba76a794fd9912af755f620606cf0">SurfMesh::Vertex</a> &amp;v){<span class="keywordflow">return</span>  cos(scale*(surfmesh.position(v)[0]))*(scale*surfmesh.position(v)[1]);};</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;e: boundaryEdges)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">auto</span> adjVertices = surfmesh.edgeVertices(e);</div>
<div class="line">    g(adjVertices.first)  = pihVertex(adjVertices.first);</div>
<div class="line">    g(adjVertices.second) = pihVertex(adjVertices.second);</div>
<div class="line">    b(adjVertices.first)  = 1;</div>
<div class="line">    b(adjVertices.second) = 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Solve Δu=0 with g as boundary conditions</span></div>
<div class="line">  PolyDEC::Solver solver;</div>
<div class="line">  PolyDEC::SparseMatrix L_dirichlet = DC::dirichletOperator( L, b );</div>
<div class="line">  solver.compute( L_dirichlet );</div>
<div class="line">  ASSERT(solver.info()==Eigen::Success);</div>
<div class="line">  PolyDEC::Form g_dirichlet = DC::dirichletVector( L, g, b, g );</div>
<div class="line">  PolyDEC::Form x_dirichlet = solver.solve( g_dirichlet );</div>
<div class="line">  PolyDEC::Form u = DC::dirichletSolution( x_dirichlet, b, g );</div>
<div class="ttc" id="astructDGtal_1_1SurfaceMesh_html_ac8fba76a794fd9912af755f620606cf0"><div class="ttname"><a href="structDGtal_1_1SurfaceMesh.html#ac8fba76a794fd9912af755f620606cf0">DGtal::SurfaceMesh::Vertex</a></div><div class="ttdeci">Index Vertex</div><div class="ttdef"><b>Definition:</b> <a href="SurfaceMesh_8h_source.html#l00108">SurfaceMesh.h:108</a></div></div>
</div><!-- fragment --><p >Leading to the following results (see <a class="el" href="dgtalCalculus-poisson_8cpp_source.html">dgtalCalculus-poisson.cpp</a>):</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Surface   </th><th class="markdownTableHeadNone">Boundary condition \( g\)   </th><th class="markdownTableHeadNone">Solution \( u \)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><div class="image">
<img src="poisson-surf.png" alt=""/>
</div>
   </td><td class="markdownTableBodyNone"><div class="image">
<img src="poisson-g.png" alt=""/>
</div>
   </td><td class="markdownTableBodyNone"><div class="image">
<img src="poisson-u.png" alt=""/>
</div>
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><div class="image">
<img src="bunny-init.png" alt=""/>
</div>
   </td><td class="markdownTableBodyNone"><div class="image">
<img src="bunny-g.png" alt=""/>
</div>
   </td><td class="markdownTableBodyNone"><div class="image">
<img src="bunny-u.png" alt=""/>
</div>
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><div class="image">
<img src="cat-init.png" alt=""/>
</div>
   </td><td class="markdownTableBodyNone"><div class="image">
<img src="cat-g.png" alt=""/>
</div>
   </td><td class="markdownTableBodyNone"><div class="image">
<img src="cat-u.png" alt=""/>
</div>
   </td></tr>
</table>
<h2><a class="anchor" id="Global"></a>
Vector Calculus</h2>
<p >Global Vector Laplace/Poisson problems can also be solved by the same way, using instead <a class="el" href="classDGtal_1_1PolygonalCalculus.html#af370c9e0153fd851a46ed930d9179ee2">PolygonalCalculus&lt;SurfMesh&gt;::globalConnectionLaplace()</a> and <a class="el" href="classDGtal_1_1PolygonalCalculus.html#a8d87e96e74d93e9e61f5686aa62e3c6a">PolygonalCalculus&lt;SurfMesh&gt;::doubledGlobalLumpedMassMatrix()</a>. One can find examples of such use in the <a class="el" href="classDGtal_1_1VectorsInHeat.html">VectorsInHeat</a> class.</p>
<h1><a class="anchor" id="sectMisc"></a>
Miscellaneous</h1>
<h2><a class="anchor" id="sectPolygonalCalculusHP"></a>
Cache mechanisms and high-performance computing</h2>
<p >The <a class="el" href="classDGtal_1_1PolygonalCalculus.html" title="Implements differential operators on polygonal surfaces from .">PolygonalCalculus</a> class has two cache mechanisms:</p>
<ul>
<li>An external cache strategy to store a given operator into a compact container. Typical use case is when the user wants to precompute a given operator, store it and efficiently reuse it while iterating over the faces. We detail this construction below.</li>
<li>The second one is a global internal cache strategy that will store <b>all</b> per face operators on the fly. In that case, each operator returning a DenseMatrix is stored in a cache the first time the <code>calculus.operator(f)</code> is called. Typical use case is when the user wants to use many times a large set of different operators. To enable this strategy, you can use the <code>calculus.enableInternalGlobalCache()</code>, or from the last parameter of the class constructor (boolean set to true). E.g. <div class="fragment"><div class="line">PolygonalCalculus&lt;SH3::RealPoint,SH3::RealVector&gt; calculus(surfmesh,<span class="keyword">true</span>);  <span class="comment">//global internal cache enabled.</span></div>
</div><!-- fragment --> By default, this behavior is disabled as it is memory expensive (all operators are explicitly stored when used for the first time), and may not have a huge running time impact for some applications. An example is given in the <a class="el" href="dgtalCalculus-bunny_8cpp_source.html">dgtalCalculus-bunny.cpp</a>. Once enabled, the class API remains the same, everything is transperent to the user.</li>
</ul>
<p >We describe here the first external cache strategy. For the sake of readability, each operator has been implemented implicitly. For example, the <em>M</em> <em>operator</em> per face is given by </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="testHeatLaplace_8cpp.html#ac5e355806c1c5ae35fbd16c24003bba3">DenseMatrix</a> M(<span class="keyword">const</span> <a class="code hl_typedef" href="testTriangulatedSurface_8cpp.html#aa7e89e659ae870a9963bb6109a53da62">Face</a> f, <span class="keyword">const</span> <span class="keywordtype">double</span> lambda=1.0)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keyword">auto</span> Uf=sharp(f);</div>
<div class="line">  <span class="keyword">auto</span> Pf=P(f);</div>
<div class="line">  <span class="keywordflow">return</span> faceArea(f) * Uf.transpose()*Uf + lambda * Pf.transpose()*Pf;</div>
<div class="line">}</div>
<div class="ttc" id="atestHeatLaplace_8cpp_html_ac5e355806c1c5ae35fbd16c24003bba3"><div class="ttname"><a href="testHeatLaplace_8cpp.html#ac5e355806c1c5ae35fbd16c24003bba3">DenseMatrix</a></div><div class="ttdeci">EigenLinearAlgebraBackend::DenseMatrix DenseMatrix</div><div class="ttdef"><b>Definition:</b> <a href="testHeatLaplace_8cpp_source.html#l00051">testHeatLaplace.cpp:51</a></div></div>
<div class="ttc" id="atestTriangulatedSurface_8cpp_html_aa7e89e659ae870a9963bb6109a53da62"><div class="ttname"><a href="testTriangulatedSurface_8cpp.html#aa7e89e659ae870a9963bb6109a53da62">Face</a></div><div class="ttdeci">TriMesh::Face Face</div><div class="ttdef"><b>Definition:</b> <a href="testTriangulatedSurface_8cpp_source.html#l00056">testTriangulatedSurface.cpp:56</a></div></div>
</div><!-- fragment --><p> which could be time consuming as the internal operators may be computed several times.</p>
<p >For high performance computations, we provide a generic cache mechanism to explicitly store all per face operators of a surface mesh (stored in a random access container).</p>
<p >A typical usage is </p><div class="fragment"><div class="line"><span class="keyword">auto</span> cacheSharp    = getOperatorCacheMatrix( [&amp;](<a class="code hl_typedef" href="testTriangulatedSurface_8cpp.html#aa7e89e659ae870a9963bb6109a53da62">Face</a> f){ <span class="keywordflow">return</span>(calculus.sharp(f);} );</div>
<div class="line"><span class="keyword">auto</span> cachefaceArea = getOperatorCacheMatrix( [&amp;](<a class="code hl_typedef" href="testTriangulatedSurface_8cpp.html#aa7e89e659ae870a9963bb6109a53da62">Face</a> f){ <span class="keywordflow">return</span>(calculus.faceArea(f);} );</div>
<div class="line"><span class="keyword">auto</span> cacheP        = getOperatorCacheMatrix( [&amp;](<a class="code hl_typedef" href="testTriangulatedSurface_8cpp.html#aa7e89e659ae870a9963bb6109a53da62">Face</a> f){ <span class="keywordflow">return</span>(calculus.P(f);} );</div>
</div><!-- fragment --><p >Then, cached operators can be accessed and combined: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> Mf =   cachefaceArea[f] * cacheU[f].transpose()*cacheU[f] + lambda * cacheP[f].transpose() * cacheP[f];</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Nov 27 2022 15:16:00 for DGtal by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
