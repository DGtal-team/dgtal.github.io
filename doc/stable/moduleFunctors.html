<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Using functions, functors and lambdas in DGtal</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Using functions, functors and lambdas in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#functors_of_DGtal">The functors in DGtal</a></li>
<li class="level1"><a href="#functorholder">The FunctorHolder class</a><ul><li class="level2"><a href="#functorholder_intro">Introduction and preliminary example</a></li>
<li class="level2"><a href="#functorholder_aim">Aim</a></li>
<li class="level2"><a href="#functorholder_why">Why this class ?</a></li>
<li class="level2"><a href="#functorholder_derivates">Which derivative class of FunctorHolder should I use ?</a></li>
</ul>
</li>
<li class="level1"><a href="#holding_an_object">Holding a callable object</a><ul><li class="level2"><a href="#holding_a_function">Holding a function</a></li>
<li class="level2"><a href="#holding_a_functor">Holding a functor</a></li>
<li class="level2"><a href="#holding_a_lambda">Holding a lambda</a></li>
<li class="level2"><a href="#holding_something_else">Holding something else</a></li>
<li class="level2"><a href="#held_object_lifetime">Held object lifetime</a></li>
<li class="level2"><a href="#auto_holdfunctor">Why using the auto keyword ?</a></li>
</ul>
</li>
<li class="level1"><a href="#calling_the_held_object">Calling the held object</a><ul><li class="level2"><a href="#parameters_return_types">What about the parameters and return value types ?</a></li>
<li class="level2"><a href="#functor_arity">What about the callable object arity ?</a></li>
</ul>
</li>
<li class="level1"><a href="#copy_and_assignment">Copying and assigning a FunctorHolder</a></li>
<li class="level1"><a href="#type_of_functorholder">The type of a FunctorHolder instance</a><ul><li class="level2"><a href="#storing_functorholder">Storing a FunctorHolder</a></li>
<li class="level2"><a href="#passing_functorholder">Passing a FunctorHolder as a parameter</a></li>
<li class="level2"><a href="#returning_functorholder">Returning a FunctorHolder</a></li>
<li class="level2"><a href="#creating_a_helper">Creating a helper</a></li>
</ul>
</li>
<li class="level1"><a href="#marking_cunaryfunctor">Making a C(Unary)Functor model based on FunctorHolder</a><ul><li class="level2"><a href="#tutorial_pointfunctorholder">A simple CUnaryFunctor model with additional typedef</a><ul><li class="level3"><a href="#pointfunctorholder_core_skeleton">The core skeleton</a></li>
<li class="level3"><a href="#pointfunctorholder_helper">The helper (factory)</a></li>
<li class="level3"><a href="#pointfunctorholder_usage">First test</a></li>
<li class="level3"><a href="#pointfunctorholder_advanced_helper">Auto-deducing the return type of the functor</a></li>
<li class="level3"><a href="#pointfunctorholder_advanced_constructor">Perfect forwarding in the constructor</a></li>
<li class="level3"><a href="#pointfunctorholder_documentation">Documenting</a></li>
</ul>
</li>
<li class="level2"><a href="#tutorial_functorconstimage">A more complex example with variable functor arity</a><ul><li class="level3"><a href="#functorconstimage_core_skeleton">The core skeleton</a></li>
<li class="level3"><a href="#functorconstimage_helper">The helper (factory)</a></li>
<li class="level3"><a href="#functorconstimage_evaluation">The evaluation operator</a></li>
<li class="level3"><a href="#functorconstimage_advanced_helper">Auto-deducing the return type of the functor</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Roland Denis</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<p>Part of the <a class="el" href="packageBase.html">Base package</a>.</p>
<p>This part of the manual lists some of the available functors in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> and also describes how to use functions, functors, lambdas, or any callable objects as <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> compatible functors.</p>
<h1><a class="anchor" id="functors_of_DGtal"></a>
The functors in DGtal</h1>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceDGtal_1_1functors.html" title="functors namespace gathers all DGtal functors.">functors</a></dd></dl>
<h1><a class="anchor" id="functorholder"></a>
The FunctorHolder class</h1>
<h2><a class="anchor" id="functorholder_intro"></a>
Introduction and preliminary example</h2>
<p>Starting with C++11, we can define functions directly in a code block, just before using it, using <a href="https://en.cppreference.com/w/cpp/language/lambda"><code>lambdas</code></a>. For small and single-used functions, it may allow to write clearer code by keeping all important informations together and avoids defining the function out of context.</p>
<p>However, lambdas cannot be directly used in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> since many functors must comply with concepts that depends on its usage. These concepts may require to define some typedef and always require that the model is assignable. Since lambdas don't meet any of these constraints, it forces the coder to define a specific class.</p>
<p>Starting with <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> 1.0, <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> and its derivatives (see <a class="el" href="moduleFunctors.html#functorholder_derivates">Which derivative class of FunctorHolder should I use ?</a>) are available and allow to use lambdas (and other callable object) in an easier way.</p>
<p>First, store your lambda in an holder that matches the targeted usage: </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> mickey = functors::holdPointFunctor&lt;Z2i::Point&gt;(</div>
<div class="line">    [] ( <a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a> <span class="keyword">const</span>&amp; pt ) {</div>
<div class="line">      <span class="keywordflow">return</span></div>
<div class="line">           (pt - <a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(0, -5)).norm() &gt; 3</div>
<div class="line">        &amp;&amp; (    pt.norm() &lt;= 20</div>
<div class="line">             || (pt - <a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(-18,21)).norm() &lt;= 10</div>
<div class="line">             || (pt - <a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>( 18,21)).norm() &lt;= 10</div>
<div class="line">           );</div>
<div class="line">    });</div>
</div><!-- fragment --><p>The usage of the <code>auto</code> keyword is here mandatory and the reason why is explained in <a class="el" href="moduleFunctors.html#auto_holdfunctor">Why using the auto keyword ?</a>.</p>
<p>Then, use the created functor with you favorite algorithm: </p><div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal_1_1Z2i.html#aca523bebdae58eb19385aaefffff8bc5">Z2i::Domain</a> <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>( <a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(-35,-25), <a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(35, 35) );</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using</span> DTL2 = DistanceTransformation&lt;<a class="code" href="namespaceDGtal_1_1Z2i.html#a9b96ab8175cf9c54b1f451858ccd46a4">Z2i::Space</a>, decltype(mickey), <a class="code" href="namespaceDGtal_1_1Z2i.html#a5334b5612687982f0154e4ee8f5dd93d">Z2i::L2Metric</a>&gt;;</div>
<div class="line"> </div>
<div class="line">  DTL2 dt( <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>, mickey, <a class="code" href="namespaceDGtal_1_1Z2i.html#afa16730fe413692cdb474b45d4fff388">Z2i::l2Metric</a> );</div>
</div><!-- fragment --><p>The <code>decltype</code> specifier is used to deduce the type of the functor, see <a class="el" href="moduleFunctors.html#passing_functorholder">Passing a FunctorHolder as a parameter</a>.</p>
<p>Finally, export the result: </p><div class="fragment"><div class="line">  <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">DTL2::Value</a> maxDT = *boost::first_max_element( dt.constRange().begin(), dt.constRange().end() );</div>
<div class="line">  <span class="keyword">using</span> HueTwice = HueShadeColorMap&lt;DTL2::Value, 1&gt;;</div>
<div class="line"> </div>
<div class="line">  Board2D aBoard;</div>
<div class="line">  aBoard &lt;&lt; <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>;</div>
<div class="line">  Display2DFactory::drawImage&lt;HueTwice&gt;(aBoard, dt, 0, maxDT);</div>
<div class="line">  aBoard.saveEPS(<span class="stringliteral">&quot;examplePointFunctorHolder.eps&quot;</span>);</div>
</div><!-- fragment --><div class="image">
<img src="examplePointFunctorHolder.png" alt=""/>
<div class="caption">
Distance transformation of Mickey</div></div>
<p>  It has never been so easy to calculate the distance map to Mickey!</p>
<h2><a class="anchor" id="functorholder_aim"></a>
Aim</h2>
<p>Given any type of callable object (function, functor and lambda) passed by value, reference or pointer, <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> stores it in the most appropriate way so that the returned object is a model of <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> functor concept (<a class="el" href="structDGtal_1_1concepts_1_1CUnaryFunctor.html">concepts::CUnaryFunctor</a> so far), and especially the <a class="el" href="structboost_1_1Assignable.html">boost::Assignable</a> concept.</p>
<p>More precisely, the storage mode depends on the lifetime of the given object, deduced from its passing mode:</p>
<ul>
<li>if the given object is passed by left-value reference (long lifetime), it will be stored as a reference (using <a href="https://en.cppreference.com/w/cpp/utility/functional/reference_wrapper"><code>std::reference_wrapper</code></a>).</li>
<li>otherwise (short lifetime, like right-value references), it will be moved to a dynamically allocated memory place (<a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a>) so that the object lifetime matches the <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html" title="Aim: hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model.">FunctorHolder</a> lifetime.</li>
</ul>
<p>In both case, the returned object is copy/move constructible and copy/move assignable so that it can be used as a functor in all <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> library.</p>
<dl class="section warning"><dt>Warning</dt><dd>This class is not meant to be directly constructed by the user. As explained below, you should use instead the <a class="el" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a> helper that will choose the more appropriate storage type depending on the given callable object.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>It is important to not explicitly specify the given object type so that it's real lifetime can be deduced using a <a href="https://en.cppreference.com/w/cpp/language/reference#Forwarding_references">universal reference</a>. However, you can transfer ownership of the object to <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html" title="Aim: hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model.">FunctorHolder</a> by moving it using <a href="https://en.cppreference.com/w/cpp/utility/move"><code>std::move</code></a>. As a consequence, the type of the returned <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html" title="Aim: hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model.">FunctorHolder</a> cannot be guessed easily and the use of the <a href="https://en.cppreference.com/w/cpp/language/auto"><code>auto</code></a> keyword is thus mandatory.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Almost all snippets used in the following explanations come from the example file <a class="el" href="exampleFunctorHolder_8cpp.html">exampleFunctorHolder.cpp</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html" title="Aim: hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model.">FunctorHolder</a>, <a class="el" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d" title="Hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model.">holdFunctor</a></dd></dl>
<h2><a class="anchor" id="functorholder_why"></a>
Why this class ?</h2>
<p>The first motivation is to be able to use lambdas as functors in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> but the problem is that all functor's concepts inherits from <a class="el" href="structboost_1_1Assignable.html">boost::Assignable</a> and a lambda is unfortunately not assignable.</p>
<p>A solution would be to rely on <a href="https://en.cppreference.com/w/cpp/utility/functional/function"><code>std::function</code></a> but this solution has two main issues:</p><ul>
<li>it refers to the callable object by using a generic pointer, like <code>double (*) (int)</code> for a function returning a <code>double</code> from an <code>int</code>. This implies that the compiler cannot inline the implementation of the callable object (since a pointer like <code>double (*) (int)</code> can point to any compatible function) and thus cannot apply some important optimizations like vectorizing the computation.</li>
<li>it uses polymorphism to hide the actual callable object type stored underneath. This implies an extra indirection when calling the underlying object.</li>
</ul>
<p>On the other hand, <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> also relies on a pointer in order to make any callable object assignable, but the pointer type is directly related to the callable object type. Therefore, even if the compiler doesn't know the address during the compilation process, since he actually know the type of the callable object, he also know its implementation and can then inline it and optimize it.</p>
<dl class="section note"><dt>Note</dt><dd>A pointer to a function has a generic type (like <code>double (*) (int)</code>) and thus prevents the compiler to inline it (even when using <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>). To avoid this, you can wrap the function into a lambda before storing it into a <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>, like explained in the section below about <a class="el" href="moduleFunctors.html#holding_a_function">Holding a function</a> .</dd></dl>
<p>For example, on a modern processor and if your functor only adds values, you can have a performance ratio of about 26.7 between using a <a href="https://en.cppreference.com/w/cpp/utility/functional/function"><code>std::function</code></a> and <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>. Even with more complex operations, there is still a significant performance penalty to use <a href="https://en.cppreference.com/w/cpp/utility/functional/function"><code>std::function</code></a> over <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>.</p>
<h2><a class="anchor" id="functorholder_derivates"></a>
Which derivative class of FunctorHolder should I use ?</h2>
<p>Depending on the concept you want to fullfil, here are the available classes that rely on <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>:</p><ul>
<li>for a <a class="el" href="structDGtal_1_1concepts_1_1CUnaryFunctor.html">concepts::CUnaryFunctor</a> model, use <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>.</li>
<li>for a <a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html">concepts::CPointFunctor</a> model, use <a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html">PointFunctorHolder</a>.</li>
<li>for a <a class="el" href="structDGtal_1_1concepts_1_1CConstImage.html">concepts::CConstImage</a> model, use <a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html">ConstImageFunctorHolder</a>.</li>
</ul>
<h1><a class="anchor" id="holding_an_object"></a>
Holding a callable object</h1>
<p>As warned before, <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> is not meant to be directly constructed but instead through the helper (factory) <a class="el" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>. You can hold any type of callable object: a function, a functor, a lambda function,...</p>
<h2><a class="anchor" id="holding_a_function"></a>
Holding a function</h2>
<p>If you want to refer to an existing function, you can directly pass its name to <a class="el" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>: </p><div class="fragment"><div class="line"><span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="exampleFunctorHolder_8cpp.html#a65616cde20c32b627a9256ee9a2177a9">signed_dist_to_unit_circle</a>(<a class="code" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a> <span class="keyword">const</span>&amp; pt)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> pt.<a class="code" href="classDGtal_1_1PointVector.html#a621809d6682ec859fd761f60b23ba2b7">norm</a>() - 1.;</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="keyword">auto</span> fn = <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a>( <a class="code" href="exampleFunctorHolder_8cpp.html#a65616cde20c32b627a9256ee9a2177a9">signed_dist_to_unit_circle</a> );</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> = <a class="code" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1, 1) ) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> If the function is templated, you must specify the needed templates: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Po<span class="keywordtype">int</span>&gt;</div>
<div class="line"><span class="keyword">inline</span></div>
<div class="line"><span class="keyword">typename</span> Point::Component</div>
<div class="line"><a class="code" href="exampleFunctorHolder_8cpp.html#a8c41fc3212565f9503f1eb15abca1eea">templated_signed_dist_to_unit_circle</a>(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> <span class="keyword">const</span>&amp; pt)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> pt.norm() - <span class="keyword">typename</span> Point::Component(1);</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="keyword">using</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> = <a class="code" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a>( templated_signed_dist_to_unit_circle&lt;Point&gt; );</div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1, 1) ) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> In both cases, the function will be passed by reference. You can also explicitly pass it by pointer using the <code>&amp;</code> keyword.</p>
<dl class="section warning"><dt>Warning</dt><dd>However, please note that passing a function by reference or by pointer will prevent the compiler from inlining it (you may have a chance by reference).</dd>
<dd>
To avoid this possible performance penalty, you should pass the function through a lambda: <div class="fragment"><div class="line">    <span class="keyword">using</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> = <a class="code" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a>( [] (<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> <span class="keyword">const</span>&amp; pt) { <span class="keywordflow">return</span> <a class="code" href="exampleFunctorHolder_8cpp.html#a65616cde20c32b627a9256ee9a2177a9">signed_dist_to_unit_circle</a>(pt); } );</div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1, 1) ) &lt;&lt; std::endl;</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="keyword">using</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> = <a class="code" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a>( [] (<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> <span class="keyword">const</span>&amp; pt) { <span class="keywordflow">return</span> <a class="code" href="exampleFunctorHolder_8cpp.html#a8c41fc3212565f9503f1eb15abca1eea">templated_signed_dist_to_unit_circle</a>(pt); } );</div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1, 1) ) &lt;&lt; std::endl;</div>
</div><!-- fragment -->thus giving the compiler free hands to inline it.</dd>
<dd>
Even better: if you have enable C++14 support, you can use generic lambdas so that you don't have to specify any type, even for templated functions (the type is resolved at the effective call): <div class="fragment"><div class="line">    <span class="keyword">auto</span> fn = <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a>( [] (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; pt) { <span class="keywordflow">return</span> <a class="code" href="exampleFunctorHolder_8cpp.html#a8c41fc3212565f9503f1eb15abca1eea">templated_signed_dist_to_unit_circle</a>(pt); } );</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> = <a class="code" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1, 1) ) &lt;&lt; std::endl; <span class="comment">// &lt;- template parameter is resolved to Point</span></div>
</div><!-- fragment -->Enjoy the genericity !</dd></dl>
<h2><a class="anchor" id="holding_a_functor"></a>
Holding a functor</h2>
<p>If you want to refer to a functor, you can pass it by (left-value) reference: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Po<span class="keywordtype">int</span>&gt;</div>
<div class="line"><span class="keyword">struct </span>SignedDistToCircle</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using</span> Real = <span class="keyword">typename</span> Point::Component;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> center;</div>
<div class="line">  Real  radius;</div>
<div class="line"> </div>
<div class="line">  SignedDistToCircle(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> <span class="keyword">const</span>&amp; pt, Real r)</div>
<div class="line">    : center(pt), radius(r)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">inline</span></div>
<div class="line">  Real operator() (<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> <span class="keyword">const</span>&amp; pt)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">return</span> (pt - center).norm() - radius;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="keyword">using</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> = <a class="code" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    SignedDistToCircle&lt;Point&gt; dist(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0, 1), 2);</div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a>( dist );</div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1, 1) ) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> You wan also inline the construction of the functor directly in the <a class="el" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a> call: </p><div class="fragment"><div class="line">    <span class="keyword">using</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> = <a class="code" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a>( SignedDistToCircle&lt;Point&gt;( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0, 1), 2 ) );</div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1, 1) ) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>or, to increase code readability, you can first construct the functor and then transfer its ownership to <a class="el" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a> by using the move semantic: </p><div class="fragment"><div class="line">    <span class="keyword">using</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> = <a class="code" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    SignedDistToCircle&lt;Point&gt; dist(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0, 1), 2);</div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a>( std::move(dist) );</div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1, 1) ) &lt;&lt; std::endl;</div>
</div><!-- fragment --> <dl class="section remark"><dt>Remarks</dt><dd>Moving the functor to <a class="el" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a> is also a way to increase its lifetime, for example when returning a <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> that depends on a local functor. See also the section <a class="el" href="moduleFunctors.html#held_object_lifetime">Held object lifetime</a>.</dd></dl>
<h2><a class="anchor" id="holding_a_lambda"></a>
Holding a lambda</h2>
<p>Without surprise, holding a lambda works the same way: </p><div class="fragment"><div class="line">    <span class="keyword">using</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> = <a class="code" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> center(0, 1);</div>
<div class="line">    <span class="keywordtype">double</span> radius = 2;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a>(</div>
<div class="line">        [&amp;center, &amp;radius] (<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> <span class="keyword">const</span>&amp; pt) {</div>
<div class="line">            <span class="keywordflow">return</span> (pt - center).norm() - radius;</div>
<div class="line">        }</div>
<div class="line">    );</div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1, 1) ) &lt;&lt; std::endl;</div>
</div><!-- fragment --> <h2><a class="anchor" id="holding_something_else"></a>
Holding something else</h2>
<p><a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> should be able to hold any callable object. However, as warned before, if you are concerned by performance, you should avoid holding a function by reference or pointer or, even worse, holding a <a href="https://en.cppreference.com/w/cpp/utility/functional/function"><code>std::function</code></a> that is more or less a pointer with an additional cost due to the polymorphism.</p>
<h2><a class="anchor" id="held_object_lifetime"></a>
Held object lifetime</h2>
<p>When passing a functor to <a class="el" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a> by lvalue reference (ie the functor has a name), the functor lifetime must exceed the <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> lifetime.</p>
<p>Otherwise, consider constructing the functor directly during the <a class="el" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a> call or transfer its ownership by using the move semantic. See the examples in section <a class="el" href="moduleFunctors.html#holding_a_functor">Holding a functor</a>.</p>
<h2><a class="anchor" id="auto_holdfunctor"></a>
Why using the auto keyword ?</h2>
<p>Since the exact storage type used in <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> is choosen by <a class="el" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a> depending on the passing mode of the callable object, it is not easily possible to known the template parameters of <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>.</p>
<p>Thus, it is recommended to use the <a href="https://en.cppreference.com/w/cpp/language/auto"><code>auto</code></a> keyword as the type placeholder for any instance of <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>.</p>
<p>See also the section about <a class="el" href="moduleFunctors.html#storing_functorholder">Storing a FunctorHolder</a>.</p>
<h1><a class="anchor" id="calling_the_held_object"></a>
Calling the held object</h1>
<p>Calling the held object is done naturally by using the <code>operator()</code>, like in the previous examples: </p><div class="fragment"><div class="line">    <span class="keyword">using</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> = <a class="code" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a>( SignedDistToCircle&lt;Point&gt;( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0, 1), 2 ) );</div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1, 1) ) &lt;&lt; std::endl;</div>
</div><!-- fragment --> <h2><a class="anchor" id="parameters_return_types"></a>
What about the parameters and return value types ?</h2>
<p>You may have notice that we never have to specify the types of the parameters used when calling the held object, neither the type of the returned object.</p>
<p>The trick behind this is the use of variadic templates and perfect forwarding so that the call of the held object is transparent for <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>. The returned value type is also automatically deduced.</p>
<h2><a class="anchor" id="functor_arity"></a>
What about the callable object arity ?</h2>
<p>The use of variadic templates for the <code>operator()</code> allows holding a callable object of any arity: </p><div class="fragment"><div class="line">    <span class="keyword">using</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> = <a class="code" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> dist = [] (<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> <span class="keyword">const</span>&amp; pt, <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> <span class="keyword">const</span>&amp; center, <span class="keywordtype">double</span> radius)</div>
<div class="line">      {</div>
<div class="line">        <span class="keywordflow">return</span> (pt - center).<a class="code" href="classDGtal_1_1PointVector.html#a621809d6682ec859fd761f60b23ba2b7">norm</a>() - radius;</div>
<div class="line">      };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a>( dist );</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1, 1), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0, 1), 2 ) &lt;&lt; std::endl;</div>
</div><!-- fragment --><h1><a class="anchor" id="copy_and_assignment"></a>
Copying and assigning a FunctorHolder</h1>
<p>A <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> instance is copyable, movable and assignable, thus making it a <a class="el" href="structboost_1_1Assignable.html">boost::Assignable</a> model and of any other concept that trivially inherit from it (e.g. <a class="el" href="structDGtal_1_1concepts_1_1CUnaryFunctor.html">concepts::CUnaryFunctor</a>).</p>
<dl class="section warning"><dt>Warning</dt><dd>When copying or assigning a <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>, the two involved instances will afterward both refer to the same callable object (i.e. the held object is not copied). For example, modifying a functor attribute after the copy will modify the result of all original and copied instances of <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> that hold it: <div class="fragment"><div class="line">    <span class="keyword">using</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> = <a class="code" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    SignedDistToCircle&lt;Point&gt; dist(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0, 1), 2);</div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a>( dist );</div>
<div class="line">    <span class="keyword">auto</span> fn2 = fn;</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1, 1) ) &lt;&lt; std::endl;  <span class="comment">// Output: -1</span></div>
<div class="line">    std::cout &lt;&lt; fn2( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1, 1) ) &lt;&lt; std::endl; <span class="comment">// Output: -1</span></div>
<div class="line"> </div>
<div class="line">    dist.radius = 3; <span class="comment">// fn and fn2 both refer to the same functor dist.</span></div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1, 1) ) &lt;&lt; std::endl;  <span class="comment">// Output: -2</span></div>
<div class="line">    std::cout &lt;&lt; fn2( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1, 1) ) &lt;&lt; std::endl; <span class="comment">// Output: -2</span></div>
</div><!-- fragment --> </dd>
<dd>
It is also the case when passing the object by rvalue reference to <a class="el" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a> since it moves it to a dynamically allocated memory place, managed by <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a>. Copying or assigning the resulting <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> is like copying or assigning the underlying <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a>: <div class="fragment"><div class="line">    <span class="keywordtype">int</span> init_cnt = 0;</div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a>( [init_cnt] () <span class="keyword">mutable</span> { <span class="keywordflow">return</span> ++init_cnt; } );</div>
<div class="line">    std::cout &lt;&lt; fn() &lt;&lt; std::endl;  <span class="comment">// Output: 1</span></div>
<div class="line">    <span class="keyword">auto</span> fn2 = fn;</div>
<div class="line">    std::cout &lt;&lt; fn2() &lt;&lt; std::endl; <span class="comment">// Output: 2</span></div>
<div class="line">    std::cout &lt;&lt; fn() &lt;&lt; std::endl;  <span class="comment">// Output: 3</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>A counterpart of this design it that <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> instances are lightweight.</dd></dl>
<h1><a class="anchor" id="type_of_functorholder"></a>
The type of a FunctorHolder instance</h1>
<dl class="section note"><dt>Note</dt><dd>Note that the next topics are not specific to <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>. They may be useful in many cases where you can't or don't want to guess the result type of an expression.</dd></dl>
<h2><a class="anchor" id="storing_functorholder"></a>
Storing a FunctorHolder</h2>
<p>As explained before (see <a class="el" href="moduleFunctors.html#auto_holdfunctor">Why using the auto keyword ?</a>), you cannot easily guess the result type of a <a class="el" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a> call. Moreover, it becomes impossible when passing a lambda in an inline way.</p>
<p>Thus, it is recommended to use the <a href="https://en.cppreference.com/w/cpp/language/auto"><code>auto</code></a> keyword as the type placeholder for any instance of <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>: </p><div class="fragment"><div class="line">    <span class="keyword">using</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> = <a class="code" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a>( SignedDistToCircle&lt;Point&gt;( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0, 1), 2 ) );</div>
</div><!-- fragment --><h2><a class="anchor" id="passing_functorholder"></a>
Passing a FunctorHolder as a parameter</h2>
<p>However, when passing a <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>, especially to a class constructor, you may still need to known the <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> exact type (including the template parameters).</p>
<p>In those cases, a solution is to first store the <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> and then to deduce its type by using the <a href="https://en.cppreference.com/w/cpp/language/decltype"><code>decltype</code></a> keyword: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> binarizer = <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a>( [] (<a class="code" href="classDGtal_1_1ImageContainerBySTLVector.html#a969107fe40d0efab29fe28f72813cb66">Image::Value</a> v) { <span class="keywordflow">return</span> v &lt;= 135; } );</div>
<div class="line">    <a class="code" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate</a>&lt;<a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a852ab282e5168b5711ef7a87b3aefa68">Image</a>, decltype(binarizer)&gt; predicate(image, binarizer);</div>
</div><!-- fragment --><p> To ease such usage, you may want to search if there exist an helper (or factory) for that class (see also <a class="el" href="moduleFunctors.html#creating_a_helper">Creating a helper</a>).</p>
<h2><a class="anchor" id="returning_functorholder"></a>
Returning a FunctorHolder</h2>
<p>The most tricky part begins when you need a function to return a <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>.</p>
<p>The problem comes from the fact that up to C++11 standard, you need to somehow specify the function's return type. In C++11, you can slightly delay this type specification using the trailing return syntax but the type still needs to be known in the signature. Basically, you need to duplicate the line of code that generates the <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> (optionaly using the function's parameters) into the function signature and deduce its type using <a href="https://en.cppreference.com/w/cpp/language/decltype"><code>decltype</code></a>: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>Binarizer</div>
<div class="line">{</div>
<div class="line">  T threshold;</div>
<div class="line">  <span class="keyword">explicit</span> Binarizer(T v) : threshold(v) {}</div>
<div class="line">  Binarizer&amp; operator= (Binarizer <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>; <span class="comment">// This is not a model of boost::Assignable</span></div>
<div class="line">  <span class="keywordtype">bool</span> operator() (T v)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> v &lt;= threshold; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">inline</span></div>
<div class="line">decltype(<a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a>(Binarizer&lt;T&gt;(128))) <span class="comment">// Deduced return type</span></div>
<div class="line"><a class="code" href="exampleFunctorHolder_8cpp.html#a24597e953891697572ee4dfda12ca272">get_trivial_binarizer</a>()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a>( Binarizer&lt;T&gt;(128) );</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="keyword">auto</span> binarizer = get_trivial_binarizer&lt;int&gt;();</div>
</div><!-- fragment --><p> If it is easier to get the return type using the actual parameters, you can use the trailing return syntax: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="exampleFunctorHolder_8cpp.html#aa31c0f42bbc8c9da6dca73690c027a63">get_mean_binarizer_from_range</a>(Iterator first, Iterator last) <span class="comment">// auto as return type</span></div>
<div class="line">     -&gt; decltype(<a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a>(Binarizer&lt;decltype(*first / std::distance(first, last))&gt;(0)))</div>
<div class="line">     <span class="comment">// with trailing return type specification using -&gt;</span></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> std::iterator_traits&lt;Iterator&gt;::value_type;</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> mean = std::accumulate(first, last, value_type(0));</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> size = std::distance(first, last);</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a>(Binarizer&lt;decltype(mean / size)&gt;(mean / size));</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="keyword">auto</span> binarizer = <a class="code" href="exampleFunctorHolder_8cpp.html#aa31c0f42bbc8c9da6dca73690c027a63">get_mean_binarizer_from_range</a>(image.begin(), image.end());</div>
<div class="line">    <a class="code" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate</a>&lt;<a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a852ab282e5168b5711ef7a87b3aefa68">Image</a>, decltype(binarizer)&gt; predicate(image, binarizer);</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Note that you don't have to put the exact same expression in the trailing return type deduction and in the actual return. Like in the previous snippet, you can simply use another expression you know the result type will be the same as the actual return expression.</dd>
<dd>
Going further, if writting such simplier expression is difficult, you can use <a href="https://en.cppreference.com/w/cpp/utility/declval"><code>std::declval</code></a> function that constructs a fake instance of any given type: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Image&gt;</div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="exampleFunctorHolder_8cpp.html#a024528ac00c71adf2ed4208a601d8218">get_mean_binarizer_from_an_image</a>(std::string <span class="keyword">const</span>&amp; file_name)</div>
<div class="line">    -&gt; decltype(<a class="code" href="exampleFunctorHolder_8cpp.html#aa31c0f42bbc8c9da6dca73690c027a63">get_mean_binarizer_from_range</a>(</div>
<div class="line">          std::declval&lt;Image&gt;().begin(), std::declval&lt;Image&gt;().end() ))</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a852ab282e5168b5711ef7a87b3aefa68">Image</a> <span class="keyword">const</span> image = <a class="code" href="structDGtal_1_1GenericReader.html#a7e2fbfbe0d3c94e6bc4ca67e96c01f7c">DGtal::GenericReader&lt;Image&gt;::import</a>(file_name);</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="exampleFunctorHolder_8cpp.html#aa31c0f42bbc8c9da6dca73690c027a63">get_mean_binarizer_from_range</a>(image.begin(), image.end());</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<p>Starting with C++14 standard, you can simply use the <a href="https://en.cppreference.com/w/cpp/language/auto"><code>auto</code></a> keyword as a return type and the compiler should deduce the actual type from the <code>return</code> statements of the function: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line"><span class="keyword">auto</span> get_mean_binarizer_from_range_cpp14(Iterator first, Iterator last)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> std::iterator_traits&lt;Iterator&gt;::value_type;</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> mean = std::accumulate(first, last, value_type(0));</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> size = std::distance(first, last);</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a>(Binarizer&lt;decltype(mean / size)&gt;(mean / size));</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="creating_a_helper"></a>
Creating a helper</h2>
<p>Usage of <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> (as other kind of objects whose type is difficult to guess) can be simplified by adding helpers (or factories) to classes whose template parameters depend on such objects.</p>
<p>A helper is only a templated function that benefits from the auto-deduction of template parameters in order to deduce the appropriate class type: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">inline</span></div>
<div class="line">Binarizer&lt;T&gt; <a class="code" href="exampleFunctorHolder_8cpp.html#aa3abc5664514bddf81db68faac73ec74">makeBinarizer</a>( T <span class="keyword">const</span>&amp; v ) <span class="comment">// T auto-deduced from the parameter v</span></div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> Binarizer&lt;T&gt;(v);</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="keyword">auto</span> binarizer = <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a>( <a class="code" href="exampleFunctorHolder_8cpp.html#aa3abc5664514bddf81db68faac73ec74">makeBinarizer</a>(135) );</div>
<div class="line">    <a class="code" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate</a>&lt;<a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a852ab282e5168b5711ef7a87b3aefa68">Image</a>, decltype(binarizer)&gt; predicate(image, binarizer);</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Starting with C++17, these helpers can be replaced by deduction guides that are custom rules for deducing class template parameters from a direct call to the constructor (without specifying the deductible template parameters): <div class="fragment"><div class="line">    <span class="keyword">auto</span> binarizer = <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a>( Binarizer(135) ); <span class="comment">// Binarizer template parameter is not specified.</span></div>
<div class="line">    <a class="code" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate</a>&lt;<a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a852ab282e5168b5711ef7a87b3aefa68">Image</a>, decltype(binarizer)&gt; predicate(image, binarizer);</div>
</div><!-- fragment --></dd></dl>
<p>For more complex classes, like <a class="el" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate</a> that use <a class="el" href="classDGtal_1_1ConstAlias.html">DGtal::ConstAlias</a> in the constructor parameters, you cannot simply use <a class="el" href="classDGtal_1_1ConstAlias.html">DGtal::ConstAlias</a> in the factory and hope that the compiler will deduce the aliases type: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">typename</span> PointFunctor,</div>
<div class="line">  <span class="keyword">typename</span> Predicate</div>
<div class="line">&gt;</div>
<div class="line"><a class="code" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate&lt;PointFunctor, Predicate&gt;</a></div>
<div class="line"><a class="code" href="exampleFunctorHolder_8cpp.html#ad44640be0e5d692904546b2e670e98b9">makePointFunctorPredicate_Example</a>(</div>
<div class="line">    <a class="code" href="classDGtal_1_1ConstAlias.html">DGtal::ConstAlias&lt;PointFunctor&gt;</a> aFun,</div>
<div class="line">    <a class="code" href="classDGtal_1_1ConstAlias.html">DGtal::ConstAlias&lt;Predicate&gt;</a> aPred)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate&lt;PointFunctor, Predicate&gt;</a>( aFun, aPred );</div>
<div class="line">}</div>
</div><!-- fragment --><p> The problem here is that implicit conversions (like the one needed from <code>PointFunctor</code> to <code><a class="el" href="classDGtal_1_1ConstAlias.html" title="Aim: This class encapsulates its parameter class so that to indicate to the user that the object/poin...">ConstAlias</a>&lt;PointFunctor&gt;</code>) are ignored during the template deduction step. In this case, the first solution is to remove the <a class="el" href="classDGtal_1_1ConstAlias.html">DGtal::ConstAlias</a> from the helper signature: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">typename</span> PointFunctor,</div>
<div class="line">  <span class="keyword">typename</span> Predicate</div>
<div class="line">&gt;</div>
<div class="line"><a class="code" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate&lt;PointFunctor, Predicate&gt;</a></div>
<div class="line"><a class="code" href="exampleFunctorHolder_8cpp.html#ad44640be0e5d692904546b2e670e98b9">makePointFunctorPredicate_Example</a>( PointFunctor <span class="keyword">const</span>&amp; aFun, Predicate <span class="keyword">const</span>&amp; aPred )</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate&lt;PointFunctor, Predicate&gt;</a>( aFun, aPred );</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="keyword">auto</span> binarizer = <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a>( <a class="code" href="exampleFunctorHolder_8cpp.html#aa3abc5664514bddf81db68faac73ec74">makeBinarizer</a>(135) );</div>
<div class="line">    <span class="keyword">auto</span> predicate = <a class="code" href="exampleFunctorHolder_8cpp.html#ad44640be0e5d692904546b2e670e98b9">makePointFunctorPredicate_Example</a>( image, binarizer );</div>
</div><!-- fragment --><p> Another problem arises here: the constructor of <a class="el" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate</a> will get as parameters only left-value references because the parameters have a name in the factory. Thus, you might miss some optimizations for right-value references.</p>
<p>In order to make a factory that doesn't change the parameters type, you must use <a href="https://en.cppreference.com/w/cpp/language/reference#Forwarding_references">forwarding references</a> (by using <code>&amp;&amp;</code> references together with template paremeter deduction, also known as universal references) and perfect forwarding using <a href="https://en.cppreference.com/w/cpp/utility/forward"><code>std::forward</code></a>: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">typename</span> PointFunctor,</div>
<div class="line">  <span class="keyword">typename</span> Predicate</div>
<div class="line">&gt;</div>
<div class="line"><a class="code" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate</a>&lt;</div>
<div class="line">  <span class="keyword">typename</span> std::decay&lt;PointFunctor&gt;::type,</div>
<div class="line">  <span class="keyword">typename</span> std::decay&lt;Predicate&gt;::type</div>
<div class="line">&gt;</div>
<div class="line"><a class="code" href="exampleFunctorHolder_8cpp.html#a6cdfd61459d5f575b8c49de13c7d4889">makePointFunctorPredicate_Example2</a>( PointFunctor &amp;&amp; aFun, Predicate &amp;&amp; aPred )</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate</a>&lt;</div>
<div class="line">      <span class="keyword">typename</span> std::decay&lt;PointFunctor&gt;::type,</div>
<div class="line">      <span class="keyword">typename</span> std::decay&lt;Predicate&gt;::type</div>
<div class="line">  &gt;(</div>
<div class="line">    std::forward&lt;PointFunctor&gt;(aFun),</div>
<div class="line">    std::forward&lt;Predicate&gt;(aPred)</div>
<div class="line">  );</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note the use of <a href="https://en.cppreference.com/w/cpp/types/decay"><code>std::decay</code></a> because the template parameter will be deduced with an included reference specification that you don't want to be part of the returned class specification (<a href="https://en.cppreference.com/w/cpp/types/decay"><code>std::decay</code></a> removes reference and constness from a given type).</p>
<h1><a class="anchor" id="marking_cunaryfunctor"></a>
Making a C(Unary)Functor model based on FunctorHolder</h1>
<p>In the following sections, we will explain how to create new <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> functor models using <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> as an internal storage in order to accept any kind of callable objects (lambdas included).</p>
<p>You may want to add such classes because some concepts derived from <a class="el" href="structDGtal_1_1concepts_1_1CUnaryFunctor.html">DGtal::concepts::CUnaryFunctor</a> may need additional data or typedef, like <a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html">DGtal::concepts::CPointFunctor</a>.</p>
<h2><a class="anchor" id="tutorial_pointfunctorholder"></a>
A simple CUnaryFunctor model with additional typedef</h2>
<p>In this section, we will explain how to write a <a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html">concepts::CPointFunctor</a> model that is basically a <a class="el" href="structDGtal_1_1concepts_1_1CUnaryFunctor.html">concepts::CUnaryFunctor</a> model with additional typedef (the point and value types).</p>
<p>The resulting class is more or less the <a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html">PointFunctorHolder</a> class which source code is visible in <a class="el" href="PointFunctorHolder_8h_source.html">PointFunctorHolder.h</a> .</p>
<h3><a class="anchor" id="pointfunctorholder_core_skeleton"></a>
The core skeleton</h3>
<p>A basic implementation of such a class would be: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">typename</span> TPoint,</div>
<div class="line">  <span class="keyword">typename</span> TValue,</div>
<div class="line">  <span class="keyword">typename</span> TFunctor</div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">class </span>PointFunctorHolder</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// DGtal types</span></div>
<div class="line">  <span class="keyword">using</span> <a class="code" href="classDGtal_1_1functors_1_1PointFunctorHolder.html#ab3bb99c9e1d5518bee5016183fc480f7">Self</a>    = PointFunctorHolder&lt;TPoint, TValue, TFunctor&gt;;</div>
<div class="line">  <span class="keyword">using</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>   = TPoint;</div>
<div class="line">  <span class="keyword">using</span> <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Value</a>   = TValue;</div>
<div class="line">  <span class="keyword">using</span> <a class="code" href="classDGtal_1_1functors_1_1PointFunctorHolder.html#a04877a37081c035218759dae3b54d7cf">Functor</a> = TFunctor;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Storing the functor</span></div>
<div class="line">  <span class="keyword">explicit</span> <a class="code" href="classDGtal_1_1functors_1_1PointFunctorHolder.html#a9b362748aaa71a04f7fa91f303f44a2c">PointFunctorHolder</a>(TFunctor <span class="keyword">const</span>&amp; fn)</div>
<div class="line">      : <a class="code" href="classDGtal_1_1functors_1_1PointFunctorHolder.html#af9ae4eec22e3132acee4828f8612010c">myFunctor</a>(fn)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Evaluating the functor</span></div>
<div class="line">  <span class="keyword">inline</span> <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Value</a> <a class="code" href="classDGtal_1_1functors_1_1PointFunctorHolder.html#a9cf86ca14c700bcb6d07cf196e4eb836">operator() </a>( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> <span class="keyword">const</span>&amp; <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a9ae40316aa447d5a39eb6f76dba59444">aPoint</a> )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">return</span> <a class="code" href="classDGtal_1_1functors_1_1PointFunctorHolder.html#af9ae4eec22e3132acee4828f8612010c">myFunctor</a>( <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a9ae40316aa447d5a39eb6f76dba59444">aPoint</a> );</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <a class="code" href="classDGtal_1_1functors_1_1PointFunctorHolder.html#a04877a37081c035218759dae3b54d7cf">Functor</a> <a class="code" href="classDGtal_1_1functors_1_1PointFunctorHolder.html#af9ae4eec22e3132acee4828f8612010c">myFunctor</a>;</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --><p>There is nothing special to say about this first draft except that there is no references to <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> because it is the helper (factory) that will actually choose <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> as the <em>TFunctor</em> template parameter of this class.</p>
<h3><a class="anchor" id="pointfunctorholder_helper"></a>
The helper (factory)</h3>
<p>Before continuing, you should read the previous section about <a class="el" href="moduleFunctors.html#creating_a_helper">Creating a helper</a> .</p>
<p>The helper of the above draft should be: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">typename</span> TPoint,</div>
<div class="line">  <span class="keyword">typename</span> TValue,</div>
<div class="line">  <span class="keyword">typename</span> TFunctor</div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span></div>
<div class="line"><a class="code" href="namespaceDGtal_1_1functors.html#a2edeed82668eb0dd5c4a11c199794237">holdPointFunctor</a>( TFunctor &amp;&amp; aFunctor )</div>
<div class="line">    -&gt; PointFunctorHolder&lt;TPoint, TValue, decltype(holdFunctor(std::forward&lt;TFunctor&gt;(aFunctor)))&gt;</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> PointFunctorHolder&lt;TPoint, TValue, decltype(holdFunctor(std::forward&lt;TFunctor&gt;(aFunctor)))&gt;{</div>
<div class="line">        <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor))</div>
<div class="line">    };</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Here we use the trailing return type (<a href="https://en.cppreference.com/w/cpp/language/auto"><code>auto</code></a> as returned type, followed by <code>-&gt;</code>) in order to choose the <em>TFunctor</em> template parameter type of our class depending on the result of <a class="el" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>.</p>
<p>As explained before, this type is not easily guessable and it is why we use the <a href="https://en.cppreference.com/w/cpp/language/decltype"><code>decltype</code></a> keyword.</p>
<p>Also note the perfect forwarding syntax (using <a href="https://en.cppreference.com/w/cpp/language/reference#Forwarding_references">universal references</a> and <a href="https://en.cppreference.com/w/cpp/utility/forward"><code>std::forward</code></a>) to avoid modifying the actual type of the given callable object (particulary keeping lvalue and rvalue references).</p>
<dl class="section remark"><dt>Remarks</dt><dd>There is many repetitions in this helper. Starting with C++14 standard, the trailing return type (after the <code>-&gt;</code>) could be removed.</dd></dl>
<h3><a class="anchor" id="pointfunctorholder_usage"></a>
First test</h3>
<p>That's it ! You can enjoy using this <a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html">concepts::CPointFunctor</a> model, for example to hold a lambda returning the point norm: </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> = PointVector&lt;2, int&gt;;</div>
<div class="line"><span class="keyword">auto</span> fn = holdPointFunctor&lt;Point, double&gt;(</div>
<div class="line">  [] (<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> <span class="keyword">const</span>&amp; pt) { <span class="keywordflow">return</span> pt.norm(); }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">BOOST_CONCEPT_ASSERT( (concepts::CPointFunctor&lt;decltype(fn)&gt;) );</div>
</div><!-- fragment --><h3><a class="anchor" id="pointfunctorholder_advanced_helper"></a>
Auto-deducing the return type of the functor</h3>
<p>Since the functor's return type can be easily deduced by calling it with a point, we can then provide an additional helper that needs only one template parameter: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">typename</span> TPoint,</div>
<div class="line">  <span class="keyword">typename</span> TFunctor</div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span></div>
<div class="line"><a class="code" href="namespaceDGtal_1_1functors.html#a2edeed82668eb0dd5c4a11c199794237">holdPointFunctor</a>( TFunctor &amp;&amp; aFunctor )</div>
<div class="line">    -&gt; PointFunctorHolder&lt;</div>
<div class="line">          TPoint,</div>
<div class="line">          <span class="keyword">typename</span> std::decay&lt;decltype(aFunctor(std::declval&lt;TPoint&gt;()))&gt;::type,</div>
<div class="line">          decltype(<a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)))</div>
<div class="line">        &gt;</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> PointFunctorHolder&lt;</div>
<div class="line">        TPoint,</div>
<div class="line">        <span class="keyword">typename</span> std::decay&lt;decltype(aFunctor(std::declval&lt;TPoint&gt;()))&gt;::type,</div>
<div class="line">        decltype(<a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)))</div>
<div class="line">      &gt;{ <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)) };</div>
<div class="line">  }</div>
</div><!-- fragment --><p>It is a little bit more tricky: we use <a href="https://en.cppreference.com/w/cpp/utility/declval"><code>std::declval</code></a> in order to generate a fake point, we give it as a parameter to the functor and we deduce the result type using <a href="https://en.cppreference.com/w/cpp/language/decltype"><code>decltype</code></a>. The use of <a href="https://en.cppreference.com/w/cpp/types/decay"><code>std::decay</code></a> allows us to remove any reference and const specifier from the deduced type.</p>
<p>The usage is very similar: </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> = PointVector&lt;2, int&gt;;</div>
<div class="line"><span class="keyword">auto</span> fn = holdPointFunctor&lt;Point&gt;( <span class="comment">// Value template parameter deduced to double</span></div>
<div class="line">  [] (<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> <span class="keyword">const</span>&amp; pt) { <span class="keywordflow">return</span> pt.norm(); }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">BOOST_CONCEPT_ASSERT( (concepts::CPointFunctor&lt;decltype(fn)&gt;) );</div>
</div><!-- fragment --><h3><a class="anchor" id="pointfunctorholder_advanced_constructor"></a>
Perfect forwarding in the constructor</h3>
<p>You may have notice that the constructor accepts the functor by constant reference. Since this functor will be a <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>, it shouldn't be a problem because copying a <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> is costless.</p>
<p>However, if you want more genericity in order to use another storage mode, you should consider using perfect forwarding in the constructor: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> Function &gt;</div>
<div class="line"><span class="keyword">explicit</span> PointFunctorHolder(Function &amp;&amp; fn)</div>
<div class="line">    : myFunctor(std::forward&lt;Function&gt;(fn))</div>
<div class="line">{}</div>
</div><!-- fragment --><p> so that the transfer from the given functor to its storage is unaffected.</p>
<p>However, the problem is that the compiler may choose this constructor as a better overload for the copy constructor, even if you define it: for example, if you copy construct from a mutable <a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html" title="Aim: hold any object callable on points as a DGtal::concepts::CPointFunctor model.">PointFunctorHolder</a>, the perfect forwarding constructor will be a better choice than the copy construction from a constant reference.</p>
<p>One of the possible solutions to avoid this is to disable this constructor when the given type is related to the current class. To do this, we can rely on SFINAE.</p>
<dl class="section note"><dt>Note</dt><dd>The idea behind <a href="https://en.cppreference.com/w/cpp/language/sfinae">SFINAE (Substitution Failure Is Not An Error)</a> is that, during the phase when the compiler lists all possible overloads that may fit a given call, if substituting the template parameters of a considered function fails (i.e. the function signature becomes invalid), then this specialization is discarded without generating a compilation error.</dd>
<dd>
So, the idea is to modify the function signature so that it becomes invalid for some types. To do so, we can add some code in:<ul>
<li>the template parameters declaration,</li>
<li>the arguments list,</li>
<li>the return type.</li>
</ul>
</dd>
<dd>
This trick works before C++11 but this standard makes it easier with the <a href="https://en.cppreference.com/w/cpp/types/enable_if"><code>std::enable_if</code></a> structure and the trailing return type.</dd>
<dd>
Using the trailing return type, you can easily disable a function overload if a given expression is invalid: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> do_something_if_addable(T v) <span class="comment">// Considered only if v is addable</span></div>
<div class="line">    -&gt; decltype(v + v)</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --></dd>
<dd>
If the type deduced by <a href="https://en.cppreference.com/w/cpp/language/decltype"><code>decltype</code></a> is not the actual return type, you can use the comma operator to specify an additional expression: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> do_something_if_addable(T v) <span class="comment">// Considered only if v is addable</span></div>
<div class="line">    -&gt; decltype(v + v, <span class="keywordtype">void</span>())    <span class="comment">// This function doesn&#39;t return</span></div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<p>So here is a viable solution: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">typename</span> Function,</div>
<div class="line">  <span class="comment">// SFINAE trick to disable this constructor in a copy/move construction context.</span></div>
<div class="line">  <span class="keyword">typename</span> std::enable_if&lt;!std::is_base_of&lt;PointFunctorHolder, typename std::decay&lt;Function&gt;::type&gt;::value, <span class="keywordtype">int</span>&gt;::type = 0</div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">explicit</span> PointFunctorHolder(Function &amp;&amp; fn)</div>
<div class="line">    : myFunctor(std::forward&lt;Function&gt;(fn))</div>
<div class="line">{}</div>
</div><!-- fragment --><p> that uses <a href="https://en.cppreference.com/w/cpp/types/is_base_of"><code>std::is_base_of</code></a> type traits to check if the given parameter is a or inherits from <a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html">PointFunctorHolder</a>.</p>
<h3><a class="anchor" id="pointfunctorholder_documentation"></a>
Documenting</h3>
<p>When documenting such a class, it is important to warn the user about two things:</p><ol type="1">
<li>the class is not meant to be used directly but only through the associated helper or factory.</li>
<li>a copied instance of this class will point to the exact same underlying object as the original instance.</li>
</ol>
<p>In addition, for performance reason, you may remark that functions should be wrapped into a lambda before being stored into your class, as explained in the section about <a class="el" href="moduleFunctors.html#holding_a_function">Holding a function</a> .</p>
<p>Finally, you should link to this module page for more informations.</p>
<h2><a class="anchor" id="tutorial_functorconstimage"></a>
A more complex example with variable functor arity</h2>
<p>In this section, we will explain how to write a class that may hold an unary or binary functor. It will be based on the <a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html">ConstImageFunctorHolder</a> class that transforms a given callable object into a <a class="el" href="structDGtal_1_1concepts_1_1CConstImage.html">concepts::CConstImage</a> model.</p>
<p>Basically, to define an image, a <a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html">concepts::CPointFunctor</a> model (i.e a functor that returns a value from a given point) would be enough but we want to allow the user to pass a functor that also depends on the image's domain (e.g. when calculating distance to the bounds).</p>
<p>To do so, using SFINAE, we can detect the arity of the given functor and even its parameter's types.</p>
<h3><a class="anchor" id="functorconstimage_core_skeleton"></a>
The core skeleton</h3>
<p>Here is the core skeleton of the <a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html">ConstImageFunctorHolder</a> class, without the <code>operator()</code> that will be introduced later: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">typename</span> TDomain,</div>
<div class="line">  <span class="keyword">typename</span> TValue,</div>
<div class="line">  <span class="keyword">typename</span> TFunctor</div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">class </span>ConstImageFunctorHolder</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// DGtal types</span></div>
<div class="line">  <span class="keyword">using</span> <a class="code" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a83322dad8065e2de6aadfd93b22fb88d">Self</a>      = ConstImageFunctorHolder&lt;TDomain, TValue, TFunctor&gt;;</div>
<div class="line">  <span class="keyword">using</span> <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a>    = TDomain;</div>
<div class="line">  <span class="keyword">using</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>     = <span class="keyword">typename</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Domain::Point</a>;</div>
<div class="line">  <span class="keyword">using</span> <a class="code" href="testCombinDSS_8cpp.html#a609ee1808a3b4f883fb28df65e9a2ed6">Vector</a>    = <span class="keyword">typename</span> <a class="code" href="testCombinDSS_8cpp.html#a609ee1808a3b4f883fb28df65e9a2ed6">Domain::Vector</a>;</div>
<div class="line">  <span class="keyword">using</span> <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Value</a>     = TValue;</div>
<div class="line">  <span class="keyword">using</span> <a class="code" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a11a79052b6833dbbabff3b5bcff28917">Functor</a>   = TFunctor;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Ranges and iterators</span></div>
<div class="line">  <span class="keyword">using</span> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a> = boost::transform_iterator&lt; std::reference_wrapper&lt;const Self&gt;, <span class="keyword">typename</span> <a class="code" href="classDGtal_1_1HyperRectDomain__Iterator.html">Domain::ConstIterator</a> &gt;;</div>
<div class="line">  <span class="keyword">using</span> <a class="code" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a7adca365c6f317a7b7ba6cef4efbe7dc">ConstReverseIterator</a> = std::reverse_iterator&lt; ConstIterator &gt;;</div>
<div class="line">  <span class="keyword">class </span><a class="code" href="classDGtal_1_1SimpleRandomAccessConstRangeFromPoint.html">ConstRange</a>; <span class="comment">// To be defined...</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Constructor</span></div>
<div class="line">  <span class="keyword">template</span> &lt; <span class="keyword">class</span> TGivenFunctor &gt;</div>
<div class="line">  <span class="keyword">explicit</span> <a class="code" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a3dbe206c4f6aa733683273d9ca4610fa">ConstImageFunctorHolder</a>( <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> <span class="keyword">const</span>&amp; aDomain, TGivenFunctor &amp;&amp; aFunctor )</div>
<div class="line">    : <a class="code" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a7da68e4c222fcbe2f7bf31d569eee86e">myDomain</a>( aDomain )</div>
<div class="line">    , <a class="code" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#ad340b962631f15f890e229600482fc7f">myFunctor</a>( std::forward&lt;TGivenFunctor&gt;(aFunctor) )</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Return the associated domain.</span></div>
<div class="line">  <span class="keyword">inline</span> <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> <span class="keyword">const</span>&amp; <a class="code" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a5a68b404050e2a955e04c83bd5880f2b">domain</a>()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">return</span> <a class="code" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a7da68e4c222fcbe2f7bf31d569eee86e">myDomain</a>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a>  <a class="code" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a7da68e4c222fcbe2f7bf31d569eee86e">myDomain</a>;</div>
<div class="line">  <a class="code" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a11a79052b6833dbbabff3b5bcff28917">Functor</a> <a class="code" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#ad340b962631f15f890e229600482fc7f">myFunctor</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Note that using perfect forwarding in the constructor doesn't imply here to add SFINAE like in <a class="el" href="moduleFunctors.html#pointfunctorholder_advanced_constructor">Perfect forwarding in the constructor</a> because a binary constructor cannot be choosen as a valid overload during a copy construction.</p>
<h3><a class="anchor" id="functorconstimage_helper"></a>
The helper (factory)</h3>
<p>The helper is very similar to the one introduced in <a class="el" href="moduleFunctors.html#pointfunctorholder_helper">The helper (factory)</a>: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">typename</span> TValue,</div>
<div class="line">  <span class="keyword">typename</span> TDomain,</div>
<div class="line">  <span class="keyword">typename</span> TFunctor</div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span></div>
<div class="line"><a class="code" href="namespaceDGtal_1_1functors.html#ae078b1e517d167341988d5a5d6366a91">holdConstImageFunctor</a>( TDomain <span class="keyword">const</span>&amp; aDomain, TFunctor &amp;&amp; aFunctor )</div>
<div class="line">    -&gt; ConstImageFunctorHolder&lt;TDomain, TValue, decltype(holdFunctor(std::forward&lt;TFunctor&gt;(aFunctor)))&gt;</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> ConstImageFunctorHolder&lt;TDomain, TValue, decltype(holdFunctor(std::forward&lt;TFunctor&gt;(aFunctor)))&gt;{</div>
<div class="line">        aDomain, <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor))</div>
<div class="line">    };</div>
<div class="line">  }</div>
</div><!-- fragment --><h3><a class="anchor" id="functorconstimage_evaluation"></a>
The evaluation operator</h3>
<p>Here, in order to take into account the fact that the held functor may by unary (accepting only a point) or binary (accepting a point and the image's domain), we must rely on the SFINAE trick explained in <a class="el" href="moduleFunctors.html#pointfunctorholder_advanced_constructor">Perfect forwarding in the constructor</a> so that the compiler chooses the right implementation: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TPo<span class="keywordtype">int</span>&gt; <span class="comment">// Needed template parameter to enable SFINAE trick</span></div>
<div class="line"><span class="keyword">inline</span></div>
<div class="line"><span class="keyword">auto</span> operator() ( TPoint <span class="keyword">const</span>&amp; <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a9ae40316aa447d5a39eb6f76dba59444">aPoint</a> ) <span class="keyword">const</span></div>
<div class="line">    -&gt; decltype( myFunctor( <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a9ae40316aa447d5a39eb6f76dba59444">aPoint</a> ) ) <span class="comment">// Using SFINAE to enable this overload for unary functor</span></div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> myFunctor( <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a9ae40316aa447d5a39eb6f76dba59444">aPoint</a> );</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TPo<span class="keywordtype">int</span>&gt; <span class="comment">// Needed template parameter to enable SFINAE trick</span></div>
<div class="line"><span class="keyword">inline</span></div>
<div class="line"><span class="keyword">auto</span> operator() ( TPoint <span class="keyword">const</span>&amp; <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a9ae40316aa447d5a39eb6f76dba59444">aPoint</a> ) <span class="keyword">const</span></div>
<div class="line">    -&gt; decltype( myFunctor( <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a9ae40316aa447d5a39eb6f76dba59444">aPoint</a>, myDomain ) ) <span class="comment">// Using SFINAE to enable this overload for binary functor</span></div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> myFunctor( <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a9ae40316aa447d5a39eb6f76dba59444">aPoint</a>, myDomain );</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Here, the first overload is valid only if the <code>myFunctor(aPoint)</code> expression is valid, that is if the held functor is unary and accept a point as parameter. Likewise, the second overload is valid only if the functor is binary and accept a point as the first argument and a domain as the second argument.</p>
<dl class="section note"><dt>Note</dt><dd>If the functor is unary and binary at the same time, this will lead to a compilation error. However, if it makes sense to handle such functors, it is possible to prioritize the two overloads.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>SFINAE trick needs to know the <em>myDomain</em> member at the method declaration. Thus, it is important to declare <em>myDomain</em> before declaring the two overloads of <code>operator()</code>.</dd></dl>
<h3><a class="anchor" id="functorconstimage_advanced_helper"></a>
Auto-deducing the return type of the functor</h3>
<p>If you want to automatically deduce the <em>TValue</em> template parameter, the solution is quite similar to the one proposed in <a class="el" href="moduleFunctors.html#pointfunctorholder_advanced_helper">Auto-deducing the return type of the functor</a> but in two versions, one for each possible arity of the given functor: </p><div class="fragment"><div class="line"><span class="comment">// Helper for a unary functor</span></div>
<div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">typename</span> TDomain,</div>
<div class="line">  <span class="keyword">typename</span> TFunctor</div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span></div>
<div class="line"><a class="code" href="namespaceDGtal_1_1functors.html#ae078b1e517d167341988d5a5d6366a91">holdConstImageFunctor</a>( TDomain <span class="keyword">const</span>&amp; aDomain, TFunctor &amp;&amp; aFunctor )</div>
<div class="line">    -&gt; ConstImageFunctorHolder&lt;</div>
<div class="line">          TDomain,</div>
<div class="line">          <span class="keyword">typename</span> std::decay&lt;decltype(aFunctor(std::declval&lt;typename TDomain::Point&gt;()))&gt;::type,</div>
<div class="line">          decltype(<a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)))</div>
<div class="line">        &gt;</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> ConstImageFunctorHolder&lt;</div>
<div class="line">        TDomain,</div>
<div class="line">        <span class="keyword">typename</span> std::decay&lt;decltype(aFunctor(std::declval&lt;typename TDomain::Point&gt;()))&gt;::type,</div>
<div class="line">        decltype(<a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)))</div>
<div class="line">      &gt;{ aDomain, <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)) };</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Helper for a binary functor</span></div>
<div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">typename</span> TDomain,</div>
<div class="line">  <span class="keyword">typename</span> TFunctor</div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span></div>
<div class="line"><a class="code" href="namespaceDGtal_1_1functors.html#ae078b1e517d167341988d5a5d6366a91">holdConstImageFunctor</a>( TDomain <span class="keyword">const</span>&amp; aDomain, TFunctor &amp;&amp; aFunctor )</div>
<div class="line">    -&gt; ConstImageFunctorHolder&lt;</div>
<div class="line">          TDomain,</div>
<div class="line">          <span class="keyword">typename</span> std::decay&lt;decltype(aFunctor(std::declval&lt;typename TDomain::Point&gt;(), aDomain))&gt;::type,</div>
<div class="line">          decltype(<a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)))</div>
<div class="line">        &gt;</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> ConstImageFunctorHolder&lt;</div>
<div class="line">        TDomain,</div>
<div class="line">        <span class="keyword">typename</span> std::decay&lt;decltype(aFunctor(std::declval&lt;typename TDomain::Point&gt;(), aDomain))&gt;::type,</div>
<div class="line">        decltype(<a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)))</div>
<div class="line">      &gt;{ aDomain, <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)) };</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Finally, an image can be easily defined from a functor with a syntax like: </p><div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> domain1(<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1,1), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(16,16));</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> image1 = <a class="code" href="namespaceDGtal_1_1functors.html#ae078b1e517d167341988d5a5d6366a91">DGtal::functors::holdConstImageFunctor</a>(</div>
<div class="line">      domain1,</div>
<div class="line">      [] (<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> <span class="keyword">const</span>&amp; pt) { <span class="keywordflow">return</span> 25 * ( std::cos( (pt - <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(4,4)).norm() ) + 1 ); }</div>
<div class="line">  );</div>
</div><!-- fragment --><p>resulting in: </p><div class="image">
<img src="ConstImageFunctorHolder_example1.png" alt=""/>
<div class="caption">
Image generated from a point-dependent lambda.</div></div>
  </div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="aclassDGtal_1_1functors_1_1PointFunctorHolder_html_a9cf86ca14c700bcb6d07cf196e4eb836"><div class="ttname"><a href="classDGtal_1_1functors_1_1PointFunctorHolder.html#a9cf86ca14c700bcb6d07cf196e4eb836">DGtal::functors::PointFunctorHolder::operator()</a></div><div class="ttdeci">Value operator()(Point const &amp;aPoint) const</div><div class="ttdoc">Evaluates the functor at the given point.</div><div class="ttdef"><b>Definition:</b> <a href="PointFunctorHolder_8h_source.html#l00132">PointFunctorHolder.h:132</a></div></div>
<div class="ttc" id="agreedy-plane-segmentation-ex2_8cpp_html_a6d06fad433cff067dfcbbbf16d6e2dbf"><div class="ttname"><a href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a></div><div class="ttdeci">MyDigitalSurface::ConstIterator ConstIterator</div><div class="ttdef"><b>Definition:</b> <a href="greedy-plane-segmentation-ex2_8cpp_source.html#l00093">greedy-plane-segmentation-ex2.cpp:93</a></div></div>
<div class="ttc" id="aexampleFunctorHolder_8cpp_html_aa3abc5664514bddf81db68faac73ec74"><div class="ttname"><a href="exampleFunctorHolder_8cpp.html#aa3abc5664514bddf81db68faac73ec74">makeBinarizer</a></div><div class="ttdeci">Binarizer&lt; T &gt; makeBinarizer(T const &amp;v)</div><div class="ttdoc">[Returning a FunctorHolder using trailing return and declval]</div><div class="ttdef"><b>Definition:</b> <a href="exampleFunctorHolder_8cpp_source.html#l00148">exampleFunctorHolder.cpp:148</a></div></div>
<div class="ttc" id="aexampleFunctorHolder_8cpp_html_ad44640be0e5d692904546b2e670e98b9"><div class="ttname"><a href="exampleFunctorHolder_8cpp.html#ad44640be0e5d692904546b2e670e98b9">makePointFunctorPredicate_Example</a></div><div class="ttdeci">DGtal::functors::PointFunctorPredicate&lt; PointFunctor, Predicate &gt; makePointFunctorPredicate_Example(PointFunctor const &amp;aFun, Predicate const &amp;aPred)</div><div class="ttdoc">[Factory of Binarizer]</div><div class="ttdef"><b>Definition:</b> <a href="exampleFunctorHolder_8cpp_source.html#l00176">exampleFunctorHolder.cpp:176</a></div></div>
<div class="ttc" id="aclassDGtal_1_1ConstAlias_html"><div class="ttname"><a href="classDGtal_1_1ConstAlias.html">DGtal::ConstAlias</a></div><div class="ttdoc">Aim: This class encapsulates its parameter class so that to indicate to the user that the object/poin...</div><div class="ttdef"><b>Definition:</b> <a href="ConstAlias_8h_source.html#l00186">ConstAlias.h:187</a></div></div>
<div class="ttc" id="astructDGtal_1_1GenericReader_html_a7e2fbfbe0d3c94e6bc4ca67e96c01f7c"><div class="ttname"><a href="structDGtal_1_1GenericReader.html#a7e2fbfbe0d3c94e6bc4ca67e96c01f7c">DGtal::GenericReader::import</a></div><div class="ttdeci">static TContainer import(const std::string &amp;filename, std::vector&lt; unsigned int &gt; dimSpace=std::vector&lt; unsigned int &gt;())</div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z2i_html_ac0a04516c81db6f4a583eddda0f64875"><div class="ttname"><a href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">DGtal::Z2i::Point</a></div><div class="ttdeci">Space::Point Point</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00095">StdDefs.h:95</a></div></div>
<div class="ttc" id="aclassDGtal_1_1SimpleRandomAccessConstRangeFromPoint_html"><div class="ttname"><a href="classDGtal_1_1SimpleRandomAccessConstRangeFromPoint.html">DGtal::SimpleRandomAccessConstRangeFromPoint</a></div><div class="ttdoc">Aim: model of CConstBidirectionalRangeFromPoint that adapts any range of elements bounded by two iter...</div><div class="ttdef"><b>Definition:</b> <a href="SimpleRandomAccessConstRangeFromPoint_8h_source.html#l00073">SimpleRandomAccessConstRangeFromPoint.h:74</a></div></div>
<div class="ttc" id="aclassDGtal_1_1ImageContainerBySTLVector_html_a969107fe40d0efab29fe28f72813cb66"><div class="ttname"><a href="classDGtal_1_1ImageContainerBySTLVector.html#a969107fe40d0efab29fe28f72813cb66">DGtal::ImageContainerBySTLVector&lt; Domain, Value &gt;::Value</a></div><div class="ttdeci">Value Value</div><div class="ttdef"><b>Definition:</b> <a href="ImageContainerBySTLVector_8h_source.html#l00151">ImageContainerBySTLVector.h:151</a></div></div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1ConstImageFunctorHolder_html_a11a79052b6833dbbabff3b5bcff28917"><div class="ttname"><a href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a11a79052b6833dbbabff3b5bcff28917">DGtal::functors::ConstImageFunctorHolder::Functor</a></div><div class="ttdeci">TFunctor Functor</div><div class="ttdef"><b>Definition:</b> <a href="ConstImageFunctorHolder_8h_source.html#l00120">ConstImageFunctorHolder.h:120</a></div></div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_a9ae40316aa447d5a39eb6f76dba59444"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a9ae40316aa447d5a39eb6f76dba59444">aPoint</a></div><div class="ttdeci">const Point aPoint(3, 4)</div></div>
<div class="ttc" id="anamespaceDGtal_1_1functors_html_a2edeed82668eb0dd5c4a11c199794237"><div class="ttname"><a href="namespaceDGtal_1_1functors.html#a2edeed82668eb0dd5c4a11c199794237">DGtal::functors::holdPointFunctor</a></div><div class="ttdeci">auto holdPointFunctor(TFunctor &amp;&amp;aFunctor) -&gt; PointFunctorHolder&lt; TPoint, TValue, decltype(holdFunctor(std::forward&lt; TFunctor &gt;(aFunctor)))&gt;</div><div class="ttdoc">PointFunctorHolder construction helper with specification of the return type.</div><div class="ttdef"><b>Definition:</b> <a href="PointFunctorHolder_8h_source.html#l00196">PointFunctorHolder.h:196</a></div></div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1ConstImageFunctorHolder_html_a83322dad8065e2de6aadfd93b22fb88d"><div class="ttname"><a href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a83322dad8065e2de6aadfd93b22fb88d">DGtal::functors::ConstImageFunctorHolder::Self</a></div><div class="ttdeci">ConstImageFunctorHolder&lt; TDomain, TValue, TFunctor &gt; Self</div><div class="ttdef"><b>Definition:</b> <a href="ConstImageFunctorHolder_8h_source.html#l00111">ConstImageFunctorHolder.h:111</a></div></div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1ConstImageFunctorHolder_html_ad340b962631f15f890e229600482fc7f"><div class="ttname"><a href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#ad340b962631f15f890e229600482fc7f">DGtal::functors::ConstImageFunctorHolder::myFunctor</a></div><div class="ttdeci">Functor myFunctor</div><div class="ttdoc">The functor that generates the image.</div><div class="ttdef"><b>Definition:</b> <a href="ConstImageFunctorHolder_8h_source.html#l00133">ConstImageFunctorHolder.h:133</a></div></div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1ConstImageFunctorHolder_html_a7da68e4c222fcbe2f7bf31d569eee86e"><div class="ttname"><a href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a7da68e4c222fcbe2f7bf31d569eee86e">DGtal::functors::ConstImageFunctorHolder::myDomain</a></div><div class="ttdeci">Domain myDomain</div><div class="ttdoc">The image domain.</div><div class="ttdef"><b>Definition:</b> <a href="ConstImageFunctorHolder_8h_source.html#l00132">ConstImageFunctorHolder.h:132</a></div></div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1ConstImageFunctorHolder_html_a5a68b404050e2a955e04c83bd5880f2b"><div class="ttname"><a href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a5a68b404050e2a955e04c83bd5880f2b">DGtal::functors::ConstImageFunctorHolder::domain</a></div><div class="ttdeci">Domain const  &amp; domain() const</div><div class="ttdoc">Returns the associated domain.</div><div class="ttdef"><b>Definition:</b> <a href="ConstImageFunctorHolder_8h_source.html#l00154">ConstImageFunctorHolder.h:154</a></div></div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1ConstImageFunctorHolder_html_a3dbe206c4f6aa733683273d9ca4610fa"><div class="ttname"><a href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a3dbe206c4f6aa733683273d9ca4610fa">DGtal::functors::ConstImageFunctorHolder::ConstImageFunctorHolder</a></div><div class="ttdeci">ConstImageFunctorHolder(Domain const &amp;aDomain, TGivenFunctor &amp;&amp;aFunctor)</div><div class="ttdoc">Constructor.</div><div class="ttdef"><b>Definition:</b> <a href="ConstImageFunctorHolder_8h_source.html#l00143">ConstImageFunctorHolder.h:143</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z2i_html_afa16730fe413692cdb474b45d4fff388"><div class="ttname"><a href="namespaceDGtal_1_1Z2i.html#afa16730fe413692cdb474b45d4fff388">DGtal::Z2i::l2Metric</a></div><div class="ttdeci">static const L2Metric l2Metric</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00123">StdDefs.h:123</a></div></div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_a852ab282e5168b5711ef7a87b3aefa68"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a852ab282e5168b5711ef7a87b3aefa68">Image</a></div><div class="ttdeci">ImageContainerBySTLVector&lt; Domain, Value &gt; Image</div><div class="ttdef"><b>Definition:</b> <a href="testSimpleRandomAccessRangeFromPoint_8cpp_source.html#l00045">testSimpleRandomAccessRangeFromPoint.cpp:45</a></div></div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1PointFunctorHolder_html_a9b362748aaa71a04f7fa91f303f44a2c"><div class="ttname"><a href="classDGtal_1_1functors_1_1PointFunctorHolder.html#a9b362748aaa71a04f7fa91f303f44a2c">DGtal::functors::PointFunctorHolder::PointFunctorHolder</a></div><div class="ttdeci">PointFunctorHolder(Function &amp;&amp;fn)</div><div class="ttdoc">Constructor.</div><div class="ttdef"><b>Definition:</b> <a href="PointFunctorHolder_8h_source.html#l00119">PointFunctorHolder.h:119</a></div></div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_acd532b318489cd93df57e0b3d136d050"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a></div><div class="ttdeci">HyperRectDomain&lt; Space &gt; Domain</div><div class="ttdef"><b>Definition:</b> <a href="testSimpleRandomAccessRangeFromPoint_8cpp_source.html#l00044">testSimpleRandomAccessRangeFromPoint.cpp:44</a></div></div>
<div class="ttc" id="aexampleFunctorHolder_8cpp_html_a65616cde20c32b627a9256ee9a2177a9"><div class="ttname"><a href="exampleFunctorHolder_8cpp.html#a65616cde20c32b627a9256ee9a2177a9">signed_dist_to_unit_circle</a></div><div class="ttdeci">double signed_dist_to_unit_circle(DGtal::PointVector&lt; 2, double &gt; const &amp;pt)</div><div class="ttdoc">[signed_dist_to_unit_circle]</div><div class="ttdef"><b>Definition:</b> <a href="exampleFunctorHolder_8cpp_source.html#l00052">exampleFunctorHolder.cpp:52</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1functors_html_ae078b1e517d167341988d5a5d6366a91"><div class="ttname"><a href="namespaceDGtal_1_1functors.html#ae078b1e517d167341988d5a5d6366a91">DGtal::functors::holdConstImageFunctor</a></div><div class="ttdeci">auto holdConstImageFunctor(TDomain const &amp;aDomain, TFunctor &amp;&amp;aFunctor) -&gt; ConstImageFunctorHolder&lt; TDomain, TValue, decltype(holdFunctor(std::forward&lt; TFunctor &gt;(aFunctor)))&gt;</div><div class="ttdoc">ConstImageFunctorHolder construction helper with specification of the return type.</div><div class="ttdef"><b>Definition:</b> <a href="ConstImageFunctorHolder_8h_source.html#l00277">ConstImageFunctorHolder.h:277</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z2i_html_a9b96ab8175cf9c54b1f451858ccd46a4"><div class="ttname"><a href="namespaceDGtal_1_1Z2i.html#a9b96ab8175cf9c54b1f451858ccd46a4">DGtal::Z2i::Space</a></div><div class="ttdeci">SpaceND&lt; 2, Integer &gt; Space</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00075">StdDefs.h:75</a></div></div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1ConstImageFunctorHolder_html_a7adca365c6f317a7b7ba6cef4efbe7dc"><div class="ttname"><a href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a7adca365c6f317a7b7ba6cef4efbe7dc">DGtal::functors::ConstImageFunctorHolder::ConstReverseIterator</a></div><div class="ttdeci">std::reverse_iterator&lt; ConstIterator &gt; ConstReverseIterator</div><div class="ttdef"><b>Definition:</b> <a href="ConstImageFunctorHolder_8h_source.html#l00123">ConstImageFunctorHolder.h:123</a></div></div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1PointFunctorHolder_html_a04877a37081c035218759dae3b54d7cf"><div class="ttname"><a href="classDGtal_1_1functors_1_1PointFunctorHolder.html#a04877a37081c035218759dae3b54d7cf">DGtal::functors::PointFunctorHolder::Functor</a></div><div class="ttdeci">TFunctor Functor</div><div class="ttdef"><b>Definition:</b> <a href="PointFunctorHolder_8h_source.html#l00104">PointFunctorHolder.h:104</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z2i_html_aca523bebdae58eb19385aaefffff8bc5"><div class="ttname"><a href="namespaceDGtal_1_1Z2i.html#aca523bebdae58eb19385aaefffff8bc5">DGtal::Z2i::Domain</a></div><div class="ttdeci">HyperRectDomain&lt; Space &gt; Domain</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00099">StdDefs.h:99</a></div></div>
<div class="ttc" id="aexampleFunctorHolder_8cpp_html_a24597e953891697572ee4dfda12ca272"><div class="ttname"><a href="exampleFunctorHolder_8cpp.html#a24597e953891697572ee4dfda12ca272">get_trivial_binarizer</a></div><div class="ttdeci">decltype(DGtal::functors::holdFunctor(Binarizer&lt; T &gt;(128))) get_trivial_binarizer()</div><div class="ttdef"><b>Definition:</b> <a href="exampleFunctorHolder_8cpp_source.html#l00102">exampleFunctorHolder.cpp:102</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z2i_html_a5334b5612687982f0154e4ee8f5dd93d"><div class="ttname"><a href="namespaceDGtal_1_1Z2i.html#a5334b5612687982f0154e4ee8f5dd93d">DGtal::Z2i::L2Metric</a></div><div class="ttdeci">ExactPredicateLpSeparableMetric&lt; Space, 2 &gt; L2Metric</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00118">StdDefs.h:118</a></div></div>
<div class="ttc" id="atestCombinDSS_8cpp_html_a609ee1808a3b4f883fb28df65e9a2ed6"><div class="ttname"><a href="testCombinDSS_8cpp.html#a609ee1808a3b4f883fb28df65e9a2ed6">Vector</a></div><div class="ttdeci">FreemanChain&lt; int &gt;::Vector Vector</div><div class="ttdef"><b>Definition:</b> <a href="testCombinDSS_8cpp_source.html#l00060">testCombinDSS.cpp:60</a></div></div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1PointFunctorHolder_html_af9ae4eec22e3132acee4828f8612010c"><div class="ttname"><a href="classDGtal_1_1functors_1_1PointFunctorHolder.html#af9ae4eec22e3132acee4828f8612010c">DGtal::functors::PointFunctorHolder::myFunctor</a></div><div class="ttdeci">Functor myFunctor</div><div class="ttdoc">The held functor.</div><div class="ttdef"><b>Definition:</b> <a href="PointFunctorHolder_8h_source.html#l00160">PointFunctorHolder.h:160</a></div></div>
<div class="ttc" id="aexampleFunctorHolder_8cpp_html_a8c41fc3212565f9503f1eb15abca1eea"><div class="ttname"><a href="exampleFunctorHolder_8cpp.html#a8c41fc3212565f9503f1eb15abca1eea">templated_signed_dist_to_unit_circle</a></div><div class="ttdeci">Point::Component templated_signed_dist_to_unit_circle(Point const &amp;pt)</div><div class="ttdoc">[signed_dist_to_unit_circle]</div><div class="ttdef"><b>Definition:</b> <a href="exampleFunctorHolder_8cpp_source.html#l00062">exampleFunctorHolder.cpp:62</a></div></div>
<div class="ttc" id="aclassDGtal_1_1PointVector_html_a621809d6682ec859fd761f60b23ba2b7"><div class="ttname"><a href="classDGtal_1_1PointVector.html#a621809d6682ec859fd761f60b23ba2b7">DGtal::PointVector::norm</a></div><div class="ttdeci">double norm(const NormType type=L_2) const</div></div>
<div class="ttc" id="aclassDGtal_1_1HyperRectDomain__Iterator_html"><div class="ttname"><a href="classDGtal_1_1HyperRectDomain__Iterator.html">DGtal::HyperRectDomain_Iterator</a></div><div class="ttdoc">Iterator for HyperRectDomain.</div><div class="ttdef"><b>Definition:</b> <a href="HyperRectDomain__Iterator_8h_source.html#l00142">HyperRectDomain_Iterator.h:154</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1functors_html_a5f6d83ea035f33c3d3fa47730be1ce9d"><div class="ttname"><a href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a></div><div class="ttdeci">auto holdFunctor(Function &amp;&amp;fn) -&gt; decltype(holdFunctorImpl(std::forward&lt; Function &gt;(fn), typename std::is_lvalue_reference&lt; Function &gt;</div><div class="ttdoc">Hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model.</div><div class="ttdef"><b>Definition:</b> <a href="FunctorHolder_8h_source.html#l00279">FunctorHolder.h:279</a></div></div>
<div class="ttc" id="atestProjection_8cpp_html_a1f1a69f8d8b037b72c2160ed12b3ef51"><div class="ttname"><a href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a></div><div class="ttdeci">Domain domain</div><div class="ttdef"><b>Definition:</b> <a href="testProjection_8cpp_source.html#l00088">testProjection.cpp:88</a></div></div>
<div class="ttc" id="aclassDGtal_1_1PointVector_html"><div class="ttname"><a href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt; 2, double &gt;</a></div></div>
<div class="ttc" id="aexampleFunctorHolder_8cpp_html_a024528ac00c71adf2ed4208a601d8218"><div class="ttname"><a href="exampleFunctorHolder_8cpp.html#a024528ac00c71adf2ed4208a601d8218">get_mean_binarizer_from_an_image</a></div><div class="ttdeci">auto get_mean_binarizer_from_an_image(std::string const &amp;file_name) -&gt; decltype(get_mean_binarizer_from_range(std::declval&lt; Image &gt;().begin(), std::declval&lt; Image &gt;().end()))</div><div class="ttdoc">[Returning a FunctorHolder using trailing return]</div><div class="ttdef"><b>Definition:</b> <a href="exampleFunctorHolder_8cpp_source.html#l00123">exampleFunctorHolder.cpp:123</a></div></div>
<div class="ttc" id="aexampleFunctorHolder_8cpp_html_a6cdfd61459d5f575b8c49de13c7d4889"><div class="ttname"><a href="exampleFunctorHolder_8cpp.html#a6cdfd61459d5f575b8c49de13c7d4889">makePointFunctorPredicate_Example2</a></div><div class="ttdeci">DGtal::functors::PointFunctorPredicate&lt; typename std::decay&lt; PointFunctor &gt;::type, typename std::decay&lt; Predicate &gt;::type &gt; makePointFunctorPredicate_Example2(PointFunctor &amp;&amp;aFun, Predicate &amp;&amp;aPred)</div><div class="ttdoc">[Factory of PointFunctorPredicate]</div><div class="ttdef"><b>Definition:</b> <a href="exampleFunctorHolder_8cpp_source.html#l00191">exampleFunctorHolder.cpp:191</a></div></div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1PointFunctorHolder_html_ab3bb99c9e1d5518bee5016183fc480f7"><div class="ttname"><a href="classDGtal_1_1functors_1_1PointFunctorHolder.html#ab3bb99c9e1d5518bee5016183fc480f7">DGtal::functors::PointFunctorHolder::Self</a></div><div class="ttdeci">PointFunctorHolder&lt; TPoint, TValue, TFunctor &gt; Self</div><div class="ttdef"><b>Definition:</b> <a href="PointFunctorHolder_8h_source.html#l00101">PointFunctorHolder.h:101</a></div></div>
<div class="ttc" id="aexampleFunctorHolder_8cpp_html_aa31c0f42bbc8c9da6dca73690c027a63"><div class="ttname"><a href="exampleFunctorHolder_8cpp.html#aa31c0f42bbc8c9da6dca73690c027a63">get_mean_binarizer_from_range</a></div><div class="ttdeci">auto get_mean_binarizer_from_range(Iterator first, Iterator last) -&gt; decltype(DGtal::functors::holdFunctor(Binarizer&lt; decltype(*first/std::distance(first, last))&gt;(0)))</div><div class="ttdoc">[Returning a FunctorHolder]</div><div class="ttdef"><b>Definition:</b> <a href="exampleFunctorHolder_8cpp_source.html#l00110">exampleFunctorHolder.cpp:110</a></div></div>
<div class="ttc" id="atestClone2_8cpp_html_a15e9592ccc512dc691b46185e6814758"><div class="ttname"><a href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a></div><div class="ttdeci">MyPointD Point</div><div class="ttdef"><b>Definition:</b> <a href="testClone2_8cpp_source.html#l00383">testClone2.cpp:383</a></div></div>
<div class="ttc" id="astructDGtal_1_1functors_1_1PointFunctorPredicate_html"><div class="ttname"><a href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate</a></div><div class="ttdoc">Aim: The predicate returns true when the predicate returns true for the value assigned to a given poi...</div><div class="ttdef"><b>Definition:</b> <a href="BasicPointPredicates_8h_source.html#l00370">BasicPointPredicates.h:371</a></div></div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_a566a00621638570a4186414035153a2e"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Value</a></div><div class="ttdeci">double Value</div><div class="ttdef"><b>Definition:</b> <a href="testSimpleRandomAccessRangeFromPoint_8cpp_source.html#l00041">testSimpleRandomAccessRangeFromPoint.cpp:38</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 9 2020 08:58:40 for DGtal by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
