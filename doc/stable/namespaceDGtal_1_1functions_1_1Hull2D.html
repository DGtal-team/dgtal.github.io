<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: DGtal::functions::Hull2D Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;1.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespaceDGtal_1_1functions_1_1Hull2D.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">DGtal::functions::Hull2D Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html" title="Hull2D namespace gathers useful functions to compute and return the convex hull or the alpha-shape of...">Hull2D</a> namespace gathers useful functions to compute and return the convex hull or the alpha-shape of a range of 2D points.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ade3b11c94c4d3736bb8efc7abcc58735" id="r_ade3b11c94c4d3736bb8efc7abcc58735"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade3b11c94c4d3736bb8efc7abcc58735">ThicknessDefinition</a> { <a class="el" href="#ade3b11c94c4d3736bb8efc7abcc58735a602f83cef2331731bf233abeaf2c0ff6">HorizontalVerticalThickness</a>
, <a class="el" href="#ade3b11c94c4d3736bb8efc7abcc58735aff78d557b689bb7423b38a557884134e">EuclideanThickness</a>
 }</td></tr>
<tr class="memdesc:ade3b11c94c4d3736bb8efc7abcc58735"><td class="mdescLeft">&#160;</td><td class="mdescRight">The 2 thickness definitions.  <a href="#ade3b11c94c4d3736bb8efc7abcc58735">More...</a><br /></td></tr>
<tr class="separator:ade3b11c94c4d3736bb8efc7abcc58735"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad39d6db9714b4194a49a178916ad886c" id="r_ad39d6db9714b4194a49a178916ad886c"><td class="memTemplParams" colspan="2">template&lt;typename Stack , typename <a class="el" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> , typename Predicate &gt; </td></tr>
<tr class="memitem:ad39d6db9714b4194a49a178916ad886c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad39d6db9714b4194a49a178916ad886c">updateHullWithStack</a> (Stack &amp;aStack, const <a class="el" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> &amp;aNewPoint, const Predicate &amp;aPredicate)</td></tr>
<tr class="memdesc:ad39d6db9714b4194a49a178916ad886c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure that updates the hull when an extra point <em>aNewPoint</em> is considered: while the last three consecutive points, ie. <em>aNewPoint</em> and the last two points of the container are not oriented such that the predicate <em>aPredicate</em> returns 'true', <br  />
 the last point of the container is removed.  <br /></td></tr>
<tr class="separator:ad39d6db9714b4194a49a178916ad886c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9e05cfa0179a24f8db24e3b5abaeae" id="r_aca9e05cfa0179a24f8db24e3b5abaeae"><td class="memTemplParams" colspan="2">template&lt;typename Stack , typename <a class="el" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> , typename Predicate &gt; </td></tr>
<tr class="memitem:aca9e05cfa0179a24f8db24e3b5abaeae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca9e05cfa0179a24f8db24e3b5abaeae">updateHullWithAdaptedStack</a> (Stack aStack, const <a class="el" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> &amp;aNewPoint, const Predicate &amp;aPredicate)</td></tr>
<tr class="memdesc:aca9e05cfa0179a24f8db24e3b5abaeae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure that calls <a class="el" href="#ad39d6db9714b4194a49a178916ad886c" title="Procedure that updates the hull when an extra point aNewPoint is considered: while the last three con...">Hull2D::updateHullWithStack</a> on a copy of the stack object used to retrieved the hull vertices. Useful when the first argument is a stack adapter returned by a function: it must be copied before being passed by reference in <a class="el" href="#ad39d6db9714b4194a49a178916ad886c" title="Procedure that updates the hull when an extra point aNewPoint is considered: while the last three con...">Hull2D::updateHullWithStack</a>.  <br /></td></tr>
<tr class="separator:aca9e05cfa0179a24f8db24e3b5abaeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b3737b4aeb5443d541b9336116f6d8" id="r_a22b3737b4aeb5443d541b9336116f6d8"><td class="memTemplParams" colspan="2">template&lt;typename Stack , typename ForwardIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:a22b3737b4aeb5443d541b9336116f6d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a22b3737b4aeb5443d541b9336116f6d8">buildHullWithStack</a> (Stack &amp;aStack, const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, const Predicate &amp;aPredicate)</td></tr>
<tr class="memdesc:a22b3737b4aeb5443d541b9336116f6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP) in linear-time. This technique is called Sklansky's scan, Graham's scan or 3-coins algorithm. <br  />
 It works for all WEVP [Toussaint and Avis, 1982 : <a class="el" href="citelist.html#CITEREF_ToussaintAvis1982">[115]</a>]. <br  />
  <br /></td></tr>
<tr class="separator:a22b3737b4aeb5443d541b9336116f6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c864509908d68566f323096fbe7bbcc" id="r_a6c864509908d68566f323096fbe7bbcc"><td class="memTemplParams" colspan="2">template&lt;typename Stack , typename ForwardIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:a6c864509908d68566f323096fbe7bbcc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6c864509908d68566f323096fbe7bbcc">buildHullWithAdaptedStack</a> (Stack aStack, const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, const Predicate &amp;aPredicate)</td></tr>
<tr class="memdesc:a6c864509908d68566f323096fbe7bbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure that calls <a class="el" href="#a22b3737b4aeb5443d541b9336116f6d8" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::buildHullWithStack</a> on a copy of the stack object used to retrieved the hull vertices. Useful when the first argument is a stack adapter returned by a function: it must be copied before being passed by reference in <a class="el" href="#a22b3737b4aeb5443d541b9336116f6d8" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::buildHullWithStack</a>.  <br /></td></tr>
<tr class="separator:a6c864509908d68566f323096fbe7bbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f28de021eaafe900082eb65d90f37d1" id="r_a7f28de021eaafe900082eb65d90f37d1"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:a7f28de021eaafe900082eb65d90f37d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7f28de021eaafe900082eb65d90f37d1">openGrahamScan</a> (const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, OutputIterator res, const Predicate &amp;aPredicate)</td></tr>
<tr class="memdesc:a7f28de021eaafe900082eb65d90f37d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP) in linear-time.  <br /></td></tr>
<tr class="separator:a7f28de021eaafe900082eb65d90f37d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2e79bf291793719f2425323ae61fee" id="r_aec2e79bf291793719f2425323ae61fee"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:aec2e79bf291793719f2425323ae61fee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aec2e79bf291793719f2425323ae61fee">closedGrahamScanFromVertex</a> (const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, OutputIterator res, const Predicate &amp;aPredicate)</td></tr>
<tr class="memdesc:aec2e79bf291793719f2425323ae61fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP) in linear-time.  <br /></td></tr>
<tr class="separator:aec2e79bf291793719f2425323ae61fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a5b9f6ff0943c40f07fb9128313af7" id="r_a36a5b9f6ff0943c40f07fb9128313af7"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:a36a5b9f6ff0943c40f07fb9128313af7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a36a5b9f6ff0943c40f07fb9128313af7">closedGrahamScanFromAnyPoint</a> (const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, OutputIterator res, const Predicate &amp;aPredicate)</td></tr>
<tr class="memdesc:a36a5b9f6ff0943c40f07fb9128313af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP) in linear-time.  <br /></td></tr>
<tr class="separator:a36a5b9f6ff0943c40f07fb9128313af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9140238e424c6e4121991d410a19011" id="r_ae9140238e424c6e4121991d410a19011"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate , typename PolarComparator &gt; </td></tr>
<tr class="memitem:ae9140238e424c6e4121991d410a19011"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae9140238e424c6e4121991d410a19011">grahamConvexHullAlgorithm</a> (const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, OutputIterator res, const Predicate &amp;aPredicate, PolarComparator &amp;aPolarComparator)</td></tr>
<tr class="memdesc:ae9140238e424c6e4121991d410a19011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure that retrieves the vertices of the convex hull of a set of 2D points given by the range [ <em>itb</em> , <em>ite</em> ). This procedure follows the well-known Graham's algorithm [Graham, 1972 : <a class="el" href="citelist.html#CITEREF_Graham1972">[61]</a>].  <br /></td></tr>
<tr class="separator:ae9140238e424c6e4121991d410a19011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e12e0b39f5b9a4f766d9915fb51c15a" id="r_a9e12e0b39f5b9a4f766d9915fb51c15a"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate , typename PolarComparator &gt; </td></tr>
<tr class="memitem:a9e12e0b39f5b9a4f766d9915fb51c15a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9e12e0b39f5b9a4f766d9915fb51c15a">grahamConvexHullAlgorithm</a> (const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, OutputIterator res, const Predicate &amp;aPredicate)</td></tr>
<tr class="memdesc:a9e12e0b39f5b9a4f766d9915fb51c15a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure that retrieves the vertices of the convex hull of a set of 2D points given by the range [ <em>itb</em> , <em>ite</em> ). This procedure follows the well-known Graham's algorithm [Graham, 1972 : <a class="el" href="citelist.html#CITEREF_Graham1972">[61]</a>].  <br /></td></tr>
<tr class="separator:a9e12e0b39f5b9a4f766d9915fb51c15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248898c40cc98e35b6dbcfe944c8adff" id="r_a248898c40cc98e35b6dbcfe944c8adff"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:a248898c40cc98e35b6dbcfe944c8adff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a248898c40cc98e35b6dbcfe944c8adff">andrewConvexHullAlgorithm</a> (const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, OutputIterator res, const Predicate &amp;aPredicate)</td></tr>
<tr class="memdesc:a248898c40cc98e35b6dbcfe944c8adff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure that retrieves the vertices of the hull of a set of 2D points given by the range [ <em>itb</em> , <em>ite</em> ). This procedure follows the well-known monotone-chain algorithm due to [Andrew, 1979 : <a class="el" href="citelist.html#CITEREF_Andrew1979">[6]</a>].  <br /></td></tr>
<tr class="separator:a248898c40cc98e35b6dbcfe944c8adff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85c48fa77f6284d8d43808576ba474b" id="r_aa85c48fa77f6284d8d43808576ba474b"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:aa85c48fa77f6284d8d43808576ba474b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa85c48fa77f6284d8d43808576ba474b">computeHullThickness</a> (const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, const <a class="el" href="#ade3b11c94c4d3736bb8efc7abcc58735">ThicknessDefinition</a> &amp;def)</td></tr>
<tr class="memdesc:aa85c48fa77f6284d8d43808576ba474b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure to compute the convex hull thickness given from different definitions (Horizontal/vertical or Euclidean distances). It takes as input the vertices of the hull given by the range [<em>itbn</em>, <em>ite</em>). The procedure applies the classic rotating caliper to recover all anti-podal pairs.  <br /></td></tr>
<tr class="separator:aa85c48fa77f6284d8d43808576ba474b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88085aa9d56842df67fe82301da58c0" id="r_ab88085aa9d56842df67fe82301da58c0"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename TInputPoint &gt; </td></tr>
<tr class="memitem:ab88085aa9d56842df67fe82301da58c0"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab88085aa9d56842df67fe82301da58c0">computeHullThickness</a> (const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, const <a class="el" href="#ade3b11c94c4d3736bb8efc7abcc58735">ThicknessDefinition</a> &amp;def, TInputPoint &amp;antipodalEdgeP, TInputPoint &amp;antipodalEdgeQ, TInputPoint &amp;antipodalVertexR)</td></tr>
<tr class="memdesc:ab88085aa9d56842df67fe82301da58c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure to compute the convex hull thickness given from different definitions (Horizontal/vertical or Euclidean distances). It takes as input the vertices of the hull given by the range [<em>itbn</em>, <em>ite</em>). The procedure applies the classic rotating caliper to recover all anti-podal pairs.  <br /></td></tr>
<tr class="separator:ab88085aa9d56842df67fe82301da58c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb410b2e853bbdbece9846f67ba8205" id="r_a5cb410b2e853bbdbece9846f67ba8205"><td class="memTemplParams" colspan="2">template&lt;typename TInputPoint &gt; </td></tr>
<tr class="memitem:a5cb410b2e853bbdbece9846f67ba8205"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5cb410b2e853bbdbece9846f67ba8205">getAngle</a> (const TInputPoint &amp;a, const TInputPoint &amp;b, const TInputPoint &amp;c, const TInputPoint &amp;d)</td></tr>
<tr class="separator:a5cb410b2e853bbdbece9846f67ba8205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3ba937825de5fe249a0507780bd42e" id="r_aeb3ba937825de5fe249a0507780bd42e"><td class="memTemplParams" colspan="2">template&lt;typename TInputPoint &gt; </td></tr>
<tr class="memitem:aeb3ba937825de5fe249a0507780bd42e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeb3ba937825de5fe249a0507780bd42e">isCoLinearOpp</a> (const TInputPoint &amp;a, const TInputPoint &amp;b, const TInputPoint &amp;c, const TInputPoint &amp;d)</td></tr>
<tr class="separator:aeb3ba937825de5fe249a0507780bd42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac0d68ce84ccfb5fe88ffb0d05b2882" id="r_a9ac0d68ce84ccfb5fe88ffb0d05b2882"><td class="memTemplParams" colspan="2">template&lt;typename TInputPoint &gt; </td></tr>
<tr class="memitem:a9ac0d68ce84ccfb5fe88ffb0d05b2882"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9ac0d68ce84ccfb5fe88ffb0d05b2882">getThicknessAntipodalPair</a> (const TInputPoint &amp;p, const TInputPoint &amp;q, const TInputPoint &amp;r, const <a class="el" href="#ade3b11c94c4d3736bb8efc7abcc58735">ThicknessDefinition</a> &amp;def)</td></tr>
<tr class="separator:a9ac0d68ce84ccfb5fe88ffb0d05b2882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131a4cdda34d1cc8815c0041d7514174" id="r_a131a4cdda34d1cc8815c0041d7514174"><td class="memTemplParams" colspan="2">template&lt;typename TInputPoint &gt; </td></tr>
<tr class="memitem:a131a4cdda34d1cc8815c0041d7514174"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a131a4cdda34d1cc8815c0041d7514174">computeHProjDistance</a> (const TInputPoint &amp;a, const TInputPoint &amp;b, const TInputPoint &amp;c, bool &amp;isInside)</td></tr>
<tr class="separator:a131a4cdda34d1cc8815c0041d7514174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4323af52b2db409c4a76e8f4f2245f59" id="r_a4323af52b2db409c4a76e8f4f2245f59"><td class="memTemplParams" colspan="2">template&lt;typename TInputPoint &gt; </td></tr>
<tr class="memitem:a4323af52b2db409c4a76e8f4f2245f59"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4323af52b2db409c4a76e8f4f2245f59">computeVProjDistance</a> (const TInputPoint &amp;a, const TInputPoint &amp;b, const TInputPoint &amp;c, bool &amp;isInside)</td></tr>
<tr class="separator:a4323af52b2db409c4a76e8f4f2245f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367555edf6627f6b054f5910778e84a5" id="r_a367555edf6627f6b054f5910778e84a5"><td class="memTemplParams" colspan="2">template&lt;typename TInputPoint &gt; </td></tr>
<tr class="memitem:a367555edf6627f6b054f5910778e84a5"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a367555edf6627f6b054f5910778e84a5">computeEuclideanDistance</a> (const TInputPoint &amp;a, const TInputPoint &amp;b, const TInputPoint &amp;c, bool &amp;isInside)</td></tr>
<tr class="separator:a367555edf6627f6b054f5910778e84a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab511ebdfea4fa4b0d02901fa5f1464" id="r_acab511ebdfea4fa4b0d02901fa5f1464"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator , typename Functor &gt; </td></tr>
<tr class="memitem:acab511ebdfea4fa4b0d02901fa5f1464"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acab511ebdfea4fa4b0d02901fa5f1464">melkmanConvexHullAlgorithm</a> (const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, OutputIterator res, Functor &amp;aFunctor)</td></tr>
<tr class="memdesc:acab511ebdfea4fa4b0d02901fa5f1464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure that retrieves the vertices of the hull of a set of 2D points given by the range [ <em>itb</em> , <em>ite</em> ). This procedure follows the well-known Melkman algorithm [Melkman, 1979 : <a class="el" href="citelist.html#CITEREF_Melkman1987">[87]</a>].  <br /></td></tr>
<tr class="separator:acab511ebdfea4fa4b0d02901fa5f1464"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:adff77b38274dbe620dfa709b71b7b338" id="r_adff77b38274dbe620dfa709b71b7b338"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adff77b38274dbe620dfa709b71b7b338">angleTolerance</a> = 1e-6</td></tr>
<tr class="separator:adff77b38274dbe620dfa709b71b7b338"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html" title="Hull2D namespace gathers useful functions to compute and return the convex hull or the alpha-shape of...">Hull2D</a> namespace gathers useful functions to compute and return the convex hull or the alpha-shape of a range of 2D points. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ade3b11c94c4d3736bb8efc7abcc58735" name="ade3b11c94c4d3736bb8efc7abcc58735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3b11c94c4d3736bb8efc7abcc58735">&#9670;&#160;</a></span>ThicknessDefinition</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ade3b11c94c4d3736bb8efc7abcc58735">DGtal::functions::Hull2D::ThicknessDefinition</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The 2 thickness definitions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ade3b11c94c4d3736bb8efc7abcc58735a602f83cef2331731bf233abeaf2c0ff6" name="ade3b11c94c4d3736bb8efc7abcc58735a602f83cef2331731bf233abeaf2c0ff6"></a>HorizontalVerticalThickness&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ade3b11c94c4d3736bb8efc7abcc58735aff78d557b689bb7423b38a557884134e" name="ade3b11c94c4d3736bb8efc7abcc58735aff78d557b689bb7423b38a557884134e"></a>EuclideanThickness&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Hull2DHelpers_8h_source.html#l00078">78</a> of file <a class="el" href="Hull2DHelpers_8h_source.html">Hull2DHelpers.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   78</span>{<a class="code hl_enumvalue" href="#ade3b11c94c4d3736bb8efc7abcc58735a602f83cef2331731bf233abeaf2c0ff6">HorizontalVerticalThickness</a>, <a class="code hl_enumvalue" href="#ade3b11c94c4d3736bb8efc7abcc58735aff78d557b689bb7423b38a557884134e">EuclideanThickness</a>};</div>
<div class="ttc" id="anamespaceDGtal_1_1functions_1_1Hull2D_html_ade3b11c94c4d3736bb8efc7abcc58735a602f83cef2331731bf233abeaf2c0ff6"><div class="ttname"><a href="#ade3b11c94c4d3736bb8efc7abcc58735a602f83cef2331731bf233abeaf2c0ff6">DGtal::functions::Hull2D::HorizontalVerticalThickness</a></div><div class="ttdeci">@ HorizontalVerticalThickness</div><div class="ttdef"><b>Definition</b> <a href="Hull2DHelpers_8h_source.html#l00078">Hull2DHelpers.h:78</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1functions_1_1Hull2D_html_ade3b11c94c4d3736bb8efc7abcc58735aff78d557b689bb7423b38a557884134e"><div class="ttname"><a href="#ade3b11c94c4d3736bb8efc7abcc58735aff78d557b689bb7423b38a557884134e">DGtal::functions::Hull2D::EuclideanThickness</a></div><div class="ttdeci">@ EuclideanThickness</div><div class="ttdef"><b>Definition</b> <a href="Hull2DHelpers_8h_source.html#l00078">Hull2DHelpers.h:78</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a248898c40cc98e35b6dbcfe944c8adff" name="a248898c40cc98e35b6dbcfe944c8adff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a248898c40cc98e35b6dbcfe944c8adff">&#9670;&#160;</a></span>andrewConvexHullAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::Hull2D::andrewConvexHullAlgorithm </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator &amp;</td>          <td class="paramname"><span class="paramname"><em>itb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;</td>          <td class="paramname"><span class="paramname"><em>ite</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator</td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;</td>          <td class="paramname"><span class="paramname"><em>aPredicate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure that retrieves the vertices of the hull of a set of 2D points given by the range [ <em>itb</em> , <em>ite</em> ). This procedure follows the well-known monotone-chain algorithm due to [Andrew, 1979 : <a class="el" href="citelist.html#CITEREF_Andrew1979">[6]</a>]. </p>
<ul>
<li>first, points are sorted along the horizontal axis.</li>
<li>then, the lower and upper convex hull are computed by a simple Graham scan. <dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7f28de021eaafe900082eb65d90f37d1" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::openGrahamScan</a></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The first point of the resulting list of extremal points follows the one with minimal x-coordinate and y-coordinate. Orientation depends on the predicate.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator </td></tr>
    <tr><td class="paramname">res</td><td>output iterator used to export the retrieved points </td></tr>
    <tr><td class="paramname">aPredicate</td><td>any ternary predicate <br  />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForwardIterator</td><td>a model of forward and readable iterator </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of incrementable and writable iterator <br  />
 </td></tr>
    <tr><td class="paramname">Predicate</td><td>a model of ternary predicate </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a6c864509908d68566f323096fbe7bbcc" name="a6c864509908d68566f323096fbe7bbcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c864509908d68566f323096fbe7bbcc">&#9670;&#160;</a></span>buildHullWithAdaptedStack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stack , typename ForwardIterator , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::Hull2D::buildHullWithAdaptedStack </td>
          <td>(</td>
          <td class="paramtype">Stack</td>          <td class="paramname"><span class="paramname"><em>aStack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;</td>          <td class="paramname"><span class="paramname"><em>itb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;</td>          <td class="paramname"><span class="paramname"><em>ite</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;</td>          <td class="paramname"><span class="paramname"><em>aPredicate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure that calls <a class="el" href="#a22b3737b4aeb5443d541b9336116f6d8" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::buildHullWithStack</a> on a copy of the stack object used to retrieved the hull vertices. Useful when the first argument is a stack adapter returned by a function: it must be copied before being passed by reference in <a class="el" href="#a22b3737b4aeb5443d541b9336116f6d8" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::buildHullWithStack</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aStack</td><td>stack copy </td></tr>
    <tr><td class="paramname">itb</td><td>begin iterator </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator </td></tr>
    <tr><td class="paramname">aPredicate</td><td>predicate <br  />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stack</td><td>a model of CStack </td></tr>
    <tr><td class="paramname">ForwardIterator</td><td>a model of forward and readable iterator </td></tr>
    <tr><td class="paramname">Predicate</td><td>a model of ternary predicate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a22b3737b4aeb5443d541b9336116f6d8" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::buildHullWithStack</a> </dd></dl>

</div>
</div>
<a id="a22b3737b4aeb5443d541b9336116f6d8" name="a22b3737b4aeb5443d541b9336116f6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b3737b4aeb5443d541b9336116f6d8">&#9670;&#160;</a></span>buildHullWithStack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stack , typename ForwardIterator , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::Hull2D::buildHullWithStack </td>
          <td>(</td>
          <td class="paramtype">Stack &amp;</td>          <td class="paramname"><span class="paramname"><em>aStack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;</td>          <td class="paramname"><span class="paramname"><em>itb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;</td>          <td class="paramname"><span class="paramname"><em>ite</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;</td>          <td class="paramname"><span class="paramname"><em>aPredicate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP) in linear-time. This technique is called Sklansky's scan, Graham's scan or 3-coins algorithm. <br  />
 It works for all WEVP [Toussaint and Avis, 1982 : <a class="el" href="citelist.html#CITEREF_ToussaintAvis1982">[115]</a>]. <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aStack</td><td>reference to the stack of retrieved vertices </td></tr>
    <tr><td class="paramname">itb</td><td>begin iterator </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator </td></tr>
    <tr><td class="paramname">aPredicate</td><td>predicate <br  />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stack</td><td>a model of CStack </td></tr>
    <tr><td class="paramname">ForwardIterator</td><td>a model of forward and readable iterator </td></tr>
    <tr><td class="paramname">Predicate</td><td>a model of ternary predicate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad39d6db9714b4194a49a178916ad886c" title="Procedure that updates the hull when an extra point aNewPoint is considered: while the last three con...">Hull2D::updateHullWithStack</a> </dd></dl>

</div>
</div>
<a id="a36a5b9f6ff0943c40f07fb9128313af7" name="a36a5b9f6ff0943c40f07fb9128313af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a5b9f6ff0943c40f07fb9128313af7">&#9670;&#160;</a></span>closedGrahamScanFromAnyPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::Hull2D::closedGrahamScanFromAnyPoint </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator &amp;</td>          <td class="paramname"><span class="paramname"><em>itb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;</td>          <td class="paramname"><span class="paramname"><em>ite</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator</td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;</td>          <td class="paramname"><span class="paramname"><em>aPredicate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP) in linear-time. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a22b3737b4aeb5443d541b9336116f6d8" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::buildHullWithStack</a> <a class="el" href="#aec2e79bf291793719f2425323ae61fee" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::closedGrahamScanFromVertex</a></dd></dl>
<p>NB: We do not assume that the starting point of the polygon is an extremal point like in <a class="el" href="#aec2e79bf291793719f2425323ae61fee" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::closedGrahamScanFromVertex</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator </td></tr>
    <tr><td class="paramname">res</td><td>output iterator used to export the retrieved points </td></tr>
    <tr><td class="paramname">aPredicate</td><td>any ternary predicate</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForwardIterator</td><td>a model of forward and readable iterator </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of incremental and writable iterator <br  />
 </td></tr>
    <tr><td class="paramname">Predicate</td><td>a model of ternary predicate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec2e79bf291793719f2425323ae61fee" name="aec2e79bf291793719f2425323ae61fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec2e79bf291793719f2425323ae61fee">&#9670;&#160;</a></span>closedGrahamScanFromVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::Hull2D::closedGrahamScanFromVertex </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator &amp;</td>          <td class="paramname"><span class="paramname"><em>itb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;</td>          <td class="paramname"><span class="paramname"><em>ite</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator</td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;</td>          <td class="paramname"><span class="paramname"><em>aPredicate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP) in linear-time. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a22b3737b4aeb5443d541b9336116f6d8" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::buildHullWithStack</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator </td></tr>
    <tr><td class="paramname">res</td><td>output iterator used to export the retrieved points </td></tr>
    <tr><td class="paramname">aPredicate</td><td>any ternary predicate <br  />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>we assume that the starting point of the polygon is an extremal point.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForwardIterator</td><td>a model of forward and readable iterator </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of incremental and writable iterator <br  />
 </td></tr>
    <tr><td class="paramname">Predicate</td><td>a model of ternary predicate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a367555edf6627f6b054f5910778e84a5" name="a367555edf6627f6b054f5910778e84a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367555edf6627f6b054f5910778e84a5">&#9670;&#160;</a></span>computeEuclideanDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double DGtal::functions::Hull2D::computeEuclideanDistance </td>
          <td>(</td>
          <td class="paramtype">const TInputPoint &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>isInside</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the euclidean distance a point <em>c</em> according to the segment [<em>a</em>, <em>b</em>]. (i.e the distance between <em>c</em> and its projected point on [<em>a</em>,<em>b</em>].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>one point of the segment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>a second point of the segment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>the point for which the vertical distance is computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">isInside</td><td>indicates if the projected point is inside the segment or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a131a4cdda34d1cc8815c0041d7514174" name="a131a4cdda34d1cc8815c0041d7514174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131a4cdda34d1cc8815c0041d7514174">&#9670;&#160;</a></span>computeHProjDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double DGtal::functions::Hull2D::computeHProjDistance </td>
          <td>(</td>
          <td class="paramtype">const TInputPoint &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>isInside</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the horizontal distance a point <code>according</code> to the segment [ <em>a</em> , <em>b</em> ]. (i.e the horizontal projection distance of <code>on</code> [ <em>a</em> , <em>b</em> ]). </p><dl class="section note"><dt>Note</dt><dd>if the segment [<em>a</em>, <em>b</em>] is horizontal (i.e <em>a</em> [1]==<em>b</em>[1]) then an infinite value (std::numerics&lt;double&gt;::max()) is returned.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>one point of the segment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>a second point of the segment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>the point for which the horizontal distance is computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">isInside</td><td>indicates if the projected point is inside the segment or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa85c48fa77f6284d8d43808576ba474b" name="aa85c48fa77f6284d8d43808576ba474b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85c48fa77f6284d8d43808576ba474b">&#9670;&#160;</a></span>computeHullThickness() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double DGtal::functions::Hull2D::computeHullThickness </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator &amp;</td>          <td class="paramname"><span class="paramname"><em>itb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;</td>          <td class="paramname"><span class="paramname"><em>ite</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ade3b11c94c4d3736bb8efc7abcc58735">ThicknessDefinition</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>def</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure to compute the convex hull thickness given from different definitions (Horizontal/vertical or Euclidean distances). It takes as input the vertices of the hull given by the range [<em>itbn</em>, <em>ite</em>). The procedure applies the classic rotating caliper to recover all anti-podal pairs. </p>
<p>Typical use: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1PointVector.html">PointVector&lt;2,DGtal::int32_t&gt;</a> <a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1InHalfPlaneBySimple3x3Matrix.html">InHalfPlaneBySimple3x3Matrix&lt;Point, DGtal::int32_t&gt;</a> <a class="code hl_typedef" href="testConvexHull2DReverse_8cpp.html#a4b95d895f3d8af697b8c550bc833cc9f">Functor</a>;  </div>
<div class="line"><a class="code hl_class" href="classDGtal_1_1MelkmanConvexHull.html">DGtal::MelkmanConvexHull&lt;Point, Functor&gt;</a> <a class="code hl_variable" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>; </div>
<div class="line"><a class="code hl_variable" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.<a class="code hl_function" href="classDGtal_1_1MelkmanConvexHull.html#a857d8322d67e96a0e6a6f5d0774377d2">add</a>(<a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0));</div>
<div class="line"><a class="code hl_variable" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(11,1));</div>
<div class="line"><a class="code hl_variable" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(12,3));</div>
<div class="line"><a class="code hl_variable" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(8,3));</div>
<div class="line"><a class="code hl_variable" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(4,5));</div>
<div class="line"><a class="code hl_variable" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(2,6));</div>
<div class="line"><a class="code hl_variable" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1,4));</div>
<div class="line"><span class="keywordtype">double</span> th = <a class="code hl_function" href="#aa85c48fa77f6284d8d43808576ba474b">computeHullThickness</a>(<a class="code hl_variable" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.begin(), <a class="code hl_variable" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.end(), </div>
<div class="line">                                 <a class="code hl_enumvalue" href="#ade3b11c94c4d3736bb8efc7abcc58735aff78d557b689bb7423b38a557884134e">DGtal::functions::Hull2D::EuclideanThickness</a>);</div>
<div class="ttc" id="aclassDGtal_1_1InHalfPlaneBySimple3x3Matrix_html"><div class="ttname"><a href="classDGtal_1_1InHalfPlaneBySimple3x3Matrix.html">DGtal::InHalfPlaneBySimple3x3Matrix</a></div><div class="ttdoc">Aim: Class that implements an orientation functor, ie. it provides a way to compute the orientation o...</div><div class="ttdef"><b>Definition</b> <a href="InHalfPlaneBySimple3x3Matrix_8h_source.html#l00091">InHalfPlaneBySimple3x3Matrix.h:92</a></div></div>
<div class="ttc" id="aclassDGtal_1_1MelkmanConvexHull_html"><div class="ttname"><a href="classDGtal_1_1MelkmanConvexHull.html">DGtal::MelkmanConvexHull</a></div><div class="ttdoc">Aim: This class implements the on-line algorithm of Melkman for the computation of the convex hull of...</div><div class="ttdef"><b>Definition</b> <a href="MelkmanConvexHull_8h_source.html#l00089">MelkmanConvexHull.h:90</a></div></div>
<div class="ttc" id="aclassDGtal_1_1MelkmanConvexHull_html_a857d8322d67e96a0e6a6f5d0774377d2"><div class="ttname"><a href="classDGtal_1_1MelkmanConvexHull.html#a857d8322d67e96a0e6a6f5d0774377d2">DGtal::MelkmanConvexHull::add</a></div><div class="ttdeci">void add(const Point &amp;aPoint)</div></div>
<div class="ttc" id="aclassDGtal_1_1PointVector_html"><div class="ttname"><a href="classDGtal_1_1PointVector.html">DGtal::PointVector</a></div><div class="ttdoc">Aim: Implements basic operations that will be used in Point and Vector classes.</div><div class="ttdef"><b>Definition</b> <a href="PointVector_8h_source.html#l00592">PointVector.h:593</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1functions_1_1Hull2D_html_aa85c48fa77f6284d8d43808576ba474b"><div class="ttname"><a href="#aa85c48fa77f6284d8d43808576ba474b">DGtal::functions::Hull2D::computeHullThickness</a></div><div class="ttdeci">double computeHullThickness(const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, const ThicknessDefinition &amp;def)</div><div class="ttdoc">Procedure to compute the convex hull thickness given from different definitions (Horizontal/vertical ...</div></div>
<div class="ttc" id="atestClone2_8cpp_html_a15e9592ccc512dc691b46185e6814758"><div class="ttname"><a href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a></div><div class="ttdeci">MyPointD Point</div><div class="ttdef"><b>Definition</b> <a href="testClone2_8cpp_source.html#l00383">testClone2.cpp:383</a></div></div>
<div class="ttc" id="atestConvexHull2DReverse_8cpp_html_a3e9b82c8e3bf7352dbd881a33c21aa52"><div class="ttname"><a href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a></div><div class="ttdeci">DGtal::MelkmanConvexHull&lt; Point, Functor &gt; ch</div><div class="ttdef"><b>Definition</b> <a href="testConvexHull2DReverse_8cpp_source.html#l00052">testConvexHull2DReverse.cpp:52</a></div></div>
<div class="ttc" id="atestConvexHull2DReverse_8cpp_html_a4b95d895f3d8af697b8c550bc833cc9f"><div class="ttname"><a href="testConvexHull2DReverse_8cpp.html#a4b95d895f3d8af697b8c550bc833cc9f">Functor</a></div><div class="ttdeci">InHalfPlaneBySimple3x3Matrix&lt; Point, double &gt; Functor</div><div class="ttdef"><b>Definition</b> <a href="testConvexHull2DReverse_8cpp_source.html#l00051">testConvexHull2DReverse.cpp:51</a></div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itb</td><td>begin iterator on the convex hull points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ite</td><td>end iterator on the convex hull points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>definition of the thickness used in the estimation (i.e HorizontalVerticalThickness or EuclideanThickness)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the convex hull contains 0, 1 or 2 points the thickness of 0 is returned. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The convex hull should be oriented in counter clockwise else it will return wrong result. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="geometry_2tools_2exampleConvexHull2D_8cpp-example.html#a17">geometry/tools/exampleConvexHull2D.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="exampleConvexHull2D_8cpp_source.html#l00122">convexHull()</a>, and <a class="el" href="testConvexHull2D_8cpp_source.html#l00274">testConvexHullCompThickness()</a>.</p>

</div>
</div>
<a id="ab88085aa9d56842df67fe82301da58c0" name="ab88085aa9d56842df67fe82301da58c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88085aa9d56842df67fe82301da58c0">&#9670;&#160;</a></span>computeHullThickness() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename TInputPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double DGtal::functions::Hull2D::computeHullThickness </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator &amp;</td>          <td class="paramname"><span class="paramname"><em>itb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;</td>          <td class="paramname"><span class="paramname"><em>ite</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ade3b11c94c4d3736bb8efc7abcc58735">ThicknessDefinition</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>def</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInputPoint &amp;</td>          <td class="paramname"><span class="paramname"><em>antipodalEdgeP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInputPoint &amp;</td>          <td class="paramname"><span class="paramname"><em>antipodalEdgeQ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInputPoint &amp;</td>          <td class="paramname"><span class="paramname"><em>antipodalVertexR</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure to compute the convex hull thickness given from different definitions (Horizontal/vertical or Euclidean distances). It takes as input the vertices of the hull given by the range [<em>itbn</em>, <em>ite</em>). The procedure applies the classic rotating caliper to recover all anti-podal pairs. </p>
<p>Typical use: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1PointVector.html">PointVector&lt;2,DGtal::int32_t&gt;</a> <a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1InHalfPlaneBySimple3x3Matrix.html">InHalfPlaneBySimple3x3Matrix&lt;Point, DGtal::int32_t&gt;</a> <a class="code hl_typedef" href="testConvexHull2DReverse_8cpp.html#a4b95d895f3d8af697b8c550bc833cc9f">Functor</a>;  </div>
<div class="line"><a class="code hl_class" href="classDGtal_1_1MelkmanConvexHull.html">DGtal::MelkmanConvexHull&lt;Point, Functor&gt;</a> <a class="code hl_variable" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>; </div>
<div class="line"><a class="code hl_variable" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.<a class="code hl_function" href="classDGtal_1_1MelkmanConvexHull.html#a857d8322d67e96a0e6a6f5d0774377d2">add</a>(<a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0));</div>
<div class="line"><a class="code hl_variable" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(11,1));</div>
<div class="line"><a class="code hl_variable" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(12,3));</div>
<div class="line"><a class="code hl_variable" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(8,3));</div>
<div class="line"><a class="code hl_variable" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(4,5));</div>
<div class="line"><a class="code hl_variable" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(2,6));</div>
<div class="line"><a class="code hl_variable" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(<a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1,4));</div>
<div class="line"><a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> p, q, s;</div>
<div class="line"><span class="keywordtype">double</span> th = <a class="code hl_function" href="#aa85c48fa77f6284d8d43808576ba474b">computeHullThickness</a>(<a class="code hl_variable" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.begin(), <a class="code hl_variable" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.end(), </div>
<div class="line">                                 <a class="code hl_enumvalue" href="#ade3b11c94c4d3736bb8efc7abcc58735aff78d557b689bb7423b38a557884134e">DGtal::functions::Hull2D::EuclideanThickness</a>, p, q, s);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">itb</td><td>begin iterator on the convex hull points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ite</td><td>end iterator on the convex hull points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>definition of the thickness used in the estimation (i.e HorizontalVerticalThickness or EuclideanThickness) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">antipodalEdgeP</td><td>one point of the antipodal edge associated to the minimal value of convex hull thickness. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">antipodalEdgeQ</td><td>one point of the antipodal edge associated to the minimal value of convex hull thickness. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">antipodalVertexR</td><td>the vertex of the antipodal pair associated to the minimal value of convex hull thickness. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the convex hull contains 0, 1 or 2 points the thickness of 0 is returned and the antipodal points are updated with the first points (if they exist). </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The convex hull should be oriented in counter clockwise else it will return wrong result. </dd></dl>

</div>
</div>
<a id="a4323af52b2db409c4a76e8f4f2245f59" name="a4323af52b2db409c4a76e8f4f2245f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4323af52b2db409c4a76e8f4f2245f59">&#9670;&#160;</a></span>computeVProjDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double DGtal::functions::Hull2D::computeVProjDistance </td>
          <td>(</td>
          <td class="paramtype">const TInputPoint &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>isInside</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the vertical distance a point <code>according</code> to the segment [<em>a</em>, <em>b</em>]. (i.e the vertical projection distance of <code>on</code> [<em>a</em>,<em>b</em>]. </p><dl class="section note"><dt>Note</dt><dd>if the segment [<em>a</em>, <em>b</em>] is vertical (i.e <em>a</em> [0]== <em>b</em> [0]) then an infinite value (std::numerics&lt;double&gt;::max()) is returned.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>one point of the segment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>a second point of the segment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>the point for which the vertical distance is computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">isInside</td><td>indicates if the projected point is inside the segment or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cb410b2e853bbdbece9846f67ba8205" name="a5cb410b2e853bbdbece9846f67ba8205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb410b2e853bbdbece9846f67ba8205">&#9670;&#160;</a></span>getAngle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputPoint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double DGtal::functions::Hull2D::getAngle </td>
          <td>(</td>
          <td class="paramtype">const TInputPoint &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the angle between the line (<em>a</em>,<em>b</em>) and (<em>c</em>,<em>d</em>) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>one of point defining the first line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>a second point defining the first line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>a third point defining the second line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>a third point defining the second line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting angle is between 0 and 2M_PI. </dd></dl>

</div>
</div>
<a id="a9ac0d68ce84ccfb5fe88ffb0d05b2882" name="a9ac0d68ce84ccfb5fe88ffb0d05b2882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac0d68ce84ccfb5fe88ffb0d05b2882">&#9670;&#160;</a></span>getThicknessAntipodalPair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double DGtal::functions::Hull2D::getThicknessAntipodalPair </td>
          <td>(</td>
          <td class="paramtype">const TInputPoint &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ade3b11c94c4d3736bb8efc7abcc58735">ThicknessDefinition</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>def</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the thickness of an anti podal pair (represented by the segment [ <em>p</em> , <em>q</em> ] and vertex <em>r</em>) according to the given distance <em>def</em> definition. <br  />
</p>
<p>If the distance definition is <em>HorizontalVerticalThickness</em>, it returns the minimal distance between the vertical/horizontal projection of <em>r</em> on ( <em>p</em> , <em>q</em> ).</p>
<p>If the distance definition is <em>EuclideanThickness</em>, it returns the distance between r and its projection on the line ( <em>p</em> ,<em>q</em> ).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>the first point of the edge anti podal pair. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>the second point of the edge anti podal pair. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>the vertex of the anti podal pair. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>definition of the thickness used in the estimation (i.e HorizontalVerticalThickness or EuclideanThickness). </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="testConvexHull2D_8cpp_source.html#l00274">testConvexHullCompThickness()</a>.</p>

</div>
</div>
<a id="a9e12e0b39f5b9a4f766d9915fb51c15a" name="a9e12e0b39f5b9a4f766d9915fb51c15a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e12e0b39f5b9a4f766d9915fb51c15a">&#9670;&#160;</a></span>grahamConvexHullAlgorithm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate , typename PolarComparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::Hull2D::grahamConvexHullAlgorithm </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator &amp;</td>          <td class="paramname"><span class="paramname"><em>itb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;</td>          <td class="paramname"><span class="paramname"><em>ite</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator</td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;</td>          <td class="paramname"><span class="paramname"><em>aPredicate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure that retrieves the vertices of the convex hull of a set of 2D points given by the range [ <em>itb</em> , <em>ite</em> ). This procedure follows the well-known Graham's algorithm [Graham, 1972 : <a class="el" href="citelist.html#CITEREF_Graham1972">[61]</a>]. </p>
<ul>
<li>choose a pole and sort the points in order of increasing angle about the pole (with a counter-clockwise orientation).</li>
<li>scan the sorted list of points and remove some points so that the given predicate returns 'true' for all sets of three consecutive points. <dl class="section see"><dt>See also</dt><dd><a class="el" href="#aec2e79bf291793719f2425323ae61fee" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::closedGrahamScanFromVertex</a></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The first point of the resulting list of extremal points is guaranteed to be the one with maximal x-coordinate and y-coordinate.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The predicate must be chosen so that is returns 'true' for counter-clockwise oriented 3-point sets. Otherwise, the procedure only returns the last convex hull edge. <br  />
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator </td></tr>
    <tr><td class="paramname">res</td><td>output iterator used to export the retrieved points </td></tr>
    <tr><td class="paramname">aPredicate</td><td>any ternary predicate <br  />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForwardIterator</td><td>a model of forward and readable iterator </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of incremental and writable iterator <br  />
 </td></tr>
    <tr><td class="paramname">Predicate</td><td>a model of ternary predicate </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="ae9140238e424c6e4121991d410a19011" name="ae9140238e424c6e4121991d410a19011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9140238e424c6e4121991d410a19011">&#9670;&#160;</a></span>grahamConvexHullAlgorithm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate , typename PolarComparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::Hull2D::grahamConvexHullAlgorithm </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator &amp;</td>          <td class="paramname"><span class="paramname"><em>itb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;</td>          <td class="paramname"><span class="paramname"><em>ite</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator</td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;</td>          <td class="paramname"><span class="paramname"><em>aPredicate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PolarComparator &amp;</td>          <td class="paramname"><span class="paramname"><em>aPolarComparator</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure that retrieves the vertices of the convex hull of a set of 2D points given by the range [ <em>itb</em> , <em>ite</em> ). This procedure follows the well-known Graham's algorithm [Graham, 1972 : <a class="el" href="citelist.html#CITEREF_Graham1972">[61]</a>]. </p>
<ul>
<li>choose a pole and sort the points in order of increasing angle about the pole with the given comparator.</li>
<li>scan the sorted list of points and remove some points so that the given predicate returns 'true' for all sets of three consecutive points. <dl class="section see"><dt>See also</dt><dd><a class="el" href="#aec2e79bf291793719f2425323ae61fee" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::closedGrahamScanFromVertex</a></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The first point of the resulting list of extremal points is guaranteed to be the one with maximal x-coordinate and y-coordinate.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The orientation of the predicate and of the polar comparator should be the same. Otherwise, the procedure only returns the last convex hull edge. For instance, you may use a predicate that returns 'true' for three points counter-clockwise oriented together with PolarPointComparatorBy2x2DetComputer. <br  />
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator </td></tr>
    <tr><td class="paramname">res</td><td>output iterator used to export the retrieved points </td></tr>
    <tr><td class="paramname">aPredicate</td><td>any ternary predicate <br  />
 </td></tr>
    <tr><td class="paramname">aPolarComparator</td><td>any polar comparator</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForwardIterator</td><td>a model of forward and readable iterator </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of incremental and writable iterator <br  />
 </td></tr>
    <tr><td class="paramname">Predicate</td><td>a model of ternary predicate </td></tr>
    <tr><td class="paramname">PolarComparator</td><td>a model of CPolarPointComparator2D. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="aeb3ba937825de5fe249a0507780bd42e" name="aeb3ba937825de5fe249a0507780bd42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3ba937825de5fe249a0507780bd42e">&#9670;&#160;</a></span>isCoLinearOpp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputPoint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::Hull2D::isCoLinearOpp </td>
          <td>(</td>
          <td class="paramtype">const TInputPoint &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputPoint &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine if the two vectors (<em>a</em>,<em>b</em>) and (<em>c</em>,<em>d</em>) are co linear from opposite directions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>one of point defining the first line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>a second point defining the first line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>a third point defining the second line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>a third point defining the second line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two vectors are co linear from opposite directions, else it returns false. </dd></dl>

</div>
</div>
<a id="acab511ebdfea4fa4b0d02901fa5f1464" name="acab511ebdfea4fa4b0d02901fa5f1464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab511ebdfea4fa4b0d02901fa5f1464">&#9670;&#160;</a></span>melkmanConvexHullAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator , typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::Hull2D::melkmanConvexHullAlgorithm </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator &amp;</td>          <td class="paramname"><span class="paramname"><em>itb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;</td>          <td class="paramname"><span class="paramname"><em>ite</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator</td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;</td>          <td class="paramname"><span class="paramname"><em>aFunctor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure that retrieves the vertices of the hull of a set of 2D points given by the range [ <em>itb</em> , <em>ite</em> ). This procedure follows the well-known Melkman algorithm [Melkman, 1979 : <a class="el" href="citelist.html#CITEREF_Melkman1987">[87]</a>]. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1MelkmanConvexHull.html" title="Aim: This class implements the on-line algorithm of Melkman for the computation of the convex hull of...">MelkmanConvexHull</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator </td></tr>
    <tr><td class="paramname">res</td><td>output iterator used to export the retrieved points </td></tr>
    <tr><td class="paramname">aFunctor</td><td>aFunctor <br  />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForwardIterator</td><td>a model of forward and readable iterator </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of incrementable and writable iterator <br  />
 </td></tr>
    <tr><td class="paramname">Functor</td><td>a model of COrientationFunctor2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f28de021eaafe900082eb65d90f37d1" name="a7f28de021eaafe900082eb65d90f37d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f28de021eaafe900082eb65d90f37d1">&#9670;&#160;</a></span>openGrahamScan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::Hull2D::openGrahamScan </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator &amp;</td>          <td class="paramname"><span class="paramname"><em>itb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;</td>          <td class="paramname"><span class="paramname"><em>ite</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator</td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;</td>          <td class="paramname"><span class="paramname"><em>aPredicate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP) in linear-time. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a22b3737b4aeb5443d541b9336116f6d8" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::buildHullWithStack</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator </td></tr>
    <tr><td class="paramname">res</td><td>output iterator used to export the retrieved points </td></tr>
    <tr><td class="paramname">aPredicate</td><td>any ternary predicate <br  />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForwardIterator</td><td>a model of forward and readable iterator </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of incremental and writable iterator <br  />
 </td></tr>
    <tr><td class="paramname">Predicate</td><td>a model of ternary predicate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca9e05cfa0179a24f8db24e3b5abaeae" name="aca9e05cfa0179a24f8db24e3b5abaeae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9e05cfa0179a24f8db24e3b5abaeae">&#9670;&#160;</a></span>updateHullWithAdaptedStack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stack , typename <a class="el" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::Hull2D::updateHullWithAdaptedStack </td>
          <td>(</td>
          <td class="paramtype">Stack</td>          <td class="paramname"><span class="paramname"><em>aStack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>aNewPoint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;</td>          <td class="paramname"><span class="paramname"><em>aPredicate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure that calls <a class="el" href="#ad39d6db9714b4194a49a178916ad886c" title="Procedure that updates the hull when an extra point aNewPoint is considered: while the last three con...">Hull2D::updateHullWithStack</a> on a copy of the stack object used to retrieved the hull vertices. Useful when the first argument is a stack adapter returned by a function: it must be copied before being passed by reference in <a class="el" href="#ad39d6db9714b4194a49a178916ad886c" title="Procedure that updates the hull when an extra point aNewPoint is considered: while the last three con...">Hull2D::updateHullWithStack</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aStack</td><td>stack copy </td></tr>
    <tr><td class="paramname">aNewPoint</td><td>new point </td></tr>
    <tr><td class="paramname">aPredicate</td><td>point predicate <br  />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stack</td><td>a model of CStack </td></tr>
    <tr><td class="paramname">Point</td><td>a model of point <br  />
 </td></tr>
    <tr><td class="paramname">Predicate</td><td>a model of ternary predicate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad39d6db9714b4194a49a178916ad886c" name="ad39d6db9714b4194a49a178916ad886c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39d6db9714b4194a49a178916ad886c">&#9670;&#160;</a></span>updateHullWithStack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stack , typename <a class="el" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::Hull2D::updateHullWithStack </td>
          <td>(</td>
          <td class="paramtype">Stack &amp;</td>          <td class="paramname"><span class="paramname"><em>aStack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>aNewPoint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;</td>          <td class="paramname"><span class="paramname"><em>aPredicate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure that updates the hull when an extra point <em>aNewPoint</em> is considered: while the last three consecutive points, ie. <em>aNewPoint</em> and the last two points of the container are not oriented such that the predicate <em>aPredicate</em> returns 'true', <br  />
 the last point of the container is removed. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a22b3737b4aeb5443d541b9336116f6d8" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">Hull2D::buildHullWithStack</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aStack</td><td>reference to the stack of retrieved vertices </td></tr>
    <tr><td class="paramname">aNewPoint</td><td>new point </td></tr>
    <tr><td class="paramname">aPredicate</td><td>point predicate <br  />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stack</td><td>a model of CStack </td></tr>
    <tr><td class="paramname">Point</td><td>a model of point <br  />
 </td></tr>
    <tr><td class="paramname">Predicate</td><td>a model of ternary predicate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="adff77b38274dbe620dfa709b71b7b338" name="adff77b38274dbe620dfa709b71b7b338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff77b38274dbe620dfa709b71b7b338">&#9670;&#160;</a></span>angleTolerance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double DGtal::functions::Hull2D::angleTolerance = 1e-6</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Hull2DHelpers_8h_source.html#l00076">76</a> of file <a class="el" href="Hull2DHelpers_8h_source.html">Hull2DHelpers.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceDGtal.html">DGtal</a></li><li class="navelem"><a class="el" href="namespaceDGtal_1_1functions.html">functions</a></li><li class="navelem"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html">Hull2D</a></li>
    <li class="footer">Generated on Mon Jun 10 2024 17:36:27 for DGtal by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
