<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Detailed explanation of COBA plane recognition algorithm</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;1.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('moduleCOBANaivePlaneRecognition.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Detailed explanation of COBA plane recognition algorithm</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#moduleCOBANaivePlaneRecognition_sec1">What planes are recognized by the COBA algorithm ?</a></li>
<li class="level1"><a href="#moduleCOBANaivePlaneRecognition_sec2">How to recognize a plane ?</a></li>
<li class="level1"><a href="#moduleCOBANaivePlaneRecognition_sec3">Extracting plane characteristics</a></li>
<li class="level1"><a href="#moduleCOBANaivePlaneRecognition_sec4">Speed and computational complexity of COBA algorithm</a></li>
<li class="level1"><a href="#moduleCOBANaivePlaneRecognition_sec5">Application to greedy segmentation into digital planes</a></li>
<li class="level1"><a href="#moduleCOBANaivePlaneRecognition_sec6">What if you do not know the main axis beforehands ?</a></li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Jacques-Olivier Lachaud</dd></dl>
<p>Part of the <a class="el" href="packageGeometry.html">Geometry package</a>.</p>
<p>This module gathers classes and functions to recognize piece of naive planes, and more generally piece of planes with arbitrary rational axis-thickness. It is based on an implementation of the COBA Algorithm [Charrier, Buzer 1998 : <a class="el" href="citelist.html#CITEREF_Charrier_2008_dgci">[22]</a>]. For the user, everything is gathered in classes <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a> and <a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1,...">COBAGenericNaivePlaneComputer</a>, which are additive primitive computers. File <a class="el" href="viewer3D-7-planes_8cpp.html">viewer3D-7-planes.cpp</a> gives a very simple example of use-case. File <a class="el" href="greedy-plane-segmentation_8cpp.html">greedy-plane-segmentation.cpp</a> is a non trivial example that uses this plane recognition algorithm.</p>
<p>Related examples are <a class="el" href="viewer3D-7-planes_8cpp.html">viewer3D-7-planes.cpp</a>, <a class="el" href="greedy-plane-segmentation_8cpp.html">greedy-plane-segmentation.cpp</a>, <a class="el" href="greedy-plane-segmentation-ex2_8cpp.html">greedy-plane-segmentation-ex2.cpp</a>.</p>
<h1><a class="anchor" id="moduleCOBANaivePlaneRecognition_sec1"></a>
What planes are recognized by the COBA algorithm ?</h1>
<p>The COBA algorithm recognizes planes defined with some equation  \(
\mu \le \vec{N} \cdot \vec{x} &lt; \mu + \epsilon \), where \( N_z \) (for instance) is 1. This is ok for instance for recognizing <b>naive</b> <b>planes</b> defined by \( d \le ax+by+cz &lt; d + \omega \) where  \( \omega
= \max(a,b,c) \). Assign indeed  \( \mu = d / \omega, \vec{N} =
(a,b,c) / \omega, \epsilon = 1 \). Extension to integer multiples or rational multiples of such planes is straightforward, and is hence provided.</p>
<p>The user thus specifies a main axis <em>axis</em> and a rational width (i.e. \( \epsilon \) as <em>widthNumerator</em> / <em>widthDenominator</em> ) at initialization (see <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html#a17098fa05c7e9cf548d69283410c10e2">COBANaivePlaneComputer::init()</a>).</p>
<p>The idea of the COBA algorithm is to transform the problem into a linear integer programming problem in the digital plane  \( Z^2
\). If the main axis is <em>z</em>, then the algorithm looks for unknown variables \( (N_x,N_y) \). Given a set of points  \( (\vec{P}_i)
\), it computes (or maintains in the incremental form) the 2D space of solutions induced by these points. More precisely, each point induces two linear constraints \( \mu \le \vec{N} \cdot \vec{P}_i \) and \( \vec{N} \cdot \vec{P}_i &lt; \mu + \epsilon \).</p>
<p>Instead of keeping this problem in \( R^2 \), the problem is cast in \( (hZ)^2 \), where the parameter <em>h</em> is the sampling step and is sufficiently small to capture a solution when there is one. When initializing the algorithm, the user must give the <em>diameter</em> of the set of points \( (\vec{P}_i) \) (here largest vector in \(\infty\) norm), see <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html#a17098fa05c7e9cf548d69283410c10e2">COBANaivePlaneComputer::init()</a>.</p>
<p>It is proven that if \( 0 &lt; h &lt; 1/(2D^3) \), where <em>D</em> is the diameter, then if there is a solution, there is a rational solution with denominator less than \( 2D^3 \).</p>
<p>The COBA algorithm uses therefore a 2D lattice polytope (a convex polygon with vertices at integer coordinates), and class <a class="el" href="classDGtal_1_1LatticePolytope2D.html" title="Aim: Represents a 2D polytope, i.e. a convex polygon, in the two-dimensional digital plane....">LatticePolytope2D</a>, to maintain the set of rational solutions. Experimentally, even for a great number of points (&lt;=100000), this convex set has generally fewer than 12 vertices (see <a class="el" href="#moduleCOBANaivePlaneRecognition_sec3">Extracting plane characteristics</a>).</p>
<p>A drawback of the COBA algorithm is that it does <b>not</b> provide the <b>minimal</b> <b>characteristics</b> of the recognized plane. This is due to the sampling method. In practice, the extracted normal is close to the minimal (integer) one.</p>
<dl class="section note"><dt>Note</dt><dd>Another problem is that parameter \( \mu \) is also unknown. To cope with that problem, a given solution (the centroid) is picked up and the maximal and minimal bounds are computed from it. If for a new point the bounds are too big, then a new direction is chosen by following the gradient of the induced constraints, and the algorithm optimizes iteratively the direction so as to get a direction with feasible bounds or no solutions. All this is hidden to the user, but explains the worst-case complexity.</dd>
<dd>
You may have a look at <a class="el" href="packageArithmetic.html">Arithmetic package</a>, more precisely at module <a class="el" href="moduleLatticePolytope2D.html">Lattice polytopes in the digital plane ZxZ (convex polygons with vertices at integer coordinates)</a> to see how lattice polytopes are represented.</dd></dl>
<h1><a class="anchor" id="moduleCOBANaivePlaneRecognition_sec2"></a>
How to recognize a plane ?</h1>
<p>The main class is <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a>. It is templated by the digital space <em>TSpace</em>, an arbitrary model of CSpace with dimension equal to 3, and by the internal integer type <em>TInternalInteger</em>, which should be an integral type with big enough precision to perform computations in the subsampled \( Z^2 \).</p>
<p>The most important inner types are (most of the others are redefinitions so that this object is a model of <a class="el" href="structboost_1_1ForwardContainer.html" title="Go to http://www.sgi.com/tech/stl/ForwardContainer.html.">boost::ForwardContainer</a>):</p>
<ul>
<li><em>Point:</em> the type of point that will be checked in the algorithm. Defined as <em>TSpace::Point</em>.</li>
<li><em>InternalInteger:</em> the type of integer used in computations. Defined as <em>TInternalInteger</em>.</li>
<li><em>PointSet:</em> the type that defines the set of points stored in this object (for now, std::set&lt;Point&gt;).</li>
<li><em>ConstIterator:</em> the type of iterator to visit the set of points that composed the currently recognized plane.</li>
</ul>
<p>You may instantiate a <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a> as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/surfaces/COBANaivePlaneComputer.h&quot;</span> </div>
<div class="line">...</div>
<div class="line">using <span class="keyword">namespace </span>Z3i;               <span class="comment">// digital space is Z3</span></div>
<div class="line">...</div>
<div class="line">COBANaivePlaneComputer&lt;Z3, <a class="code hl_typedef" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63">int64_t</a>&gt; plane; <span class="comment">// int64_t is enough for diameter 100</span></div>
<div class="line">plane.init( 2, 100, 1, 1 );        <span class="comment">// axis is z, diameter is 100, epsilon=1/1</span></div>
<div class="ttc" id="anamespaceDGtal_html_a1c09e3f63904ff371f1b99f45069fc63"><div class="ttname"><a href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63">DGtal::int64_t</a></div><div class="ttdeci">boost::int64_t int64_t</div><div class="ttdoc">signed 94-bit integer.</div><div class="ttdef"><b>Definition</b> <a href="BasicTypes_8h_source.html#l00074">BasicTypes.h:74</a></div></div>
</div><!-- fragment --><p>Assuming you have a sequence of points stored in a container <em>v</em>, you may recognize if it is a piece of z-axis naive plane with the following piece of code:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> isZNaivePlane( <span class="keyword">const</span> vector&lt;Point&gt; &amp; v )</div>
<div class="line">{</div>
<div class="line">  COBANaivePlaneComputer&lt;Z3, int64_t&gt; plane; <span class="comment">// int64_t is enough for diameter 500</span></div>
<div class="line">  plane.init( 2, 500, 1, 1 );        <span class="comment">// axis is z, diameter is 500, epsilon=1/1</span></div>
<div class="line">  <span class="keywordflow">for</span> ( vector&lt;Point&gt;::const_iterator it = v.begin(), itEnd = v.end();</div>
<div class="line">        it != itEnd; ++it )</div>
<div class="line">    <span class="keywordflow">if</span> ( ! plane.extend( *it ) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Therefore, the main methods for recognizing a plane are:</p>
<ul>
<li>COBANaivePlaneComputer::extend(const Point &amp;): given a <em>Point</em>, it updates this plane such that it includes also this new point. If this is possible, it returns <code>true</code>, otherwise it returns <code>false</code> and the object is in the same state as before the call.</li>
<li>COBANaivePlaneComputer::isExtendable(const Point &amp;)const: given a <em>Point</em>, it checks whether or not there is a plane that includes also this new point. It returns <code>true</code> in this case, otherwise it returns <code>false</code>. The object is left unchanged whatever the result.</li>
<li><a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html#aa4ae8d1eeb769fd3da49b1d7fdaedf1e">COBANaivePlaneComputer::extend(TInputIterator it, TInputIterator itE)</a>: given a range [it,itE) of <em>Point</em>, it updates this plane such that it includes also this range of points. If this is possible, it returns <code>true</code>, otherwise it returns <code>false</code> and the object is in the same state as before the call.</li>
<li><a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html#ac33b33fc1ef109945cfe7abeee95937e">COBANaivePlaneComputer::isExtendable(TInputIterator it, TInputIterator itE)const</a>: given a range [it,itE) of <em>Point</em>, it checks whether or not there is a plane that includes also this range of new points. It returns <code>true</code> in this case, otherwise it returns <code>false</code>. The object is left unchanged whatever the result.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Calling <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html#ade84fff24b51267194134370648c7171">COBANaivePlaneComputer::isExtendable</a> before <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html#af2772a864766a21ee7ab9538c6c8d66e">COBANaivePlaneComputer::extend</a> does not induce a speed up on the second method. You should prefer calling directly <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html#af2772a864766a21ee7ab9538c6c8d66e">COBANaivePlaneComputer::extend()</a> whenever you wish to extend the plane at this point.</dd></dl>
<p>You may also have a look at example <a class="el" href="viewer3D-7-planes_8cpp.html">viewer3D-7-planes.cpp</a>.</p>
<div class="image">
<img src="coba-naive-plane.png" alt=""/>
<div class="caption">
Piece of naive plane containing the four green points. There is no naive plane containing also any one of the red points.</div></div>
 <dl class="section note"><dt>Note</dt><dd><em>TInternalInteger</em> specifies the type of integer used in internal computations. The type should be able to hold integers of order (2*D^3)^2 if D is the diameter of the set of digital points. In practice, diameter is limited to 20 for int32_t, diameter is approximately 500 for int64_t, and whatever with BigInteger/GMP integers. For huge diameters, the slow-down is polylogarithmic with the diameter.</dd></dl>
<h1><a class="anchor" id="moduleCOBANaivePlaneRecognition_sec3"></a>
Extracting plane characteristics</h1>
<p>You may obtain the current normal to the plane as a 3D vector over some real-value type (e.g. <code>float</code>, <code>double</code>) with the templated methods <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html#a48231152212b6da91beaa6d2ac70c35e">COBANaivePlaneComputer::getNormal</a> (one component has norm 1) and <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html#ab0599e07e1aab0a6434c5366f26fdd21">COBANaivePlaneComputer::getUnitNormal</a> (the 2-norm of the vector is 1).</p>
<p>You may obtain the upper and lower bounds of the scalar products with <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html#a2965102df98f6496885ad60af8a9a558">COBANaivePlaneComputer::getBounds</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The COBA algorithm does not give you the minimal characteristics of the plane that contains all the input points. It provides you one feasible solution.</dd></dl>
<h1><a class="anchor" id="moduleCOBANaivePlaneRecognition_sec4"></a>
Speed and computational complexity of COBA algorithm</h1>
<p>It is not a trivial task to determine bounds on the computational complexity of this algorithm that depends only on the number of points <em>N</em>. Indeed, the determinant factor on the complexity is the number of times <em>k</em> that the plane parameters are updated. Another factor is the number of vertices <em>v</em> of the current convex set of solutions.</p>
<ul>
<li>The parameter <em>k</em> depends on the order of added point. It is related to the depth of bidimensional continued fraction of the plane normal (since each update corresponds to a refinement of the plane normal). A rule of thumb upper bound is some  \( O(\log^2(D))
  \), but experiments suggest a much lower bound.</li>
<li>The parameter <em>v</em> seems mostly bounded in experiments. It is of course bounded by \( O(D^\frac{2}{3}) \), which is the 2D lattice polytope with the maximum number of sides in a D x D box. However, experiments suggest a more likely \( \log \log D \).</li>
<li>Note also that each time a new point is inserted, we check if it has already been added. With std::set, this implies a \(O(\log N)\) cost.</li>
</ul>
<p>Putting everything together gives some  \( O(N \log N +
k(v+N+\log(D))\log^2(D)) \). Neglecting <em>v</em> gives  \( O( N (\log N +
k \log^3 D ) ) \).</p>
<p>We have runned the following benchmark to estimate the average speed of COBA algorithm. For each experiment, 1000 naive planes were randomly chosen. Then, for an input diameter <em>D</em>, <em>N</em> points are randomly chosen in the parallelepiped D x D x D, such that they belong to the plane. We measure the time <em>T</em> to recognize these points as a naive plane (all calls to extend succeed). We also measure the number of updates <em>k</em> for this recognition. The following figures show the obtained results for a number of points varying from 50 to 100000 and a diameter varying from 50 to 1000000. It shows that the algorithm performs better in practice than the given upper bounds, even assuming \( k = \log \log D \) and <em>v</em> constant.</p>
<dl class="section note"><dt>Note</dt><dd>All computations were made with <em>TInternalInteger</em> set to BigInteger.</dd></dl>
<div class="image">
<img src="COBA-timings.png" alt=""/>
<div class="caption">
Time (in ms) to recognize a naive plane as a function of the number of points N (x-axis) and the diameter (y-axis). Time is averaged over 1000 random recognitions.</div></div>
 <div class="image">
<img src="COBA-updates.png" alt=""/>
<div class="caption">
Number of updates (and deviation) when recognizing a naive plane, as a function of the number of points N (x-axis) and the diameter (y-axis). This number is averaged over 1000 random recognitions.</div></div>
 <h1><a class="anchor" id="moduleCOBANaivePlaneRecognition_sec5"></a>
Application to greedy segmentation into digital planes</h1>
<p>Example <a class="el" href="greedy-plane-segmentation_8cpp.html">greedy-plane-segmentation.cpp</a> illustrates the use of <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a> to segment a digital surface into connected pieces of digital planes.</p>
<p>The surface will be define as some digital surface in a thresholded 3D image. The image is loaded here.</p>
<div class="fragment"><div class="line">  QApplication application(argc,argv);</div>
<div class="line">  <span class="keyword">typedef</span> ImageSelector &lt; Domain, int&gt;::Type <a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a852ab282e5168b5711ef7a87b3aefa68">Image</a>;</div>
<div class="line">  <a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a852ab282e5168b5711ef7a87b3aefa68">Image</a> image = <a class="code hl_struct" href="structDGtal_1_1VolReader.html">VolReader&lt;Image&gt;::importVol</a>(inputFilename);</div>
<div class="line">  <a class="code hl_typedef" href="testVoronoiMapComplete_8cpp.html#ac14360761d68859fc57ca37aea0b5c93">DigitalSet</a> set3d (image.domain());</div>
<div class="line">  <a class="code hl_struct" href="structDGtal_1_1SetFromImage.html">SetFromImage&lt;DigitalSet&gt;::append&lt;Image&gt;</a>(set3d, image, threshold,255);</div>
</div><!-- fragment --><p>Then the digital surface is built within this volume.</p>
<div class="fragment"><div class="line">  <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a>( <span class="stringliteral">&quot;Set up digital surface.&quot;</span> );</div>
<div class="line">  <span class="comment">// We initializes the cellular grid space used for defining the</span></div>
<div class="line">  <span class="comment">// digital surface.</span></div>
<div class="line">  <a class="code hl_typedef" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a> ks;</div>
<div class="line">  <span class="keywordtype">bool</span> ok = ks.<a class="code hl_function" href="classDGtal_1_1KhalimskySpaceND.html#a15dcbcaae831dd1c36090e6336c177d4">init</a>( set3d.domain().lowerBound(),</div>
<div class="line">                     set3d.domain().upperBound(), <span class="keyword">true</span> );</div>
<div class="line">  <span class="keywordflow">if</span> ( ! ok ) std::cerr &lt;&lt; <span class="stringliteral">&quot;[KSpace.init] Failed.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <a class="code hl_class" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency&lt;KSpace::dimension&gt;</a> surfAdj( <span class="keyword">true</span> ); <span class="comment">// interior in all directions.</span></div>
<div class="line">  <a class="code hl_class" href="classDGtal_1_1DigitalSetBoundary.html">MyDigitalSurfaceContainer</a>* ptrSurfContainer =</div>
<div class="line">    <span class="keyword">new</span> <a class="code hl_typedef" href="greedy-plane-segmentation-ex2_8cpp.html#ac9ee7087e3a195e77c3d27a1b002d6d6">MyDigitalSurfaceContainer</a>( ks, set3d, surfAdj );</div>
<div class="line">  <a class="code hl_class" href="classDGtal_1_1DigitalSurface.html">MyDigitalSurface</a> digSurf( ptrSurfContainer ); <span class="comment">// acquired</span></div>
<div class="line">  <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div>
</div><!-- fragment --><p>We define a few types. Note the <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a> and the structure SegmentedPlane, which will store information for each plane.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>Z3i;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_typedef" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63">DGtal::int64_t</a> <a class="code hl_typedef" href="greedy-plane-segmentation-ex2_8cpp.html#aec66eb43935379dd86245097a9c70bac">InternalInteger</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1COBANaivePlaneComputer.html">COBANaivePlaneComputer&lt;Z3,InternalInteger&gt;</a> <a class="code hl_typedef" href="greedy-plane-segmentation-ex2_8cpp.html#a56a9dd4ad526e12927cd7ccea682d244">NaivePlaneComputer</a>;</div>
<div class="line"><span class="comment">// We choose the DigitalSetBoundary surface container in order to</span></div>
<div class="line"><span class="comment">// segment connected or unconnected surfaces.</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1DigitalSetBoundary.html">DigitalSetBoundary&lt;KSpace,DigitalSet&gt;</a> <a class="code hl_typedef" href="greedy-plane-segmentation-ex2_8cpp.html#ac9ee7087e3a195e77c3d27a1b002d6d6">MyDigitalSurfaceContainer</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1DigitalSurface.html">DigitalSurface&lt;MyDigitalSurfaceContainer&gt;</a> <a class="code hl_typedef" href="greedy-plane-segmentation-ex2_8cpp.html#a03d731f44ed1110acdbefdc2357f84cf">MyDigitalSurface</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_typedef" href="classDGtal_1_1DigitalSurface.html#a40056dd099c93e7ab5dfc5196a56e550">MyDigitalSurface::ConstIterator</a> <a class="code hl_typedef" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_typedef" href="classDGtal_1_1DigitalSurface.html#a637f8034aff12a2f65fe9cc47c95b8db">MyDigitalSurface::Vertex</a> <a class="code hl_typedef" href="testTriangulatedSurface_8cpp.html#ae931baebcf0de56dd5f3b9342207e4fd">Vertex</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_typedef" href="classDGtal_1_1DigitalSurface.html#aaa80abbd219d17cd225cc8f961be68f2">MyDigitalSurface::SurfelSet</a> <a class="code hl_typedef" href="greedy-plane-segmentation-ex2_8cpp.html#a9e248ca0929052a040e6dfa7018611c2">SurfelSet</a>;</div>
<div class="line"><span class="keyword">typedef</span> SurfelSet::iterator <a class="code hl_typedef" href="greedy-plane-segmentation-ex2_8cpp.html#a25cdaf11e42c0d24f9f7aa870f50e2e1">SurfelSetIterator</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1BreadthFirstVisitor.html">BreadthFirstVisitor&lt;MyDigitalSurface&gt;</a> <a class="code hl_typedef" href="greedy-plane-segmentation-ex2_8cpp.html#ac49b0cfbe4d1466bd0b6ab2a3b2f703b">Visitor</a>;</div>
<div class="line"><span class="keyword">struct </span>SegmentedPlane {</div>
<div class="line">  <a class="code hl_class" href="classDGtal_1_1COBANaivePlaneComputer.html">NaivePlaneComputer</a> plane;</div>
<div class="line">  <a class="code hl_class" href="classDGtal_1_1Color.html">Color</a> color;</div>
<div class="line">};</div>
</div><!-- fragment --><p>We proceed to the segmentation itself. Note that we iterate over each surface element (surfel or vertex). Only vertices not processed can define the starting point of a new plane. Then a breadth-first traversal is initiated from this vertex and vertices are added to the plane as long as it is possible.</p>
<div class="fragment"><div class="line">  <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a>( <span class="stringliteral">&quot;Segment into planes.&quot;</span> );</div>
<div class="line">  std::set&lt;Vertex&gt; processedVertices;</div>
<div class="line">  std::vector&lt;SegmentedPlane*&gt; segmentedPlanes;</div>
<div class="line">  std::map&lt;Vertex,SegmentedPlane*&gt; v2plane;</div>
<div class="line">  <a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> p;</div>
<div class="line">  <a class="code hl_typedef" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> axis;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb = digSurf.size();</div>
<div class="line">  <span class="keywordflow">for</span> ( <a class="code hl_typedef" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a> it = digSurf.begin(), itE= digSurf.end(); it != itE; ++it )</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> ( ( (++j) % 50 == 0 ) || ( j == nb ) ) <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#ad8efd553b31277903be115e7aa256f74">progressBar</a>( j, nb );</div>
<div class="line">      <a class="code hl_typedef" href="testTriangulatedSurface_8cpp.html#ae931baebcf0de56dd5f3b9342207e4fd">Vertex</a> v = *it;</div>
<div class="line">      <span class="keywordflow">if</span> ( processedVertices.find( v ) != processedVertices.end() ) <span class="comment">// already in set</span></div>
<div class="line">        <span class="keywordflow">continue</span>; <span class="comment">// process to next vertex</span></div>
<div class="line"> </div>
<div class="line">      SegmentedPlane* ptrSegment = <span class="keyword">new</span> SegmentedPlane;</div>
<div class="line">      segmentedPlanes.push_back( ptrSegment ); <span class="comment">// to delete them afterwards.</span></div>
<div class="line">      axis = ks.<a class="code hl_function" href="classDGtal_1_1KhalimskySpaceND.html#a1e9033f0d1b60cd23fbfb96c19ee5ab1">sOrthDir</a>( v );</div>
<div class="line">      ptrSegment-&gt;plane.<a class="code hl_function" href="classDGtal_1_1COBANaivePlaneComputer.html#a17098fa05c7e9cf548d69283410c10e2">init</a>( axis, 500, widthNum, widthDen );</div>
<div class="line">      <span class="comment">// The visitor takes care of all the breadth-first traversal.</span></div>
<div class="line">      <a class="code hl_class" href="classDGtal_1_1BreadthFirstVisitor.html">Visitor</a> visitor( digSurf, v );</div>
<div class="line">      <span class="keywordflow">while</span> ( ! visitor.finished() )</div>
<div class="line">        {</div>
<div class="line">          <a class="code hl_typedef" href="classDGtal_1_1BreadthFirstVisitor.html#ad66e84867d0eb0c092900af4df0ae026">Visitor::Node</a> node = visitor.current();</div>
<div class="line">          v = node.first;</div>
<div class="line">          <span class="keywordflow">if</span> ( processedVertices.find( v ) == processedVertices.end() )</div>
<div class="line">            { <span class="comment">// Vertex is not in processedVertices</span></div>
<div class="line">              axis = ks.<a class="code hl_function" href="classDGtal_1_1KhalimskySpaceND.html#a1e9033f0d1b60cd23fbfb96c19ee5ab1">sOrthDir</a>( v );</div>
<div class="line">              p = ks.<a class="code hl_function" href="classDGtal_1_1KhalimskySpaceND.html#a36d05bc463af9b7521723edfee606315">sCoords</a>( ks.<a class="code hl_function" href="classDGtal_1_1KhalimskySpaceND.html#aaa60ad137a7aa68627cd86b0d76c3693">sDirectIncident</a>( v, axis ) );</div>
<div class="line">              <span class="keywordtype">bool</span> isExtended = ptrSegment-&gt;plane.<a class="code hl_function" href="classDGtal_1_1COBANaivePlaneComputer.html#af2772a864766a21ee7ab9538c6c8d66e">extend</a>( p );</div>
<div class="line">              <span class="keywordflow">if</span> ( isExtended )</div>
<div class="line">                { <span class="comment">// surfel is in plane.</span></div>
<div class="line">                  processedVertices.insert( v );</div>
<div class="line">                  v2plane[ v ] = ptrSegment;</div>
<div class="line">                  visitor.expand();</div>
<div class="line">                }</div>
<div class="line">              <span class="keywordflow">else</span> <span class="comment">// surfel is not in plane and should not be used in the visit.</span></div>
<div class="line">                visitor.ignore();</div>
<div class="line">            }</div>
<div class="line">          <span class="keywordflow">else</span> <span class="comment">// surfel is already in some plane.</span></div>
<div class="line">            visitor.ignore();</div>
<div class="line">        }</div>
<div class="line">      <span class="comment">// Assign random color for each plane.</span></div>
<div class="line">      ptrSegment-&gt;color = <a class="code hl_class" href="classDGtal_1_1Color.html">Color</a>( rand() % 256, rand() % 256, rand() % 256, 255 );</div>
<div class="line">    }</div>
<div class="line">  <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div>
</div><!-- fragment --><p>We display it using 3D viewers.</p>
<div class="fragment"><div class="line">  <a class="code hl_class" href="classDGtal_1_1Viewer3D.html">Viewer3D&lt;&gt;</a> viewer( ks );</div>
<div class="line">  viewer.show();</div>
<div class="line">  <span class="keywordflow">for</span> ( std::map&lt;Vertex,SegmentedPlane*&gt;::const_iterator</div>
<div class="line">          it = v2plane.begin(), itE = v2plane.end();</div>
<div class="line">        it != itE; ++it )</div>
<div class="line">    {</div>
<div class="line">      viewer &lt;&lt; <a class="code hl_struct" href="structDGtal_1_1CustomColors3D.html">CustomColors3D</a>( it-&gt;second-&gt;color, it-&gt;second-&gt;color );</div>
<div class="line">      viewer &lt;&lt; ks.<a class="code hl_function" href="classDGtal_1_1KhalimskySpaceND.html#a22d8a0b3bf9ab0c07596ff57af908f92">unsigns</a>( it-&gt;first );</div>
<div class="line">    }</div>
<div class="line">  viewer &lt;&lt; Viewer3D&lt;&gt;::updateDisplay;</div>
</div><!-- fragment --><div class="image">
<img src="greedy-plane-segmentation-al-w1.png" alt=""/>
<div class="caption">
Greedy segmentation of Al capone into naive planes.</div></div>
 <dl class="section note"><dt>Note</dt><dd>This approach to plane segmentation is very naive. Because there are favored axes when iterating (vertices are not randomly picked up), this technique has indeed the drawback of favoring "slice planes", which are not very useful.</dd>
<dd>
<b>Exercice</b> 1. Randomize the greedy plane recognition. The simplest approach is first to put all vertices into a vector, then suffle it with STL algorithms. And then iterate over this shuffled set.</dd>
<dd>
<b>Exercice</b> 2. Enhance the polyhedrization by selecting first the vertices that induces the biggest planes. This is much slower than above, but will give nicer results. For each vertex, computes its best plane by breadth-first traversal. Stores the obtained size (or better moments). Do that for each vertex independently. Put them in a priority queue, the first to be popped should be the ones with the biggest size. The remaining of the algorithm is unchanged.</dd></dl>
<h1><a class="anchor" id="moduleCOBANaivePlaneRecognition_sec6"></a>
What if you do not know the main axis beforehands ?</h1>
<p>In this case, you should use the class <a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1,...">COBAGenericNaivePlaneComputer</a>. You use it similarly to <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a>, but you do not need to specify a main axis when calling <a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html#aafeaade647f0bdb99ebf952e3b7203b8">COBAGenericNaivePlaneComputer::init()</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/surfaces/COBAGenericNaivePlaneComputer.h&quot;</span> </div>
<div class="line">...</div>
<div class="line">using <span class="keyword">namespace </span>Z3i;            <span class="comment">// digital space is Z3</span></div>
<div class="line">...</div>
<div class="line">COBAGenericNaivePlaneComputer&lt;Z3, <a class="code hl_typedef" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63">int64_t</a>&gt; plane; <span class="comment">// int64_t is enough for diameter 100</span></div>
<div class="line">plane.init( 100, 1, 1 );        <span class="comment">// diameter is 100, epsilon=1/1</span></div>
</div><!-- fragment --><p>Then, you may use methods <a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html#ac74b0f508659f6889929163b838295c1">COBAGenericNaivePlaneComputer::clear()</a>, <a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html#a5d92322a1cb00ea3d358496551a21ff5">COBAGenericNaivePlaneComputer::extend()</a>, <a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html#aaeaa5e995f412aa718bab660ce3367b9">COBAGenericNaivePlaneComputer::isExtendable()</a>, etc, similarly as for class <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a>. The advantage is that the object detects progressively what is the correct main axis. You may know what is a correct main axis by calling <a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html#aeb0accb6c809179d0c1ea017169a847f">COBAGenericNaivePlaneComputer::active()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The principle of <a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1,...">COBAGenericNaivePlaneComputer</a> is to have three instances of <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a> at the beginning, one per possible axis. When extending the object by adding points, all active instances are extended. If any one of the active instance fails, it is removed from the active instances. It is guaranteed that if there is a naive plane (of specified width) that contains the given set of points, then the object <a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1,...">COBAGenericNaivePlaneComputer</a> will have at least one active <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a> instance. <a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1,...">COBAGenericNaivePlaneComputer</a> is thus a correct recognizer of arbitrary pieces of naive planes. </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">DGtal - Digital Geometry Tools and Algorithms Library.</a></li><li class="navelem"><a class="el" href="packageGeometry.html">Geometry package</a></li>
    <li class="footer">Generated on Mon Jun 10 2024 17:36:17 for DGtal by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
