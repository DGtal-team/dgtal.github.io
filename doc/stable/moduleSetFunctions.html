<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Set operations on arbitrary containers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Set operations on arbitrary containers </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation:</dt><dd>Jacques-Olivier Lachaud</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.9.1</dd></dl>
<p>Part of the <a class="el" href="packageBase.html">Base package</a>.</p>
<p>This part of the manual describes how to perform set operations (union, intersection, difference, symmetric difference) on arbitrary containers.</p>
<p>The following programs are related to this documentation: <a class="el" href="testSetFunctions_8cpp_source.html">testSetFunctions.cpp</a></p>
<h1><a class="anchor" id="dgtal_setfunctions_sec1"></a>
Motivation for a common framework for set operations</h1>
<p>The STL library provides algorithm for performing set operations (std::set_union, std::set_intersection, std::set_difference, std::set_symmetric_difference). These algorithms are generic given iterators on an ordered range and an output iterator. So, in circumstances where you have two sorted vectors with unique elements, you could/should use directly STL set operations. You could also do this when you have two sets.</p>
<p>However, there are several cases when you cannot use them straightforwardly:</p>
<ul>
<li>if you wish to assign the result to one of the input set, you must use a temporary container.</li>
<li>if your set is represented with some unordered_set variant, you must build intermediate vectors.</li>
<li>if you wish to perform set operations on keys of datas stored in two maps, you have also to specify the comparison operator.</li>
<li>if you are in templated class where the Container type is generic (could be a set or unordered_set for instance) then your code must be adapted to each variant.</li>
<li>the syntax is heavier than just using binary operators |, &amp;, -, ^ or |=, &amp;=, -=, ^=.</li>
</ul>
<p>Therefore we propose functions to perform set operations on arbitrary containers. At compile time, the compiler chooses the most adequate way to compute the set operations, depending on the container type. It uses the traits class <a class="el" href="structDGtal_1_1ContainerTraits.html" title="Defines default container traits for arbitrary types.">ContainerTraits</a> to determine the type of container and to select the appropriate code. For the user, this is totally transparent, at least when he uses the binary operators |, &amp;, -, ^ or |=, &amp;=, -=, ^=.</p>
<h1><a class="anchor" id="dgtal_setfunctions_sec2"></a>
Performing set operations</h1>
<p>It is enough to include module <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a> and then write <code>using namespace <a class="el" href="namespaceDGtal_1_1functions_1_1setops.html">DGtal::functions::setops</a></code> to use binary operators directly on your containers. The following snippet shows an example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/base/SetFunctions.h&quot;</span></div><div class="line">...</div><div class="line">using <span class="keyword">namespace </span><a class="code" href="namespaceDGtal_1_1functions_1_1setops.html">DGtal::functions::setops</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::list&lt;int&gt; Container; <span class="comment">// could be boost::unordered_set&lt;int&gt;, etc</span></div><div class="line"><span class="keywordtype">int</span> S1[ 10 ] = { 4, 15, 20, 17, 9, 7, 13, 12, 1, 3 }; </div><div class="line"><span class="keywordtype">int</span> S2[ 6 ]  = { 17, 14, 19, 2, 3, 4 };</div><div class="line">Container A( S1, S1 + 10 );</div><div class="line">Container B( S2, S2 + 6 );</div><div class="line">Container AorB    = A | B; <span class="comment">// union</span></div><div class="line">Container AandB   = A &amp; B; <span class="comment">// intersection</span></div><div class="line">Container AxorB   = A ^ B; <span class="comment">// symmetric difference</span></div><div class="line">Container AminusB = A - B; <span class="comment">// difference</span></div><div class="line">Container BminusA = B - A; <span class="comment">// difference</span></div><div class="line">A |= B;                    <span class="comment">// assign union</span></div><div class="line">B &amp;= A;                    <span class="comment">// assign intersection</span></div><div class="line">A ^= B;                    <span class="comment">// assign symmetric difference</span></div><div class="line">B -= A;                    <span class="comment">// assign difference</span></div></div><!-- fragment --><p>If you dislike operators, you may also use functions (defined in namespace <a class="el" href="namespaceDGtal_1_1functions.html" title="functions namespace gathers all DGtal functionsxs.">DGtal::functions</a>):</p><ul>
<li>union: <a class="el" href="namespaceDGtal_1_1functions.html#ac58ca694e397fb84d77c53aba2134887">functions::assignUnion</a>, <a class="el" href="namespaceDGtal_1_1functions.html#af848d0d5748af67bcb76b3d5e1f616cd">functions::makeUnion</a></li>
<li>intersection: <a class="el" href="namespaceDGtal_1_1functions.html#af3360043e7032e9a8eaf2ef0fde60afd">functions::assignIntersection</a>, <a class="el" href="namespaceDGtal_1_1functions.html#a8de7a7bd0c7511d57569c794cff3a113">functions::makeIntersection</a></li>
<li>difference: <a class="el" href="namespaceDGtal_1_1functions.html#ac97099c06241a42dce86a53230b665d7">functions::assignDifference</a>, <a class="el" href="namespaceDGtal_1_1functions.html#adc5faa4fb283d3dd8b530f1aa46e1303">functions::makeDifference</a></li>
<li>symmetric difference: <a class="el" href="namespaceDGtal_1_1functions.html#a65694ad895f3f4cb42c54213fce7295a">functions::assignSymmetricDifference</a>, <a class="el" href="namespaceDGtal_1_1functions.html#a03f0a6573a95aa152c8b8320baee6884">functions::makeSymmetricDifference</a>.</li>
</ul>
<p>There are templated versions of these functions that are useful if you know that, at this point in the program, your container is sorted (for instance your list or vector is already sorted). You may thus give the hint to set operations at this point.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceDGtal_1_1functions.html">DGtal::functions</a>;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;int&gt; Container; <span class="comment">// could be boost::unordered_set&lt;int&gt;, etc</span></div><div class="line"><span class="keywordtype">int</span> S1[ 10 ] = { 1, 3, 4, 7, 9, 12, 13, 15, 17, 20 };</div><div class="line"><span class="keywordtype">int</span> S2[ 6 ]  = { 2, 3, 4, 14, 17, 19 };</div><div class="line">Container A( S1, S1 + 10 );</div><div class="line">Container B( S2, S2 + 6 );</div><div class="line">Container AorB = makeUnion&lt;Container,true&gt;( A, B ); </div></div><!-- fragment --><h1><a class="anchor" id="dgtal_setfunctions_sec3"></a>
Benchmark for set operations</h1>
<p>We benchmark set operations for different kind of containers. In each case, we do not take into account the time for constructing containers A and B, we only measure the time to perform the operation. For each container, we compare the running time of our implementation and the running time obtained by first converting the container to a vector and perform STL set operation and converting back. Running times are in milliseconds.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">N = approx. size of A,B  </th><th class="markdownTableHeadNone">10000  </th><th class="markdownTableHeadNone">100000  </th><th class="markdownTableHeadNone">1000000  </th><th class="markdownTableHeadNone">10000000   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">vector&lt;int&gt; union  </td><td class="markdownTableBodyNone">0.6  </td><td class="markdownTableBodyNone">7.6  </td><td class="markdownTableBodyNone">91.1  </td><td class="markdownTableBodyNone">1039.2   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">(conversion) union  </td><td class="markdownTableBodyNone">0.7  </td><td class="markdownTableBodyNone">7.7  </td><td class="markdownTableBodyNone">90.7  </td><td class="markdownTableBodyNone">1034.3   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">vector&lt;int&gt; inter  </td><td class="markdownTableBodyNone">0.6  </td><td class="markdownTableBodyNone">7.1  </td><td class="markdownTableBodyNone">86.4  </td><td class="markdownTableBodyNone">986.5   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">(conversion) inter  </td><td class="markdownTableBodyNone">0.6  </td><td class="markdownTableBodyNone">7.1  </td><td class="markdownTableBodyNone">86.6  </td><td class="markdownTableBodyNone">981.0   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">vector&lt;int&gt; diff  </td><td class="markdownTableBodyNone">0.6  </td><td class="markdownTableBodyNone">7.0  </td><td class="markdownTableBodyNone">84.8  </td><td class="markdownTableBodyNone">991.0   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">(conversion) diff  </td><td class="markdownTableBodyNone">0.6  </td><td class="markdownTableBodyNone">7.3  </td><td class="markdownTableBodyNone">83.9  </td><td class="markdownTableBodyNone">986.1   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">vector&lt;int&gt; sym_diff  </td><td class="markdownTableBodyNone">0.6  </td><td class="markdownTableBodyNone">7.2  </td><td class="markdownTableBodyNone">85.2  </td><td class="markdownTableBodyNone">987.1   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">(conversion) sym_diff  </td><td class="markdownTableBodyNone">0.6  </td><td class="markdownTableBodyNone">7.1  </td><td class="markdownTableBodyNone">84.4  </td><td class="markdownTableBodyNone">982.4   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">set&lt;int&gt; union  </td><td class="markdownTableBodyNone">2.0  </td><td class="markdownTableBodyNone">25.8  </td><td class="markdownTableBodyNone">308.7  </td><td class="markdownTableBodyNone">3402.6   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">(conversion) union  </td><td class="markdownTableBodyNone">2.1  </td><td class="markdownTableBodyNone">27.0  </td><td class="markdownTableBodyNone">322.3  </td><td class="markdownTableBodyNone">3559.7   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">set&lt;int&gt; inter  </td><td class="markdownTableBodyNone">1.5  </td><td class="markdownTableBodyNone">17.3  </td><td class="markdownTableBodyNone">202.0  </td><td class="markdownTableBodyNone">2269.4   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">(conversion) inter  </td><td class="markdownTableBodyNone">1.7  </td><td class="markdownTableBodyNone">19.3  </td><td class="markdownTableBodyNone">241.8  </td><td class="markdownTableBodyNone">2515.9   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">set&lt;int&gt; diff  </td><td class="markdownTableBodyNone">1.3  </td><td class="markdownTableBodyNone">14.5  </td><td class="markdownTableBodyNone">171.0  </td><td class="markdownTableBodyNone">1821.7   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">(conversion) diff  </td><td class="markdownTableBodyNone">1.4  </td><td class="markdownTableBodyNone">16.5  </td><td class="markdownTableBodyNone">203.3  </td><td class="markdownTableBodyNone">2135.7   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">set&lt;int&gt; sym_diff  </td><td class="markdownTableBodyNone">1.7  </td><td class="markdownTableBodyNone">18.6  </td><td class="markdownTableBodyNone">213.8  </td><td class="markdownTableBodyNone">2403.7   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">(conversion) sym_diff  </td><td class="markdownTableBodyNone">1.6  </td><td class="markdownTableBodyNone">20.0  </td><td class="markdownTableBodyNone">242.6  </td><td class="markdownTableBodyNone">2660.7   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unordered_set&lt;int&gt; union  </td><td class="markdownTableBodyNone">1.0  </td><td class="markdownTableBodyNone">10.5  </td><td class="markdownTableBodyNone">176.2  </td><td class="markdownTableBodyNone">2464.1   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">(conversion) union  </td><td class="markdownTableBodyNone">2.5  </td><td class="markdownTableBodyNone">28.5  </td><td class="markdownTableBodyNone">439.3  </td><td class="markdownTableBodyNone">5855.7   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unordered_set&lt;int&gt; inter  </td><td class="markdownTableBodyNone">0.8  </td><td class="markdownTableBodyNone">10.6  </td><td class="markdownTableBodyNone">171.4  </td><td class="markdownTableBodyNone">2036.6   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">(conversion) inter  </td><td class="markdownTableBodyNone">2.1  </td><td class="markdownTableBodyNone">21.3  </td><td class="markdownTableBodyNone">321.3  </td><td class="markdownTableBodyNone">3929.2   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unordered_set&lt;int&gt; diff  </td><td class="markdownTableBodyNone">0.9  </td><td class="markdownTableBodyNone">11.8  </td><td class="markdownTableBodyNone">203.6  </td><td class="markdownTableBodyNone">2429.1   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">(conversion) diff  </td><td class="markdownTableBodyNone">1.9  </td><td class="markdownTableBodyNone">19.7  </td><td class="markdownTableBodyNone">290.2  </td><td class="markdownTableBodyNone">3523.1   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unordered_set&lt;int&gt; sym_diff  </td><td class="markdownTableBodyNone">2.5  </td><td class="markdownTableBodyNone">29.5  </td><td class="markdownTableBodyNone">428.5  </td><td class="markdownTableBodyNone">5855.4   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">(conversion) sym_diff  </td><td class="markdownTableBodyNone">2.1  </td><td class="markdownTableBodyNone">22.1  </td><td class="markdownTableBodyNone">339.4  </td><td class="markdownTableBodyNone">4025.6   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>It is worthy to note that the genericity offered by these functions does not slow down direct set operations on vectors, as can be seen on the upper part of the table. A second remark is that our set operations are almost always faster for set and unordered_set structures. In fact, for container set, it uses STL set operations. The only case where you could consider converting a container is when performing symmetric difference on an unordered set.</dd>
<dd>
An unordered_set is slightly faster than a set for union and intersection, slightly slower for difference, much slower for symmetric difference.</dd>
<dd>
Container A and B are built by inserting N elements whose values are in \( \{0,...,N-1\} \). Hence, both A and B have less than N elements but are of the order of N.</dd></dl>
<h1><a class="anchor" id="dgtal_setfunctions_sec4"></a>
Set relations</h1>
<p>We have chosen not to overload operators == (equality), &lt;= (subset), &gt;= (supset), != (difference), because there is a big risk of mess up with other standard operator overloading (for instance, it poses a problem with catch test framework). You may use <a class="el" href="namespaceDGtal_1_1functions.html#a82988f18c989530f73dab774abe12c90">functions::isEqual</a> and <a class="el" href="namespaceDGtal_1_1functions.html#ac7e98eb410830e5ca846260e66bff422">functions::isSubset</a> to compare sets.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceDGtal_1_1functions.html">DGtal::functions</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceDGtal_1_1functions_1_1setops.html">DGtal::functions::setops</a>;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;int&gt; Container; <span class="comment">// could be boost::unordered_set&lt;int&gt;, etc</span></div><div class="line"><span class="keywordtype">int</span> S1[ 10 ] = { 1, 3, 4, 7, 9, 12, 13, 15, 17, 20 };</div><div class="line"><span class="keywordtype">int</span> S2[ 6 ]  = { 2, 3, 4, 14, 17, 19 };</div><div class="line">Container A( S1, S1 + 10 );</div><div class="line">Container B( S2, S2 + 6 );</div><div class="line"><span class="keywordflow">if</span> ( <a class="code" href="namespaceDGtal_1_1functions.html#ac7e98eb410830e5ca846260e66bff422">isSubset</a>( A, A | B ) ) std::cout &lt;&lt; <span class="stringliteral">&quot;ok&quot;</span> &lt;&lt; std::endl; </div><div class="line"><span class="keywordflow">else</span>                        std::cout &lt;&lt; <span class="stringliteral">&quot;erreur&quot;</span> &lt;&lt; std::endl; </div><div class="line"><span class="keywordflow">if</span> ( <a class="code" href="namespaceDGtal_1_1functions.html#ac7e98eb410830e5ca846260e66bff422">isSubset</a>( A &amp; B, B ) ) std::cout &lt;&lt; <span class="stringliteral">&quot;ok&quot;</span> &lt;&lt; std::endl; </div><div class="line"><span class="keywordflow">else</span>                        std::cout &lt;&lt; <span class="stringliteral">&quot;erreur&quot;</span> &lt;&lt; std::endl; </div><div class="line"><span class="keywordflow">if</span> ( <a class="code" href="namespaceDGtal_1_1functions.html#a82988f18c989530f73dab774abe12c90">isEqual</a>( ( A | B ) - ( A &amp; B ), A ^ B ) )</div><div class="line">                            std::cout &lt;&lt; <span class="stringliteral">&quot;ok&quot;</span> &lt;&lt; std::endl; </div><div class="line"><span class="keywordflow">else</span>                        std::cout &lt;&lt; <span class="stringliteral">&quot;erreur&quot;</span> &lt;&lt; std::endl; </div></div><!-- fragment --><h1><a class="anchor" id="dgtal_setfunctions_sec5"></a>
For developpers: a traits class for containers</h1>
<p>In order to have set operations that can be indifferently applied to many kind of containers, we use a mechanism called traits. The class <a class="el" href="structDGtal_1_1ContainerTraits.html" title="Defines default container traits for arbitrary types.">ContainerTraits</a> is used to define the category for each container. There are several categories, which form a kind of hierarchy. Each <a class="el" href="structDGtal_1_1ContainerTraits.html" title="Defines default container traits for arbitrary types.">ContainerTraits</a> should contain an inner type called <code>Category</code> that defines the type of container. By default, it is <a class="el" href="structDGtal_1_1NotContainerCategory.html">NotContainerCategory</a>. But the <a class="el" href="structDGtal_1_1ContainerTraits.html" title="Defines default container traits for arbitrary types.">ContainerTraits</a> class is specialized for every STL container, for instance with:</p>
<div class="fragment"><div class="line"><span class="comment">// Defines container traits for std::vector&lt;&gt;.</span></div><div class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> T, <span class="keyword">class</span> Alloc &gt;</div><div class="line"><span class="keyword">struct </span>ContainerTraits&lt; std::vector&lt;T, Alloc&gt; &gt;</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> SequenceCategory <a class="code" href="structDGtal_1_1ContainerTraits.html#a64e553ee00afdedf9af22bbc707dd801">Category</a>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Defines container traits for std::map&lt;&gt;.</span></div><div class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Compare, <span class="keyword">class</span> Alloc &gt;</div><div class="line"><span class="keyword">struct </span>ContainerTraits&lt; std::map&lt;Key, T, Compare, Alloc&gt; &gt;</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> MapAssociativeCategory <a class="code" href="structDGtal_1_1ContainerTraits.html#a64e553ee00afdedf9af22bbc707dd801">Category</a>;</div><div class="line">};</div><div class="line"></div><div class="line">...</div></div><!-- fragment --><p>If you define a new container, you may associate its correct Category by specializing its <a class="el" href="structDGtal_1_1ContainerTraits.html" title="Defines default container traits for arbitrary types.">ContainerTraits</a> class with the correct category among <a class="el" href="structDGtal_1_1NotContainerCategory.html">NotContainerCategory</a>, <a class="el" href="structDGtal_1_1ContainerCategory.html">ContainerCategory</a>, <a class="el" href="structDGtal_1_1SequenceCategory.html">SequenceCategory</a>, <a class="el" href="structDGtal_1_1AssociativeCategory.html">AssociativeCategory</a>, <a class="el" href="structDGtal_1_1SimpleAssociativeCategory.html">SimpleAssociativeCategory</a>, <a class="el" href="structDGtal_1_1PairAssociativeCategory.html">PairAssociativeCategory</a>, <a class="el" href="structDGtal_1_1UniqueAssociativeCategory.html">UniqueAssociativeCategory</a>, <a class="el" href="structDGtal_1_1MultipleAssociativeCategory.html">MultipleAssociativeCategory</a>, <a class="el" href="structDGtal_1_1OrderedAssociativeCategory.html">OrderedAssociativeCategory</a>, <a class="el" href="structDGtal_1_1UnorderedAssociativeCategory.html">UnorderedAssociativeCategory</a>, <a class="el" href="structDGtal_1_1SetAssociativeCategory.html">SetAssociativeCategory</a>, <a class="el" href="structDGtal_1_1MultisetAssociativeCategory.html">MultisetAssociativeCategory</a>, <a class="el" href="structDGtal_1_1MapAssociativeCategory.html">MapAssociativeCategory</a>, <a class="el" href="structDGtal_1_1MultimapAssociativeCategory.html">MultimapAssociativeCategory</a>, <a class="el" href="structDGtal_1_1UnorderedSetAssociativeCategory.html">UnorderedSetAssociativeCategory</a>, <a class="el" href="structDGtal_1_1UnorderedMultisetAssociativeCategory.html">UnorderedMultisetAssociativeCategory</a>, <a class="el" href="structDGtal_1_1UnorderedMapAssociativeCategory.html">UnorderedMapAssociativeCategory</a>, <a class="el" href="structDGtal_1_1UnorderedMultimapAssociativeCategory.html">UnorderedMultimapAssociativeCategory</a>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 27 2019 12:04:09 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
