<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Surface mesh data structure for representing manifold or non-manifold polygonal surfaces in R3</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Surface mesh data structure for representing manifold or non-manifold polygonal surfaces in R3 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#SurfMesh_sec1">Creating a surface mesh</a></li>
<li class="level1"><a href="#SurfMesh_sec2">Topological relations within a surface mesh</a></li>
<li class="level1"><a href="#SurfMesh_sec3">A surface mesh is a graph</a></li>
<li class="level1"><a href="#SurfMesh_sec4">Getting manifold, boundary and non-manifold parts</a></li>
<li class="level1"><a href="#SurfMesh_sec5">Geometric positions and normals, and other information associated to cells</a></li>
<li class="level1"><a href="#SurfMesh_sec6">Further geometric services</a></li>
<li class="level1"><a href="#SurfMesh_sec7">Conversion and output to OBJ file format</a></li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Jacques-Olivier Lachaud</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1</dd></dl>
<p>Part of <a class="el" href="packageShapes.html">Shapes package</a></p>
<p>This part of the manual describes how to represent and manipulate generic polygonal surfaces embedded in \( \mathbb{R}^3 \). The class <a class="el" href="structDGtal_1_1SurfaceMesh.html">SurfaceMesh</a> proposes an index-based data structure that encodes all topological relations between vertices, edges and faces, even if the mesh presents some non manifold places (like 3 triangles tied along the same edge). Input/output operations to and from OBJ files are provided through classes <a class="el" href="structDGtal_1_1SurfaceMeshReader.html">SurfaceMeshReader</a> and <a class="el" href="structDGtal_1_1SurfaceMeshWriter.html">SurfaceMeshWriter</a>. Creation of classical surface 3D shapes (sphere, torus, Schwarz lantern) with groundtruth geometry is provided in <a class="el" href="structDGtal_1_1SurfaceMeshHelper.html">SurfaceMeshHelper</a>.</p>
<p>The following programs are related to this documentation: </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="testSurfaceMesh_8cpp.html">testSurfaceMesh.cpp</a>, <a class="el" href="exampleSurfaceMesh_8cpp.html" title="An example file for SurfaceMesh in 3D.">exampleSurfaceMesh.cpp</a></dd></dl>
<p>The useful includes are: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/shapes/SurfaceMesh.h&quot;</span>           <span class="comment">// main class</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/shapes/SurfaceMeshHelper.h&quot;</span>     <span class="comment">// creation/conversion</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/io/readers/SurfaceMeshReader.h&quot;</span> <span class="comment">// input from OBJ file</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/io/readers/SurfaceMeshWriter.h&quot;</span> <span class="comment">// output to OBJ file</span></div>
</div><!-- fragment --><h1><a class="anchor" id="SurfMesh_sec1"></a>
Creating a surface mesh</h1>
<p>A surface mesh (class <a class="el" href="structDGtal_1_1SurfaceMesh.html">SurfaceMesh</a>) is a template class parameterized by the types chosen for 3D points and 3D vectors. A common choice is <code><a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a>&lt; double, 3 &gt;</code> for both, or equivalently <code><a class="el" href="namespaceDGtal_1_1Z3i.html#a5f087066515ecd33cefd7bd080ef8114">Z3i::RealPoint</a></code> and <code><a class="el" href="namespaceDGtal_1_1Z3i.html#a5576ca14b13483060ec716f17bf6d81d">Z3i::RealVector</a></code>. Although the topological part of the class does not impose a 3D embedding, the class <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> imposes it since its target is 3D geometry processing. Indeed some geometric operations like computing normals from positions or i/o to OBJ format have meaning only in 3D.</p>
<p>First, write the following typedefs:</p>
<div class="fragment"><div class="line">  <span class="comment">// The following typedefs are useful</span></div>
<div class="line">  <span class="keyword">typedef</span> SurfaceMesh&lt; RealPoint, RealVector &gt;       SurfMesh;</div>
<div class="line">  <span class="keyword">typedef</span> SurfaceMeshHelper&lt; RealPoint, RealVector &gt; Helper;</div>
<div class="line">  <span class="keyword">typedef</span> SurfMesh::Vertices                         Vertices;</div>
</div><!-- fragment --><p> Then, there are several ways for creating a surface mesh (see <a class="el" href="exampleSurfaceMesh_8cpp.html">exampleSurfaceMesh.cpp</a> for several examples):</p>
<ul>
<li>by hand with a range of points for each vertex and a range of indices for of each polygonal face (see <a class="el" href="structDGtal_1_1SurfaceMesh.html#a5ef42406f47298de32220d127c91dfa3">SurfaceMesh::SurfaceMesh</a> and <a class="el" href="structDGtal_1_1SurfaceMesh.html#ac37c605467b040d20fe242f941044cba">SurfaceMesh::init</a>).</li>
</ul>
<div class="fragment"><div class="line">  std::vector&lt; RealPoint &gt; positions =</div>
<div class="line">    { { 0, 0, 5 }, { 1, 1, 3 }, { -1, 1, 3 }, { -1, -1, 3 }, { 1, -1, 3 } };</div>
<div class="line">  std::vector&lt; Vertices  &gt; faces =</div>
<div class="line">    { { 0, 1, 2 }, { 0, 2, 3 }, { 0, 3, 4 }, { 0, 4, 1 }, { 4, 3, 2, 1 } };</div>
<div class="line">  <span class="keyword">auto</span> pyramid_mesh = SurfMesh( positions.cbegin(), positions.cend(),</div>
<div class="line">                                faces.cbegin(), faces.cend() );</div>
</div><!-- fragment --><ul>
<li>by reading an OBJ (see <a class="el" href="structDGtal_1_1SurfaceMeshReader.html#a609dcf8e4bfb573e2b8c12b8beda388b">SurfaceMeshReader::readOBJ</a>).</li>
</ul>
<div class="fragment"><div class="line">  SurfMesh    smesh;</div>
<div class="line">  std::string S = examplesPath + <span class="stringliteral">&quot;samples/spot.obj&quot;</span>;</div>
<div class="line">  std::ifstream input( S.c_str() );</div>
<div class="line">  <span class="keywordtype">bool</span> ok_read  =  <a class="code" href="structDGtal_1_1SurfaceMeshReader.html#a609dcf8e4bfb573e2b8c12b8beda388b">SurfaceMeshReader&lt; RealPoint, RealVector &gt;::readOBJ</a>( input, smesh );</div>
<div class="line">  input.close();</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;Read &quot;</span> &lt;&lt; ( ok_read ? <span class="stringliteral">&quot;OK&quot;</span> : <span class="stringliteral">&quot;ERROR&quot;</span> )</div>
<div class="line">               &lt;&lt; <span class="stringliteral">&quot; mesh=&quot;</span> &lt;&lt; smesh &lt;&lt; std::endl;</div>
</div><!-- fragment --><ul>
<li>by using classical predefined surfaces (see <a class="el" href="structDGtal_1_1SurfaceMeshHelper.html#aaefdf1b72df3d261c2e08f0315feb4f8">SurfaceMeshHelper::makeSphere</a>, <a class="el" href="structDGtal_1_1SurfaceMeshHelper.html#abf505fb6da1221e624eac901e9a56362">SurfaceMeshHelper::makeTorus</a>, <a class="el" href="structDGtal_1_1SurfaceMeshHelper.html#abfedc0b0759677aab667ce60d6dfa5b8">SurfaceMeshHelper::makeLantern</a>).</li>
</ul>
<div class="fragment"><div class="line">  <span class="keyword">auto</span> torus_mesh = Helper::makeTorus</div>
<div class="line">    ( 2.5, 0.5, <a class="code" href="classDGtal_1_1PointVector.html">RealPoint</a> { 0.0, 0.0, 0.0 }, 40, 40, 0, Helper::NormalsType::NO_NORMALS );</div>
</div><!-- fragment --> <div class="image">
<img src="exampleSurfaceMesh.jpg" alt=""/>
<div class="caption">
Creating surface meshes from OBJ file, by specifying vertex/face information or predefined shapes</div></div>
<h1><a class="anchor" id="SurfMesh_sec2"></a>
Topological relations within a surface mesh</h1>
<p>All topological relations are precomputed as static arrays in <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> class (which is thus not adapted to dynamic topological updates). You may access the number of cells with <a class="el" href="structDGtal_1_1SurfaceMesh.html#ad32cc734fe88ed61b14c03632d2cde31">SurfaceMesh::nbVertices</a>, <a class="el" href="structDGtal_1_1SurfaceMesh.html#aadc9198c62b1e9b19107f97dc2ddf006">SurfaceMesh::nbEdges</a>, <a class="el" href="structDGtal_1_1SurfaceMesh.html#aac6df23e1b3e15f57df733bb6db40a81">SurfaceMesh::nbFaces</a>. Note that edge indices corresponds to pairs of vertices (i,j) with i&lt;j.</p>
<p>You may ask for each vertex <em>v:</em> </p><ul>
<li>its range of incident faces with <a class="el" href="structDGtal_1_1SurfaceMesh.html#ac33bc603456ef18c0235984573f52819">SurfaceMesh::incidentFaces</a> (order not significant)</li>
<li>its range of neighbor vertices with <a class="el" href="structDGtal_1_1SurfaceMesh.html#adeecc6c396f542ac4a4687d44fa143cb">SurfaceMesh::neighborVertices</a> (order not significant)</li>
</ul>
<p>You may ask for each face <em>f:</em> </p><ul>
<li>its range of incident vertices with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a7582377906fd0876b5242087e95e0dd9">SurfaceMesh::incidentVertices</a> (the order is significant: to each consecutive pair of vertices, there is a corresponding edge).</li>
<li>its range of neighbor faces with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a14252183ef38876935be2fc60b1a95fe">SurfaceMesh::neighborFaces</a> (order not significant)</li>
</ul>
<p>You may create an edge index with <a class="el" href="structDGtal_1_1SurfaceMesh.html#aca1088826624c5caeec89959e81c6fbf">SurfaceMesh::makeEdge</a>. If the two vertices (i,j) do not form an edge, then the returned index is <a class="el" href="structDGtal_1_1SurfaceMesh.html#aadc9198c62b1e9b19107f97dc2ddf006">SurfaceMesh::nbEdges</a>. Note that calling <code>makeEdge(i,j)</code> or <code>makeEdge(j,i)</code> returns always the same index, whether valid or invalid.</p>
<p>You may ask for each edge <em>e:</em> </p><ul>
<li>its two incident vertices with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a7582377906fd0876b5242087e95e0dd9">SurfaceMesh::incidentVertices</a>, as pair (i,j) with (i&lt;j).</li>
<li>its range of bordering faces with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a445fc9454698feb2b511d11cc9325aad">SurfaceMesh::edgeFaces</a> (they can be incident clockwise or counterclockwise)</li>
<li>its range of left bordering faces with <a class="el" href="structDGtal_1_1SurfaceMesh.html#ac6c10c8bb58182bf79bc18dde1c73b12">SurfaceMesh::edgeLeftFaces</a> (a face to its left, being defined ccw, means that the face is some <code>(..., i, j, ... )</code>)</li>
<li>its range of right bordering faces with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a786162fa9024e11895924c3dfc020682">SurfaceMesh::edgeRightFaces</a> (a face to its left, being defined ccw, means that the face is some <code>(..., j, i, ... )</code>)</li>
</ul>
<p>All the preceding methods have global variants returning all incident faces, all incident vertices, etc: <a class="el" href="structDGtal_1_1SurfaceMesh.html#afc977bb23dd4e7fe09ba1593df6def10">SurfaceMesh::allIncidentFaces</a>, <a class="el" href="structDGtal_1_1SurfaceMesh.html#ac0a2983a80c66e39b85cf71368cb9053">SurfaceMesh::allIncidentVertices</a>, <a class="el" href="structDGtal_1_1SurfaceMesh.html#ae9c47796ab4228489ca0fb69c2d50149">SurfaceMesh::allNeighborFaces</a>, <a class="el" href="structDGtal_1_1SurfaceMesh.html#a92ae3f4852fbbd81c0e98eb01fbdad49">SurfaceMesh::allNeighborVertices</a>, <a class="el" href="structDGtal_1_1SurfaceMesh.html#a8a5e75d81736dd8a757a2c66843e8dc8">SurfaceMesh::allEdgeFaces</a>, <a class="el" href="structDGtal_1_1SurfaceMesh.html#ab38ecba9777b56b8396e07b5c53f4c2a">SurfaceMesh::allEdgeLeftFaces</a>, <a class="el" href="structDGtal_1_1SurfaceMesh.html#a3989e2303a5cd12cb5b5b89e68d92372">SurfaceMesh::allEdgeRightFaces</a>.</p>
<p>Since vertices/edges/faces are indices, visiting them is simply a loop from 0 (included) till <a class="el" href="structDGtal_1_1SurfaceMesh.html#ad32cc734fe88ed61b14c03632d2cde31">SurfaceMesh::nbVertices</a> / <a class="el" href="structDGtal_1_1SurfaceMesh.html#aadc9198c62b1e9b19107f97dc2ddf006">SurfaceMesh::nbEdges</a> / <a class="el" href="structDGtal_1_1SurfaceMesh.html#aac6df23e1b3e15f57df733bb6db40a81">SurfaceMesh::nbFaces</a> (all excluded).</p>
<h1><a class="anchor" id="SurfMesh_sec3"></a>
A surface mesh is a graph</h1>
<p>Class <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> is a model of <a class="el" href="structDGtal_1_1concepts_1_1CUndirectedSimpleGraph.html" title="Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not neces...">concepts::CUndirectedSimpleGraph</a> (see also moduleGraphDefinitions). Hence you can for instance perform a breadth first traversal on its vertices.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/shapes/SurfaceMesh.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/graph/BreadthFirstVisitor.h&quot;</span></div>
<div class="line">...</div>
<div class="line">typedef SurfaceMesh&lt; RealPoint, RealVector &gt; SurfMesh;</div>
<div class="line">SurfMesh smesh;</div>
</div><!-- fragment --><div class="fragment"><div class="line">  BreadthFirstVisitor&lt; SurfMesh &gt; visitor( smesh, 0 );</div>
<div class="line">  std::vector&lt;double&gt;             distances( smesh.nbVertices() );</div>
<div class="line">  <span class="keywordtype">double</span> biggest_d = 0.0;</div>
<div class="line">  <span class="keywordflow">while</span> ( ! visitor.finished() )</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">auto</span> v = visitor.current().first;  <span class="comment">// current vertex</span></div>
<div class="line">      <span class="keyword">auto</span> d = visitor.current().second; <span class="comment">// current distance</span></div>
<div class="line">      biggest_d      = (double) d;</div>
<div class="line">      distances[ v ] = biggest_d;</div>
<div class="line">      visitor.expand();</div>
<div class="line">    }</div>
</div><!-- fragment --> <h1><a class="anchor" id="SurfMesh_sec4"></a>
Getting manifold, boundary and non-manifold parts</h1>
<p><a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> can compute range of edges that have the same topology.</p>
<ul>
<li><a class="el" href="structDGtal_1_1SurfaceMesh.html#ab053beb5757cc26b5c0dd9c6053eeb42">SurfaceMesh::computeManifoldBoundaryEdges</a> returns the edges that lie on the boundary of the mesh, i.e. they have only one incident face.</li>
<li><a class="el" href="structDGtal_1_1SurfaceMesh.html#a2bdf5511bb00776a160aed5f8589af80">SurfaceMesh::computeManifoldInnerEdges</a> returns the edges that lie on the inside of the mesh, with two incident faces, consistently oriented or not.</li>
<li><a class="el" href="structDGtal_1_1SurfaceMesh.html#ab0a56f6242bce2ace7a31ad35b583252">SurfaceMesh::computeManifoldInnerConsistentEdges</a> returns the edges that lie on the inside of the mesh, with consistent local orientation, i.e. they have one left incident face, and one right incident face.</li>
<li><a class="el" href="structDGtal_1_1SurfaceMesh.html#a18dfbbad425584b1a4ba60559097a05d">SurfaceMesh::computeManifoldInnerUnconsistentEdges</a> returns the edges that have two incident faces, but not correctly oriented, i.e. they may have two left incident faces and no right incident face, or two right incident faces and no left incident face.</li>
<li><a class="el" href="structDGtal_1_1SurfaceMesh.html#add89b6762bb7150e760351ca110d28f8">SurfaceMesh::computeNonManifoldEdges</a> returns the edges that are non manifold, i.e. neither boundary or inner edges: they may have more than two incident faces, or two left incident faces for instance.</li>
</ul>
<p>Locating non manifold vertices (like pinched vertices) requires more work and is not implemented.</p>
<h1><a class="anchor" id="SurfMesh_sec5"></a>
Geometric positions and normals, and other information associated to cells</h1>
<p>Vertex positions can be accessed and modified through methods <a class="el" href="structDGtal_1_1SurfaceMesh.html#a588ded45e821d2e139b23e8b6cbbe45c">SurfaceMesh::positions</a>, or <a class="el" href="structDGtal_1_1SurfaceMesh.html#a1963ef0c711e98ceff402c5f610dd7b1">SurfaceMesh::position</a> with a given vertex index.</p>
<p>You may associate normal vectors to the mesh as follows:</p><ul>
<li>to vertices with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a2380b33954d4706f4e2d6643be4b89bf">SurfaceMesh::setVertexNormals</a></li>
<li>to faces with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a9c28be28fa07b724ee6604cc88177859">SurfaceMesh::setFaceNormals</a></li>
<li>to faces from vertex positions with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a51bb91e3a8f3296e4e3a5062bc272f91">SurfaceMesh::computeFaceNormalsFromPositions</a></li>
<li>from faces to vertices with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a66173c8fdc013e2b41b60669b268baf4">SurfaceMesh::computeVertexNormalsFromFaceNormals</a> or <a class="el" href="structDGtal_1_1SurfaceMesh.html#a95f5eaf3fcfe06f2644bd2fdf98f527a">SurfaceMesh::computeVertexNormalsFromFaceNormalsWithMaxWeights</a></li>
<li>from vertices to faces with <a class="el" href="structDGtal_1_1SurfaceMesh.html#ad6030c53a9979e2ff9ec4fb0da4a56a8">SurfaceMesh::computeFaceNormalsFromVertexNormals</a></li>
</ul>
<p>Normals are then accessed with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a4dc72e5cca3debbe5105e5736d582eb8">SurfaceMesh::vertexNormals</a> for vertices, <a class="el" href="structDGtal_1_1SurfaceMesh.html#a3f63b6657234e3cd793a261392fca33d">SurfaceMesh::faceNormals</a> for faces, or per element with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a5d95e19d58d9d2d5c81efb7bad21af03">SurfaceMesh::vertexNormal</a> and <a class="el" href="structDGtal_1_1SurfaceMesh.html#a66a25c58fc620a6e56dd4ffc2057e59e">SurfaceMesh::faceNormal</a>.</p>
<p>More generally, you can transfer (by averaging) vector of values:</p>
<ul>
<li>from faces to vertices with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a65df2c41eb4875999c9212c7f5df7d62">SurfaceMesh::computeVertexValuesFromFaceValues</a> or <a class="el" href="structDGtal_1_1SurfaceMesh.html#a1ef0d2e49005477ef1433ed0dc93bea9">SurfaceMesh::computeVertexUnitVectorsFromFaceUnitVectors</a> for unit vectors</li>
<li>from vertices to faces with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a545b0f5cb95a0ff1958fe890ee2735a6">SurfaceMesh::computeFaceValuesFromVertexValues</a> or <a class="el" href="structDGtal_1_1SurfaceMesh.html#a9b07c042333e0e6a71cb7a861a45c77b">SurfaceMesh::computeFaceUnitVectorsFromVertexUnitVectors</a> for unit vectors</li>
</ul>
<h1><a class="anchor" id="SurfMesh_sec6"></a>
Further geometric services</h1>
<p>The following local geometric services are provided:</p>
<ul>
<li>the area of a face with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a4ecb750380b28e683894b7147e286717">SurfaceMesh::faceArea</a></li>
<li>the centroid of a face with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a319ebe4a9146218ec828a436eabce6c9">SurfaceMesh::faceCentroid</a></li>
<li>the centroid of an edge with <a class="el" href="structDGtal_1_1SurfaceMesh.html#ad47116b56e00f134f45715432660180e">SurfaceMesh::edgeCentroid</a></li>
<li>the average distance between the centroid of face and its vertices with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a468a554c9e453dfd4b7eab5e4d585ed4">SurfaceMesh::localWindow</a></li>
<li>the classical Max's weights for each incident face to a vertex with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a40da91badf55d7dca689038c9e7f2022">SurfaceMesh::getMaxWeights</a> (see <a class="el" href="structDGtal_1_1SurfaceMesh.html#a95f5eaf3fcfe06f2644bd2fdf98f527a">SurfaceMesh::computeVertexNormalsFromFaceNormalsWithMaxWeights</a>)</li>
<li>the vector of weighted faces comprising all the faces included in some ball with <a class="el" href="structDGtal_1_1SurfaceMesh.html#abc25df3bb3a910aeb402817d30a6713c">SurfaceMesh::computeFacesInclusionsInBall</a>, where the weights represent the inclusion ratio of each face in the given ball (from 0, empty intersection, to 1, completely included).</li>
<li>the vectors of weighted cells comprising all the cells included in some ball with <a class="el" href="structDGtal_1_1SurfaceMesh.html#aacf5e524ff895c5dddb7d67feabada10">SurfaceMesh::computeCellsInclusionsInBall</a>, where the weights represent the inclusion ratio (from 0, empty intersection, to 1, completely included).</li>
</ul>
<p>The following global geometric services are provided:</p>
<ul>
<li>the average of the length of edges with <a class="el" href="structDGtal_1_1SurfaceMesh.html#af39993de1b39d4e225742bc79502cafa">SurfaceMesh::averageEdgeLength</a></li>
</ul>
<p>You may also perturbate the mesh positions with uniform or non uniform random noise: with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a48ea9dbdb41f6d76f3a7d386ef7ab6ba">SurfaceMesh::perturbateWithUniformRandomNoise</a> and <a class="el" href="structDGtal_1_1SurfaceMesh.html#a2094a7663c3d875c2966561c888a8f53">SurfaceMesh::perturbateWithAdaptiveUniformRandomNoise</a>;</p>
<h1><a class="anchor" id="SurfMesh_sec7"></a>
Conversion and output to OBJ file format</h1>
<p>You can convert a <a class="el" href="structDGtal_1_1SurfaceMesh.html">SurfaceMesh</a> to a <a class="el" href="classDGtal_1_1Mesh.html">Mesh</a> object simply by calling <a class="el" href="classDGtal_1_1MeshHelpers.html#a94060e366b4dc1388cac915973a5ab3a">MeshHelpers::surfaceMesh2Mesh</a>.</p>
<p>You can also output OBJ file (if available, with vertex normal information) using class <a class="el" href="structDGtal_1_1SurfaceMeshWriter.html#a2d786cc76abdacdbabaa75f9518cbf72">SurfaceMeshWriter::writeOBJ</a>, with some specialization allowing you to color faces. Edge lines and iso-lines can also be output as OBJ in same class.</p>
<p>The snippet below shows how to output the distances computed in <a class="el" href="moduleSurfaceMesh.html#SurfMesh_sec3">A surface mesh is a graph</a> as a surface colored per face with three isolines corresponding to relative distances 0.25, 0.5 and 0.75.</p>
<div class="fragment"><div class="line">  <span class="comment">// Displaying faces colored by their distance to vertex 0.</span></div>
<div class="line">  <span class="keyword">auto</span> face_distances = smesh.computeFaceValuesFromVertexValues( distances );</div>
<div class="line">  <span class="keyword">auto</span> cmap = GradientColorMap&lt; double &gt;( 0.0, biggest_d, <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2ac677c31e4299bc29c4e591063b4fc9bb">CMAP_JET</a> );</div>
<div class="line">  std::vector&lt;Color&gt; face_colors( smesh.nbFaces() );</div>
<div class="line">  <span class="keywordflow">for</span> ( <a class="code" href="testTriangulatedSurface_8cpp.html#aa7e89e659ae870a9963bb6109a53da62">SurfMesh::Face</a> j = 0; j &lt; smesh.nbFaces(); ++j )</div>
<div class="line">    face_colors[ j ] = cmap( face_distances[ j ] );      </div>
<div class="line">  <span class="keyword">typedef</span> SurfaceMeshWriter&lt; RealPoint, RealVector &gt; Writer;</div>
<div class="line">  Writer::writeOBJ( <span class="stringliteral">&quot;spot-bft.obj&quot;</span>, smesh, face_colors );</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Displaying three isolines.</span></div>
<div class="line">  Writer::writeIsoLinesOBJ( <span class="stringliteral">&quot;spot-iso-0_25.obj&quot;</span>, smesh,</div>
<div class="line">                            face_distances, distances, distances.back() * 0.25, 0.2 );</div>
<div class="line">  Writer::writeIsoLinesOBJ( <span class="stringliteral">&quot;spot-iso-0_5.obj&quot;</span>,  smesh,</div>
<div class="line">                            face_distances, distances, distances.back() * 0.5,  0.2 );</div>
<div class="line">  Writer::writeIsoLinesOBJ( <span class="stringliteral">&quot;spot-iso-0_75.obj&quot;</span>, smesh,</div>
<div class="line">                            face_distances, distances, distances.back() * 0.75, 0.2 );</div>
</div><!-- fragment --> <div class="image">
<img src="spot-bft-isolines.png" alt=""/>
<div class="caption">
SurfaceMesh faces colored according to distance to bluest vertex and three isodistance lines</div></div>
 </div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="atestTriangulatedSurface_8cpp_html_aa7e89e659ae870a9963bb6109a53da62"><div class="ttname"><a href="testTriangulatedSurface_8cpp.html#aa7e89e659ae870a9963bb6109a53da62">Face</a></div><div class="ttdeci">TriMesh::Face Face</div><div class="ttdef"><b>Definition:</b> <a href="testTriangulatedSurface_8cpp_source.html#l00056">testTriangulatedSurface.cpp:56</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a8fc7012708b0416880a5c8b12dfdf9dd"><div class="ttname"><a href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">DGtal::trace</a></div><div class="ttdeci">Trace trace</div><div class="ttdef"><b>Definition:</b> <a href="Common_8h_source.html#l00150">Common.h:150</a></div></div>
<div class="ttc" id="astructDGtal_1_1SurfaceMeshReader_html_a609dcf8e4bfb573e2b8c12b8beda388b"><div class="ttname"><a href="structDGtal_1_1SurfaceMeshReader.html#a609dcf8e4bfb573e2b8c12b8beda388b">DGtal::SurfaceMeshReader::readOBJ</a></div><div class="ttdeci">static bool readOBJ(std::istream &amp;input, SurfaceMesh &amp;smesh)</div></div>
<div class="ttc" id="aclassDGtal_1_1Trace_html_ad054990834d2763627166540087a2980"><div class="ttname"><a href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">DGtal::Trace::info</a></div><div class="ttdeci">std::ostream &amp; info()</div></div>
<div class="ttc" id="anamespaceDGtal_html_aa68309838cffd86a3c671c44ef129cb2ac677c31e4299bc29c4e591063b4fc9bb"><div class="ttname"><a href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2ac677c31e4299bc29c4e591063b4fc9bb">DGtal::CMAP_JET</a></div><div class="ttdeci">@ CMAP_JET</div><div class="ttdef"><b>Definition:</b> <a href="GradientColorMap_8h_source.html#l00069">GradientColorMap.h:69</a></div></div>
<div class="ttc" id="aclassDGtal_1_1PointVector_html"><div class="ttname"><a href="classDGtal_1_1PointVector.html">DGtal::PointVector</a></div><div class="ttdoc">Aim: Implements basic operations that will be used in Point and Vector classes.</div><div class="ttdef"><b>Definition:</b> <a href="PointVector_8h_source.html#l00592">PointVector.h:593</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 9 2020 08:58:57 for DGtal by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
