<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Curvature measures on meshes and digital surfaces</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;1.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Curvature measures on meshes and digital surfaces </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#dgtal_curvature_measures_sec1">Introduction to curvature measures</a></li>
<li class="level1"><a href="#dgtal_curvature_measures_sec2">Computing curvature measures on meshes</a><ul><li class="level2"><a href="#dgtal_curvature_measures_sec21">Normal Cycle curvature measures</a></li>
<li class="level2"><a href="#dgtal_curvature_measures_sec22">Interpolated Corrected Normal Current curvature measures</a></li>
<li class="level2"><a href="#dgtal_curvature_measures_sec23">Vertex-interpolated versus face-constant corrected normal current</a></li>
<li class="level2"><a href="#dgtal_curvature_measures_sec24">More on curvature measures</a></li>
<li class="level2"><a href="#dgtal_curvature_measures_sec25">ICNC Curvature computation on OBJ surface</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtal_curvature_measures_sec3">Corrected curvature measures on digital surfaces</a><ul><li class="level2"><a href="#dgtal_curvature_measures_sec31">CCNC and ICNC curvature measures on discretized polynomial surfaces</a></li>
<li class="level2"><a href="#dgtal_curvature_measures_sec32">ICNC curvature measures on digital boundaries in VOL file</a></li>
<li class="level2"><a href="#dgtal_curvature_measures_sec33">Comparison between integral invariant  and CNC curvature estimates on digital boundaries</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Jacques-Olivier Lachaud</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.3</dd></dl>
<p>Part of the <a class="el" href="packageGeometry.html">Geometry package</a>.</p>
<p >This part of the manual describes the implementation of several curvature measures on quite arbitrary meshes (any instance of <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a>). The classical curvature measures related to the Normal Cycle are provided as well as the more general curvature measures based on corrected normal currents. This module implements the research on corrected normal currents presented in papers <a class="el" href="citelist.html#CITEREF_lachaud:hal-02193774">[71]</a> and <a class="el" href="citelist.html#CITEREF_lachaud2020interpolated">[72]</a>, and also gives a stand-alone implementation of the normal cycle method, which was presented in papers <a class="el" href="citelist.html#CITEREF_cohen2003restricted">[35]</a> and <a class="el" href="citelist.html#CITEREF_cohen2006second">[36]</a>.</p>
<p >The following programs are related to this documentation: <a href="geometry_2meshes_2curvature-measures-icnc-3d_8cpp-example.html">geometry/meshes/curvature-measures-icnc-3d.cpp</a>, <a href="geometry_2meshes_2curvature-measures-icnc-XY-3d_8cpp-example.html">geometry/meshes/curvature-measures-icnc-XY-3d.cpp</a>, <a href="geometry_2meshes_2curvature-measures-nc-3d_8cpp-example.html">geometry/meshes/curvature-measures-nc-3d.cpp</a>, <a href="geometry_2meshes_2curvature-measures-nc-XY-3d_8cpp-example.html">geometry/meshes/curvature-measures-nc-XY-3d.cpp</a>, <a href="geometry_2meshes_2obj-curvature-measures-icnc-3d_8cpp-example.html">geometry/meshes/obj-curvature-measures-icnc-3d.cpp</a>, <a href="geometry_2meshes_2obj-curvature-measures-icnc-XY-3d_8cpp-example.html">geometry/meshes/obj-curvature-measures-icnc-XY-3d.cpp</a>, <a href="geometry_2meshes_2vol-curvature-measures-icnc-3d_8cpp-example.html">geometry/meshes/vol-curvature-measures-icnc-3d.cpp</a>, <a href="geometry_2meshes_2vol-curvature-measures-icnc-XY-3d_8cpp-example.html">geometry/meshes/vol-curvature-measures-icnc-XY-3d.cpp</a>, <a href="geometry_2meshes_2digpoly-curvature-measures-cnc-3d_8cpp-example.html">geometry/meshes/digpoly-curvature-measures-cnc-3d.cpp</a>, <a href="geometry_2meshes_2digpoly-curvature-measures-cnc-3d_8cpp-example.html">geometry/meshes/digpoly-curvature-measures-cnc-XY-3d.cpp</a>.</p>
<p >The following tests are related to this documentation: <a class="el" href="testCorrectedNormalCurrentComputer_8cpp.html">testCorrectedNormalCurrentComputer.cpp</a>, <a class="el" href="testNormalCycleComputer_8cpp.html">testNormalCycleComputer.cpp</a>.</p>
<h1><a class="anchor" id="dgtal_curvature_measures_sec1"></a>
Introduction to curvature measures</h1>
<p >Curvature is an important geometric piece of information which has the drawback of being well defined only on smooth sets. Unfortunately, most geometric data are non-smooth (e.g. triangulated or polygonal surfaces, point clouds, polyhedra). A lot of works have thus aimed at generalizing curvatures to such sets, while guaranteeing that such definitions tend (in some sense) towards the classical smooth curvatures when working on finer and finer non smooth approximations of smooth data.</p>
<p >The seminal paper of Federer <a class="el" href="citelist.html#CITEREF_federer1959curvature">[50]</a> first defined <em>curvature</em> <em>measures</em> on sets with positive reach (which includes smooth and convex polyhedra, but not triangulated surfaces in general). Using the notion of Normal Cycle introduced by Wintgen <a class="el" href="citelist.html#CITEREF_wintgen1982normal">[115]</a>, the curvature measure principle was then extended to a wider class of objects including triangulations, digitized objects and subanalytic sets by Fu <a class="el" href="citelist.html#CITEREF_fu1994curvature">[56]</a>.</p>
<p >The main idea of the <b>Normal</b> <b>Cycle</b> is to embed the shape into the Grassmann bundle, which encodes both positions and the normal cones. This embedding is itself piecewise smooth, and curvatures can be defined onto it by integration with the <em>invariant</em> <em>differential</em> <em>forms</em> (Lipschitz-Killing forms). This approach was used for instance by Cohen-Steiner and Morvan <a class="el" href="citelist.html#CITEREF_cohen2003restricted">[35]</a> <a class="el" href="citelist.html#CITEREF_cohen2006second">[36]</a> for triangulated surfaces, where they show stability of curvature measures for surface sampling with convergent normals. Extensions of such works to point clouds using offset surfaces were proposed by Chazal, Cohen-Steiner, Lieutier and Thibert in <a class="el" href="citelist.html#CITEREF_chazal2009stability">[24]</a>.</p>
<p >However these methods do not provide consistent curvature estimates when the normal vector field of the discretization does not tend towards the normal vector field of the reference smooth surface. A famous example is the <a href="https://en.wikipedia.org/wiki/Schwarz_lantern">Schwarz lantern</a>. This is also the case of digital surfaces that are boundaries of pixel/voxel data in images. For these surfaces, even high resolution data implies only 4 (in 2D) or 6 (in 3D) possible normal vectors.</p>
<p >This module therefore proposes an implementation of <b>corrected</b> <b>normal</b> <b>currents</b> to compute curvature measures onto quite general discrete surface data. The key idea is to replace the normal vector field of a surface <em>S</em> by another vector field <b>u</b> which we assume to be geometrically more meaningful. For instance if <em>S</em> is a digitization of a smooth surface <em>X</em>, one may take for <b>u</b> a local average of the naive normals of <em>X</em>.</p>
<p >The general theory was proposed by Lachaud, Romon and Thibert in <a class="el" href="citelist.html#CITEREF_lachaud:hal-02193774">[71]</a>. It deals with piecewise \( C^{1,1} \) surfaces, with piecewise \( C^1 \) corrected normal vector field. A specialized version restricted to polygonal meshes equipped with a normal vector field defined by linear interpolation was presented in <a class="el" href="citelist.html#CITEREF_lachaud2020interpolated">[72]</a>, and leads to quite simple formulae.</p>
<p >For instance, the <em>interpolated</em> <em>corrected</em> <em>curvature</em> <em>measures</em> take the following values on a triangle \( \tau_{ijk} \), with vertices <em>i</em>, <em>j</em>, <em>k:</em> </p>
<p class="formulaDsp">
\[
  \begin{align*}
  \mu^{(0)}(\tau_{ijk}) = &amp;\frac{1}{2} \langle \bar{\mathbf{u}} \mid (\mathbf{x}_j - \mathbf{x}_i) \times (\mathbf{x}_k - \mathbf{x}_i) \rangle, \\
  \mu^{(1)}(\tau_{ijk}) = &amp;\frac{1}{2} \langle \bar{\mathbf{u}} \mid (\mathbf{u}_k - \mathbf{u}_j) \times \mathbf{x}_i + (\mathbf{u}_i - \mathbf{u}_k) \times \mathbf{x}_j + (\mathbf{u}_j - \mathbf{u}_i) \times \mathbf{x}_k \rangle, \\
  \mu^{(2)}(\tau_{ijk}) = &amp;\frac{1}{2} \langle \mathbf{u}_i \mid \mathbf{u}_j \times \mathbf{u}_k \rangle, \\
  \mu^{\mathbf{X},\mathbf{Y}}(\tau_{ijk}) = &amp; \frac{1}{2} \big\langle \bar{\mathbf{u}} \big| \langle \mathbf{Y} | \mathbf{u}_k -\mathbf{u}_i \rangle \mathbf{X} \times (\mathbf{x}_j - \mathbf{x}_i) \big\rangle
    -\frac{1}{2} \big\langle \bar{\mathbf{u}} \big| \langle \mathbf{Y} | \mathbf{u}_j -\mathbf{u}_i \rangle \mathbf{X} \times (\mathbf{x}_k - \mathbf{x}_i) \big\rangle,
  \end{align*}
\]
</p>
<p> where \( \langle \cdot \mid \cdot \rangle \) denotes the usual scalar product, \( \bar{\mathbf{u}}=\frac{1}{3}( \mathbf{u}_i + \mathbf{u}_j + \mathbf{u}_k )\).</p>
<p >The measure \( \mu^{(0)} \) is the <em>corrected</em> <em>area</em> <em>density</em> of the given triangle, \( \mu^{(1)} \) is twice its <em>corrected</em> <em>mean</em> <em>curvature</em> <em>density</em>, \( \mu^{(2)} \) is its <em>corrected</em> <em>Gaussian</em> <em>curvature</em> <em>density</em>. The (anisotropic) measure \(
\mu^{\mathbf{X},\mathbf{Y}} \) is the trace of the <em>corrected</em> <em>second</em> <em>fundamental</em> <em>form</em> along directions \( \mathbf{X} \) and \( \mathbf{Y} \). While the smooth second fundamental form is naturally a symmetric 2-tensor, there is no easy way to define tangent directions at a vertex, so the anisotropic measure depends on two 3D vectors; when \( \mathbf{X} \) and \( \mathbf{Y} \) are tangent, \( \mu^{\mathbf{X},\mathbf{Y}} \) is close to the second fundamental form applied to these vectors, while its value along normal direction tends to zero asymptotically.</p>
<p >These measures are naturally extended to an arbitrary subset <em>B</em> of \( \mathbb{R}^3 \) by measuring its intersection ratio with each triangle \( \tau \) and by suming over all triangles of the mesh.</p>
<p class="formulaDsp">
\[
\mu^{(k)}( B ) = \sum_{\tau : \text{triangle} } \mu^{(k)}( \tau ) \frac{\mathrm{Area}( \tau \cap B )}{\mathrm{Area}(\tau)}.
\]
</p>
<h1><a class="anchor" id="dgtal_curvature_measures_sec2"></a>
Computing curvature measures on meshes</h1>
<p >Curvature measures formula per triangle/edge/vertex are provided in class <a class="el" href="structDGtal_1_1NormalCycleFormula.html" title="Aim: A helper class that provides static methods to compute normal cycle formulas of curvatures.">NormalCycleFormula</a> (for the curvatures measures induced by the Normal Cycle) and in class <a class="el" href="structDGtal_1_1CorrectedNormalCurrentFormula.html" title="Aim: A helper class that provides static methods to compute corrected normal current formulas of curv...">CorrectedNormalCurrentFormula</a> (for the curvatures measures induced by corrected normal currents with interpolated corrected normal vector field).</p>
<p >However one generally wishes to compute the measures over a mesh in a ball of given center and radius. It is then more convenient to use classes <a class="el" href="structDGtal_1_1NormalCycleComputer.html" title="Aim: Utility class to compute curvatures measures induced by (1) the normal cycle induced by a Surfac...">NormalCycleComputer</a> and <a class="el" href="structDGtal_1_1CorrectedNormalCurrentComputer.html" title="Aim: Utility class to compute curvature measures induced by (1) a corrected normal current defined by...">CorrectedNormalCurrentComputer</a>, which are dedicated to compute curvature measures over a <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> object.</p>
<h2><a class="anchor" id="dgtal_curvature_measures_sec21"></a>
Normal Cycle curvature measures</h2>
<p >You may proceed as follows (see examples <a href="geometry_2meshes_2curvature-measures-nc-3d_8cpp-example.html">geometry/meshes/curvature-measures-nc-3d.cpp</a> and <a href="geometry_2meshes_2curvature-measures-nc-XY-3d_8cpp-example.html">geometry/meshes/curvature-measures-nc-XY-3d.cpp</a>).</p>
<p >You need to include header file of class <a class="el" href="structDGtal_1_1NormalCycleComputer.html" title="Aim: Utility class to compute curvatures measures induced by (1) the normal cycle induced by a Surfac...">NormalCycleComputer</a>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/meshes/NormalCycleComputer.h&quot;</span></div>
</div><!-- fragment --><p> then use some typedefs adapted to your problem. </p><div class="fragment"><div class="line">  <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceDGtal.html">DGtal</a>;</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceDGtal_1_1Z3i.html">DGtal::Z3i</a>;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_struct" href="structDGtal_1_1SurfaceMesh.html">SurfaceMesh&lt; RealPoint, RealVector &gt;</a>         SM;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_struct" href="structDGtal_1_1NormalCycleComputer.html">NormalCycleComputer&lt; RealPoint, RealVector &gt;</a> NC;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_struct" href="structDGtal_1_1SurfaceMeshHelper.html">SurfaceMeshHelper&lt; RealPoint, RealVector &gt;</a>   SMH;</div>
<div class="ttc" id="anamespaceDGtal_1_1Z3i_html"><div class="ttname"><a href="namespaceDGtal_1_1Z3i.html">DGtal::Z3i</a></div><div class="ttdoc">Z3i this namespace gathers the standard of types for 3D imagery.</div></div>
<div class="ttc" id="anamespaceDGtal_html"><div class="ttname"><a href="namespaceDGtal.html">DGtal</a></div><div class="ttdoc">DGtal is the top-level namespace which contains all DGtal functions and types.</div><div class="ttdef"><b>Definition:</b> <a href="ClosedIntegerHalfPlane_8h_source.html#l00048">ClosedIntegerHalfPlane.h:49</a></div></div>
<div class="ttc" id="astructDGtal_1_1NormalCycleComputer_html"><div class="ttname"><a href="structDGtal_1_1NormalCycleComputer.html">DGtal::NormalCycleComputer</a></div><div class="ttdoc">Aim: Utility class to compute curvatures measures induced by (1) the normal cycle induced by a Surfac...</div><div class="ttdef"><b>Definition:</b> <a href="NormalCycleComputer_8h_source.html#l00067">NormalCycleComputer.h:68</a></div></div>
<div class="ttc" id="astructDGtal_1_1SurfaceMeshHelper_html"><div class="ttname"><a href="structDGtal_1_1SurfaceMeshHelper.html">DGtal::SurfaceMeshHelper</a></div><div class="ttdoc">Aim: An helper class for building classical meshes.</div><div class="ttdef"><b>Definition:</b> <a href="SurfaceMeshHelper_8h_source.html#l00063">SurfaceMeshHelper.h:64</a></div></div>
<div class="ttc" id="astructDGtal_1_1SurfaceMesh_html"><div class="ttname"><a href="structDGtal_1_1SurfaceMesh.html">DGtal::SurfaceMesh</a></div><div class="ttdoc">Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...</div><div class="ttdef"><b>Definition:</b> <a href="SurfaceMesh_8h_source.html#l00091">SurfaceMesh.h:92</a></div></div>
</div><!-- fragment --><p >We will compute curvature measures onto a <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> object. Here, we build a torus of big radius 3 and small radius 1, with a discretization of 20x20.</p>
<div class="fragment"><div class="line">SM smesh = SMH::makeTorus( 3.0, 1.0, <a class="code hl_typedef" href="testAstroid2D_8cpp.html#ac914bb734ccb5a7c569747c1e699c1aa">RealPoint</a> { 0.0, 0.0, 0.0 }, 20, 20, 0,</div>
<div class="line">                           SMH::NormalsType::NO_NORMALS );</div>
<div class="ttc" id="atestAstroid2D_8cpp_html_ac914bb734ccb5a7c569747c1e699c1aa"><div class="ttname"><a href="testAstroid2D_8cpp.html#ac914bb734ccb5a7c569747c1e699c1aa">RealPoint</a></div><div class="ttdeci">Z2i::RealPoint RealPoint</div><div class="ttdef"><b>Definition:</b> <a href="testAstroid2D_8cpp_source.html#l00046">testAstroid2D.cpp:46</a></div></div>
</div><!-- fragment --><p >It is not necessary here to equip the mesh with normals, since the Normal Cycle infers the normals from the positions of the mesh. We can now compute three measures onto the mesh, <code>mu0</code> the area measure, <code>mu1</code> twice the mean curvature measure, and <code>mu2</code> the Gaussian curvature measure. You have static methods <a class="el" href="structDGtal_1_1NormalCycleComputer.html#a0746faf13489a2ab2d751773aed50f83">NormalCycleComputer::meanCurvature</a> and <a class="el" href="structDGtal_1_1NormalCycleComputer.html#a771b165d090533ea7a80e2122aa04898">NormalCycleComputer::GaussianCurvature</a> that estimate respectively mean and Gaussian curvature from measures.</p>
<div class="fragment"><div class="line">  <span class="comment">// builds a NormalCycleComputer object onto the mesh</span></div>
<div class="line">  NC nc( smesh );</div>
<div class="line">  <span class="comment">// computes area, mean and Gaussian curvature measures</span></div>
<div class="line">  <span class="keyword">auto</span> mu0 = nc.computeMu0();</div>
<div class="line">  <span class="keyword">auto</span> mu1 = nc.computeMu1();</div>
<div class="line">  <span class="keyword">auto</span> mu2 = nc.computeMu2();</div>
</div><!-- fragment --><p >Normal cycle mean and Gaussian curvature measures have meaning only around edges and vertices. So it is necessary to measure them in a big enough ball that includes at least one edge or vertex, and then to normalize the result by dividing by the area measure. Therefore, if we wish to estimate mean and Gaussian curvatures at every face centroid (say), the following snippet shows how to do it, assuming a measuring ball radius of <code>R</code>:</p>
<div class="fragment"><div class="line">  <span class="comment">// estimates mean (H) and Gaussian (G) curvatures by measure normalization.</span></div>
<div class="line">  std::vector&lt; double &gt; <a class="code hl_enumvalue" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ac1d9f50f86825a1a2302ec2449c17196">H</a>( smesh.nbFaces() );</div>
<div class="line">  std::vector&lt; double &gt; G( smesh.nbFaces() );</div>
<div class="line">  <span class="keywordflow">for</span> ( <span class="keyword">auto</span> f = 0; f &lt; smesh.nbFaces(); ++f )</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> b    = smesh.faceCentroid( f );</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> area = mu0.measure( b, <a class="code hl_enumvalue" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ae1e1d3d40573127e9ee0480caf1283d6">R</a>, f );</div>
<div class="line">      <a class="code hl_enumvalue" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ac1d9f50f86825a1a2302ec2449c17196">H</a>[ f ] = nc.meanCurvature    ( area, mu1.measure( b, <a class="code hl_enumvalue" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ae1e1d3d40573127e9ee0480caf1283d6">R</a>, f ) );</div>
<div class="line">      G[ f ] = nc.GaussianCurvature( area, mu2.measure( b, <a class="code hl_enumvalue" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ae1e1d3d40573127e9ee0480caf1283d6">R</a>, f ) );</div>
<div class="line">    }</div>
<div class="ttc" id="anamespaceDGtal_html_abb201440d2d4b97d7078c6716a8d6f49ac1d9f50f86825a1a2302ec2449c17196"><div class="ttname"><a href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ac1d9f50f86825a1a2302ec2449c17196">DGtal::ProbingMode::H</a></div><div class="ttdeci">@ H</div></div>
<div class="ttc" id="anamespaceDGtal_html_abb201440d2d4b97d7078c6716a8d6f49ae1e1d3d40573127e9ee0480caf1283d6"><div class="ttname"><a href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ae1e1d3d40573127e9ee0480caf1283d6">DGtal::ProbingMode::R</a></div><div class="ttdeci">@ R</div></div>
</div><!-- fragment --><p >This is is the result for a measuring ball radius of 0.5 onto the torus shape. </p><pre class="fragment">Expected mean curvatures: min=0.25 max=0.625
Computed mean curvatures: min=0.189446 max=0.772277
Expected Gaussian curvatures: min=-0.5 max=0.25
Computed Gaussian curvatures: min=-0.682996 max=0.547296
</pre><p >A quite similar code allows you to compute anisotropic curvature measures (i.e. a kind of second fundamental form). You may extract from the returned tensor measure (using eigenvalues/eigenvectors) principal curvatures and principal directions, by using method <a class="el" href="structDGtal_1_1NormalCycleComputer.html#ac09864ae904bcbba14942ba370b5abb6">NormalCycleComputer::principalCurvatures</a>.</p>
<div class="fragment"><div class="line">  <span class="comment">// builds a NormalCycleComputer object onto the torus mesh</span></div>
<div class="line">  NC nc( smesh );</div>
<div class="line">  <span class="comment">// computes area, anisotropic XY curvature measures</span></div>
<div class="line">  <span class="keyword">auto</span> mu0  = nc.computeMu0();</div>
<div class="line">  <span class="keyword">auto</span> muXY = nc.computeMuXY();</div>
</div><!-- fragment --> <div class="fragment"><div class="line">  <span class="comment">// Estimates principal curvatures (K1,K2) and directions (D1,D2) by</span></div>
<div class="line">  <span class="comment">// measure normalization and eigen decomposition.</span></div>
<div class="line">  std::vector&lt; double &gt; K1( smesh.nbFaces() );</div>
<div class="line">  std::vector&lt; double &gt; K2( smesh.nbFaces() );</div>
<div class="line">  std::vector&lt; RealVector &gt; D1( smesh.nbFaces() );</div>
<div class="line">  std::vector&lt; RealVector &gt; D2( smesh.nbFaces() );</div>
<div class="line">  <span class="comment">// Principal directions computation requires a local face normal</span></div>
<div class="line">  smesh.computeFaceNormalsFromPositions();</div>
<div class="line">  <span class="keywordflow">for</span> ( <span class="keyword">auto</span> f = 0; f &lt; smesh.nbFaces(); ++f )</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> b    = smesh.faceCentroid( f );</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> N    = smesh.faceNormals()[ f ];</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> area = mu0 .measure( b, <a class="code hl_enumvalue" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ae1e1d3d40573127e9ee0480caf1283d6">R</a>, f );</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> M    = muXY.measure( b, <a class="code hl_enumvalue" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ae1e1d3d40573127e9ee0480caf1283d6">R</a>, f );</div>
<div class="line">      std::tie( K1[ f ], K2[ f ], D1[ f ], D2[ f ] )</div>
<div class="line">        = nc.principalCurvatures( area, M, N );</div>
<div class="line">    }</div>
</div><!-- fragment --><pre class="fragment">Expected k1 curvatures: min=-0.5 max=0.25
Computed k1 curvatures: min=-0.581281 max=0.441977
Expected k2 curvatures: min=1 max=1
Computed k2 curvatures: min=0.904081 max=1.06404
</pre><p >Curvature estimates are displayed with a colormap [-0.625 ... 0 ... 0.625] -&gt; [Blue ... White ... Red].</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="torus-nc-H-True-r0_5.jpg" alt="" width="90%"/>
<div class="caption">
Normal cycle mean curvature measure, r=0.5</div></div>
 </td><td><div class="image">
<img src="torus-nc-G-True-r0_5.jpg" alt="" width="90%"/>
<div class="caption">
Normal cycle Gaussian curvature measure, r=0.5</div></div>
 </td><td><div class="image">
<img src="torus-nc-K1-D1-True-r0_5.jpg" alt="" width="90%"/>
<div class="caption">
Normal cycle smallest principal curvature and direction, r=0.5</div></div>
 </td><td><div class="image">
<img src="torus-nc-K2-D2-True-r0_5.jpg" alt="" width="90%"/>
<div class="caption">
Normal cycle greatest principal curvature and direction, r=0.5</div></div>
  </td></tr>
</table>
<h2><a class="anchor" id="dgtal_curvature_measures_sec22"></a>
Interpolated Corrected Normal Current curvature measures</h2>
<p >You may proceed as follows (see examples <a href="geometry_2meshes_2curvature-measures-icnc-3d_8cpp-example.html">geometry/meshes/curvature-measures-icnc-3d.cpp</a> and <a href="geometry_2meshes_2curvature-measures-icnc-XY-3d_8cpp-example.html">geometry/meshes/curvature-measures-icnc-XY-3d.cpp</a>).</p>
<p >You need to include header file of class <a class="el" href="structDGtal_1_1CorrectedNormalCurrentComputer.html" title="Aim: Utility class to compute curvature measures induced by (1) a corrected normal current defined by...">CorrectedNormalCurrentComputer</a>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/meshes/CorrectedNormalCurrentComputer.h&quot;</span></div>
</div><!-- fragment --><p> then use some typedefs adapted to your problem. </p><div class="fragment"><div class="line">  <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceDGtal.html">DGtal</a>;</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceDGtal_1_1Z3i.html">DGtal::Z3i</a>;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_struct" href="structDGtal_1_1SurfaceMesh.html">SurfaceMesh&lt; RealPoint, RealVector &gt;</a>                    SM;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_struct" href="structDGtal_1_1CorrectedNormalCurrentComputer.html">CorrectedNormalCurrentComputer&lt; RealPoint, RealVector &gt;</a> CNC;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_struct" href="structDGtal_1_1SurfaceMeshHelper.html">SurfaceMeshHelper&lt; RealPoint, RealVector &gt;</a>              SMH;</div>
<div class="ttc" id="astructDGtal_1_1CorrectedNormalCurrentComputer_html"><div class="ttname"><a href="structDGtal_1_1CorrectedNormalCurrentComputer.html">DGtal::CorrectedNormalCurrentComputer</a></div><div class="ttdoc">Aim: Utility class to compute curvature measures induced by (1) a corrected normal current defined by...</div><div class="ttdef"><b>Definition:</b> <a href="CorrectedNormalCurrentComputer_8h_source.html#l00069">CorrectedNormalCurrentComputer.h:70</a></div></div>
</div><!-- fragment --><p >We will compute curvature measures onto a <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> object. Here, we build a torus of big radius 3 and small radius 1, with a discretization of 20x20.</p>
<div class="fragment"><div class="line">SM smesh = SMH::makeTorus( 3.0, 1.0, <a class="code hl_typedef" href="testAstroid2D_8cpp.html#ac914bb734ccb5a7c569747c1e699c1aa">RealPoint</a> { 0.0, 0.0, 0.0 }, 20, 20, 0,</div>
<div class="line">                           SMH::NormalsType::VERTEX_NORMALS );</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>It is necessary here to equip the mesh with normals, since the Corrected NormalCurrent needs a corrected vector field to compute curvatures.</dd></dl>
<p>Here we just provide the corrected normal vector field \( \mathbf{u}
\) as a normal vector per vertex, the field is then linearly interpolated. We can now compute three measures onto the mesh, <code>mu0</code> the area measure, <code>mu1</code> twice the mean curvature measure, and <code>mu2</code> the Gaussian curvature measure. You have static methods <a class="el" href="structDGtal_1_1CorrectedNormalCurrentComputer.html#ac4bd5d55e986d07f7e305c7c15814a45">CorrectedNormalCurrentComputer::meanCurvature</a> and <a class="el" href="structDGtal_1_1CorrectedNormalCurrentComputer.html#acc2e62565ff0c72b274c9bfe2e89d722">CorrectedNormalCurrentComputer::GaussianCurvature</a> that estimate respectively mean and Gaussian curvature from measures.</p>
<div class="fragment"><div class="line">  <span class="comment">// builds a CorrectedNormalCurrentComputer object onto the torus/lantern/sphere mesh</span></div>
<div class="line">  CNC cnc( smesh );</div>
<div class="line">  <span class="comment">// computes area, mean and Gaussian curvature measures</span></div>
<div class="line">  <span class="keyword">auto</span> mu0 = cnc.computeMu0();</div>
<div class="line">  <span class="keyword">auto</span> mu1 = cnc.computeMu1();</div>
<div class="line">  <span class="keyword">auto</span> mu2 = cnc.computeMu2();</div>
</div><!-- fragment --><p >A big advantage of (interpolated) Corrected Normal Current over Normal Cycle is that the induced mean and Gaussian curvature measures have meaning for arbitrary measuring set (even when the area of the set tends to zero. Therefore, if we wish to estimate mean and Gaussian curvatures at every face centroid (say), the following snippet shows how to do it, assuming a measuring ball radius of <code>R</code>:</p>
<div class="fragment"><div class="line">  <span class="comment">// estimates mean (H) and Gaussian (G) curvatures by measure normalization.</span></div>
<div class="line">  std::vector&lt; double &gt; <a class="code hl_enumvalue" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ac1d9f50f86825a1a2302ec2449c17196">H</a>( smesh.nbFaces() );</div>
<div class="line">  std::vector&lt; double &gt; G( smesh.nbFaces() );</div>
<div class="line">  <span class="keywordflow">for</span> ( <span class="keyword">auto</span> f = 0; f &lt; smesh.nbFaces(); ++f )</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> b    = smesh.faceCentroid( f );</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> area = mu0.measure( b, <a class="code hl_enumvalue" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ae1e1d3d40573127e9ee0480caf1283d6">R</a>, f );</div>
<div class="line">      <a class="code hl_enumvalue" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ac1d9f50f86825a1a2302ec2449c17196">H</a>[ f ] = cnc.meanCurvature    ( area, mu1.measure( b, <a class="code hl_enumvalue" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ae1e1d3d40573127e9ee0480caf1283d6">R</a>, f ) );</div>
<div class="line">      G[ f ] = cnc.GaussianCurvature( area, mu2.measure( b, <a class="code hl_enumvalue" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ae1e1d3d40573127e9ee0480caf1283d6">R</a>, f ) );</div>
<div class="line">    }</div>
</div><!-- fragment --><p >This is is the result for a measuring ball radius of 0.0 onto the torus shape (perfect results !). </p><pre class="fragment">Expected mean curvatures: min=0.25 max=0.625
Computed mean curvatures: min=0.25 max=0.625
Expected Gaussian curvatures: min=-0.5 max=0.25
Computed Gaussian curvatures: min=-0.5 max=0.25
</pre><p >This is is the result for a measuring ball radius of 0.5 onto the torus shape (better than Normal cycle). </p><pre class="fragment">Expected mean curvatures: min=0.25 max=0.625
Computed mean curvatures: min=0.264763 max=0.622318
Expected Gaussian curvatures: min=-0.5 max=0.25
Computed Gaussian curvatures: min=-0.470473 max=0.244636
</pre><p >A quite similar code allows you to compute anisotropic curvature measures (i.e. a kind of second fundamental form). You may extract from the returned tensor measure (using eigenvalues/eigenvectors) principal curvatures and principal directions, by using method <a class="el" href="structDGtal_1_1CorrectedNormalCurrentComputer.html#ab2bc940118c947bedadb579b022779bd">CorrectedNormalCurrentComputer::principalCurvatures</a>.</p>
<div class="fragment"><div class="line">  <span class="comment">// builds a CorrectedNormalCurrentComputer object onto the mesh</span></div>
<div class="line">  CNC cnc( smesh );</div>
<div class="line">  <span class="comment">// computes area, anisotropic XY curvature measures</span></div>
<div class="line">  <span class="keyword">auto</span> mu0  = cnc.computeMu0();</div>
<div class="line">  <span class="keyword">auto</span> muXY = cnc.computeMuXY();</div>
</div><!-- fragment --> <div class="fragment"><div class="line">  <span class="comment">// Estimates principal curvatures (K1,K2) and directions (D1,D2) by</span></div>
<div class="line">  <span class="comment">// measure normalization and eigen decomposition.</span></div>
<div class="line">  std::vector&lt; double &gt; K1( smesh.nbFaces() );</div>
<div class="line">  std::vector&lt; double &gt; K2( smesh.nbFaces() );</div>
<div class="line">  std::vector&lt; RealVector &gt; D1( smesh.nbFaces() );</div>
<div class="line">  std::vector&lt; RealVector &gt; D2( smesh.nbFaces() );</div>
<div class="line">  <span class="comment">// Principal directions computation requires a local face normal</span></div>
<div class="line">  smesh.computeFaceNormalsFromPositions();</div>
<div class="line">  <span class="keywordflow">for</span> ( <span class="keyword">auto</span> f = 0; f &lt; smesh.nbFaces(); ++f )</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> b    = smesh.faceCentroid( f );</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> N    = smesh.faceNormals()[ f ];</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> area = mu0 .measure( b, <a class="code hl_enumvalue" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ae1e1d3d40573127e9ee0480caf1283d6">R</a>, f );</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> M    = muXY.measure( b, <a class="code hl_enumvalue" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ae1e1d3d40573127e9ee0480caf1283d6">R</a>, f );</div>
<div class="line">      std::tie( K1[ f ], K2[ f ], D1[ f ], D2[ f ] )</div>
<div class="line">        = cnc.principalCurvatures( area, M, N );</div>
<div class="line">    }</div>
</div><!-- fragment --><p >This gives you such results for principal curvatures estimations, first for a radius 0: </p><pre class="fragment">Expected k1 curvatures: min=-0.5 max=0.25
Computed k1 curvatures: min=-0.500225 max=0.249888
Expected k2 curvatures: min=1 max=1
Computed k2 curvatures: min=1.00011 max=1.00678
</pre><p >then for a radius of 0.5: </p><pre class="fragment">Expected k1 curvatures: min=-0.5 max=0.25
Computed k1 curvatures: min=-0.454026 max=0.242436
Expected k2 curvatures: min=1 max=1
Computed k2 curvatures: min=0.924283 max=0.95338
</pre><p >Curvature estimates are displayed with a colormap [-0.625 ... 0 ... 0.625] -&gt; [Blue ... White ... Red].</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="torus-cnc-H-True-r0.jpg" alt="" width="90%"/>
<div class="caption">
Corrected Normal Current mean curvature measure, r=0</div></div>
 </td><td><div class="image">
<img src="torus-cnc-G-True-r0.jpg" alt="" width="90%"/>
<div class="caption">
Corrected Normal Current Gaussian curvature measure, r=0</div></div>
 </td><td><div class="image">
<img src="torus-cnc-K1-D1-True-r0.jpg" alt="" width="90%"/>
<div class="caption">
Corrected Normal Current smallest principal curvature and direction, r=0</div></div>
 </td><td><div class="image">
<img src="torus-cnc-K2-D2-True-r0.jpg" alt="" width="90%"/>
<div class="caption">
Corrected Normal Current greatest principal curvature and direction, r=0</div></div>
  </td></tr>
<tr>
<td><div class="image">
<img src="torus-cnc-H-True-r0_5.jpg" alt="" width="90%"/>
<div class="caption">
Corrected Normal Current mean curvature measure, r=0.5</div></div>
 </td><td><div class="image">
<img src="torus-cnc-G-True-r0_5.jpg" alt="" width="90%"/>
<div class="caption">
Corrected Normal Current Gaussian curvature measure, r=0.5</div></div>
 </td><td><div class="image">
<img src="torus-cnc-K1-D1-True-r0_5.jpg" alt="" width="90%"/>
<div class="caption">
Corrected Normal Current smallest principal curvature and direction, r=0.5</div></div>
 </td><td><div class="image">
<img src="torus-cnc-K2-D2-True-r0_5.jpg" alt="" width="90%"/>
<div class="caption">
Corrected Normal Current greatest principal curvature and direction, r=0.5</div></div>
  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>You may check that Normal Cycle fails on the Schwarz lantern, while interpolated Corrected Normal Current provides the correct curvature estimation.</dd></dl>
<table class="doxtable">
<tr>
<td><pre class="fragment">./examples/geometry/meshes/curvature-measures-nc-3d lantern 20 20 0.5
</pre> outputs <pre class="fragment">Expected mean curvatures: min=0.25 max=0.25
Computed mean curvatures: min=0.795695 max=1.41211
Expected Gaussian curvatures: min=0 max=0
Computed Gaussian curvatures: min=-6.79045e-14 max=15.0937
</pre>  </td><td><pre class="fragment">./examples/geometry/meshes/curvature-measures-icnc-3d lantern 20 20 0.5
</pre> outputs <pre class="fragment">Expected mean curvatures: min=0.25 max=0.25
Computed mean curvatures: min=0.25 max=0.25
Expected Gaussian curvatures: min=0 max=0
Computed Gaussian curvatures: min=0 max=0
</pre>   </td></tr>
</table>
<h2><a class="anchor" id="dgtal_curvature_measures_sec23"></a>
Vertex-interpolated versus face-constant corrected normal current</h2>
<p >The theory of corrected normal currents works for arbitrary piecewise smooth corrected normal vector fields. Class <a class="el" href="structDGtal_1_1CorrectedNormalCurrentComputer.html" title="Aim: Utility class to compute curvature measures induced by (1) a corrected normal current defined by...">CorrectedNormalCurrentComputer</a> allows you to choose between a constant per face corrected normal vector field (called <em>Constant</em> <em>Corrected</em> <em>Normal</em> <em>Current</em>, CCNC), or a smooth corrected normal vector field obtained by linear interpolation of vertex normals per face (called <em>Interpolated</em> <em>Corrected</em> <em>Normal</em> <em>Current</em>, ICNC).</p>
<p >The choice is made automatically by the <a class="el" href="structDGtal_1_1CorrectedNormalCurrentComputer.html" title="Aim: Utility class to compute curvature measures induced by (1) a corrected normal current defined by...">CorrectedNormalCurrentComputer</a> object according to the user-defined normal vector field of its associated <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> object:</p>
<ul>
<li>if <code>myMesh.vertexNormals()</code> is not empty, then the <a class="el" href="structDGtal_1_1CorrectedNormalCurrentComputer.html" title="Aim: Utility class to compute curvature measures induced by (1) a corrected normal current defined by...">CorrectedNormalCurrentComputer</a> computes ICNC measures,</li>
<li>otherwise if <code>myMesh.faceNormals()</code> is not empty, then the <a class="el" href="structDGtal_1_1CorrectedNormalCurrentComputer.html" title="Aim: Utility class to compute curvature measures induced by (1) a corrected normal current defined by...">CorrectedNormalCurrentComputer</a> computes CCNC measures,</li>
<li>otherwise the CNC does not work and outputs a warning.</li>
</ul>
<p >For instance, you may force ICNC on a mesh as follows: </p><div class="fragment"><div class="line">CNC cnc( smesh );</div>
<div class="line"><span class="comment">// computes normals if necessary</span></div>
<div class="line"><span class="keywordflow">if</span> ( smesh.vertexNormals().empty() )</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> ( smesh.faceNormals().empty() )</div>
<div class="line">      smesh.computeFaceNormalsFromPositions();</div>
<div class="line">    smesh.computeVertexNormalsFromFaceNormals();</div>
<div class="line">  }</div>
<div class="line">...</div>
</div><!-- fragment --><p> Otherwise, assume you have not set any vertex normals, the following code uses CCNC: </p><div class="fragment"><div class="line">CNC cnc( smesh );</div>
<div class="line"><span class="comment">// computes normals if necessary</span></div>
<div class="line"><span class="keywordflow">if</span> ( smesh.faceNormals().empty() )</div>
<div class="line">  smesh.computeFaceNormalsFromPositions();</div>
<div class="line">...</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>As Normal Cycle curvature measures, face-constant CNC (CCNC) curvature measures require a minimum radius for the measuring ball. Indeed, its \( \mu^{(1)} \) and \(
\mu^{(\mathbf{X},\mathbf{Y})} \) measures must capture at least one edge, while its \( \mu^{(2)} \) measure must capture at least one vertex. In opposition to CCNC and NC, vertex-interpolated CNC curvature measures (ICNC) are valid for arbitrary radius. All the ICNC curvatures have a well-defined limit when the measuring set radius tends to zero.</dd></dl>
<h2><a class="anchor" id="dgtal_curvature_measures_sec24"></a>
More on curvature measures</h2>
<p ><a class="el" href="structDGtal_1_1NormalCycleComputer.html" title="Aim: Utility class to compute curvatures measures induced by (1) the normal cycle induced by a Surfac...">NormalCycleComputer</a> and <a class="el" href="structDGtal_1_1CorrectedNormalCurrentComputer.html" title="Aim: Utility class to compute curvature measures induced by (1) a corrected normal current defined by...">CorrectedNormalCurrentComputer</a> provides methods that return measures, more precisely as <a class="el" href="structDGtal_1_1SurfaceMeshMeasure.html" title="Aim: stores an arbitrary measure on a SurfaceMesh object. The measure can be spread onto its vertices...">SurfaceMeshMeasure</a> objects. The values of measure may be arbitrary scalars, vectors or tensors. Here curvature measures are either scalars (like area, mean and Gaussian curvature measures) or tensors (anisotropic measures).</p>
<p >A <a class="el" href="structDGtal_1_1SurfaceMeshMeasure.html" title="Aim: stores an arbitrary measure on a SurfaceMesh object. The measure can be spread onto its vertices...">SurfaceMeshMeasure</a> provides several handy methods to evaluate measures wrt simple subsets of \( \mathbb{R}^3 \).</p>
<ul>
<li><a class="el" href="structDGtal_1_1SurfaceMeshMeasure.html#aa1ba1f4053adfc637b5e40fde715cf49">SurfaceMeshMeasure::measure() const </a>returns the total measure, i.e. \(
  \mu(\mathbb{R^3}) \).</li>
<li>SurfaceMeshMeasure::measure( const RealPoint&amp;, Scalar, Face ) const computes the measure \( \mu(B_r(x)) \), where \(
  B_r(x) \) is the ball of center <em>x</em> and radius <em>r</em>. The center <em>x</em> must lie on or close to the face <em>f</em>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The measures may be associated to 0-, 1-, 2- cells, but generally you do not require this level of detail. If you prefer to have direct access to these measures, you have several overloaded methods to do this: <a class="el" href="structDGtal_1_1SurfaceMeshMeasure.html#a1ebedd76d6e78c7b7882caacc029ed39">SurfaceMeshMeasure::vertexMeasure</a>, <a class="el" href="structDGtal_1_1SurfaceMeshMeasure.html#a0d15af91a60f9815ecccf1c2aba150a3">SurfaceMeshMeasure::edgeMeasure</a>, <a class="el" href="structDGtal_1_1SurfaceMeshMeasure.html#a7bd1237db50a9a101ea9a036d153b42e">SurfaceMeshMeasure::faceMeasure</a>. They can accept weighted sum of cells as input.</dd></dl>
<h2><a class="anchor" id="dgtal_curvature_measures_sec25"></a>
ICNC Curvature computation on OBJ surface</h2>
<p >Examples <a href="geometry_2meshes_2obj-curvature-measures-icnc-3d_8cpp-example.html">geometry/meshes/obj-curvature-measures-icnc-3d.cpp</a> and <a href="geometry_2meshes_2obj-curvature-measures-icnc-XY-3d_8cpp-example.html">geometry/meshes/obj-curvature-measures-icnc-XY-3d.cpp</a> show how to compute all curvature information on an arbitrary mesh.</p>
<p >The only difference in the above examples is the way the <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> object is created. Here we read an OBJ file to create it.</p>
<div class="fragment"><div class="line">  SM smesh;</div>
<div class="line">  std::ifstream obj_stream( input.c_str() );</div>
<div class="line">  <span class="keywordtype">bool</span> ok = SMR::readOBJ( obj_stream, smesh );</div>
<div class="line">  <span class="keywordflow">if</span> ( !ok )</div>
<div class="line">    {</div>
<div class="line">      <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#a7fc3d7aa5e75357287452e5689e03efa">error</a>() &lt;&lt;  <span class="stringliteral">&quot;Unable to read file &lt;&quot;</span> &lt;&lt; input.c_str() &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <a class="code hl_typedef" href="testAstroid2D_8cpp.html#ac914bb734ccb5a7c569747c1e699c1aa">RealPoint</a> lo = smesh.position( 0 );</div>
<div class="line">  <a class="code hl_typedef" href="testAstroid2D_8cpp.html#ac914bb734ccb5a7c569747c1e699c1aa">RealPoint</a> up = smesh.position( 0 );</div>
<div class="line">  <span class="keywordflow">for</span> ( <span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : smesh.positions() )</div>
<div class="line">    lo = lo.<a class="code hl_function" href="classDGtal_1_1PointVector.html#a5042a1ec2f009a8f43d485a1a7e16ae2">inf</a>( p ), up = up.<a class="code hl_function" href="classDGtal_1_1PointVector.html#a8ee1582e76f9875e278cc1cef7caa3ed">sup</a>( p );</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> diameter = (up - lo).norm();</div>
<div class="line">  <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#a9b36f5ab76b1945c8156cb4dba780bfb">info</a>() &lt;&lt; <span class="stringliteral">&quot;Mesh=&quot;</span> &lt;&lt; smesh</div>
<div class="line">               &lt;&lt; <span class="stringliteral">&quot; diameter=&quot;</span> &lt;&lt; diameter</div>
<div class="line">               &lt;&lt; <span class="stringliteral">&quot; radius=&quot;</span> &lt;&lt; <a class="code hl_enumvalue" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ae1e1d3d40573127e9ee0480caf1283d6">R</a> &lt;&lt; std::endl;</div>
<div class="ttc" id="aclassDGtal_1_1PointVector_html_a5042a1ec2f009a8f43d485a1a7e16ae2"><div class="ttname"><a href="classDGtal_1_1PointVector.html#a5042a1ec2f009a8f43d485a1a7e16ae2">DGtal::PointVector::inf</a></div><div class="ttdeci">auto inf(const PointVector&lt; dim, OtherComponent, OtherStorage &gt; &amp;aPoint) const -&gt; decltype(DGtal::inf(*this, aPoint))</div><div class="ttdoc">Implements the infimum (or greatest lower bound).</div></div>
<div class="ttc" id="aclassDGtal_1_1PointVector_html_a8ee1582e76f9875e278cc1cef7caa3ed"><div class="ttname"><a href="classDGtal_1_1PointVector.html#a8ee1582e76f9875e278cc1cef7caa3ed">DGtal::PointVector::sup</a></div><div class="ttdeci">auto sup(const PointVector&lt; dim, OtherComponent, OtherStorage &gt; &amp;aPoint) const -&gt; decltype(DGtal::sup(*this, aPoint))</div><div class="ttdoc">Implements the supremum (or least upper bound).</div></div>
<div class="ttc" id="aclassDGtal_1_1Trace_html_a7fc3d7aa5e75357287452e5689e03efa"><div class="ttname"><a href="classDGtal_1_1Trace.html#a7fc3d7aa5e75357287452e5689e03efa">DGtal::Trace::error</a></div><div class="ttdeci">std::ostream &amp; error()</div></div>
<div class="ttc" id="aclassDGtal_1_1Trace_html_a9b36f5ab76b1945c8156cb4dba780bfb"><div class="ttname"><a href="classDGtal_1_1Trace.html#a9b36f5ab76b1945c8156cb4dba780bfb">DGtal::Trace::info</a></div><div class="ttdeci">std::ostream &amp; info()</div></div>
<div class="ttc" id="anamespaceDGtal_html_a8fc7012708b0416880a5c8b12dfdf9dd"><div class="ttname"><a href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">DGtal::trace</a></div><div class="ttdeci">Trace trace</div><div class="ttdef"><b>Definition:</b> <a href="Common_8h_source.html#l00154">Common.h:154</a></div></div>
</div><!-- fragment --><p >Remember that a <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> object may represent a non-manifold polygonal surface.</p>
<p >Once the mesh is created, you just need to ensure that the <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> object has a normal vector attached to each of its vertex. This can be done as follows (or just provide an OBJ file with vertex normals):</p>
<div class="fragment"><div class="line">  <span class="comment">// builds a CorrectedNormalCurrentComputer object onto the SurfaceMesh object</span></div>
<div class="line">  CNC cnc( smesh );</div>
<div class="line">  <span class="comment">// computes normals if necessary</span></div>
<div class="line">  <span class="keywordflow">if</span> ( smesh.vertexNormals().empty() )</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> ( smesh.faceNormals().empty() )</div>
<div class="line">        smesh.computeFaceNormalsFromPositions();</div>
<div class="line">      smesh.computeVertexNormalsFromFaceNormals();</div>
<div class="line">    }</div>
<div class="line">  <span class="comment">// computes area, mean and Gaussian curvature measures</span></div>
<div class="line">  <span class="keyword">auto</span> mu0 = cnc.computeMu0();</div>
<div class="line">  <span class="keyword">auto</span> mu1 = cnc.computeMu1();</div>
<div class="line">  <span class="keyword">auto</span> mu2 = cnc.computeMu2();</div>
</div><!-- fragment --><p >The rest of the code is identical. The two examples gives the following curvature estimates on "spot.obj" file.</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="spot-cnc-H-r0_05.jpg" alt="" width="90%"/>
<div class="caption">
Interpolated corrected mean curvature measure, r=0.05</div></div>
 </td><td><div class="image">
<img src="spot-cnc-G-r0_05.jpg" alt="" width="90%"/>
<div class="caption">
Interpolated corrected Gaussian curvature measure, r=0.05</div></div>
 </td><td><div class="image">
<img src="spot-cnc-K1-D1-r0_05.jpg" alt="" width="90%"/>
<div class="caption">
Interpolated corrected smallest principal curvature and direction, r=0.05</div></div>
 </td><td><div class="image">
<img src="spot-cnc-K2-D2-r0_05.jpg" alt="" width="90%"/>
<div class="caption">
Interpolated corrected greatest principal curvature and direction, r=0.05</div></div>
  </td></tr>
</table>
<h1><a class="anchor" id="dgtal_curvature_measures_sec3"></a>
Corrected curvature measures on digital surfaces</h1>
<p >It is difficult to estimate curvatures on digital surfaces, since they naturally have only very few normal directions. You may have a look at module <a class="el" href="moduleIntegralInvariant.html">Integral invariant curvature estimator 2D/3D</a> to see a method that estimates such curvatures when the digital surface is the boundary of a volume of voxels.</p>
<p >Corrected Normal Currents are well adapted to digital surface geometric analysis. Indeed, we can have good estimates of the normal vector field of a digital surface (see <a class="el" href="classDGtal_1_1ShortcutsGeometry.html">ShortcutsGeometry</a>), which will be used as the corrected normal vector field associated to the current.</p>
<p >As examples of digital surfaces, we show how to estimate curvatures on a digitization of polynomial surfaces, then on the boundary of a voxel object defined in VOL file.</p>
<h2><a class="anchor" id="dgtal_curvature_measures_sec31"></a>
CCNC and ICNC curvature measures on discretized polynomial surfaces</h2>
<p >Examples <a href="geometry_2meshes_2digpoly-curvature-measures-cnc-3d_8cpp-example.html">geometry/meshes/digpoly-curvature-measures-cnc-3d.cpp</a> and <a href="geometry_2meshes_2digpoly-curvature-measures-cnc-3d_8cpp-example.html">geometry/meshes/digpoly-curvature-measures-cnc-XY-3d.cpp</a> show how to extract all curvature information from digitized polynomial surfaces.</p>
<p >We first read the polynomial definition and extracts the digital surface approximating the implicit surface at the given resolution.</p>
<div class="fragment"><div class="line">  <span class="comment">// Read polynomial and build digital surface</span></div>
<div class="line">  <span class="keyword">auto</span> params = SH::defaultParameters() | SHG::defaultParameters();</div>
<div class="line">  params( <span class="stringliteral">&quot;t-ring&quot;</span>, 3 )( <span class="stringliteral">&quot;surfaceTraversal&quot;</span>, <span class="stringliteral">&quot;Default&quot;</span> );</div>
<div class="line">  params( <span class="stringliteral">&quot;polynomial&quot;</span>, poly )( <span class="stringliteral">&quot;gridstep&quot;</span>, h ); </div>
<div class="line">  params( <span class="stringliteral">&quot;minAABB&quot;</span>, -B )( <span class="stringliteral">&quot;maxAABB&quot;</span>, B );</div>
<div class="line">  params( <span class="stringliteral">&quot;offset&quot;</span>, 3.0 );</div>
<div class="line">  <span class="keyword">auto</span> shape       = SH::makeImplicitShape3D( params );</div>
<div class="line">  <span class="keyword">auto</span> <a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>           = SH::getKSpace( params );</div>
<div class="line">  <span class="keyword">auto</span> dshape      = SH::makeDigitizedImplicitShape3D( shape, params );</div>
<div class="line">  <span class="keyword">auto</span> bimage      = SH::makeBinaryImage( dshape, params );</div>
<div class="line">  <span class="keywordflow">if</span> ( bimage == <span class="keyword">nullptr</span> ) </div>
<div class="line">    {</div>
<div class="line">      <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#a7fc3d7aa5e75357287452e5689e03efa">error</a>() &lt;&lt;  <span class="stringliteral">&quot;Unable to read polynomial &lt;&quot;</span></div>
<div class="line">                    &lt;&lt; poly.c_str() &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keyword">auto</span> sembedder   = SH::getSCellEmbedder( <a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a> );</div>
<div class="line">  <span class="keyword">auto</span> embedder    = SH::getCellEmbedder( <a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a> );</div>
<div class="line">  <span class="keyword">auto</span> surface     = SH::makeDigitalSurface( bimage, <a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, params );</div>
<div class="line">  <span class="keyword">auto</span> surfels     = SH::getSurfelRange( surface, params );</div>
<div class="line">  <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#a9b36f5ab76b1945c8156cb4dba780bfb">info</a>() &lt;&lt; <span class="stringliteral">&quot;- surface has &quot;</span> &lt;&lt; surfels.size()&lt;&lt; <span class="stringliteral">&quot; surfels.&quot;</span> &lt;&lt; std::endl;</div>
<div class="ttc" id="atestCubicalComplex_8cpp_html_a2b87ed989d2519d025bd5d4fbcbac062"><div class="ttname"><a href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a></div><div class="ttdeci">KSpace K</div><div class="ttdef"><b>Definition:</b> <a href="testCubicalComplex_8cpp_source.html#l00062">testCubicalComplex.cpp:62</a></div></div>
</div><!-- fragment --><p >We build a <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> object that represents exactly the digital surface.</p>
<div class="fragment"><div class="line">  SM smesh;</div>
<div class="line">  std::vector&lt; SM::Vertices &gt; faces;</div>
<div class="line">  SH::Cell2Index c2i;</div>
<div class="line">  <span class="keyword">auto</span> pointels = SH::getPointelRange( c2i, surface );</div>
<div class="line">  <span class="keyword">auto</span> vertices = SH::RealPoints( pointels.size() );</div>
<div class="line">  std::transform( pointels.cbegin(), pointels.cend(), vertices.begin(),</div>
<div class="line">                  [&amp;] (<span class="keyword">const</span> SH::Cell&amp; c) { return h * embedder( c ); } ); </div>
<div class="line">  <span class="keywordflow">for</span> ( <span class="keyword">auto</span>&amp;&amp; surfel : *surface )</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> primal_surfel_vtcs = SH::getPointelRange( <a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, surfel );</div>
<div class="line">      SM::Vertices face;              </div>
<div class="line">      <span class="keywordflow">for</span> ( <span class="keyword">auto</span>&amp;&amp; primal_vtx : primal_surfel_vtcs )</div>
<div class="line">        face.push_back( c2i[ primal_vtx ] );</div>
<div class="line">      faces.push_back( face );</div>
<div class="line">    }</div>
<div class="line">  smesh.init( vertices.cbegin(), vertices.cend(),</div>
<div class="line">              faces.cbegin(),    faces.cend() );</div>
<div class="line">  <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#a9b36f5ab76b1945c8156cb4dba780bfb">info</a>() &lt;&lt; smesh &lt;&lt; std::endl;</div>
</div><!-- fragment --><p >We build the Corrected Normal Current on this mesh, and use a digital estimator of normal vector (here convolved trivial normals) to set the corrected normal vector at each face or vertex, depending on the choice of the user.</p>
<div class="fragment"><div class="line">  <span class="comment">// Builds a CorrectedNormalCurrentComputer object onto the SurfaceMesh object</span></div>
<div class="line">  CNC cnc( smesh );</div>
<div class="line">  <span class="comment">// Estimates normal vectors using Convolved Trivial Normal estimator </span></div>
<div class="line">  <span class="keyword">auto</span> face_normals = SHG::getCTrivialNormalVectors( surface, surfels, params );</div>
<div class="line">  <span class="comment">// Set corrected face normals =&gt; Corrected Normal Current with</span></div>
<div class="line">  <span class="comment">// constant per face corrected vector field.</span></div>
<div class="line">  smesh.setFaceNormals( face_normals.cbegin(), face_normals.cend() ); <span class="comment">// CCNC</span></div>
<div class="line">  <span class="comment">// Set corrected vertex normals =&gt; Corrected Normal Current with</span></div>
<div class="line">  <span class="comment">// smooth linearly interpolated per face corrected vector field.</span></div>
<div class="line">  <span class="keywordflow">if</span> ( interpolated ) smesh.computeVertexNormalsFromFaceNormals();    <span class="comment">// ICNC</span></div>
<div class="line">  <span class="comment">// computes area, mean and Gaussian curvature measures</span></div>
<div class="line">  <span class="keyword">auto</span> mu0 = cnc.computeMu0();</div>
<div class="line">  <span class="keyword">auto</span> mu1 = cnc.computeMu1();</div>
<div class="line">  <span class="keyword">auto</span> mu2 = cnc.computeMu2();</div>
</div><!-- fragment --><p >The remaining of the code to estimate curvatures from measures is identical to above. You can obtain the following results:</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="digtorus-h0_5-ccnc-H-CTrivial-r1.jpg" alt="" width="90%"/>
<div class="caption">
Face-constant corrected mean curvature measure, r=1</div></div>
 </td><td><div class="image">
<img src="digtorus-h0_5-ccnc-G-CTrivial-r1.jpg" alt="" width="90%"/>
<div class="caption">
Face-constant corrected Gaussian curvature measure, r=1</div></div>
 </td><td><div class="image">
<img src="digtorus-h0_5-ccnc-K1-D1-CTrivial-r1.jpg" alt="" width="90%"/>
<div class="caption">
Face-constant corrected smallest principal curvature and direction, r=1</div></div>
 </td><td><div class="image">
<img src="digtorus-h0_5-ccnc-K2-D2-CTrivial-r1.jpg" alt="" width="90%"/>
<div class="caption">
Face-constant corrected greatest principal curvature and direction, r=1</div></div>
  </td></tr>
<tr>
<td><div class="image">
<img src="digtorus-h0_5-icnc-H-CTrivial-r1.jpg" alt="" width="90%"/>
<div class="caption">
Vertex-interpolated corrected mean curvature measure, r=1</div></div>
 </td><td><div class="image">
<img src="digtorus-h0_5-icnc-G-CTrivial-r1.jpg" alt="" width="90%"/>
<div class="caption">
Vertex-interpolated corrected Gaussian curvature measure, r=1</div></div>
 </td><td><div class="image">
<img src="digtorus-h0_5-icnc-K1-D1-CTrivial-r1.jpg" alt="" width="90%"/>
<div class="caption">
Vertex-interpolated corrected smallest principal curvature and direction, r=1</div></div>
 </td><td><div class="image">
<img src="digtorus-h0_5-icnc-K2-D2-CTrivial-r1.jpg" alt="" width="90%"/>
<div class="caption">
Vertex-interpolated corrected greatest principal curvature and direction, r=1</div></div>
  </td></tr>
</table>
<h2><a class="anchor" id="dgtal_curvature_measures_sec32"></a>
ICNC curvature measures on digital boundaries in VOL file</h2>
<p >Examples <a href="geometry_2meshes_2vol-curvature-measures-icnc-3d_8cpp-example.html">geometry/meshes/vol-curvature-measures-icnc-3d.cpp</a> and <a href="geometry_2meshes_2vol-curvature-measures-icnc-XY-3d_8cpp-example.html">geometry/meshes/vol-curvature-measures-icnc-XY-3d.cpp</a> show how to estimate curvatures on the boundary of a digital object.</p>
<p >We first read the VOL file and extracts the digital surface bounding the digital object.</p>
<div class="fragment"><div class="line">  <span class="comment">// Read VOL file and build digital surface</span></div>
<div class="line">  <span class="keyword">auto</span> params = SH::defaultParameters() | SHG::defaultParameters();</div>
<div class="line">  params( <span class="stringliteral">&quot;thresholdMin&quot;</span>, m )( <span class="stringliteral">&quot;thresholdMax&quot;</span>, M )( <span class="stringliteral">&quot;closed&quot;</span>, 1);</div>
<div class="line">  params( <span class="stringliteral">&quot;t-ring&quot;</span>, 3 )( <span class="stringliteral">&quot;surfaceTraversal&quot;</span>, <span class="stringliteral">&quot;Default&quot;</span> );</div>
<div class="line">  <span class="keyword">auto</span> bimage = SH::makeBinaryImage( input.c_str(), params );</div>
<div class="line">  <span class="keywordflow">if</span> ( bimage == <span class="keyword">nullptr</span> ) </div>
<div class="line">    {</div>
<div class="line">      <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#a7fc3d7aa5e75357287452e5689e03efa">error</a>() &lt;&lt;  <span class="stringliteral">&quot;Unable to read file &lt;&quot;</span> &lt;&lt; input.c_str() &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keyword">auto</span> <a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>      = SH::getKSpace( bimage, params );</div>
<div class="line">  <span class="keyword">auto</span> sembedder   = SH::getSCellEmbedder( <a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a> );</div>
<div class="line">  <span class="keyword">auto</span> embedder    = SH::getCellEmbedder( <a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a> );</div>
<div class="line">  <span class="keyword">auto</span> surface     = SH::makeDigitalSurface( bimage, <a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, params );</div>
<div class="line">  <span class="keyword">auto</span> surfels     = SH::getSurfelRange( surface, params );</div>
<div class="line">  <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#a9b36f5ab76b1945c8156cb4dba780bfb">info</a>() &lt;&lt; <span class="stringliteral">&quot;- surface has &quot;</span> &lt;&lt; surfels.size()&lt;&lt; <span class="stringliteral">&quot; surfels.&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p >We build a <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> object that represents exactly the digital surface.</p>
<div class="fragment"><div class="line">  SM smesh;</div>
<div class="line">  std::vector&lt; SM::Vertices &gt; faces;</div>
<div class="line">  SH::Cell2Index c2i;</div>
<div class="line">  <span class="keyword">auto</span> pointels = SH::getPointelRange( c2i, surface );</div>
<div class="line">  <span class="keyword">auto</span> vertices = SH::RealPoints( pointels.size() );</div>
<div class="line">  std::transform( pointels.cbegin(), pointels.cend(), vertices.begin(),</div>
<div class="line">                  [&amp;] (<span class="keyword">const</span> SH::Cell&amp; c) { return embedder( c ); } ); </div>
<div class="line">  <span class="keywordflow">for</span> ( <span class="keyword">auto</span>&amp;&amp; surfel : *surface )</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> primal_surfel_vtcs = SH::getPointelRange( <a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, surfel );</div>
<div class="line">      SM::Vertices face;              </div>
<div class="line">      <span class="keywordflow">for</span> ( <span class="keyword">auto</span>&amp;&amp; primal_vtx : primal_surfel_vtcs )</div>
<div class="line">        face.push_back( c2i[ primal_vtx ] );</div>
<div class="line">      faces.push_back( face );</div>
<div class="line">    }</div>
<div class="line">  smesh.init( vertices.cbegin(), vertices.cend(),</div>
<div class="line">              faces.cbegin(),    faces.cend() );</div>
<div class="line">  <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#a9b36f5ab76b1945c8156cb4dba780bfb">info</a>() &lt;&lt; smesh &lt;&lt; std::endl;</div>
</div><!-- fragment --><p >We build the Corrected Normal Current on this mesh, and use a digital estimator of the normal vectors (here convolved trivial normals) to set the corrected normal vector at each vertex.</p>
<div class="fragment"><div class="line">  <span class="comment">// Builds a CorrectedNormalCurrentComputer object onto the SurfaceMesh object</span></div>
<div class="line">  CNC cnc( smesh );</div>
<div class="line">  <span class="comment">// Estimates normal vectors using Convolved Trivial Normal estimator </span></div>
<div class="line">  <span class="keyword">auto</span> face_normals = SHG::getCTrivialNormalVectors( surface, surfels, params );</div>
<div class="line">  smesh.setFaceNormals( face_normals.cbegin(), face_normals.cend() );</div>
<div class="line">  <span class="comment">// if ( smesh.vertexNormals().empty() )</span></div>
<div class="line">  <span class="comment">//   smesh.computeVertexNormalsFromFaceNormals();</span></div>
<div class="line">  <span class="comment">// computes area, mean and Gaussian curvature measures</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Compute mu0&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keyword">auto</span> mu0 = cnc.computeMu0();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Compute mu1&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keyword">auto</span> mu1 = cnc.computeMu1();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Compute mu2&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keyword">auto</span> mu2 = cnc.computeMu2();</div>
</div><!-- fragment --><p >The remaining of the code to estimate curvatures from measures is identical to above. We run the examples on "Al" vol file, which gives the following results.</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="al-cnc-H-r2.jpg" alt="" width="90%"/>
<div class="caption">
Interpolated corrected mean curvature measure, r=2</div></div>
 </td><td><div class="image">
<img src="al-cnc-G-r2.jpg" alt="" width="90%"/>
<div class="caption">
Interpolated corrected Gaussian curvature measure, r=2</div></div>
 </td><td><div class="image">
<img src="al-cnc-K1-D1-r2.jpg" alt="" width="90%"/>
<div class="caption">
Interpolated corrected smallest principal curvature and direction, r=2</div></div>
 </td><td><div class="image">
<img src="al-cnc-K2-D2-r2.jpg" alt="" width="90%"/>
<div class="caption">
Interpolated corrected greatest principal curvature and direction, r=2</div></div>
  </td></tr>
</table>
<h2><a class="anchor" id="dgtal_curvature_measures_sec33"></a>
Comparison between integral invariant  and CNC curvature estimates on digital boundaries</h2>
<p >We give below a few comparisons (in terms of accuracy and speed) between CNC curvature estimations and Integral Invariant (II) method (see <a class="el" href="moduleIntegralInvariant.html">Integral invariant curvature estimator 2D/3D</a>). II method is a curvature estimation method specialized (and restricted) to boundaries of digital volumes (i.e. set of voxels). Therefore we compare their respective performance on digitizations of polynomial surfaces.</p>
<dl class="section note"><dt>Note</dt><dd>We use example <a class="el" href="curvature-comparator-ii-cnc-3d_8cpp.html">curvature-comparator-ii-cnc-3d.cpp</a> to do the computations.</dd></dl>
<p>We run the tests on <b>goursat</b> polynomial surface, with digitization gridsteps \( h \in \{ 1, 0.5, 0.25, 0.125, 0.0625 \} \). <a class="el" href="structDGtal_1_1Parameters.html">Parameters</a> are set up as follows:</p>
<ul>
<li><b>II</b> <b>method</b> <ul>
<li>integration radius is \( R = 3h^{\frac{1}{3}} \), which is the standard parametrization,</li>
<li>we test both mean curvature and Gaussian curvature estimations.</li>
</ul>
</li>
<li><b>CNC</b> <b>method</b> <ul>
<li>corrected normal vector field is II normal vector estimation with also radius \( R = 3h^{\frac{1}{3}} \),</li>
<li>measure radius for CNC is \( \rho = h^{\frac{1}{2}} \),</li>
<li>either constant or interpolated CNC measures are computed,</li>
<li>we test both mean curvature and Gaussian curvature estimations.</li>
</ul>
</li>
</ul>
<p >We plot below accuracy as a function of the digitization gridstep.</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="goursat-ii-ccnc-h-vs-H.jpg" alt="" width="90%"/>
<div class="caption">
Accuracy comparison between II and constant CNC mean curvature estimates, as a function of the digitization gridstep</div></div>
 </td><td><div class="image">
<img src="goursat-ii-icnc-h-vs-H.jpg" alt="" width="90%"/>
<div class="caption">
Accuracy comparison between II and interpolated CNC mean curvature estimates, as a function of the digitization gridstep</div></div>
 </td><td><div class="image">
<img src="goursat-ii-icnc-h-vs-G.jpg" alt="" width="90%"/>
<div class="caption">
Accuracy comparison between II and interpolated CNC Gaussian curvature estimates, as a function of the digitization gridstep</div></div>
  </td></tr>
</table>
<p >We plot below accuracy as a function of the computation time (in ms).</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="goursat-ii-icnc-t-vs-H.jpg" alt="" width="90%"/>
<div class="caption">
Accuracy comparison between II and interpolated CNC mean curvature estimates, as a function of the computation time (in ms)</div></div>
 </td><td><div class="image">
<img src="goursat-ii-icnc-t-vs-G.jpg" alt="" width="90%"/>
<div class="caption">
Accuracy comparison between II and interpolated CNC Gaussian curvature estimates, as a function of the computation time (in ms)</div></div>
  </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">curvature estimator   </th><th class="markdownTableHeadNone">number of surfels   </th><th class="markdownTableHeadNone">error loo   </th><th class="markdownTableHeadNone">error l2   </th><th class="markdownTableHeadNone">total time (ms)   </th><th class="markdownTableHeadNone">normal estimation time (ms)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">II mean curvature   </td><td class="markdownTableBodyNone">9510   </td><td class="markdownTableBodyNone">0.212016   </td><td class="markdownTableBodyNone">0.0835415   </td><td class="markdownTableBodyNone">148 (mean+Gaussian)   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ICNC mean curvature   </td><td class="markdownTableBodyNone">9510   </td><td class="markdownTableBodyNone">0.0640707   </td><td class="markdownTableBodyNone">0.0199467   </td><td class="markdownTableBodyNone">450 (mean+Gaussian)   </td><td class="markdownTableBodyNone">83    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">II Gaussian curvature   </td><td class="markdownTableBodyNone">9510   </td><td class="markdownTableBodyNone">0.0501252   </td><td class="markdownTableBodyNone">0.0150247   </td><td class="markdownTableBodyNone">148 (mean+Gaussian)   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ICNC Gaussian curvature   </td><td class="markdownTableBodyNone">9510   </td><td class="markdownTableBodyNone">0.0263134   </td><td class="markdownTableBodyNone">0.00686261   </td><td class="markdownTableBodyNone">450 (mean+Gaussian)   </td><td class="markdownTableBodyNone">83    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">II mean curvature   </td><td class="markdownTableBodyNone">151374   </td><td class="markdownTableBodyNone">0.124552   </td><td class="markdownTableBodyNone">0.0546997   </td><td class="markdownTableBodyNone">31635 (mean+Gaussian)   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ICNC mean curvature   </td><td class="markdownTableBodyNone">151374   </td><td class="markdownTableBodyNone">0.0295432   </td><td class="markdownTableBodyNone">0.00730423   </td><td class="markdownTableBodyNone">38582 (mean+Gaussian)   </td><td class="markdownTableBodyNone">19322    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">II Gaussian curvature   </td><td class="markdownTableBodyNone">151374   </td><td class="markdownTableBodyNone">0.0433595   </td><td class="markdownTableBodyNone">0.00983477   </td><td class="markdownTableBodyNone">31635 (mean+Gaussian)   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ICNC Gaussian curvature   </td><td class="markdownTableBodyNone">151374   </td><td class="markdownTableBodyNone">0.0194384   </td><td class="markdownTableBodyNone">0.00262745   </td><td class="markdownTableBodyNone">38582 (mean+Gaussian)   </td><td class="markdownTableBodyNone">19322   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Both CNC curvature estimators are twice to five times more accurate than II curvature estimates. About speed, asymptotically, most of the time taken by CNC is for computing II normal vectors. Finally, as shown by pictures, CNC curvature estimates are much more stable than II curvature estimates, which tend to oscillate around the correct value. </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Nov 27 2022 15:16:00 for DGtal by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
