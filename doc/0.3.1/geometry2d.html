<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DGtal: Analysis of one-dimensional discrete structures</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DGtal&#160;<span id="projectnumber">0.4.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Analysis of one-dimensional discrete structures </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><dl class="author"><dt><b>Author:</b></dt><dd>Tristan Roussillon</dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2011/08/31</dd></dl>
<p>This part of the manual describes how to extract patterns from one-dimensional discrete structures (basically digital curves).</p>
<ol type="1">
<li><a class="el" href="geometry2d.html#geometryIntro">One-dimensional discrete structures</a><ol type="a">
<li><a class="el" href="geometry2d.html#geometryBasicConcepts">Iterators/Circulators and Ranges.</a></li>
<li><a class="el" href="geometry2d.html#geometryGridCurve">GridCurve and FreemanChain.</a></li>
</ol>
</li>
<li><a class="el" href="geometry2d.html#geometrySegments">Segments and on-line detection of segments.</a></li>
<li><a class="el" href="geometry2d.html#geometrySegmentsExtraction">Segments Extraction.</a><ol type="a">
<li><a class="el" href="geometry2d.html#geometryGreedyDecomposition">Greedy segmentation</a></li>
<li><a class="el" href="geometry2d.html#geometryUniqueDecomposition">Saturated segmentation.</a></li>
</ol>
</li>
</ol>
<h2><a class="anchor" id="geometryIntro"></a>
One-dimensional discrete structures</h2>
<p>The goal is to provide tools that help in analysing any one-dimensional discrete structures in a generic framework. These structures are assumed to be constant, not mutable. This is a (not exhaustive) list of such structures used in digital geometry:</p>
<ul>
<li>digital curves<ul>
<li>2d, 3d, nd</li>
<li>4-connected, 8-connected, disconnected</li>
<li>interpixels, pixels</li>
<li>open, closed</li>
</ul>
</li>
<li>chaincodes</li>
</ul>
<h3><a class="anchor" id="geometryBasicConcepts"></a>
Iterators/Circulators and Ranges.</h3>
<p>Since these structures are one-dimensional and discrete, they can be viewed as a locally ordered set of elements, like a string of pearls. Two notions are thus important: the one of <em>element</em> and the one of <em>local order</em>, which means that all the elements (except maybe at the ends) have a previous and next element. The concept of <em>iterator</em> is heavily used in our framework because it encompasses these two notions at the same time: like a pointer, it provides a way of moving along the structure (operator++, operator--) and provides a way of getting the elements (operator*).</p>
<p>In the following, iterators are assumed to be constant (because the structures are assumed to be constant) and to be at least bidirectionnal (ie. they are either bidirectionnal iterators or random access iterators). You can read the STL documentation about iterators: <a href="http://www.sgi.com/tech/stl/Iterators.html">http://www.sgi.com/tech/stl/Iterators.html</a> to learn more about the different kind of iterators.</p>
<p>The notion of <em>reachability</em> is very important. An iterator j is reachable from an iterator i if and only if i can be made equal to j with finitely many applications of the operator++. If j is reachable from i, one can iterate over the <em>range</em> of elements bounded by i and j, from the one pointed to by i and up to but not including the one pointed to by j. Such a range is valid and is denoted by [i,j).</p>
<p>Let i and j be two iterators that point to two elements of a same structure. For open (or linear) structures, [i,j) is not always a valid range (ie. j is not always reachable from i) because if j has not been reached and if i points to the last element, one application of the operator++ makes i to be equal to the <em>past-the-end</em> value, ie. an iterator value that points past the last element (just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element of the array). If i turns out to be equal to the past-the-end value, then j cannot be reached from i. If an iterator denoted by begin points to the first element of a given structure and an iterator denoted by end is the past-the-end value, iterating over the range [begin,end) is a way of iterating over all the elements of the underlying structure. If the underlying structure is empty, it only has a past-the-end value. As a consequence, a range [i, i) denotes an empty range. A range of a linear structure is illustrated below (normal values are depicted with a small straight segment, whereas the past-the-end value is depicted with a cross). In this example, [i,j) is not a valid range because j cannot be reached from i and the whole range may be denoted by [begin,end).</p>
<div align="center">
<img src="linearRange.png" alt="linearRange.png"/>
<p><strong>Linear range</strong></p></div>
  However, for closed (or circular) structures, [i,j) should always be a valid range (ie. j should always be reachable from i) and there should be no past-the-end value. As a consequence, iterating over all the elements or dealing with empty ranges is different. The chosen solution is the same as the one used in <a href="http://www.cgal.org/Manual/3.3/doc_html/cgal_manual/Circulator/Chapter_main.html">CGAL</a>. Circular iterators (or <em>circulators</em> for short) are used instead classic iterators. They behave like classic iterators but they have a specific state in the empty range case. As long as i != j, the range [i,j) behaves like a classic iterator range and could be used in STL algorithms. The range [i,i) is used to iterate over all the elements in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> algorithms (each element is visited only once). Such a range is however considered as empty in STL algorithms. A range of a circular structure is illustrated below. In this example, [i,j) is a valid range.</p>
<div align="center">
<img src="circularRange.png" alt="circularRange.png"/>
<p><strong>Circular range</strong></p></div>
  Either an iterator or a circulator may have a reverse counterpart, ie. an adaptor that enables a backward scanning. The operator++ of the adaptor calls the operator-- of the underlying (circular)iterator and conversely. You can use the STL reverse iterator for that: <a href="http://www.sgi.com/tech/stl/ReverseIterator.html">http://www.sgi.com/tech/stl/ReverseIterator.html</a></p>
<h3><a class="anchor" id="geometryGridCurve"></a>
GridCurve and FreemanChain.</h3>
<p>Two objects are provided in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> to deal with digital curves: <a class="el" href="classDGtal_1_1GridCurve.html" title="Aim: describes an alternative sequence of signed 0-cell (pointels) and 1-cell (linels) in any dimensi...">GridCurve</a> and <a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a>.</p>
<p><a class="el" href="classDGtal_1_1GridCurve.html" title="Aim: describes an alternative sequence of signed 0-cell (pointels) and 1-cell (linels) in any dimensi...">GridCurve</a> is an (open or closed) n-dimensional oriented grid curve. It stores a list of alternated (signed) 0-cells and 1-cells, but provides many ranges to iterate over different kinds of elements:</p>
<ul>
<li>in nd:<ul>
<li><a class="el" href="classSCellsRange.html" title="Aim: model of CRange that provides services to (circularly)iterate over the signed d-cells of a grid ...">SCellsRange</a> to iterate over the (signed) cells (0-cells or 1-cells),</li>
<li><a class="el" href="classPointsRange.html" title="Aim: model of CRange that provides services to (circularly)iterate over the 0-cells of a grid curve...">PointsRange</a> to iterate over the 0-cells viewed as integer points,</li>
<li><a class="el" href="classMidPointsRange.html" title="Aim: model of CRange that provides services to (circularly)iterate over the signed 1-cells of a grid ...">MidPointsRange</a> to iterate over the midpoint of the 1-cells,</li>
<li><a class="el" href="classArrowsRange.html" title="Aim: model of CRange that provides services to (circularly)iterate over the signed 1-cells of a grid ...">ArrowsRange</a> to iterator over the (signed) 1-cells viewed as a pair point-vector (the point stands for the starting point of the arrow, the vector gives the orientation or the arrow).</li>
</ul>
</li>
<li>in 2d:<ul>
<li><a class="el" href="classInnerPointsRange.html" title="Aim: model of CRange that provides services to (circularly)iterate over the 2-cells (viewed as points...">InnerPointsRange</a> to iterate over the 2-cells, viewed as integer points, that are <em>directly</em> incident to the (signed) 1-cells,</li>
<li><a class="el" href="classOuterPointsRange.html" title="Aim: model of CRange that provides services to (circularly)iterate over the 2-cells (viewed as points...">OuterPointsRange</a> to iterate over the 2-cells, viewed as integer points, that are <em>indirectly</em> incident to the (signed) 1-cells,</li>
<li><a class="el" href="classIncidentPointsRange.html" title="Aim: model of CRange that provides services to (circularly)iterate over the two 2-cells (viewed as po...">IncidentPointsRange</a> to iterate over the pairs of 2-cells that are incident to the 1-cells (both inner points and outer points),</li>
<li><a class="el" href="classCodesRange.html" title="Aim: model of CRange that provides services to (circularly)iterate over the 1-cells of a 2d grid curv...">CodesRange</a> to iterate over the (signed) 1-cells viewed as codes {0,1,2,3}.</li>
</ul>
</li>
</ul>
<p>You can get an access to these nine ranges through the following methods:</p>
<ul>
<li>get0SCellsRange()</li>
<li>get1SCellsRange()</li>
<li>getPointsRange()</li>
<li>getMidPointsRange()</li>
<li>getArrowsRange()</li>
<li>getInnerPointsRange()</li>
<li>getOuterPointsRange()</li>
<li>getIncidentPointsRange()</li>
<li>getCodesRange()</li>
</ul>
<p>The different ranges for a grid curve whose chain code is 1110002223333 are depicted below.</p>
<div align="center">
<img src="0cellsRange.png" alt="0cellsRange.png"/>
<p><strong>Range of 0-cells</strong></p></div>
  <div align="center">
<img src="1cellsRange.png" alt="1cellsRange.png"/>
<p><strong>Range of 1-cells</strong></p></div>
  <div align="center">
<img src="PointsRange.png" alt="PointsRange.png"/>
<p><strong>Points of integer coordinates associated to 0-cells</strong></p></div>
  <div align="center">
<img src="MidPointsRange.png" alt="MidPointsRange.png"/>
<p><strong>Points of half-integer coordinates accociated to 1-cells</strong></p></div>
  <div align="center">
<img src="InnerPointsRange.png" alt="InnerPointsRange.png"/>
<p><strong>Points of integer coordinates associated to the 2-cells directly incident to the 1-cells</strong></p></div>
  <div align="center">
<img src="OuterPointsRange.png" alt="OuterPointsRange.png"/>
<p><strong>Points of integer coordinates associated to the 2-cells indirectly incident to the 1-cells</strong></p></div>
  <div align="center">
<img src="IncidentPointsRange.png" alt="IncidentPointsRange.png"/>
<p><strong>Points of integer coordinates associated to the 2-cells incident to the 1-cells</strong></p></div>
  <a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a> is 2-dimensional and 4-connected digital curve stored as a string of codes {0,1,2,3} as follows:</p>
<ul>
<li>0 for a horizontal step to the right</li>
<li>1 for a vertical step to the up</li>
<li>2 for a horizontal step to the left</li>
<li>3 for a vertical step to the bottom As <a class="el" href="classDGtal_1_1GridCurve.html" title="Aim: describes an alternative sequence of signed 0-cell (pointels) and 1-cell (linels) in any dimensi...">GridCurve</a>, it provides a <a class="el" href="classCodesRange.html" title="Aim: model of CRange that provides services to (circularly)iterate over the 1-cells of a 2d grid curv...">CodesRange</a>.</li>
</ul>
<p>Each range has the following inner types:</p>
<ul>
<li>ConstIterator</li>
<li>ConstReverseIterator</li>
<li>ConstCirculator</li>
<li>ConstReverseCirculator</li>
</ul>
<p>And each range provides these (circular)iterator services:</p>
<ul>
<li>begin() : begin ConstIterator</li>
<li>end() : end ConstIterator</li>
<li>rbegin() : begin ConstReverseIterator</li>
<li>rend() : end ConstReverseIterator</li>
<li>c() : ConstCirculator</li>
<li>rc() : ConstReverseCirculator</li>
</ul>
<p>You can use these services to iterate over the elements of a given range as follows:  <a class="el" href="exampleGridCurve2d_8cpp_source.html" title="An example file for GridCurve.">geometry/exampleGridCurve2d.cpp</a> GridCurveRangeIterators</p>
<p>Since <a class="el" href="classDGtal_1_1GridCurve.html" title="Aim: describes an alternative sequence of signed 0-cell (pointels) and 1-cell (linels) in any dimensi...">GridCurve</a> and <a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a> have both a method isClosed(), you can decide to use a classic iterator or a circulator at running time as follows:</p>
<div class="fragment"><pre class="fragment">    <span class="comment">//c is a grid curve, r is an instance of Range</span>
    <span class="comment">//myProcessing is a template function where </span>
    <span class="comment">//the range r is processed through (circular)iterators</span>
    <span class="keywordflow">if</span> ( c.isClosed() ) {
      myProcessing&lt;Range::ConstCirculator&gt;( r.c(), r.c() ); 
    } <span class="keywordflow">else</span> {
      myProcessing&lt;Range::ConstIterator&gt;( r.begin(), r.end() ); 
    }
</pre></div><h2><a class="anchor" id="geometrySegments"></a>
Segments and on-line detection of segments.</h2>
<p>In this section, we focus on parts of one-dimensional structures, called <em>segment</em>. More precisely, a segment is a valid and not empty range. Any model of the concept <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment of a range, ie. a valid and not empty subrange...">CSegment</a>, should have the following inner types:</p>
<ul>
<li>Self (its own type)</li>
<li>ConstIterator</li>
</ul>
<p>and the following methods:</p>
<ul>
<li>begin() : begin iterator</li>
<li>end() : end iterator</li>
</ul>
<p>Moreover, a segment can be defined from a property P, which can be built from conjunctions and disjunctions of other properties. A given property P is valid iff it is true for any valid range of only one element and true for any valid range of any segment for which P is true. For instance, the properties "to be a 4-connected DSS" or "to be a balanced word" can define segments, but "to contain at least k elements (k &gt; 1)" cannot define segments because it does not hold for ranges of strictly less than k elements.</p>
<p>In digital geometry, a primitive is usually defined as a class of digital objects: the Gauss digitization of a Euclidean disk is an example of primitive. In this framework, a primitive is the class of segments verifying the same valid property P.</p>
<p>The detection problem consists in deciding whether a given segment belongs to a class of segments defined from a valid property P or not. If P is valid, the detection of a segment can be performed in an incremental way: a segment is initialized at a starting element and then can be extended to the neighbors elements if the property P still holds. A segment that can control its own extension (so that P remains true) is a <em>segment computer</em>. A segment computer is not a single concept, but actually five concepts that form a hierarchy: the first one can only extend itself in one direction, while others define additional functionality. The five concepts that are actually used in segmentation algorithms are <a class="el" href="structDGtal_1_1CTrivialSegmentComputer.html" title="Aim: Defines the concept describing the most trivial segment computer, ie. a model of CSegment that c...">CTrivialSegmentComputer</a>, <a class="el" href="structDGtal_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer, ie. a model of CSegment that can exte...">CForwardSegmentComputer</a>, <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a>, <a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html" title="Aim: Defines the concept describing a dynamic segment computer, ie. a model of CSegment that can exte...">CDynamicSegmentComputer</a> and <a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie...">CDynamicBidirectionalSegmentComputer</a>.</p>
<div align="center">
<img src="segmentComputersHierarchy.png" alt="segmentComputersHierarchy.png"/>
<p><strong>Hierarchy</strong></p></div>
  The most restrictive kind of segment computer is <a class="el" href="structDGtal_1_1CTrivialSegmentComputer.html" title="Aim: Defines the concept describing the most trivial segment computer, ie. a model of CSegment that c...">CTrivialSegmentComputer</a>, which is only presented to smoothly introduce the next concepts. <a class="el" href="structDGtal_1_1CTrivialSegmentComputer.html" title="Aim: Defines the concept describing the most trivial segment computer, ie. a model of CSegment that c...">CTrivialSegmentComputer</a> is a refinement of <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment of a range, ie. a valid and not empty subrange...">CSegment</a> and should provide in addition the following two methods:</p>
<ul>
<li>void init ( const Iterator&amp; it ) : set the segment to the element pointed to by it.</li>
<li>bool extend () : return 'true' and extend the segment to the element pointed to by end() if it is possible, return 'false' and does not extend the segment otherwise.</li>
<li>bool isExtendable () : return 'true' if the segment can be extended to the element pointed to by end() and 'false' otherwise (no extension is performed).</li>
</ul>
<p>Detecting a segment in a range looks like this:</p>
<div class="fragment"><pre class="fragment">    <span class="comment">//s is a segment computer</span>
    <span class="comment">//[begin,end) is a range</span>
                s.init( begin );
    <span class="keywordflow">while</span> ( (s.end() != end) &amp;&amp; (s.extend()) ) {} 
</pre></div><p>If the underlying structure is closed, infinite loops are avoided as follows:</p>
<div class="fragment"><pre class="fragment">    <span class="comment">//s is a segment computer</span>
    <span class="comment">//c is a circulator</span>
                s.init( c );
    <span class="keywordflow">while</span> ( (s.end() != s.begin()) &amp;&amp; (s.extend()) ) {} 
</pre></div><p>Segment computers are based on iterators. This is a useful feature since it provides a way to iterate over the segment if it is required at some points of the detection process. However the extension of a segment can be performed in only one direction (given by operator++). To cope with this problem, the models of <a class="el" href="structDGtal_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer, ie. a model of CSegment that can exte...">CForwardSegmentComputer</a>, which is a refinement of <a class="el" href="structDGtal_1_1CTrivialSegmentComputer.html" title="Aim: Defines the concept describing the most trivial segment computer, ie. a model of CSegment that c...">CTrivialSegmentComputer</a>, should define the following nested type:</p>
<ul>
<li>Reverse</li>
</ul>
<p>Reverse is a type that behaves like Self but with reverse iterators. In order to get a reverse copy of a segment computer, the following method should be defined:</p>
<ul>
<li>Reverse getReverse() : get a reverse copy</li>
</ul>
<p>As the name suggests, forward segment computers can only extend themselves in the forward direction, but this direction is relative to the direction of the underlying iterators. They cannot extend themselves in two directions at the same time contrary to bidirectional segment computers.</p>
<p>Any model of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a>, which is a refinement of <a class="el" href="structDGtal_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer, ie. a model of CSegment that can exte...">CForwardSegmentComputer</a>, should define the following methods:</p>
<ul>
<li>bool extendOppositeEnd () : return 'true' and extend the segment to the element pointed to by --begin() if it is possible, return 'false' and does not extend the segment otherwise.</li>
<li>bool isOppositeEndExtendable () : return 'true' if the segment can be extended to the element pointed to by --begin() and 'false' otherwise (no extension is performed).</li>
</ul>
<p>The concept <a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html" title="Aim: Defines the concept describing a dynamic segment computer, ie. a model of CSegment that can exte...">CDynamicSegmentComputer</a> is another refinement of <a class="el" href="structDGtal_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer, ie. a model of CSegment that can exte...">CForwardSegmentComputer</a>. Any model of this concept should define the following method:</p>
<ul>
<li>bool retract () : return 'true' and move the beginning of the segment to ++begin() if ++begin() != end(), return 'false' otherwise.</li>
</ul>
<p>Finally, the concept <a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie...">CDynamicBidirectionalSegmentComputer</a> is a refinement of both <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a> and <a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html" title="Aim: Defines the concept describing a dynamic segment computer, ie. a model of CSegment that can exte...">CDynamicSegmentComputer</a>.</p>
<p>A model of <a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie...">CDynamicBidirectionalSegmentComputer</a> is the class <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: Dynamic recognition of a digital straight segment (DSS) defined as the sequence of simply connec...">ArithmeticalDSS</a>, devoted to the dynamic recognition of DSSs, defined as a sequence of connected points <img class="formulaInl" alt="$ (x,y) $" src="form_52.png"/> such that <img class="formulaInl" alt="$ \mu \leq ax - by < \mu + \omega $" src="form_0.png"/> (see Debled and Reveilles, 1995).</p>
<p>Here is a short example of how to use this class in the 4-connected case:  <a class="el" href="ArithmeticalDSS_8cpp_source.html">geometry/ArithmeticalDSS.cpp</a> ArithmeticalDSS4Usage</p>
<p>Here is a short example of how to use this class in the 8-connected case:  <a class="el" href="ArithmeticalDSS_8cpp_source.html">geometry/ArithmeticalDSS.cpp</a> ArithmeticalDSS8Usage</p>
<p>These snippets are drawn from <a class="el" href="ArithmeticalDSS_8cpp_source.html">ArithmeticalDSS.cpp</a>.</p>
<p>The resulting DSSs of the two previous pieces of code are drawing below:</p>
<div align="center">
<img src="DSS8.png" alt="DSS8.png"/>
<p><strong>8-connected DSS drawn with the paving mode</strong></p></div>
 <div align="center">
<img src="DSS4.png" alt="DSS4.png"/>
<p><strong>4-connected DSS drawn with the grid mode</strong></p></div>
 <p>See <a class="el" href="dgtal_dgtalboard.html">Board2D: a stream mechanism for displaying 2D digital objects</a> for the drawing mechanism.</p>
<p>As seen above, the code can be different if an iterator or a circulator is used as the nested ConstIterator type. Moreover, some tasks can be made faster for a given kind of segment computer than for another kind of segment computer. That's why many generic functions are provided in  <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>:</p>
<ul>
<li>maximalExtension, oppositeEndMaximalExtension, maximalSymmetricExtension,</li>
<li>maximalRetraction, oppositeEndMaximalRetraction,</li>
<li>longestSegment,</li>
<li>firstMaximalSegment, lastMaximalSegment, mostCenteredMaximalSegment,</li>
<li>previousMaximalSegment, nextMaximalSegment,</li>
</ul>
<p>These functions are used in the segmentation algorithms.</p>
<h2><a class="anchor" id="geometrySegmentsExtraction"></a>
Segments Extraction.</h2>
<p>A given range contains a finite set of segments verifying a given valid property P. A <em>segmentation</em> is a subset of the whole set of segments, such that:</p>
<ul>
<li>(i) each element of the range belongs to a segment of the subset and</li>
<li>(ii) no segment contains another segment of the subset. Due to (ii), the segments of a segmentation can be ordered without ambiguity (according to the position of their first element for instance).</li>
</ul>
<p>Segmentation algorithms should verify the concept CSegmentation. A CSegmentation model should define the following nested type:</p>
<ul>
<li>SegmentComputerIterator: a model of the concept CSegmentComputerIterator</li>
</ul>
<p>It should also define a constructor taking as input parameters:</p>
<ul>
<li>begin/end iterators of the range to be segmented.</li>
<li>an instance of a model of CSegmentComputer.</li>
</ul>
<p>Note that a model of CSegmentComputerIterator should define the following methods :</p>
<ul>
<li>default and copy constructors</li>
<li>dereference operator: return an instance of a model of CSegmentComputer.</li>
<li>intersectPrevious(), intersectNext(): return 'true' if the current segment intersects, respectively, the previous and the next one (when they exist), 'false' otherwise.</li>
</ul>
<h3><a class="anchor" id="geometryGreedyDecomposition"></a>
Greedy segmentation</h3>
<p>The first and simplest segmentation is the greedy one: from a starting element, extend a segment while it is possible, get the last element of the resulting segment and iterate. This segmentation algorithm is implemented in the class  <a class="el" href="classDGtal_1_1GreedySegmentation.html" title="Aim: Computes the greedy segmentation of a range given by a pair of ConstIterators. The last element of a given segment is the first one one of the next segment.">GreedySegmentation</a>.</p>
<p>In the short example below, a digital curve stored in a STL vector is decomposed into 8-connected DSSs whose parameters are sent to the standard output. </p>
<div class="fragment"><pre class="fragment">  <span class="comment">//types definition</span>
  <span class="keyword">typedef</span> PointVector&lt;2,int&gt; Point;
  <span class="keyword">typedef</span> std::vector&lt;Point&gt; Range;
  <span class="keyword">typedef</span> Range::const_iterator ConstIterator;
  <span class="keyword">typedef</span> ArithmeticalDSS&lt;ConstIterator,int,8&gt; SegmentComputer;
        <span class="keyword">typedef</span> GreedySegmentation&lt;SegmentComputer&gt; Segmentation;

        <span class="comment">//input points</span>
        Range curve;
        curve.push_back(Point(1,1));
        curve.push_back(Point(2,1));
        curve.push_back(Point(3,2));
        curve.push_back(Point(4,2));
        curve.push_back(Point(5,2));
        curve.push_back(Point(6,2));
        curve.push_back(Point(7,2));
        curve.push_back(Point(8,1));
        curve.push_back(Point(9,1));

  <span class="comment">//Segmentation</span>
        SegmentComputer recognitionAlgorithm;
  Segmentation theSegmentation(curve.<a class="code" href="classDGtal_1_1FreemanChain.html#adadc3381807f63d38d0a3bc468b972b4">begin</a>(), curve.<a class="code" href="classDGtal_1_1FreemanChain.html#aeb64e50f10e798c9db8ffcc972af4844">end</a>(), recognitionAlgorithm);
                                 
  Segmentation::SegmentComputerIterator i = theSegmentation.<a class="code" href="classDGtal_1_1FreemanChain.html#adadc3381807f63d38d0a3bc468b972b4">begin</a>();
  Segmentation::SegmentComputerIterator end = theSegmentation.end();
  <span class="keywordflow">for</span> ( ; i != end; ++i) {
                SegmentComputer current(*i);
                <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a33ae7cd58d47594cee54640946c6b859">info</a>() &lt;&lt; current &lt;&lt; std::endl;   <span class="comment">//standard output</span>
  } 
</pre></div><p>If you want to get the DSSs segmentation of the digital curve when it is scanned in the reverse way, you can use the reverse iterator of the STL vector: </p>
<div class="fragment"><pre class="fragment">...
        <span class="keyword">typedef</span> Range::const_reverse_iterator ConstReverseIterator;
...
  Segmentation theSegmentation(curve.rbegin(), curve.rend(), recognitionAlgorithm);
...
</pre></div><p>The resulting segmentations are shown in the figures below:</p>
<div align="center">
<img src="left_right.png" alt="left_right.png"/>
<p><strong>segmented from left to right</strong></p></div>
 <div align="center">
<img src="right_left.png" alt="right_left.png"/>
<p><strong>segmented from right to left</strong></p></div>
 <p>If you want to get the DSSs segmentation of a part of the digital curve (not the whole digital curve), you can give the range to process as a pair of iterators when calling the setSubRange() method as follow: </p>
<div class="fragment"><pre class="fragment">  theSegmentation.setSubRange(beginIt, endIt);
</pre></div><p>Obviously, [beginIt, endIt) has to be a valid range included in the wider range [curve.begin(), curve.end()).</p>
<p>Moreover, a part of a digital curve may be processed either as an independant (open) digital curve or as a part whose segmentation at the ends depends of the underlying digital curve. That's why 3 processing modes are available:</p>
<ul>
<li>"Truncate" (default), the extension of the last segment (and the segmentation) stops just before endIt.</li>
<li>"Truncate+1", the last segment is extended to endIt too if it is possible, provided that endIt != curve.end().</li>
<li>"DoNotTruncate", the last segment is extended as far as possible, provided that curve.end() is not reached.</li>
</ul>
<p>In order to set a mode (before getting a SegmentComputerIterator), use the setMode() method as follow: </p>
<div class="fragment"><pre class="fragment">  theSegmentation.setMode(<span class="stringliteral">&quot;DoNotTruncate&quot;</span>);
</pre></div><p> Note that the default mode will be used for any unknown modes.</p>
<p>The complexity of the greedy segmentation algorithm relies on the complexity of the extend() method of the segment computer. If it runs in (possibly amortized) constant time, then the complexity of the segmentation is linear in the length of the range.</p>
<h3><a class="anchor" id="geometryUniqueDecomposition"></a>
Saturated segmentation.</h3>
<p>A unique and richer segmentation, called saturated segmentation, is the whole set of <em>maximal segments</em> (a maximal segment is a segment that cannot be contained in a greater segment). This segmentation algorithm is implemented in the class <a class="el" href="classDGtal_1_1SaturatedSegmentation.html">SaturatedSegmentation</a>.</p>
<p>In the previous segmentation code, instead of the line: </p>
<div class="fragment"><pre class="fragment">        <span class="keyword">typedef</span> GreedySegmentation&lt;SegmentComputer&gt; Segmentation;
</pre></div><p> it is enough to write the following line: </p>
<div class="fragment"><pre class="fragment">        <span class="keyword">typedef</span> SaturatedSegmentation&lt;SegmentComputer&gt; Segmentation;
</pre></div><p>to get the following figure: </p>
<div align="center">
<img src="maxseg.png" alt="maxseg.png"/>
<p><strong>maximal segments</strong></p></div>
 <p>See  <a class="el" href="convex-and-concave-parts_8cpp_source.html">convex-and-concave-parts.cpp</a> for an example of how to use maximal DSSs to decompose a digital curve into convex and concave parts.</p>
<p>If you want to get the saturated segmentation of a part of the digital curve (not the whole digital curve), you can give the range to process as a pair of iterators when calling the setSubRange() method as follow: </p>
<div class="fragment"><pre class="fragment">  theSegmentation.setSubRange(beginIt, endIt);
</pre></div><p>Obviously, [beginIt, endIt) has to be a valid range included in the wider range [curve.begin(), curve.end()).</p>
<p>Moreover, the segmentation at the ends depends of the underlying digital curve. Among the whole set of maximal segments that pass through the first (resp. last) element of the range, one maximal segment must be chosen as the first (resp. last) retrieved maximal segments. Several processing modes are therefore available:</p>
<ul>
<li>"First",</li>
<li>"MostCentered" (default),</li>
<li>"Last",</li>
</ul>
<p>The mode i indicates that the segmentation begins with the i-th maximal segment passing through the first element and ends with the i maximal segment passing through the last element.</p>
<p>In order to set a mode (before getting a SegmentComputerIterator), use the setMode() method as follow: </p>
<div class="fragment"><pre class="fragment">  theSegmentation.setMode(<span class="stringliteral">&quot;First&quot;</span>);
</pre></div><p> Note that the default mode will be used for any unknown modes.</p>
<p>The complexity of the saturated segmentation algorithm relies on the complexity of the functions available for computing maximal segments (firstMaximalSegment, lastMaximalSegment, mostCenteredMaximalSegment, previousMaximalSegment and nextMaximalSegment), which are specialized according to the type of segment computer (forward, bidirectional and dynamic).</p>
<p>Let <img class="formulaInl" alt="$ l $" src="form_44.png"/> be the length of the range and <img class="formulaInl" alt="$ n $" src="form_45.png"/> the number of maximal segments. Let <img class="formulaInl" alt="$ L_i $" src="form_46.png"/> be the length of the i-th maximal segments. During the segmentation, the current segment is extended:</p>
<ul>
<li>at most <img class="formulaInl" alt="$ 2.\Sigma_{1 \leq i \leq n} L_i $" src="form_47.png"/> times in the forward case.</li>
<li>exactly <img class="formulaInl" alt="$ \Sigma_{1 \leq i \leq n} L_i $" src="form_48.png"/> times in the bidirectional case.</li>
<li><img class="formulaInl" alt="$ l $" src="form_44.png"/> times in the dynamic case. (But in this case, the current segment is also retracted <img class="formulaInl" alt="$ l $" src="form_44.png"/> times).</li>
</ul>
<p>Moreover, note that <img class="formulaInl" alt="$ \Sigma_{1 \leq i \leq n} L_i $" src="form_48.png"/> may be equal to <img class="formulaInl" alt="$ O(l) $" src="form_49.png"/> (for instance for DSSs). </p>
</div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Tue Sep 27 2011 10:27:08 for DGtal by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
