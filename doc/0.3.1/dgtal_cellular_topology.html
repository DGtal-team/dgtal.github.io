<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DGtal: Cellular grid space and topology, cells, digital surfaces</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DGtal&#160;<span id="projectnumber">0.4.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Cellular grid space and topology, cells, digital surfaces </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p>Documentation written by Jacques-Olivier Lachaud and Bertrand Kerautret.</p>
<p>This part of the manual describes how to define cellular grid space or cartesian cubic spaces, as well as the main objects living in these spaces. A part of this documentation comes from project <a href="https://gforge.liris.cnrs.fr/projects/imagene">ImaGene</a>. A lot of the ideas, concepts, algorithms, and code is also a backport from <a href="https://gforge.liris.cnrs.fr/projects/imagene">ImaGene</a>.</p>
<ol type="1">
<li><a class="el" href="dgtal_cellular_topology.html#dgtal_ctopo_sec1">The digital space is a cubic grid</a><ol type="a">
<li><a class="el" href="dgtal_cellular_topology.html#dgtal_ctopo_sec1_1">Images and digital spaces</a></li>
<li><a class="el" href="dgtal_cellular_topology.html#dgtal_ctopo_sec1_2">Cells in the cubical grid and Khalimsky coordinates</a></li>
<li><a class="el" href="dgtal_cellular_topology.html#dgtal_ctopo_sec1_3">Models for cellular grid spaces</a></li>
<li><a class="el" href="dgtal_cellular_topology.html#dgtal_ctopo_sec1_4">Creating a cellular grid space</a></li>
<li><a class="el" href="dgtal_cellular_topology.html#dgtal_ctopo_sec1_5">Creating (unsigned) cells in a cellular grid space</a></li>
<li><a class="el" href="dgtal_cellular_topology.html#dgtal_ctopo_sec1_6">Cells may be unsigned or signed</a></li>
<li><a class="el" href="dgtal_cellular_topology.html#dgtal_ctopo_sec1_7">Accessing and modifying cell coordinates.</a></li>
<li><a class="el" href="dgtal_cellular_topology.html#dgtal_ctopo_sec1_8">Moving within the cellular grid space</a></li>
<li><a class="el" href="dgtal_cellular_topology.html#dgtal_ctopo_sec1_9">Cell topology and directions</a></li>
<li><a class="el" href="dgtal_cellular_topology.html#dgtal_ctopo_sec1_10">Cell adjacency and neighborhood</a></li>
<li><a class="el" href="dgtal_cellular_topology.html#dgtal_ctopo_sec1_11">Cell incidence</a></li>
</ol>
</li>
<li><a class="el" href="dgtal_cellular_topology.html#dgtal_ctopo_sec2">Surfel adjacency and digital surfaces</a><ol type="a">
<li><a class="el" href="dgtal_cellular_topology.html#dgtal_ctopo_sec2_1">Tracking Boundary</a></li>
<li><a class="el" href="dgtal_cellular_topology.html#dgtal_ctopo_sec2_2">Tracking 2D Boundary</a></li>
<li><a class="el" href="dgtal_cellular_topology.html#dgtal_ctopo_sec2_3">Tracking 3D Boundary</a></li>
<li><a class="el" href="dgtal_cellular_topology.html#dgtal_ctopo_sec2_4">Extracting SCell connected boundary surfels</a></li>
</ol>
</li>
</ol>
<h2><a class="anchor" id="dgtal_ctopo_sec1"></a>
The digital space is a cubic grid</h2>
<h3><a class="anchor" id="dgtal_ctopo_sec1_1"></a>
Images and digital spaces</h3>
<p>2D images are often seen as two dimensional arrays, where each cell is a pixel with some value (a gray level, a color). If <img class="formulaInl" alt="$\mathbf{Z}$" src="form_1.png"/> is the set of integer numbers, then an image is a map from a rectangular subset of <img class="formulaInl" alt="$\mathbf{Z} \times \mathbf{Z}$" src="form_2.png"/> to some space (gray levels, colors).</p>
<p>More generally, a nD image is a map from a parallelepipedic subset of <img class="formulaInl" alt="$\mathbf{Z}^n$" src="form_3.png"/> to some space (gray levels, colors).</p>
<p>Many algorithms need to represent positions in images (ie pixels and voxels), in order to represent regions in images. Often, we need also to measure the shape of a region, for instance its perimeter, or we may be interested in the interface between two regions. In these cases, it is often convenient (and generally it is also the theoretic way) to represent other elements in digital spaces, such as paths in-between regions, the thin boundary or surface of a region, etc. We need in this case to represent not only the "squares" (pixels) or "cubes" (voxels) of images, but also their faces, edges, vertices.</p>
<p>We therefore model not only n-dimensional cells (the hypercubes in nD), but also all the lower dimensional cells of the space. For instance, in 2D, we have:</p>
<ul>
<li>2-dimensional cells (closed unit square) = pixels</li>
<li>1-dimensional cells (closed unit segment) = linels</li>
<li>0-dimensional cells (closed point) = pointels</li>
</ul>
<p>The set of all cells <img class="formulaInl" alt="$\mathbf{F}^n$" src="form_4.png"/> is called the n-dimensional space of cubical complexes, or n-dimensional cellular grid space. The couple <img class="formulaInl" alt="$(\mathbf{F}^n,\subseteq)$" src="form_5.png"/> is a partially ordered set or poset. Let <img class="formulaInl" alt="$X$" src="form_6.png"/> be any subset of <img class="formulaInl" alt="$\mathbf{F}^n$" src="form_4.png"/>. The set <img class="formulaInl" alt="$\mathcal{U}=\{U \subseteq X / \forall x \in U, x^{\uparrow} \subseteq U \}$" src="form_7.png"/>, where <img class="formulaInl" alt="$x^{\uparrow}=\{y \in X, x \le y\}$" src="form_8.png"/> or the up incident cells of x, is a topology on <img class="formulaInl" alt="$X$" src="form_6.png"/>, called the Aleksandrov topology. Therefore we can use standard combinatorial topology results for any subset of the cellular grid space.</p>
<p>Cells of the cellular grid space are illustrated below. The paving mode of digital space gives a nice illustration of what is this space. The 2-cell is in red, the 1-cell in green, the 0-cell in blue.</p>
<div align="center">
<img src="cellular-grid-space-1.png" alt="cellular-grid-space-1.png"/>
<p><strong>Illustration of a cellular grid space with cells of different dimensions.</strong></p></div>
 <h3><a class="anchor" id="dgtal_ctopo_sec1_2"></a>
Cells in the cubical grid and Khalimsky coordinates</h3>
<p>We use now the regularity of the cubical grid to represent it efficiently. In 1D, the cubical grid is a simple line alternating closed points {k} and open unit segments (k,k+1). Khalimsky noticed that this (topological) space is homeomorphic to the integer set <img class="formulaInl" alt="$\mathbf{Z}$" src="form_1.png"/>, if we declare every even integer as closed and every odd integer as open.</p>
<p>A digital cell in 1D is thus just an integer. Its topology is defined by its parity. The cell 2k is the closed point {k}; the cell 2k+1 is the segment (k,k+1) (considered open).</p>
<p>In 2D, we use the fact that <img class="formulaInl" alt="$\mathbf{Z}^2$" src="form_9.png"/> is a cartesian product. A digital cell in 2D is thus a couple of integer</p>
<ul>
<li>(2i, 2j): a pointel which is the point set {(i,j)} in the plane</li>
</ul>
<ul>
<li>(2i+1, 2j): an horizontal linel which is the open segment {(i,i+1) x j} in the plane.</li>
</ul>
<ul>
<li>(2i, 2j+1): a vertical linel which is the open segment {i x (j,j+1)} in the plane.</li>
</ul>
<ul>
<li>(2i+1, 2j+1): a pixel which is the open square {(i,i+1) x (j,j+1)} in the plane.</li>
</ul>
<p>In nD, the principle is the same. A cell is thus uniquely identifed by an n-tuple of integers whose parities define the topology of the cell. These integers are called the <b>Khalimsky</b> <b>coordinates</b> of the cell.</p>
<p>For instance, the pixel (x,y) of the digital space <img class="formulaInl" alt="$\mathbf{Z}^2$" src="form_9.png"/> corresponds to the 2-cell (2x+1,2y+1) of the cellular grid space <img class="formulaInl" alt="$\mathbf{F}^2$" src="form_10.png"/>.</p>
<h3><a class="anchor" id="dgtal_ctopo_sec1_3"></a>
Models for cellular grid spaces</h3>
<p>Instead of chosing a specific implementation of a cellular grid space, we keep the genericity and efficiency objective of <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> by defining a cellular grid space as the concept CCellularGridSpaceND. It provides a set of types (Cell, SCell, etc) and methods to manipulate cells of arbitrary dimension. Models of CCellularGridSpaceND are:</p>
<ol type="1">
<li>the <a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex...">KhalimskySpaceND</a> template class.</li>
<li>the --- yet to come --- CodedKhalimskySpaceND class, a backport from class KnSpace of <a href="http://gforge.liris.cnrs.fr/projects/imagene">ImaGene</a>.</li>
</ol>
<p>The inner types are:</p>
<ul>
<li>Integer: the type for representing a coordinate or component in this space.</li>
<li>Size: the type for representing a size (unsigned)</li>
<li>Cell: the type of unsigned cells</li>
<li>SCell: the type of signed cells</li>
<li>Sign: the sign type for cells</li>
<li>DirIterator: the type for iterating over directions of a cell</li>
<li>Point: the type for representing a digital point in this space</li>
<li>Vector: the type for representing a digital vector in this space</li>
<li>Space: the associated digital space type</li>
<li>KhalimskySpace: this cellular grid space</li>
<li>Cells: a sequence of unsigned cells</li>
<li>SCells: a sequence of signed cells</li>
</ul>
<p>Methods include:</p>
<ul>
<li>Cell creation services</li>
<li>Read accessors to cells</li>
<li>Write accessors to cells</li>
<li>Conversion signed/unsigned cells</li>
<li>Cell topology services</li>
<li>Direction iterator services for cells</li>
<li>Unsigned cell geometry services</li>
<li>Signed cell geometry services</li>
<li>Neighborhood services</li>
<li>Incidence services</li>
<li>Interface</li>
</ul>
<h3><a class="anchor" id="dgtal_ctopo_sec1_4"></a>
Creating a cellular grid space</h3>
<p>We use hereafter the model <a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex...">KhalimskySpaceND</a>. To create a 2D cellular grid space where cells have coordinates coded with standard <code>int</code> (32 bits generally), we can write:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">   #include &quot;DGtal/topology/KhalimskySpaceND.h&quot;</span>
   ...
   <span class="keyword">typedef</span> KhalimskySpaceND&lt; 2, int &gt; <a class="code" href="namespaceDGtal_1_1Z2i.html#a6183d00ec6f8c4f81748fd20a52e5590">KSpace</a>;
   KSpace K;
   Point low( -3, -4 );
   Point high( 5, 3 ); 
   <span class="comment">// true for closed space, false for open space.</span>
   <span class="keywordtype">bool</span> space_ok = K.init( low, high, <span class="keyword">true</span> );
</pre></div><p>Note that the cellular grid space is limited by the given bounds. Since the user has chosen a closed space, the Khalimsky coordinates of cells are bounded by:</p>
<ul>
<li>lower bound: (-3*2, -4*2)</li>
<li>upper bound: (5*2+2, 3*2+2)</li>
</ul>
<p>Another frequent way of constructing a cellular grid space is to start from a preexisting digital space and <a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a>. You can define the associated cellular grid space as follows:</p>
<div class="fragment"><pre class="fragment">   ...
   <span class="keyword">typedef</span> SpaceND&lt;3, int&gt; Z;
   <span class="keyword">typedef</span> HyperRectDomain&lt;Z&gt; <a class="code" href="namespaceDGtal_1_1Z2i.html#aca523bebdae58eb19385aaefffff8bc5">Domain</a>;
   ...
   Domain domain( a, b );
   ...
   <span class="keyword">typedef</span> KhalimskySpaceND&lt; Z::dimension, Z::Integer &gt; KSpace;
   KSpace K;
   <span class="keywordtype">bool</span> space_ok = K.init( domain.lowerBound(), domain.upperBound(), true );
</pre></div><p>If you wish to build a digital space and a <a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a> from a cellular grid space K, you may write:</p>
<div class="fragment"><pre class="fragment">   ...
   <span class="keyword">typedef</span> SpaceND&lt;KSpace::dimension, KSpace::Integer&gt; Z;
   <span class="keyword">typedef</span> HyperRectDomain&lt;Z&gt; Domain;
   Domain domain( K.lowerBound(), K.upperBound() );
</pre></div><p>Last but not least, for standard users it is generally enough to use the default types provided in "DGtal/helpers/StdDefs.h". </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">   #include &quot;DGtal/helpers/StdDefs.h&quot;</span>
   ...
   <span class="keyword">using namespace </span>Z2i;
   KSpace K; <span class="comment">// or K2 K;</span>
   ...
</pre></div><h3><a class="anchor" id="dgtal_ctopo_sec1_5"></a>
Creating (unsigned) cells in a cellular grid space</h3>
<p>There are many ways of creating cells within a cellular grid space. The simplest way is certainly to give the Khalimsky coordinates of the cell you wish to create. Its topology is then induced by its coordinates. We use generally <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#aff1a33ccc713c2a00e3ab73ea44e1e69">KhalimskySpaceND::uCell</a> for arbitrary cells, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a255ac161cb44b2a8634529a5717dde67">KhalimskySpaceND::uSpel</a> for n-dimensional cells, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a369b2eebcc3c692d0e029e677817574f">KhalimskySpaceND::uPointel</a> for 0-dimensional cells.</p>
<p>The full code of this example is in file <a href="ctopo-1_8cpp-example.html">ctopo-1.cpp</a>. Pointels or 0-cells are displayed in blue, linels or 1-cells in green, pixels or 2-cells in red. Note that <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#aff1a33ccc713c2a00e3ab73ea44e1e69">KhalimskySpaceND::uCell</a> requires Khalimsky coordinates while the two others require digital coordinates (the topology is known in the two latter cases).</p>
<div class="fragment"><pre class="fragment">  KSpace K;
  Point plow(-3,-2);
  Point pup(5,3);
  K.init( plow, pup, <span class="keyword">true</span> );
  <a class="code" href="namespaceDGtal_1_1Z2i.html#a3013e647aa4b87b40c1554ed6234f9e6">Cell</a> pixlow = K.uSpel( plow ); <span class="comment">// pixel (-3*2+1,-2*2+1)</span>
  <a class="code" href="namespaceDGtal_1_1Z2i.html#a3013e647aa4b87b40c1554ed6234f9e6">Cell</a> ptlow = K.uPointel( plow ); <span class="comment">// pointel (-3*2,-2*2)</span>
  <a class="code" href="namespaceDGtal_1_1Z2i.html#a3013e647aa4b87b40c1554ed6234f9e6">Cell</a> pixup = K.uSpel( pup ); <span class="comment">// pixel (5*2+1,3*2+1)</span>
  <a class="code" href="namespaceDGtal_1_1Z2i.html#a3013e647aa4b87b40c1554ed6234f9e6">Cell</a> ptup1 = K.uPointel( pup );   <span class="comment">// pointel (5*2,3*2)</span>
  <a class="code" href="namespaceDGtal_1_1Z2i.html#a3013e647aa4b87b40c1554ed6234f9e6">Cell</a> ptup2 = K.uTranslation( ptup1, Point::diagonal() ); <span class="comment">// pointel (6*2,4*2)</span>
  <a class="code" href="namespaceDGtal_1_1Z2i.html#a3013e647aa4b87b40c1554ed6234f9e6">Cell</a> linelb = K.uCell( Point( 1, 0 ) ); <span class="comment">// linel (1,0) bottom</span>
  <a class="code" href="namespaceDGtal_1_1Z2i.html#a3013e647aa4b87b40c1554ed6234f9e6">Cell</a> linelt = K.uCell( Point( 1, 2 ) ); <span class="comment">// linel (1,2) top</span>
  <a class="code" href="namespaceDGtal_1_1Z2i.html#a3013e647aa4b87b40c1554ed6234f9e6">Cell</a> linell = K.uCell( Point( 0, 1 ) ); <span class="comment">// linel (0,1) left</span>
  <a class="code" href="namespaceDGtal_1_1Z2i.html#a3013e647aa4b87b40c1554ed6234f9e6">Cell</a> linelr = K.uCell( Point( 2, 1 ) ); <span class="comment">// linel (2,1) right</span>
</pre></div><div align="center">
<img src="ctopo-1.png" alt="ctopo-1.png"/>
<p><strong>Displaying some cells in different colors.</strong></p></div>
 <p>The file <a href="ctopo-1-3d_8cpp-example.html">ctopo-1-3d.cpp</a> shows another example in 3D:</p>
<div class="fragment"><pre class="fragment">  KSpace K;
  Point plow(0,0,0);  
  Point pup(3,3,2);
  ...
  <a class="code" href="namespaceDGtal_1_1Z2i.html#a3013e647aa4b87b40c1554ed6234f9e6">Cell</a> ptlow = K.uPointel( plow ); <span class="comment">// pointel (0*2,0*2, 0*2)</span>
  <a class="code" href="namespaceDGtal_1_1Z2i.html#a3013e647aa4b87b40c1554ed6234f9e6">Cell</a> ptup1 = K.uPointel( pup ); <span class="comment">// pointel (3*2,3*2, 2*2)</span>
  <a class="code" href="namespaceDGtal_1_1Z2i.html#a3013e647aa4b87b40c1554ed6234f9e6">Cell</a> ptup2 = K.uTranslation( ptup1, Point::diagonal() ); <span class="comment">// pointel (4*2, 4*2, 3*2)</span>

  viewer &lt;&lt; ptlow &lt;&lt; ptup1 &lt;&lt; ptup2; 
  <a class="code" href="namespaceDGtal_1_1Z2i.html#a3013e647aa4b87b40c1554ed6234f9e6">Cell</a> linel0 = K.uCell( Point( 1, 0, 2 ) ); <span class="comment">// linel (2, 0, 2)</span>
  viewer &lt;&lt; linel0; <span class="comment">// ...</span>
  <a class="code" href="namespaceDGtal_1_1Z2i.html#a3013e647aa4b87b40c1554ed6234f9e6">Cell</a> surfelA = K.uCell( Point( 2, 1, 3 ) ); <span class="comment">// surfel (2,1,3)</span>
  viewer &lt;&lt; surfelA; <span class="comment">//...</span>
  <a class="code" href="namespaceDGtal_1_1Z2i.html#a3013e647aa4b87b40c1554ed6234f9e6">Cell</a> vox1 = K.uCell( Point( 3, 3, 3 ) ); <span class="comment">// voxel (3,3,3)</span>
  viewer &lt;&lt; vox1;
</pre></div><div align="center">
<img src="ctopo-1-3d.png" alt="ctopo-1-3d.png"/>
<p><strong>Displaying some cells in different colors.</strong></p></div>
 <h3><a class="anchor" id="dgtal_ctopo_sec1_6"></a>
Cells may be unsigned or signed</h3>
<p>Up to now, we have only consider unsigned cells (type Cell). However it is often convenient to assign a sign (POS or NEG) to a cell, a kind of orientation. The sign is especially useful to define boundary operators and digital surfaces. It is also used in algebraic topological models of cubical complexes, for instance to define chains (formal sums of cells).</p>
<p>Signed cells have type SCell. They are created using methods <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a1223cf533c27e6670e4c3455f27fdac1">KhalimskySpaceND::sCell</a> for arbitrary cells, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a7e96bae62af1a14ff0d06126351694ae">KhalimskySpaceND::sSpel</a> for n-dimensional cells, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#aa0ff427be9e99b6b7fe12687c788bfdb">KhalimskySpaceND::sPointel</a> for 0-dimensional cells. The user gives the sign at creation, either K.POS or K.NEG if K is the space.</p>
<p>You may use methods <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a54c6096b1edfe75de6c5d746fb592d50">KhalimskySpaceND::sSign</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#afb9765a9e4386cc599824f8356a61cce">KhalimskySpaceND::sSetSign</a> <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#afbe88ffc6984bc3dcdc927e01970e67a">KhalimskySpaceND::signs</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#afeb509567bc8f9cf144b2192893122b8">KhalimskySpaceND::unsigns</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a86c0e1e388c8c5965f4d862ee62e2aed">KhalimskySpaceND::sOpp</a>, respectively to get the sign of a signed cell, to change the sign of a signed cell, to sign an unsigned cell, to unsign a signed cell, and to compute the cell with opposite sign.</p>
<p>All methods concerning unsigned cells are prefixed by <code>u</code>, all methods concerning signed cells are prefixed by <code>s</code>.</p>
<p>Note that the sign of the signed and unsigned are well taked into account in the display with  <a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a> .</p>
<center> <div align="center">
<img src="ctopo-1b-3d.png" alt="ctopo-1b-3d.png"/>
<p><strong>Visualisation of unsigned Cell</strong></p></div>
  <div align="center">
<img src="ctopo-1s-3d.png" alt="ctopo-1s-3d.png"/>
<p><strong>Visualisation of signed Cell</strong></p></div>
  </center><h3><a class="anchor" id="dgtal_ctopo_sec1_7"></a>
Accessing and modifying cell coordinates.</h3>
<p>Since one does not necessarily know which model of CCellularGridSpaceND you may be using, you cannot access the cell coordinates directly. Therefore a model of CCellularGridSpaceND provides a set of methods to access and modify cell coordinates and topology. Here a few of them (with the model example <a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex...">KhalimskySpaceND</a>)</p>
<ul>
<li>Read accessors to coordinate(s)<ul>
<li><a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a001b7b05ee1817e77da45a6b414036fa">KhalimskySpaceND::uKCoord</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae1fb74b3d118d4fe8a73e2403555cf96">KhalimskySpaceND::sKCoord</a> (read Khalimsky coordinate)</li>
<li><a class="el" href="classDGtal_1_1KhalimskySpaceND.html#acae38f62d4e607176ce34138d0a792c9">KhalimskySpaceND::uCoord</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ab56a7904ee4c1192052c507c2d811379">KhalimskySpaceND::sCoord</a> (read digital coordinate)</li>
<li><a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a590277e6a16eef3aec269401a6f9d5fa">KhalimskySpaceND::uKCoords</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#aa4c3df21b31c40827b62a1baaebcf857">KhalimskySpaceND::sKCoords</a> (read Khalimsky coordinates)</li>
<li><a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae703e3f5da68aad8e4b9e0df60cd2126">KhalimskySpaceND::uCoords</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#af5e51115159abc3106c402e68b26128b">KhalimskySpaceND::sCoords</a> (read digital coordinates)</li>
</ul>
</li>
<li>Write accessors to coordinate(s)<ul>
<li><a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a66dacf50f409d7d05547cf54f50f4709">KhalimskySpaceND::uSetKCoord</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a423e59e5c25a221c29a6b6d77f6ed589">KhalimskySpaceND::sSetKCoord</a> (write Khalimsky coordinate)</li>
<li><a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a8a50eda6410503a0c31d7f918f464759">KhalimskySpaceND::uSetCoord</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a163b5e3a27adb2445f80dc8a1813e75d">KhalimskySpaceND::sSetCoord</a> (write digital coordinate)</li>
<li><a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ad9e8fd86c485107918908f95a3886448">KhalimskySpaceND::uSetKCoords</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae622350e3cd33ff6241bec0dee480721">KhalimskySpaceND::sSetKCoords</a> (write Khalimsky coordinates)</li>
<li><a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a76fb0b8ab89bacff5113599ec3851493">KhalimskySpaceND::uSetCoords</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a695ad71f24bf5e9aaa1069d66916574f">KhalimskySpaceND::sSetCoords</a> (write digital coordinates)</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="dgtal_ctopo_sec1_8"></a>
Moving within the cellular grid space</h3>
<p>Note that you dispose also of a whole set of methods to determine cells according to different geometric queries. The following methods do not change the topology of the input cell only the coordiantes. Again the prefix <code>u</code> is related to method taking as input unsigned cells while the prefix <code>s</code> is related to signed cells:</p>
<ul>
<li>Getting the first or last cell of the space: <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a0f16991a3dfed6d188df65dc031a4de5">KhalimskySpaceND::uFirst</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a638a3d5d84d1a7c5dbf1044540d26026">KhalimskySpaceND::uLast</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a508558a8b4dbd032bbf00d10b4d348a6">KhalimskySpaceND::sFirst</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ac72f3ef2e706e359d304795fa581fabc">KhalimskySpaceND::sLast</a></li>
</ul>
<ul>
<li>Moving to the adjacent cell with one coordinate greater or one coordinate lower: <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ad9c5bbffb14d6f716e2eaa87a78f7281">KhalimskySpaceND::uGetIncr</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ad482a39e3ad8e3bf9fc1566f8b16612f">KhalimskySpaceND::uGetDecr</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a5c588209032cb8f080e47b2fb1402a6f">KhalimskySpaceND::sGetIncr</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a001b20467a324de004e84f7c73c9b60a">KhalimskySpaceND::sGetDecr</a>, or moving to an arbitrary cell along some axis with <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a18a7e614f3065fc4e755735c229c7a00">KhalimskySpaceND::uGetAdd</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a5ede2674b177b0476e13d464fd75b127">KhalimskySpaceND::uGetSub</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a7e0c0f75960316a89239135b0c5404fb">KhalimskySpaceND::sGetAdd</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a3ef0b3058e2f682cf598662c5e0f5ca9">KhalimskySpaceND::sGetSub</a>.</li>
</ul>
<ul>
<li>Testing whether you are the cell with maximal or minimal coordinate along some axis with <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#af0bfa8affa5cc093ac4456fdde06b39d">KhalimskySpaceND::uIsMax</a> or <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ad9ea6898b5b8a0098ff5446a33798dd6">KhalimskySpaceND::uIsMin</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a0117478b026c3ecf76c80e6a131d798a">KhalimskySpaceND::sIsMax</a> or <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a4e484ff3a98dbe0ac0a611f6f85d1d00">KhalimskySpaceND::sIsMin</a></li>
</ul>
<ul>
<li>Getting the cell along some axis that has same coordinates as the input cell but for one which belongs the minimal or maximal accepted in this space: <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a91a1010c8cb4f67740a9ae1cb304c0ec">KhalimskySpaceND::uGetMax</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#aad292f917bdcb9feedb9bfcd59d619e4">KhalimskySpaceND::uGetMin</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ad712a78be17810a79144bf978cd81a52">KhalimskySpaceND::sGetMax</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ad52a7d33eec034b1233bd852602e5239">KhalimskySpaceND::sGetMin</a></li>
</ul>
<ul>
<li>Projet a cell along some coordinate onto the axis-aligned hyperplanes spanned by a cell with <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a8d70ab5efae988a51f29af0393e5a07d">KhalimskySpaceND::uProject</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#aee5c196ba58e4b9ddde0bf385dd8cb56">KhalimskySpaceND::uProjection</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a3d8482b853751e72521f25c31f430359">KhalimskySpaceND::sProject</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a2a52f8c460e92fafc1063e26884438ee">KhalimskySpaceND::sProjection</a></li>
</ul>
<ul>
<li>Computes the distance of the cell to the bounds of the space along some axis with <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ac36a173c1237e7030dccf99aa9c53d4e">KhalimskySpaceND::uDistanceToMax</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a6cfa3f390686cbb8451f0fceb581ecdf">KhalimskySpaceND::uDistanceToMin</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#aa013ebe89ac6a16fd228e66f3f8e28ae">KhalimskySpaceND::sDistanceToMax</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#acb5e079514cb6038579d5fa1fadf9330">KhalimskySpaceND::sDistanceToMin</a></li>
</ul>
<ul>
<li>Getting the next cell in this space such that if one starts from the first cell (with same topology) of the space and iterates this process, then all cells of the space with same topology were visited. This may be done with <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a9a74704846e251a9e18e12f96a36d690">KhalimskySpaceND::uNext</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a948cae7017a79ecbaa9467640242a3ef">KhalimskySpaceND::sNext</a>. Below is a code snippet that does a scanning of all cells of same topology between first and last cell.</li>
</ul>
<div class="fragment"><pre class="fragment">       KSpace K;
       <a class="code" href="namespaceDGtal_1_1Z2i.html#a3013e647aa4b87b40c1554ed6234f9e6">Cell</a> first, last; <span class="comment">// lower and upper bounds </span>
       <a class="code" href="namespaceDGtal_1_1Z2i.html#a3013e647aa4b87b40c1554ed6234f9e6">Cell</a> p = first;
       <span class="keywordflow">do</span> 
       { <span class="comment">// ... whatever [p] is the current cell</span>
       }
       <span class="keywordflow">while</span> ( K.uNext( p, first, last ) ); 
</pre></div><p>For instance (see. <a href="khalimskySpaceScanner_8cpp-example.html">khalimskySpaceScanner.cpp </a> ) you will obtain the default following scan:</p>
<div align="center">
<img src="khalimskySpaceScanner1.png" alt="khalimskySpaceScanner1.png"/>
<p><strong>Sequence of visited pixels in a scan of Khalimsky Space (standard scan order).</strong></p></div>
 <ul>
<li>The scan can also be done by explicitly controll the order: <div class="fragment"><pre class="fragment">   KSpace::Cell q;

   ...
   <span class="keywordflow">for</span> (q = K.uGetMaxT(q, 0); K.uIsInside(q,0); q = K.uGetDecr(q, 0))
        <span class="keywordflow">for</span> ( q = K.uGetMinT(q, 1); K.uIsInside(q,1); q = K.uGetIncr(q, 1)){
         <span class="comment">// ... whatever [q] is the current cell</span>
                
        }               
</pre></div> You will obtain the following scan:</li>
</ul>
<div align="center">
<img src="khalimskySpaceScanner2.png" alt="khalimskySpaceScanner2.png"/>
<p><strong>Sequence of visited pixels in a scan of Khalimsky Space (other scan order).</strong></p></div>
 <ul>
<li>Translating arbitrarily a cell in the space with <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a00e26ac349a1713ae774fb9cbf83fddc">KhalimskySpaceND::uTranslation</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#acec217f9664c2fc9f23683cc711c3cf4">KhalimskySpaceND::sTranslation</a>.</li>
</ul>
<h3><a class="anchor" id="dgtal_ctopo_sec1_9"></a>
Cell topology and directions</h3>
<p>As said above, the cell topology is defined by the parity of its Khalimsky coordinates. The number of coordinates where the cell is open define the dimension of the cell. A cell of maximal dimension (n) is called a <em>pixel</em> in 2D, a <em>voxel</em> in 3D, and sometimes called a <em>spel</em> or <em>xel</em> in nD. A cell of minimial dimension (0) is often called a <em>pointel</em>. n-1 cells are called <em>surfels</em> (or sometimes <em>linels</em> in 2D). Here are the methods related to the cell topology.</p>
<ul>
<li>the dimension of a cell is given by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a2330dc5dba382df89801c4e420f95fa8">KhalimskySpaceND::uDim</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a7724461b1404a6db561c49fd2c918d8a">KhalimskySpaceND::sDim</a>.</li>
</ul>
<ul>
<li>whether a cell is open or not along some axis is returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a306243a1f17fc7c93c1be8d57e77d558">KhalimskySpaceND::uIsOpen</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#aec8d78fc82b601e757aaca3d3c3de08d">KhalimskySpaceND::sIsOpen</a>.</li>
</ul>
<ul>
<li>whether a cell is a surfel or not is returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a2b26a666325e58542d9179fa48a189e6">KhalimskySpaceND::uIsSurfel</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#aaebcb89aad612c1adb6dfc794377d312">KhalimskySpaceND::sIsSurfel</a>. NB: you should use it instead of comparing the dimension of the cell with n-1, depending on the model of cellular grid space chosen.</li>
</ul>
<ul>
<li>the integer coding the topology of the cell such that the k-th bit is 1 whenever the cell is open along the k-th axis is returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#adab5baa58d76e0645b15df983af1d322">KhalimskySpaceND::uTopology</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a7218b1d15a79913765323fdaa7062652">KhalimskySpaceND::sTopology</a>.</li>
</ul>
<ul>
<li>you may iterate over all open coordinates (or all closed coordinates) of a cell with the iterator returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a929b4f7aaa63e05dd48b34001725e9c0">KhalimskySpaceND::uDirs</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a133ef989d9450848c100954c13f45a6e">KhalimskySpaceND::sDirs</a> (<a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a50fefabbe426937d449313b70b3018a6">KhalimskySpaceND::uOrthDirs</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a5090c62eee1d210794fabd73243a9557">KhalimskySpaceND::sOrthDirs</a> for closed coordinates), such as in this snippet:</li>
</ul>
<div class="fragment"><pre class="fragment">     KSpace::Cell p;
     ...
     <span class="keywordflow">for</span> ( KnSpace::DirIterator q = ks.uDirs( p ); q != 0; ++q ) 
     { 
        KSpace::Dimension dir = *q;
        ...
     } 
</pre></div><h3><a class="anchor" id="dgtal_ctopo_sec1_10"></a>
Cell adjacency and neighborhood</h3>
<p>You may obtain the cells of same topology which are (face-)adjacent to a given cell with the following methods:</p>
<ul>
<li>the neighborhood of a given cell within the space are given by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a9f94c85f58807a4aa508a964e6f11737">KhalimskySpaceND::uNeighborhood</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#af699c6fa77c4bfecfecc66fa49539784">KhalimskySpaceND::sNeighborhood</a>, while the proper neighborhood is returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a389e3a9806106af457d0ae765646dbc9">KhalimskySpaceND::uProperNeighborhood</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a4420ae8d3d9972c89f6acf57127cf247">KhalimskySpaceND::sProperNeighborhood</a>.</li>
</ul>
<ul>
<li>the cell that is adjacent forward or backward along some given axis is returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a18f3719c4d7d523726156f47b3a0fbcb">KhalimskySpaceND::uAdjacent</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a6d4515295f6b0dd4d31f13a063af70b5">KhalimskySpaceND::sAdjacent</a>.</li>
</ul>
<h3><a class="anchor" id="dgtal_ctopo_sec1_11"></a>
Cell incidence</h3>
<p>Cells incident to some cell touch the cell but do not have the same dimension. Cells lower incident to a cell have lower dimensions, cells upper incident to a cell have higher dimensions. Specific rules determine the sign of incident cells to a signed cell:</p>
<ol type="1">
<li>A first rule is that along some axis, the forward and the backward incident cell have opposite sign.</li>
</ol>
<ol type="1">
<li>A second rule is that the rules are invariant by translation of cells.</li>
</ol>
<ol type="1">
<li>A third rule is that changing the sign of the cell changes the sign of all incident cells.</li>
</ol>
<ol type="1">
<li>A last rule is that taking an incident cell along some axis k then taking an incident cell along some other axis l will give a cell that has the opposite sign as if the incidence was taken before along l and after along k.</li>
</ol>
<p>These rules together allow the definition of (co)boundary operators, which are homomorphisms between chains of cells. They have the property that applied twice they give the null chain. Otherwise said, the boundary of a set of cells has an empty boundary.</p>
<ul>
<li>The cell incident to some given cell along some axis and in forward or backward direction is returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a3b0b9af32eb5003d657f5a9ba90cec4c">KhalimskySpaceND::uIncident</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a085e79ad476f836d879ff366d9dbe966">KhalimskySpaceND::sIncident</a>.</li>
</ul>
<div class="fragment"><pre class="fragment">     <a class="code" href="namespaceDGtal_1_1Z2i.html#ada8961626acc7fab62a96bf22bc74281">SCell</a> pix = K.sSpel( Point( 0,0 ), K.POS ); <span class="comment">// pixel (0+1,0+1)</span>
     <a class="code" href="namespaceDGtal_1_1Z2i.html#ada8961626acc7fab62a96bf22bc74281">SCell</a> leftl = K.sIncident( pix, 0, <span class="keyword">false</span> ); <span class="comment">// linel (0,0+1)</span>
     <a class="code" href="namespaceDGtal_1_1Z2i.html#ada8961626acc7fab62a96bf22bc74281">SCell</a> rightl = K.sIncident( pix, 0, <span class="keyword">true</span> ); <span class="comment">// linel (2,0+1)</span>
     <a class="code" href="namespaceDGtal_1_1Z2i.html#ada8961626acc7fab62a96bf22bc74281">SCell</a> downl = K.sIncident( pix, 1, <span class="keyword">false</span> ); <span class="comment">// linel (0+1,0)</span>
     <a class="code" href="namespaceDGtal_1_1Z2i.html#ada8961626acc7fab62a96bf22bc74281">SCell</a> upl = K.sIncident( pix, 1, <span class="keyword">true</span> );    <span class="comment">// linel (0+1,2)</span>
     <a class="code" href="namespaceDGtal_1_1Z2i.html#ada8961626acc7fab62a96bf22bc74281">SCell</a> ptld = K.sIncident( leftl, 1, <span class="keyword">false</span> );<span class="comment">// pointel (0,0)</span>
     <a class="code" href="namespaceDGtal_1_1Z2i.html#ada8961626acc7fab62a96bf22bc74281">SCell</a> ptdl = K.sIncident( downl, 0, <span class="keyword">false</span> );<span class="comment">// pointel (0,0)</span>
     <span class="comment">// ptld and ptdl have opposite signs.</span>
</pre></div><ul>
<li>The set of cells low incident to a given cell (i.e. just 1 dimension less) is returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ac429cdca60c5b853c9fc4a50116619ce">KhalimskySpaceND::uLowerIncident</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a63dae1ad6c18b8111abad30e1588ade5">KhalimskySpaceND::sLowerIncident</a>.</li>
</ul>
<ul>
<li>The set of cells up incident to a given cell (i.e. just 1 dimension more) is returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#aeae345c5ff7b1376b53ba6f4caf15077">KhalimskySpaceND::uUpperIncident</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a69c35e0c27cdbdf4e83a77f357349a29">KhalimskySpaceND::sUpperIncident</a>.</li>
</ul>
<ul>
<li>The proper faces of an unsigned cell are returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a91cfff3ce98d13a546dfc4f195fb7812">KhalimskySpaceND::uFaces</a>.</li>
</ul>
<ul>
<li>The proper cofaces of an unsigned cell are returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ab7e019d99972c3058797fe783ef5faf4">KhalimskySpaceND::uCoFaces</a>.</li>
</ul>
<ul>
<li>One of the two cells that are incident to some signed cells along some axis has a positive sign. The orientation (forward or backward) is called the <em>direct</em> orientation. It is returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#aac64aaa55d118a6c8beec0b0cfcdb5b1">KhalimskySpaceND::sDirect</a>. It is worth to note that the following assertion is always true:</li>
</ul>
<div class="fragment"><pre class="fragment">     <span class="comment">// c is a signed cell, k a direction</span>
     ASSERT( K.sSign( K.sIncident( c, k, K.sDirect( c, k ) ) ) == K.POS );
</pre></div><ul>
<li>You may obtain straightforwardly the positive incident cell along some axis with <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a3866fdb4505dded79a0eb085db2690f6">KhalimskySpaceND::sDirectIncident</a> and the negative incident cell along some axis with <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ade5051d2db70b9e44bfe700a7c442070">KhalimskySpaceND::sIndirectIncident</a>.</li>
</ul>
<h2><a class="anchor" id="dgtal_ctopo_sec2"></a>
Surfel adjacency and digital surfaces</h2>
<p>The preceding definitions of signed cells and their incidence will help us to define consistently what is a digital surface and how to move over it.</p>
<h3><a class="anchor" id="dgtal_ctopo_sec2_1"></a>
Tracking Boundary</h3>
<h3><a class="anchor" id="dgtal_ctopo_sec2_2"></a>
Tracking 2D Boundary</h3>
<p>The surfaces classes offers the possibility to extract an open or closed contour as a sequence of surfels obtained from a DigitalSet and a starting surfel. The full code of this example is available in file <a href="ctopo-2_8cpp-example.html">ctopo-2.cpp </a>.</p>
<p>The first step to extract the surfel boudary of a 2D digital set is to obtain an initial boundary surfel: </p>
<div class="fragment"><pre class="fragment">      aCell = <a class="code" href="classDGtal_1_1Surfaces.html#ae3713d71a17ff1de88a33ff19b6c53d4">Surfaces&lt;Z2i::KSpace&gt;::findABel</a>(ks, set2d);       
</pre></div><p>The first surfel can also be displayed in red with <a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (wi...">Board2D</a>: </p>
<div class="fragment"><pre class="fragment">       Board2D board;
       board &lt;&lt; image.domain() &lt;&lt; set2d; <span class="comment">// display domain and set</span>
       board &lt;&lt; CustomStyle( aCell.styleName(), <span class="keyword">new</span> CustomColors(  Board2D::Color( 255, 0, 0 ),
                                                                   Board2D::Color( 192, 0, 0 ) ));
       board &lt;&lt; aCell;
</pre></div><div align="center">
<img src="ctopo2a.png" alt="ctopo2a.png"/>
<p><strong>Start surfel before a tracking (in red).</strong></p></div>
 <p>Then you can extract the sequence of consecutive surfels: </p>
<div class="fragment"><pre class="fragment">     std::vector&lt;Z2i::SCell&gt; vectBdrySCell;
     SurfelAdjacency&lt;2&gt; SAdj( <span class="keyword">true</span> );
     <a class="code" href="classDGtal_1_1Surfaces.html#a7d39d7e0346cb40b279d54a78f90d662">Surfaces&lt;Z2i::KSpace&gt;::track2DBoundary</a>( vectBdrySCell,
                                             ks, SAdj, set2d, aCell );
</pre></div><p> and display it: </p>
<div class="fragment"><pre class="fragment">     GradientColorMap&lt;int&gt; cmap_grad( 0, vectBdrySCell.size() );
     cmap_grad.addColor( Board2D::Color( 50, 50, 255 ) );
     cmap_grad.addColor( Board2D::Color( 255, 0, 0 ) );
     cmap_grad.addColor( Board2D::Color( 255, 255, 10 ) );
   
     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0;
     std::vector&lt;Z2i::SCell&gt;::iterator it;
     <span class="keywordflow">for</span> ( it=vectBdrySCell.begin() ; it != vectBdrySCell.end(); it++ ){
          board&lt;&lt; CustomStyle((*it).styleName() ,
                              <span class="keyword">new</span> CustomColors( Board2D::Color::Black,
                                                cmap_grad( d )))&lt;&lt; *it;
          d++;
    }
</pre></div><p> You will obtain the following ordered sequence of surfels:</p>
<div align="center">
<img src="ctopo2b.png" alt="ctopo2b.png"/>
<p><strong>Tracking of a closed 2D contour.</strong></p></div>
 <p>The resulting sequence of surfels does not necessary present an open contour (try for instance image "samples/circleR10modif.pgm"):</p>
<div align="center">
<img src="ctopo2c.png" alt="ctopo2c.png"/>
<p><strong>Tracking of an open 2D contour.</strong></p></div>
 <h3><a class="anchor" id="dgtal_ctopo_sec2_3"></a>
Tracking 3D Boundary</h3>
<p>With only few modifications we can apply the same extraction on 3D surfel set. The file <a href="ctopo-2-3d_8cpp-example.html">ctopo-2-3d.cpp </a> shows the same previous example adapted in 3D.</p>
<p>with the same code we can get a surfel boundary: </p>
<div class="fragment"><pre class="fragment">   <a class="code" href="namespaceDGtal_1_1Z3i.html#a96583b392d71bd493733117e3136d82b">Z3i::SCell</a> aCell = <a class="code" href="classDGtal_1_1Surfaces.html#ae3713d71a17ff1de88a33ff19b6c53d4">Surfaces&lt;Z3i::KSpace&gt;::findABel</a>(ks, set3d);
</pre></div><p>From this SCell all the surfel connected sets can be extracted: </p>
<div class="fragment"><pre class="fragment">   <span class="comment">// Extracting all boundary surfels which are connected to the initial boundary Cell.</span>
   <a class="code" href="classDGtal_1_1Surfaces.html#af59cc573fa6a5bb91ccd3ad36d0cc020">Surfaces&lt;Z3i::KSpace&gt;::trackBoundary</a>( vectBdrySCellALL,
                                         ks,SAdj, set3d, aCell );
</pre></div><p>To see both initial surfel and the surfel set, we can use the transparent mode:</p>
<div class="fragment"><pre class="fragment">   viewer &lt;&lt; SetMode3D((*(vectBdrySCellALL.begin())).styleName(), <span class="stringliteral">&quot;Transparent&quot;</span>);
</pre></div><p>To avoid surfel superposition we need to increase with a small shift the surfel size, for this purpose you can add the following key: </p>
<div class="fragment"><pre class="fragment">   viewer &lt;&lt; <a class="code" href="classDGtal_1_1Display3D.html#a96b45e0a0c762c14c0e5e27045d1ca04a4db609bbe1edad3885d830ca83394bda">Viewer3D::shiftSurfelVisu</a>; 
</pre></div><p> or use the special mode "Highlighted" which increase automaticly the surfel size.</p>
<p>You can obtain for instance the following visualisation:</p>
<div align="center">
<img src="ctopo3dSurfel.png" alt="ctopo3dSurfel.png"/>
<p><strong>Tracking surfaces in 3D (start surfel in green).</strong></p></div>
 <p>Since in 3D there are several choice for the direction used to exctract surfel boundary, we can specify the constant direction need to drive the surfel extraction:</p>
<div class="fragment"><pre class="fragment">   <span class="comment">// Extract the boundary contour associated to the initial surfel in its first direction</span>
    <a class="code" href="classDGtal_1_1Surfaces.html#a7d39d7e0346cb40b279d54a78f90d662">Surfaces&lt;Z3i::KSpace&gt;::track2DBoundary</a>( vectBdrySCell,
                                            ks, *(ks.sDirs( aCell )),SAdj, set3d, aCell );
</pre></div><p>After extracting the two surfels cut you may obtain the following visualisation:</p>
<div align="center">
<img src="ctopo3dSurfelCut.png" alt="ctopo3dSurfelCut.png"/>
<p><strong>Tracking surfaces and slices in 3D (start surfel in green).</strong></p></div>
 <h3><a class="anchor" id="dgtal_ctopo_sec2_4"></a>
Extracting SCell connected boundary surfels</h3>
<p>The class <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> shows other usefull function to extract connected boundary surfels from a digital set and given a surfel adjacency definition. The example <a href="3dKSSurfaceExtraction_8cpp-example.html">3dKSSurfaceExtraction.cpp </a> shows an example of such an extraction.</p>
<p>From a domain we construct a DigitalSet inserting points under given conditions (see. <a href="3dKSSurfaceExtraction_8cpp-example.html">3dKSSurfaceExtraction.cpp </a> for more details)</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;DGtal/helpers/Surfaces.h&quot;</span>
<span class="preprocessor">#include &quot;DGtal/topology/KhalimskySpaceND.h&quot;</span>
...
Domain domain( p1, p2);
<a class="code" href="namespaceDGtal_1_1Z2i.html#a371252c324e496cf8650757c1a2b4eb0">DigitalSet</a> diamond_set( domain );
...
  diamond_set.insertNew( *it );
....
</pre></div><p>With this domain bounding points (p1, p2), a KhalimskySpace is constructed and a <a class="el" href="classDGtal_1_1SurfelAdjacency.html" title="Aim: Represent adjacencies between surfel elements, telling if it follows an interior to exterior ord...">SurfelAdjacency</a> definition is introduced.</p>
<div class="fragment"><pre class="fragment"> KSpace K;
 K.init(p1, p2, <span class="keyword">true</span>);
 SurfelAdjacency&lt;3&gt; SAdj( <span class="keyword">true</span> );
</pre></div><p>Then we can extract all connected surfels from the digitalSet surface :</p>
<div class="fragment"><pre class="fragment">  SetPredicate&lt;DigitalSet&gt; shape_set_predicate( diamond_set );
  <a class="code" href="classDGtal_1_1Surfaces.html#a5319797bafe542d55f080a28db7badee">Surfaces&lt;KSpace&gt;::extractAllConnectedSCell</a>(vectConnectedSCell,K, SAdj, shape_set_predicate);
</pre></div><p>After processing a simple display of each resulting connecting component you can obtain such a visualisation:</p>
<center> <div align="center">
<img src="KSurfelsConnectedOrientExt.png" alt="KSurfelsConnectedOrientExt.png"/>
<p><strong>Visualisation of connected set of SignefKhalimskySpaceND</strong></p></div>
 </center><p>Here since the last argument is set to true, the resulting SignedKhalimskySpaceND are signed in order to indicate the direction of exterior. You can also get the SignefKhalimskySpaceND with default sign:</p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classDGtal_1_1Surfaces.html#a5319797bafe542d55f080a28db7badee">Surfaces&lt;KSpace&gt;::extractAllConnectedSCell</a>(vectConnectedSCell,K, SAdj, shape_set_predicate, <span class="keyword">false</span>);
</pre></div><p>and you will get the resulting cell display:</p>
<center> <div align="center">
<img src="KSurfelsConnectedDefaultOrient.png" alt="KSurfelsConnectedDefaultOrient.png"/>
<p><strong>Visualisation of connected set of SignefKhalimskySpaceND</strong></p></div>
 </center> </div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Tue Sep 27 2011 10:27:08 for DGtal by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
