<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Tutorial: Surface area estimation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;2.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('tutoAreaSurface.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial: Surface area estimation </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Jeremy Levallois</dd></dl>
<p>The objective of this tutorial is to perform some elementary surface analysis of 3D objects. With this tutorial, you will experiment the following <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> features</p>
<ul>
<li>Build a 3D shape (parametric)</li>
<li>Convert it to a Digital <a class="el" href="testAstroid2D_8cpp.html#a71f4199b023fa1f3b1d8a36a946e7759">Shape</a> (<a class="el" href="classDGtal_1_1GaussDigitizer.html" title="Aim: A class for computing the Gauss digitization of some Euclidean shape, i.e. its intersection with...">GaussDigitizer</a>)</li>
<li>Extract Digital border of a digital shape (<a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">LightImplicitDigitalSurface</a> / <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>)</li>
<li>Use an differential quantity estimator (<a class="el" href="classDGtal_1_1IntegralInvariantCovarianceEstimator.html" title="Aim: This class implement an Integral Invariant estimator which computes for each surfel the covarian...">IntegralInvariantCovarianceEstimator</a> + a functor)</li>
</ul>
<p>Please use the following template file for this tutorial: <a class="el" href="AreaSurfaceEstimation-template_8cpp_source.html">AreaSurfaceEstimation-template.cpp</a></p>
<h1 class="doxsection"><a class="anchor" id="tutosectIntroAreaSurface"></a>
Introduction</h1>
<p>When analyzing 3D border of a shape, the surface area plays an important role for shape description. <a class="el" href="structA.html">A</a> way to estimate the area of a surface is to compute the difference between the normal of the shape and the normal of the digital point. Given a shape  \(\mathcal{X}\), the surface area function can be estimated with :   </p><p class="formulaDsp">
\[ \hat{AreaSurface (X)} = \sum_x ( \textbf{n_e}(x) . \textbf{n_s}(\hat{x}) )
\]
</p>
<p> where \( \textbf{n_e}(x) \) denotes the normal vector estimated at position \( x \in \mathcal{X} \), \( \textbf{n_s}(\hat{x}) \) the normal vector of surface element (surfel) \( \hat{x}  \in Dig_h{\mathcal{X}} \), and \( . \) the dot product.</p>
<h1 class="doxsection"><a class="anchor" id="AS_tutosectLoadVol"></a>
Import volumetric image an visualization</h1>
<p>Let start with shape construction. First of all, create a source file with the following includes (or copy the <a class="el" href="AreaSurfaceEstimation-template_8cpp_source.html">AreaSurfaceEstimation-template.cpp</a> source file):</p>
<div class="fragment"><div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/shapes/GaussDigitizer.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/topology/LightImplicitDigitalSurface.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/topology/DigitalSurface.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/graph/DepthFirstVisitor.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/graph/GraphVisitorRange.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/surfaces/estimation/IIGeometricFunctors.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/surfaces/estimation/IntegralInvariantCovarianceEstimator.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceDGtal.html">DGtal</a>;</div>
</div><!-- fragment --><ol type="1">
<li>Define a type (<em>typedef</em>) for the shape you want to use (<a class="el" href="classDGtal_1_1Ball3D.html" title="Aim: Model of the concept StarShaped3D represents any Sphere in the space.">Ball3D</a>, <a class="el" href="classDGtal_1_1ImplicitBall.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create a ball in nD....">ImplicitBall</a>, ....)</li>
<li>Use the <a class="el" href="classDGtal_1_1GaussDigitizer.html" title="Aim: A class for computing the Gauss digitization of some Euclidean shape, i.e. its intersection with...">GaussDigitizer</a> to convert the Euclidean shape to a digital one, with a given gridstep \( h \).</li>
</ol>
<p>Once you have created the digital shape, you need to get the domain and create a KhalimskySpace (see <a class="el" href="namespaceDGtal_1_1Z3i.html#a4c1b0b50dafb838783bc2347a840147d">Z3i::KSpace</a>) from it.</p>
<p>At this point, you have a digital object created from an Euclidean one. Now, we want to extract the border of this digital object.</p>
<h1 class="doxsection"><a class="anchor" id="tutosecBorder"></a>
Border extraction</h1>
<ol type="1">
<li>First of all, have a look to the LightDigitalSurface and <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a> class and check the template type you have to specified to this class to create an instance.</li>
<li>As you may have seen, we need a visitor to iterate over the border of the digital <a class="el" href="exampleMaximalSegmentSliceEstimation_8cpp.html#a86f9b721e4e72a3388a69cb2ed596f8f">Surface</a>. In order to use the best part of the following estimator, we will use a depth first visitor (see <a class="el" href="classDGtal_1_1DepthFirstVisitor.html" title="Aim: This class is useful to perform a depth-first exploration of a graph given a starting point or s...">DepthFirstVisitor</a> and <a class="el" href="classDGtal_1_1GraphVisitorRange.html" title="Aim: Transforms a graph visitor into a single pass input range.">GraphVisitorRange</a>).</li>
<li>Thanks to the GraphVisitor, we can iterate over the digital surface.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="tutosecEstimation"></a>
Normal estimation</h1>
<p>As discussed in the introduction, we will use a normal vector estimator to compute the surface area of our object. We will use IntegralInvarianceCovarianceEstimator (II) who, with the good functor (can be found in IIGeometricFunctors namespace/file ). <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> offers also some other normal vector estimators, so feel free to use wich one you want.</p>
<p>The main idea is to choose the functor you want (IIGeometricFunctors::IINormalDirectionFunctor on this case) and use the II estimator on all the digital surface:</p>
<ul>
<li>Initialize the functor</li>
<li>Initialize the covariance estimator ( constructor(functor), attach(), setParams(), <a class="el" href="testCubicalComplex_8cpp.html#a2ab29adfd8ee31956627f4230b96a34b">init()</a> )</li>
<li>Evaluate the estimator on all surfel of the border of the shape</li>
<li>Compute for all surfel the dot product of the estimated euclidean normal vector (result of the estimator) and the surfel normal vector (see below)</li>
</ul>
<p>To extract the surfel normal vector, we need to use some method from the <a class="el" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a> (see <a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex,...">KhalimskySpaceND</a> for all methods avalaible):</p>
<ul>
<li>sOrthDir( surfel ) returns the orthogonal direction of a surfel.</li>
<li>sDirectIncident( surfel, orthDir ) returns the direct incident surfel of a given surfel and a direction</li>
<li>sKCoords( surfel ) returns a vector of coordinates (of KhalimskySpace)</li>
</ul>
<ol type="1">
<li>Is the surface area estimation multigrid convergent ? As you can see at the begining of the file, we set the gridstep \( h \) to</li>
</ol>
<ol type="1">
<li>If you change this value \( h \le 1 \), how the estimation of the surface area changes ?</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="areaSurfaceCCL"></a>
Conclusion</h1>
<p>You can check <a class="el" href="AreaSurfaceEstimation-final_8cpp_source.html">AreaSurfaceEstimation-final.cpp</a> to get some answers to the above mentioned questions.</p>
<p>Several optimizations can be developed. For example, instead of evaluate for all surface element separately, we can estimate all surfels in one call of eval(). This uses some optimization of II estimator and can be see in overall computation time. Some others normal vector estimators can be used, as VoronoiCovarianceMeasureLocalEstimator. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="index.html">DGtal - Digital Geometry Tools and Algorithms Library.</a></li><li class="navelem"><a href="packageTutorials.html">Tutorials</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for DGtal by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
