<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Digital topology and digital objects</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;2.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('moduleDigitalTopology.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Digital topology and digital objects </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Jacques-Olivier Lachaud and Bertrand Kerautret.</dd></dl>
<p>Part of the <a class="el" href="packageTopology.html">Topology package</a>.</p>
<p>This part of the manual describes how to define digital objects. Subset of a digital sets are not really objects as long as they do not have some adjacency relation which describes how points (pixels in 2D, voxels in 3D, <em>spels</em> in nD) are connected. Digital topology was introduced by Rosenfeld as a framework to describe consistently how objects are connected and how complements of objects are connected. It has lead him to define two different adjacencies relations, one for the foreground (object), one for the background (complement of object). For well chosen adjacency relations, we find again some classical results of topology in continuous domains. For instance, the Jordan property may hold for several couples of adjacencies.</p>
<p>The topology kernel of <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> allows to define adjacencies, topologies, objects, and operations with objects in a very generic framework. Some of these operations have been specialized for standard spaces and topologies, in order to keep operations as fast as possible.</p>
<p>Once a topology (class <a class="el" href="classDGtal_1_1DigitalTopology.html">DigitalTopology</a>) has been defined from two adjacencies (models of <a class="el" href="structDGtal_1_1concepts_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">concepts::CAdjacency</a>), a digital object (class <a class="el" href="classDGtal_1_1Object.html">Object</a>) has a <em>border</em> which is the set of elements adjacent to its complement. The border is again a digital object. <a class="el" href="structA.html">A</a> digital object can also be seen as a graph, which can be traversed in many ways, although the breadth-first is often very useful (class <a class="el" href="classDGtal_1_1Expander.html">Expander</a>).</p>
<h1 class="doxsection"><a class="anchor" id="dgtal_topology_sec1_ajdacency"></a>
Adjacency relations</h1>
<p>An adjacency relation in a digital space <b>X</b> describes which points of the digital space are close to each other. Generally it is a reflexive and symmetric relation over the points of <b>X</b>. Interested readers can read the works of Azriel Rosenfeld and Gabor Herman to see a well-founded theory of digital spaces.</p>
<h2 class="doxsection"><a class="anchor" id="dgtal_topology_sec1_1"></a>
4- and 8- adjacencies in Z2</h2>
<p>In \( Z^2 \), two adjacencies are used. The so-called <b>4-adjacency</b> tells that a 2D point is adjacent to itself and to four other points (north, east, south, and west points). The so-called <b>8-adjacency</b> tells that a 2D point is adjacent to itself and to eight other points (the four points of the 4-adjacency relation added with four points in the diagonals). These two adjacencies relations are translation invariant, symmetric, reflexive. You can define them as follows with <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span> <a class="code hl_typedef" href="examplePlaneProbingParallelepipedEstimator_8cpp.html#ad31c3eca44cf6770809bc47f2b456212">Integer</a>;                <span class="comment">// choose your digital line here.</span></div>
<div class="line"><span class="keyword">typedef</span> SpaceND&lt;2,Integer&gt; Z2;      <span class="comment">// Z^2</span></div>
<div class="line"><span class="keyword">typedef</span> MetricAdjacency&lt;Z2,1&gt; Adj4; <span class="comment">// 4-adjacency type</span></div>
<div class="line"><span class="keyword">typedef</span> MetricAdjacency&lt;Z2,2&gt; Adj8; <span class="comment">// 8-adjacency type</span></div>
<div class="line">Adj4 adj4;                          <span class="comment">// instance of 4-adjacency</span></div>
<div class="line">Adj8 adj8;                          <span class="comment">// instance of 8-adjacency</span></div>
<div class="ttc" id="aexamplePlaneProbingParallelepipedEstimator_8cpp_html_ad31c3eca44cf6770809bc47f2b456212"><div class="ttname"><a href="examplePlaneProbingParallelepipedEstimator_8cpp.html#ad31c3eca44cf6770809bc47f2b456212">Integer</a></div><div class="ttdeci">Point::Coordinate Integer</div><div class="ttdef"><b>Definition</b> <a href="examplePlaneProbingParallelepipedEstimator_8cpp_source.html#l00044">examplePlaneProbingParallelepipedEstimator.cpp:44</a></div></div>
</div><!-- fragment --><p>You can equivalently use the types <a class="el" href="namespaceDGtal_1_1Z2i.html#a4d25eff23463be573774eff2ac86a794">Z2i::Adj4</a> and <a class="el" href="namespaceDGtal_1_1Z2i.html#aba773ccf268d50d2d75a9bc930b1b3b2">Z2i::Adj8</a>, (namespace <a class="el" href="namespaceDGtal_1_1Z2i.html" title="Z2i this namespace gathers the standard of types for 2D imagery.">Z2i</a> in "DGtal/helpers/StdDefs.h"), defined on <code><a class="el" href="classDGtal_1_1SpaceND.html">SpaceND&lt;2,int&gt;</a></code>.</p>
<p>It is well known that if you choose the 4-adjacency for an object, one should choose the 8-adjacency for the background in order to get consistent topological properties. For instance a simple 4-connected digital close curve (of more than 4 points) splits the digital space into two 8-connected background components (digital Jordan theorem). The same is true if you choose the 8-adjacency relation for the object, the 4-adjacency should be choosed for the background. This is called the <b>digital Jordan theorem</b> (Rosenfeld).</p>
<div class="image">
<img src="DiskWithAdj4.png" alt=""/>
<div class="caption">
Illustration of a Digital Object with the 4-adjacency</div></div>
<div class="image">
<img src="DiskWithAdj8.png" alt=""/>
<div class="caption">
Illustration of a Digital Object with the 8-adjacency</div></div>
<h2 class="doxsection"><a class="anchor" id="dgtal_topology_sec1_2"></a>
6-, 18- and 26- adjacencies in Z3</h2>
<p>Similarly as the 4-,8- adjacencies in 3D, the name of the 6-, 18-, 26- adjacencies defined in Z3 comes from the number of proper adjacent points for each point. Seeing a digital 3D point as a cube, the 6-neighbors are the points sharing at least a face with the cube, the 18-neighbors are the ones sharing at least an edge, while the 26-neighbors are the ones sharing at least a vertex. These three adjacencies relations are translation invariant, symmetric, reflexive. You can define them as follows with <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span> <a class="code hl_typedef" href="examplePlaneProbingParallelepipedEstimator_8cpp.html#ad31c3eca44cf6770809bc47f2b456212">Integer</a>;                 <span class="comment">// choose your digital line here.</span></div>
<div class="line"><span class="keyword">typedef</span> SpaceND&lt;3,Integer&gt; Z3;       <span class="comment">// Z^3</span></div>
<div class="line"><span class="keyword">typedef</span> MetricAdjacency&lt;Z3,1&gt; Adj6;  <span class="comment">// 6-adjacency type</span></div>
<div class="line"><span class="keyword">typedef</span> MetricAdjacency&lt;Z3,2&gt; Adj18; <span class="comment">// 18-adjacency type</span></div>
<div class="line"><span class="keyword">typedef</span> MetricAdjacency&lt;Z3,3&gt; Adj26; <span class="comment">// 26-adjacency type</span></div>
<div class="line">Adj6 adj6;                           <span class="comment">// instance of 6-adjacency</span></div>
<div class="line">Adj18 adj18;                         <span class="comment">// instance of 18-adjacency</span></div>
<div class="line">Adj26 adj26;                         <span class="comment">// instance of 26-adjacency</span></div>
</div><!-- fragment --><p>You can equivalently use the types <a class="el" href="namespaceDGtal_1_1Z3i.html#a88c46bc17937d2a2d389c663e529ea9d">Z3i::Adj6</a>, <a class="el" href="namespaceDGtal_1_1Z3i.html#a02769c25d70f4f7e85fcee03b369e55c">Z3i::Adj18</a> and <a class="el" href="namespaceDGtal_1_1Z3i.html#a44acb785a4616854c8fe13be68ed6e08">Z3i::Adj26</a>, (namespace <a class="el" href="namespaceDGtal_1_1Z3i.html" title="Z3i this namespace gathers the standard of types for 3D imagery.">Z3i</a> in "DGtal/helpers/StdDefs.h"), defined on <code><a class="el" href="classDGtal_1_1SpaceND.html">SpaceND&lt;3,int&gt;</a></code>.</p>
<h2 class="doxsection"><a class="anchor" id="dgtal_topology_sec1_3"></a>
Metric adjacencies in Zn</h2>
<p>Adjacencies based on metrics can be defined in arbitrary dimension. They all have the properties to be translation invariant, reflexive and symmetric. They include the standard 4-, 8-adjacencies in Z2 and 6-, 18-, and 26-adjacencies in Z3. Given a maximal 1-norm <code>n1</code>, two points <code>p1</code> and <code>p2</code> are adjacent if and only if \( \| p2 - p1 \|_1 \le n1 \) and  \( \| p2 - p1
   \|_\infty \le 1 \). Metric adjacencies are implemented in the template class <a class="el" href="classDGtal_1_1MetricAdjacency.html" title="Aim: Describes digital adjacencies in digital spaces that are defined with the 1-norm and the infinit...">MetricAdjacency</a>. For now, only metric adjacencies in Z2 are specialized, so as to be (slightly) optimized.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> n = ...;                   <span class="comment">// choose your dimension.</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span> <a class="code hl_typedef" href="examplePlaneProbingParallelepipedEstimator_8cpp.html#ad31c3eca44cf6770809bc47f2b456212">Integer</a>;                 <span class="comment">// choose your digital line here.</span></div>
<div class="line"><span class="keyword">typedef</span> SpaceND&lt;n,int&gt; Zn;           <span class="comment">// Z^N</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> n1 = ...;                  <span class="comment">// choose your max 1-norm here.</span></div>
<div class="line"><span class="keyword">typedef</span> MetricAdjacency&lt;Zn,n1&gt; MyAdj;<span class="comment">// your adjacency type.</span></div>
<div class="line">Myadj myAdj;                         <span class="comment">// your instance.</span></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="dgtal_topology_sec1_4"></a>
Concepts CAdjacency et CDomainAdjacency</h2>
<p>Adjacencies are used at many places as a basis for more complex operations. To keep genericity and efficiency, adjacencies should satisfy the concept <a class="el" href="structDGtal_1_1concepts_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">concepts::CAdjacency</a>. They are specialized only at instanciation as argument to templates. <a class="el" href="structA.html">A</a> model of <a class="el" href="structDGtal_1_1concepts_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">concepts::CAdjacency</a> should define the following inner types:</p>
<ul>
<li><a class="el" href="structDGtal_1_1ArithmeticalDSLKernel.html">Space</a>: the space of the adjacency.</li>
<li><a class="el" href="classDGtal_1_1SpaceND.html">Point</a>: the digital point type.</li>
<li>Adjacency: the type of the adjacency itself.</li>
</ul>
<p>It should also define the following methods:</p>
<ul>
<li>isAdjacentTo</li>
<li>isProperlyAdjacentTo</li>
<li>writeNeighborhood</li>
<li>writeProperNeighborhood</li>
</ul>
<p>Methods <code>writeNeighborhood</code> and <code>writeProperNeighborhood</code> are overloaded so as to substitute their own predicate with another user-given predicate. They are useful to restrict neighborhoods.</p>
<p><a class="el" href="structA.html">A</a> <a class="el" href="structDGtal_1_1concepts_1_1CDomainAdjacency.html" title="Aim: Refines the concept CAdjacency by telling that the adjacency is specific to a given domain of th...">concepts::CDomainAdjacency</a> refines a <a class="el" href="structDGtal_1_1concepts_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">concepts::CAdjacency</a> by specifying a limiting domain for the adjacency. It adds the following inner types:</p>
<ul>
<li><a class="el" href="classDGtal_1_1VoronoiMap.html">Domain</a>: the type of embedding domain.</li>
<li>Predicate: the type of the predicate "is in domain ?".</li>
</ul>
<p>It should also define the following methods:</p>
<ul>
<li>domain</li>
<li>predicate</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="dgtal_topology_sec2_digital_topology"></a>
Digital topology over a digital space</h1>
<p><a class="el" href="structA.html">A</a> digital topology is a couple of adjacencies, one for the foreground, one for the background. The template class <a class="el" href="classDGtal_1_1DigitalTopology.html" title="Aim: Represents a digital topology as a couple of adjacency relations.">DigitalTopology</a> can be used to create such a couple.</p>
<p>The following lines of code creates the classical (6,18) topology over \( Z^3 \).</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> SpaceND&lt; 3,int &gt; Z3;</div>
<div class="line"><span class="keyword">typedef</span> MetricAdjacency&lt; Z3, 1 &gt; Adj6;</div>
<div class="line"><span class="keyword">typedef</span> MetricAdjacency&lt; Z3, 2 &gt; Adj18;</div>
<div class="line"><span class="keyword">typedef</span> DigitalTopology&lt; Adj6, Adj18 &gt; DT6_18;</div>
<div class="line"> </div>
<div class="line">Adj6 adj6;</div>
<div class="line">Adj18 adj18;</div>
<div class="line">DT6_18 dt6_18( adj6, adj18, <a class="code hl_enumvalue" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083da731ee8276af4e05e2fe322cf2a4fd179">JORDAN_DT</a> );</div>
<div class="ttc" id="anamespaceDGtal_html_a9f57dcd68d3056024eec6b4205f7083da731ee8276af4e05e2fe322cf2a4fd179"><div class="ttname"><a href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083da731ee8276af4e05e2fe322cf2a4fd179">DGtal::JORDAN_DT</a></div><div class="ttdeci">@ JORDAN_DT</div><div class="ttdef"><b>Definition</b> <a href="DigitalTopology_8h_source.html#l00057">DigitalTopology.h:57</a></div></div>
</div><!-- fragment --><p>The foreground adjacency is classically called <em> kappa </em>  \( \kappa
\) while the background is called <em>lambda</em> \( \lambda \) . Any topology has a reversed topology which is the topology  \(   (\lambda,\kappa) \).</p>
<p><a class="el" href="structA.html">A</a> topology can be a <b>Jordan</b> couple. In this case, some objects of this space have nice properties. The reader is referred to the papers of Herman or to its book <b> Geometry of digital spaces </b>.</p>
<h1 class="doxsection"><a class="anchor" id="dgtal_topology_sec3_digital_object"></a>
Digital objects</h1>
<p><a class="el" href="structA.html">A</a> digital object is a set of points together with a topology describing how points are close to each others. In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>, they are defined by the template class <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a>, parameterized by the topology (a <a class="el" href="classDGtal_1_1DigitalTopology.html" title="Aim: Represents a digital topology as a couple of adjacency relations.">DigitalTopology</a>) and a digital set of points (any model of CDigitalSet like <a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim: A container class for storing sets of digital points within some given domain.">DigitalSetBySTLSet</a> or <a class="el" href="classDGtal_1_1DigitalSetBySTLVector.html" title="Aim: Realizes the concept CDigitalSet by using the STL container std::vector.">DigitalSetBySTLVector</a>).</p>
<p>The digital object stores its own set of points with a copy-on-write smart pointer. This means that a digital object can be copied without overhead, and may for instance be passed by value or returned. The input digital set given at construction specifies the domain of the object, which remains the same for the lifetime of the object.</p>
<h2 class="doxsection"><a class="anchor" id="dgtal_topology_sec3_1"></a>
Construction of digital objects</h2>
<p><a class="el" href="structA.html">A</a> digital object is generally initialized with some given set. The type of the set can be chosen so as to leave to the user the choice of the best set container for the object. You may use the <a class="el" href="structDGtal_1_1DigitalSetSelector.html" title="Aim: Automatically defines an adequate digital set type according to the hints given by the user.">DigitalSetSelector</a> to let the compiler choose your digital set container at compilation time according to some preferences. The choice <a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim: A container class for storing sets of digital points within some given domain.">DigitalSetBySTLSet</a> is the most versatile and generally the most efficient. The choice <a class="el" href="classDGtal_1_1DigitalSetBySTLVector.html" title="Aim: Realizes the concept CDigitalSet by using the STL container std::vector.">DigitalSetBySTLVector</a> is only good for very small objects.</p>
<div class="fragment"><div class="line">...</div>
<div class="line">typedef Z3::Point <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>;</div>
<div class="line"><span class="keyword">typedef</span> HyperRectDomain&lt; Z3 &gt; <a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a>; </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_typedef" href="classDGtal_1_1HyperRectDomain.html#ad460a9309eb81ab5391a57f7d2a17055">Domain::ConstIterator</a> DomainConstIterator; </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_typedef" href="structDGtal_1_1DigitalSetSelector.html#a3fedd6ed479daf13da0649e960b1866a">DigitalSetSelector&lt; Domain, BIG_DS+HIGH_BEL_DS &gt;::Type</a> <a class="code hl_typedef" href="testVoronoiMapComplete_8cpp.html#ac14360761d68859fc57ca37aea0b5c93">DigitalSet</a>;</div>
<div class="line"><span class="keyword">typedef</span> Object&lt;DT6_18, DigitalSet&gt; ObjectType;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> p1( -50, -50, -50 );</div>
<div class="line"><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> p2( 50, 50, 50 );</div>
<div class="line"><a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>( p1, p2 );</div>
<div class="line"><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> c( 0, 0 );</div>
<div class="line"><span class="comment">// diamond of radius 30</span></div>
<div class="line"><a class="code hl_typedef" href="testVoronoiMapComplete_8cpp.html#ac14360761d68859fc57ca37aea0b5c93">DigitalSet</a> diamond_set( <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a> );</div>
<div class="line"><span class="keywordflow">for</span> ( DomainConstIterator it = <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.begin(); it != <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.end(); ++it )</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> ( (*it - c ).norm1() &lt;= 30 ) diamond_set.insertNew(  it );</div>
<div class="line">  }</div>
<div class="line">ObjectType diamond( dt6_18, diamond_set );</div>
<div class="line"><span class="comment">// The following line takes almost no time.</span></div>
<div class="line">ObjectType diamond_clone( diamond );</div>
<div class="line"><span class="comment">// Since one of the objects is modified, the set is duplicated at the following line</span></div>
<div class="line">diamond_clone.pointSet().erase( c );</div>
<div class="ttc" id="aclassDGtal_1_1HyperRectDomain_html_ad460a9309eb81ab5391a57f7d2a17055"><div class="ttname"><a href="classDGtal_1_1HyperRectDomain.html#ad460a9309eb81ab5391a57f7d2a17055">DGtal::HyperRectDomain&lt; Space &gt;::ConstIterator</a></div><div class="ttdeci">Iterator ConstIterator</div><div class="ttdef"><b>Definition</b> <a href="HyperRectDomain_8h_source.html#l00125">HyperRectDomain.h:125</a></div></div>
<div class="ttc" id="astructDGtal_1_1DigitalSetSelector_html_a3fedd6ed479daf13da0649e960b1866a"><div class="ttname"><a href="structDGtal_1_1DigitalSetSelector.html#a3fedd6ed479daf13da0649e960b1866a">DGtal::DigitalSetSelector::Type</a></div><div class="ttdeci">DigitalSetByAssociativeContainer&lt; Domain, std::unordered_set&lt; typename Domain::Point &gt; &gt; Type</div><div class="ttdef"><b>Definition</b> <a href="DigitalSetSelector_8h_source.html#l00102">DigitalSetSelector.h:102</a></div></div>
<div class="ttc" id="atestClone2_8cpp_html_a4075d279133f1952978300b7e135f83d"><div class="ttname"><a href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a></div><div class="ttdeci">MyPointD Point</div><div class="ttdef"><b>Definition</b> <a href="testClone2_8cpp_source.html#l00381">testClone2.cpp:381</a></div></div>
<div class="ttc" id="atestProjection_8cpp_html_a1f1a69f8d8b037b72c2160ed12b3ef51"><div class="ttname"><a href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a></div><div class="ttdeci">Domain domain</div><div class="ttdef"><b>Definition</b> <a href="testProjection_8cpp_source.html#l00088">testProjection.cpp:88</a></div></div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_acd532b318489cd93df57e0b3d136d050"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a></div><div class="ttdeci">HyperRectDomain&lt; Space &gt; Domain</div><div class="ttdef"><b>Definition</b> <a href="testSimpleRandomAccessRangeFromPoint_8cpp_source.html#l00044">testSimpleRandomAccessRangeFromPoint.cpp:44</a></div></div>
<div class="ttc" id="atestVoronoiMapComplete_8cpp_html_ac14360761d68859fc57ca37aea0b5c93"><div class="ttname"><a href="testVoronoiMapComplete_8cpp.html#ac14360761d68859fc57ca37aea0b5c93">DigitalSet</a></div><div class="ttdeci">Z2i::DigitalSet DigitalSet</div><div class="ttdef"><b>Definition</b> <a href="testVoronoiMapComplete_8cpp_source.html#l00040">testVoronoiMapComplete.cpp:40</a></div></div>
</div><!-- fragment --><p>Objects may also be initialized empty, so that you can easily use a container to store them. Of course, they are not valid in this case.</p>
<div class="fragment"><div class="line">ObjectType object;          <span class="comment">// valid</span></div>
<div class="line">vector&lt;ObjectType&gt; objects; <span class="comment">// valid</span></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="dgtal_topology_sec3_2"></a>
Neighborhood of a point in an object</h2>
<p>An object proposes several methods to return the neighborhood of a given point of the object.</p>
<ul>
<li><a class="el" href="classDGtal_1_1Object.html#a6a8da6bf41905a4ae6b24c93d3d0298c">Object::neighborhood</a>, <a class="el" href="classDGtal_1_1Object.html#a5dfbef899715f5f0d81e02ad63504892">Object::properNeighborhood</a>: the neighborhoods are returned as objects (with a digital set type considered small).</li>
<li><a class="el" href="classDGtal_1_1Object.html#a0027f115d49cd45c73874a260411906b">Object::neighborhoodSize</a>, <a class="el" href="classDGtal_1_1Object.html#add0dfaee5d56f74a453348b0e6394fe8">Object::properNeighborhoodSize</a>: prefer these methods if you only need the cardinal of the neighborhoods and not the neighborhoods itselves</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="dgtal_topology_sec3_3"></a>
Border of a digital object</h2>
<p>Objects have a border, which are the points which touch the complement in the sense of background adjacency. <a class="el" href="structA.html">A</a> border of an object is itself an object, with the same topology as the object.</p>
<div class="fragment"><div class="line">ObjectType bdiamond = diamond.border(); <span class="comment">// one component</span></div>
<div class="line">ObjectType bdiamond_clone = diamond_clone.border(); <span class="comment">// two components</span></div>
</div><!-- fragment --><p>The resulting border can be visualized for instance by: (see <a class="el" href="3dBorderExtraction_8cpp.html">3dBorderExtraction.cpp</a>) </p><div class="fragment"><div class="line">PolyscopeViewer&lt;&gt; viewer;</div>
<div class="line">viewer&lt;&lt;  Color(250, 250,250);</div>
<div class="line">viewer &lt;&lt; bdiamond_clone;</div>
<div class="line">viewer &lt;&lt; bdiamond ;</div>
<div class="line">viewer &lt;&lt; ClippingPlane(1,1,0,5, <span class="keyword">false</span>);</div>
<div class="line">viewer.show();</div>
</div><!-- fragment --><div class="image">
<img src="visuBorderExtraction.png" alt=""/>
<div class="caption">
Border extraction visualisation</div></div>
<p> see example <a class="el" href="3dBorderExtraction_8cpp.html">3dBorderExtraction.cpp</a></p>
<div class="image">
<img src="visuBorderExtraction2.png" alt=""/>
<div class="caption">
Border extraction visualisation from imported volume </div></div>
<p> see example: <a class="el" href="3dBorderExtractionImg_8cpp.html">3dBorderExtractionImg.cpp</a></p>
<h2 class="doxsection"><a class="anchor" id="dgtal_topology_sec3_4"></a>
Connectedness and connected components</h2>
<p>The digital topology induces a connectedness relation on the object (transitive closure of the foreground adjacency) and a connectedness relation on the complement of the set (transitive closure of the background adjacency). Objects may be connected or not. The connectedness is stored with the object, if it is known. The method <a class="el" href="classDGtal_1_1Object.html#a0667cb583604e1b138695a6e7ca816a3">Object::connectedness</a> returns CONNECTED, DISCONNECTED or UNKNOWN depending on the connectedness of this object and if it has been computed. The method <a class="el" href="classDGtal_1_1Object.html#a4aae59f1144ced95ccf25eb08cf77ea0">Object::computeConnectedness</a> forces the computation. After this process, the connectedness is either CONNECTED or DISCONNECTED.</p>
<p>Furthermore, you can use the method <a class="el" href="classDGtal_1_1Object.html#a9273515f3a3796470faa948c6a64ea37">Object::writeComponents</a> to compute all the connected components of this object. It also updates the connectedness of this object to either CONNECTED or DISCONNECTED depending on the number of connected components. Each connected component is of course CONNECTED.</p>
<p>You may use writeComponents as follows:</p>
<div class="fragment"><div class="line">std::vector&lt; ObjectType &gt; objects;</div>
<div class="line">std::back_insert_iterator&lt; std::vector&lt; ObjectType &gt; &gt; inserter( objects );</div>
<div class="line"><span class="comment">// nbc == 1 since the boundary of the diamond is connected.</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbc = bdiamond.writeComponents( inserter );</div>
<div class="line"><span class="comment">// nbd == 2 since the boundary of the diamond minus its center is disconnected.</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbd = bdiamond_clone.writeComponents( inserter );</div>
<div class="line"><span class="comment">// objects.size() == 3</span></div>
</div><!-- fragment --><p>You must be careful when using an output iterator writing in the same container as 'this' object (see <a class="el" href="classDGtal_1_1Object.html#a9273515f3a3796470faa948c6a64ea37">Object::writeComponents</a>).</p>
<h2 class="doxsection"><a class="anchor" id="dgtal_topology_sec3_5"></a>
Simple points</h2>
<p><a class="el" href="structA.html">A</a> basic mechanism for simple points is implemented in the <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> class. It relies on the well-known definition of simple points of <a class="el" href="citelist.html#CITEREF_bertrand:1994">[12]</a> , based on the number of connected components in a geodesic neighborhood of the point. It is valid in 2D and 3D. It should not be sufficient in nD, since toric connected components may appear. However, you can use it anyway as a kind of "extended" simplicity.</p>
<p>To test if a point is simple for an object, just call the method <a class="el" href="classDGtal_1_1Object.html#ae9ea876b5d762b4445e757ba7be42633">Object::isSimple</a> with the point as parameter. To illustrate this, we give the full code for the homotopic thinning of a shape in 2D and 3D.</p>
<p>The file <a class="el" href="homotopicThinning3D_8cpp.html">homotopicThinning3D.cpp</a> illustrates the homotopic thinning on a 26_6 object.</p>
<p>First a digital object (with 6_26 adjacency) is defined from a digital set representing two rings : </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span>Z3i;</div>
<div class="line">...</div>
<div class="line">Point p1( -50, -50, -50 );</div>
<div class="line"><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> p2( 50, 50, 50 );</div>
<div class="line"><a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>( p1, p2 );</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> ringCenter( 0, 0, 0 );  </div>
<div class="line"><a class="code hl_typedef" href="testVoronoiMapComplete_8cpp.html#ac14360761d68859fc57ca37aea0b5c93">DigitalSet</a> shape_set( <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a> );</div>
<div class="line"><span class="keywordflow">for</span> ( <a class="code hl_typedef" href="classDGtal_1_1HyperRectDomain.html#ad460a9309eb81ab5391a57f7d2a17055">Domain::ConstIterator</a> it = <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.begin(); it != <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.end(); ++it )</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> ( ((*it - ringCenter ).norm() &lt;= 25) &amp;&amp; ((*it - ringCenter ).norm() &gt;= 18)</div>
<div class="line">         &amp;&amp; ( (((*it)[0] &lt;= 3)&amp;&amp; ((*it)[0] &gt;= -3))|| (((*it)[1] &lt;= 3)&amp;&amp; ((*it)[1] &gt;= -3)))){</div>
<div class="line">      shape_set.insertNew( *it );</div>
<div class="line">    }</div>
<div class="line">  }  </div>
<div class="line">Object6_26 shape( dt6_26, shape_set );</div>
</div><!-- fragment --><p>Then the thinning is performed by testing if a point is simple:</p>
<div class="fragment"><div class="line"><span class="keywordflow">do</span> </div>
<div class="line">    {</div>
<div class="line">      <a class="code hl_typedef" href="testVoronoiMapComplete_8cpp.html#ac14360761d68859fc57ca37aea0b5c93">DigitalSet</a> &amp; S = shape.pointSet();</div>
<div class="line">      std::queue&lt;DigitalSet::Iterator&gt; Q;</div>
<div class="line">      <span class="keywordflow">for</span> ( <a class="code hl_typedef" href="classDGtal_1_1DigitalSetByAssociativeContainer.html#ab0d0cdd0ba4c6829d818da81590cd320">DigitalSet::Iterator</a> it = S.begin(); it != S.end(); ++it )</div>
<div class="line">        <span class="keywordflow">if</span> ( shape.isSimple( *it ) )</div>
<div class="line">          Q.push( it );</div>
<div class="line">      nb_simple = 0;</div>
<div class="line">      <span class="keywordflow">while</span> ( ! Q.empty() )</div>
<div class="line">        {</div>
<div class="line">          <a class="code hl_typedef" href="classDGtal_1_1DigitalSetByAssociativeContainer.html#ab0d0cdd0ba4c6829d818da81590cd320">DigitalSet::Iterator</a> it = Q.front();</div>
<div class="line">          Q.pop();</div>
<div class="line">          <span class="keywordflow">if</span> ( shape.isSimple( *it ) )</div>
<div class="line">            {</div>
<div class="line">              cerr &lt;&lt; <span class="stringliteral">&quot;point simple &quot;</span> &lt;&lt; (*it) &lt;&lt; endl; </div>
<div class="line">              S.erase( *it );</div>
<div class="line">              ++nb_simple;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">      ++layer;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">while</span> ( nb_simple != 0 );</div>
<div class="ttc" id="aclassDGtal_1_1DigitalSetByAssociativeContainer_html_ab0d0cdd0ba4c6829d818da81590cd320"><div class="ttname"><a href="classDGtal_1_1DigitalSetByAssociativeContainer.html#ab0d0cdd0ba4c6829d818da81590cd320">DGtal::DigitalSetByAssociativeContainer&lt; Domain, std::unordered_set&lt; typename Domain::Point &gt; &gt;::Iterator</a></div><div class="ttdeci">Container::iterator Iterator</div><div class="ttdef"><b>Definition</b> <a href="DigitalSetByAssociativeContainer_8h_source.html#l00106">DigitalSetByAssociativeContainer.h:106</a></div></div>
</div><!-- fragment --><p>Finally the result can simply be displayed using <a class="el" href="classDGtal_1_1PolyscopeViewer.html">PolyscopeViewer</a>: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="testVoronoiMapComplete_8cpp.html#ac14360761d68859fc57ca37aea0b5c93">DigitalSet</a> &amp; S = shape.pointSet();</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Transparency is handled automatically</span></div>
<div class="line"> </div>
<div class="line"> viewer.drawAsPaving();</div>
<div class="line"> viewer &lt;&lt; Color(25,25,255, 255);</div>
<div class="line"> viewer &lt;&lt; S ; </div>
<div class="line"> </div>
<div class="line"> viewer &lt;&lt; Color(250, 0,0, 5);</div>
<div class="line"> viewer &lt;&lt; shape_set;</div>
</div><!-- fragment --><p>We obtain the following result: </p><div class="image">
<img src="visuThinning.png" alt=""/>
<div class="caption">
Resulting 3d thinning with the 6_26 object</div></div>
<h1 class="doxsection"><a class="anchor" id="dgtal_topology_sec4"></a>
Neighborhood configurations, predicates and look up tables.</h1>
<p><span class="tt">Object::isSimple(input_point)</span> is an example of a predicate (ie. a function returning a Boolean value) that depends on the topology of the object and on the occupancy configuration of the <span class="tt">input_point</span> neighborhood.<br  />
 There is a limited amount of possible configuration of the neighborhood depending on the dimension of the space. In 2D, there are 2^8 different neighborhood configurations, and in 3D 2^26. The result of the predicate will vary depending on the topology of the space, but the number of occupancy configurations will be the same for any topology in that dimension.</p>
<p>The calculation of a predicate for each point is repetitive and can be computationally intensive. However thanks to the limited amount of neighborhood occupancy configurations, we can pre-compute the Boolean result of the predicate for each configuration and store it in a look up table.</p>
<p>In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>, pre-computed look up tables for different predicates and topologies are distributed with the source code, and decompressed at build/install time to be ready to use. The tables locations are stored in string variables in: "DGtal/topology/tables/NeighborhoodTables.h"</p>
<p>Different functions to work with these pre-computed tables are in the header: "DGtal/topology/NeighborhoodConfigurations.h"</p>
<p><a class="el" href="classDGtal_1_1Object.html">Object</a> is able to take advantage of this just preloading the table before calling isSimple. This speeds up a thinning process by orders of magnitude. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="testNeighborhoodConfigurations_8cpp.html">testNeighborhoodConfigurations.cpp</a></dd></dl>
<div class="fragment"><div class="line">Object26_6 object( dt26_6, point_set );</div>
<div class="line"><span class="keywordtype">object</span>.setTable(<a class="code hl_function" href="namespaceDGtal_1_1functions.html#a96aab076fc2c3bd049f041f5867be7a5">functions::loadTable&lt;3&gt;</a>(simplicity::tableSimple26_6))</div>
<div class="line"><span class="comment">// Any following call to isSimple after setTable will use the pre-computed calculations.</span></div>
<div class="line"><span class="keywordtype">object</span>.isSimple(a_point);</div>
<div class="ttc" id="anamespaceDGtal_1_1functions_html_a96aab076fc2c3bd049f041f5867be7a5"><div class="ttname"><a href="namespaceDGtal_1_1functions.html#a96aab076fc2c3bd049f041f5867be7a5">DGtal::functions::loadTable</a></div><div class="ttdeci">DGtal::CountedPtr&lt; boost::dynamic_bitset&lt;&gt; &gt; loadTable(const std::string &amp;input_filename, const unsigned int known_size, const bool compressed=true)</div></div>
</div><!-- fragment --><p>In 2D:</p>
<div class="fragment"><div class="line">Object4_8 object( dt4_8, point_set );</div>
<div class="line"><span class="keywordtype">object</span>.setTable(<a class="code hl_function" href="namespaceDGtal_1_1functions.html#a96aab076fc2c3bd049f041f5867be7a5">functions::loadTable&lt;2&gt;</a>(simplicity::tableSimple4_8))</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Be sure to choose the table with the same topology than the object. </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="index.html">DGtal - Digital Geometry Tools and Algorithms Library.</a></li><li class="navelem"><a href="packageTopology.html">Topology package</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for DGtal by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
