<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Using functions, functors and lambdas in DGtal</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;2.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('moduleFunctors.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Using functions, functors and lambdas in DGtal </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Roland Denis</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<p>Part of the <a class="el" href="packageBase.html">Base package</a>.</p>
<p>This part of the manual lists some of the available functors in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> and also describes how to use functions, functors, lambdas, or any callable objects as <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> compatible functors.</p>
<h1 class="doxsection"><a class="anchor" id="functors_of_DGtal"></a>
The functors in DGtal</h1>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceDGtal_1_1functors.html" title="functors namespace gathers all DGtal functors.">functors</a></dd></dl>
<h1 class="doxsection"><a class="anchor" id="functorholder"></a>
The FunctorHolder class</h1>
<h2 class="doxsection"><a class="anchor" id="functorholder_intro"></a>
Introduction and preliminary example</h2>
<p>Starting with C++11, we can define functions directly in a code block, just before using it, using <a href="https://en.cppreference.com/w/cpp/language/lambda"><span class="tt">lambdas</span></a>. For small and single-used functions, it may allow to write clearer code by keeping all important informations together and avoids defining the function out of context.</p>
<p>However, lambdas cannot be directly used in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> since many functors must comply with concepts that depends on its usage. These concepts may require to define some typedef and always require that the model is assignable. Since lambdas don't meet any of these constraints, it forces the coder to define a specific class.</p>
<p>Starting with <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> 1.0, <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> and its derivatives (see <a class="el" href="#functorholder_derivates">Which derivative class of FunctorHolder should I use ?</a>) are available and allow to use lambdas (and other callable object) in an easier way.</p>
<p>First, store your lambda in an holder that matches the targeted usage: </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> mickey = <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a2edeed82668eb0dd5c4a11c199794237">functors::holdPointFunctor&lt;Z2i::Point&gt;</a>(</div>
<div class="line">    [] ( <a class="code hl_typedef" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a> <span class="keyword">const</span>&amp; pt ) {</div>
<div class="line">      <span class="keywordflow">return</span></div>
<div class="line">           (pt - <a class="code hl_typedef" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(0, -5)).norm() &gt; 3</div>
<div class="line">        &amp;&amp; (    pt.<a class="code hl_function" href="classDGtal_1_1PointVector.html#a621809d6682ec859fd761f60b23ba2b7">norm</a>() &lt;= 20</div>
<div class="line">             || (pt - <a class="code hl_typedef" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(-18,21)).norm() &lt;= 10</div>
<div class="line">             || (pt - <a class="code hl_typedef" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>( 18,21)).norm() &lt;= 10</div>
<div class="line">           );</div>
<div class="line">    });</div>
</div><!-- fragment --><p> The usage of the <span class="tt">auto</span> keyword is here mandatory and the reason why is explained in <a class="el" href="#auto_holdfunctor">Why using the auto keyword ?</a>.</p>
<p>Then, use the created functor with you favorite algorithm: </p><div class="fragment"><div class="line">  <a class="code hl_typedef" href="namespaceDGtal_1_1Z2i.html#aca523bebdae58eb19385aaefffff8bc5">Z2i::Domain</a> <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>( <a class="code hl_typedef" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(-35,-25), <a class="code hl_typedef" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(35, 35) );</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using </span>DTL2 = <a class="code hl_class" href="classDGtal_1_1DistanceTransformation.html">DistanceTransformation</a>&lt;<a class="code hl_typedef" href="namespaceDGtal_1_1Z2i.html#a9b96ab8175cf9c54b1f451858ccd46a4">Z2i::Space</a>, <span class="keyword">decltype</span>(mickey), <a class="code hl_typedef" href="namespaceDGtal_1_1Z2i.html#a5334b5612687982f0154e4ee8f5dd93d">Z2i::L2Metric</a>&gt;;</div>
<div class="line"> </div>
<div class="line">  DTL2 <a class="code hl_variable" href="dgtalCalculus-geodesic_8cpp.html#a778e38aa889751afffa2dea6b803e67a">dt</a>( <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>, mickey, <a class="code hl_variable" href="namespaceDGtal_1_1Z2i.html#afa16730fe413692cdb474b45d4fff388">Z2i::l2Metric</a> );</div>
</div><!-- fragment --><p> The <span class="tt">decltype</span> specifier is used to deduce the type of the functor, see <a class="el" href="#passing_functorholder">Passing a FunctorHolder as a parameter</a>.</p>
<p>Finally, export the result: </p><div class="fragment"><div class="line">  DTL2::Value maxDT = *boost::first_max_element( <a class="code hl_variable" href="dgtalCalculus-geodesic_8cpp.html#a778e38aa889751afffa2dea6b803e67a">dt</a>.constRange().begin(), <a class="code hl_variable" href="dgtalCalculus-geodesic_8cpp.html#a778e38aa889751afffa2dea6b803e67a">dt</a>.constRange().end() );</div>
<div class="line">  <span class="keyword">using </span>HueTwice = <a class="code hl_class" href="classDGtal_1_1HueShadeColorMap.html">HueShadeColorMap&lt;DTL2::Value, 1&gt;</a>;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classDGtal_1_1Board2D.html">Board2D</a> aBoard;</div>
<div class="line">  aBoard &lt;&lt; <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>;</div>
<div class="line">  <a class="code hl_function" href="structDGtal_1_1Display2DFactory.html#a04cfb624dcf9eb08913cc30dbf13cd96">Display2DFactory::drawImage&lt;HueTwice&gt;</a>(aBoard, <a class="code hl_variable" href="dgtalCalculus-geodesic_8cpp.html#a778e38aa889751afffa2dea6b803e67a">dt</a>, 0, maxDT);</div>
<div class="line">  aBoard.<a class="code hl_function" href="classLibBoard_1_1Board.html#ac39d5033a3a95e50f8ab7772e24c56bb">saveEPS</a>(<span class="stringliteral">&quot;examplePointFunctorHolder.eps&quot;</span>);</div>
</div><!-- fragment --> <div class="image">
<img src="examplePointFunctorHolder.png" alt=""/>
<div class="caption">
Distance transformation of Mickey</div></div>
<p> It has never been so easy to calculate the distance map to Mickey!</p>
<h2 class="doxsection"><a class="anchor" id="functorholder_aim"></a>
Aim</h2>
<p>Given any type of callable object (function, functor and lambda) passed by value, reference or pointer, <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> stores it in the most appropriate way so that the returned object is a model of <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> functor concept (<a class="el" href="structDGtal_1_1concepts_1_1CUnaryFunctor.html">concepts::CUnaryFunctor</a> so far), and especially the <a class="el" href="structboost_1_1Assignable.html">boost::Assignable</a> concept.</p>
<p>More precisely, the storage mode depends on the lifetime of the given object, deduced from its passing mode:</p>
<ul>
<li>if the given object is passed by left-value reference (long lifetime), it will be stored as a reference (using <a href="https://en.cppreference.com/w/cpp/utility/functional/reference_wrapper"><span class="tt">std::reference_wrapper</span></a>).</li>
<li>otherwise (short lifetime, like right-value references), it will be moved to a dynamically allocated memory place (<a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="tt">std::shared_ptr</span></a>) so that the object lifetime matches the <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html" title="Aim: hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model.">FunctorHolder</a> lifetime.</li>
</ul>
<p>In both case, the returned object is copy/move constructible and copy/move assignable so that it can be used as a functor in all <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> library.</p>
<dl class="section warning"><dt>Warning</dt><dd>This class is not meant to be directly constructed by the user. As explained below, you should use instead the <a class="el" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a> helper that will choose the more appropriate storage type depending on the given callable object.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>It is important to not explicitly specify the given object type so that it's real lifetime can be deduced using a <a href="https://en.cppreference.com/w/cpp/language/reference#Forwarding_references">universal reference</a>. However, you can transfer ownership of the object to <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html" title="Aim: hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model.">FunctorHolder</a> by moving it using <a href="https://en.cppreference.com/w/cpp/utility/move"><span class="tt">std::move</span></a>. As a consequence, the type of the returned <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html" title="Aim: hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model.">FunctorHolder</a> cannot be guessed easily and the use of the <a href="https://en.cppreference.com/w/cpp/language/auto"><span class="tt">auto</span></a> keyword is thus mandatory.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Almost all snippets used in the following explanations come from the example file <a class="el" href="exampleFunctorHolder_8cpp.html">exampleFunctorHolder.cpp</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html" title="Aim: hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model.">FunctorHolder</a>, <a class="el" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f" title="Hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model.">holdFunctor</a></dd></dl>
<h2 class="doxsection"><a class="anchor" id="functorholder_why"></a>
Why this class ?</h2>
<p>The first motivation is to be able to use lambdas as functors in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> but the problem is that all functor's concepts inherits from <a class="el" href="structboost_1_1Assignable.html">boost::Assignable</a> and a lambda is unfortunately not assignable.</p>
<p><a class="el" href="structA.html">A</a> solution would be to rely on <a href="https://en.cppreference.com/w/cpp/utility/functional/function"><span class="tt">std::function</span></a> but this solution has two main issues:</p><ul>
<li>it refers to the callable object by using a generic pointer, like <span class="tt">double (*) (int)</span> for a function returning a <span class="tt">double</span> from an <span class="tt">int</span>. This implies that the compiler cannot inline the implementation of the callable object (since a pointer like <span class="tt">double (*) (int)</span> can point to any compatible function) and thus cannot apply some important optimizations like vectorizing the computation.</li>
<li>it uses polymorphism to hide the actual callable object type stored underneath. This implies an extra indirection when calling the underlying object.</li>
</ul>
<p>On the other hand, <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> also relies on a pointer in order to make any callable object assignable, but the pointer type is directly related to the callable object type. Therefore, even if the compiler doesn't know the address during the compilation process, since he actually know the type of the callable object, he also know its implementation and can then inline it and optimize it.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="structA.html">A</a> pointer to a function has a generic type (like <span class="tt">double (*) (int)</span>) and thus prevents the compiler to inline it (even when using <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>). To avoid this, you can wrap the function into a lambda before storing it into a <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>, like explained in the section below about <a class="el" href="#holding_a_function">Holding a function</a> .</dd></dl>
<p>For example, on a modern processor and if your functor only adds values, you can have a performance ratio of about 26.7 between using a <a href="https://en.cppreference.com/w/cpp/utility/functional/function"><span class="tt">std::function</span></a> and <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>. Even with more complex operations, there is still a significant performance penalty to use <a href="https://en.cppreference.com/w/cpp/utility/functional/function"><span class="tt">std::function</span></a> over <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>.</p>
<h2 class="doxsection"><a class="anchor" id="functorholder_derivates"></a>
Which derivative class of FunctorHolder should I use ?</h2>
<p>Depending on the concept you want to fullfil, here are the available classes that rely on <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>:</p><ul>
<li>for a <a class="el" href="structDGtal_1_1concepts_1_1CUnaryFunctor.html">concepts::CUnaryFunctor</a> model, use <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>.</li>
<li>for a <a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html">concepts::CPointFunctor</a> model, use <a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html">PointFunctorHolder</a>.</li>
<li>for a <a class="el" href="structDGtal_1_1concepts_1_1CConstImage.html">concepts::CConstImage</a> model, use <a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html">ConstImageFunctorHolder</a>.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="holding_an_object"></a>
Holding a callable object</h1>
<p>As warned before, <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> is not meant to be directly constructed but instead through the helper (factory) <a class="el" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a>. You can hold any type of callable object: a function, a functor, a lambda function,...</p>
<h2 class="doxsection"><a class="anchor" id="holding_a_function"></a>
Holding a function</h2>
<p>If you want to refer to an existing function, you can directly pass its name to <a class="el" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a>: </p><div class="fragment"><div class="line"><span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code hl_function" href="exampleFunctorHolder_8cpp.html#a65616cde20c32b627a9256ee9a2177a9">signed_dist_to_unit_circle</a>(<a class="code hl_class" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a> <span class="keyword">const</span>&amp; pt)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> pt.<a class="code hl_function" href="classDGtal_1_1PointVector.html#a621809d6682ec859fd761f60b23ba2b7">norm</a>() - 1.;</div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="keyword">auto</span> fn = <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a>( <a class="code hl_function" href="exampleFunctorHolder_8cpp.html#a65616cde20c32b627a9256ee9a2177a9">signed_dist_to_unit_circle</a> );</div>
<div class="line">    <span class="keyword">using </span><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> = <a class="code hl_class" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(1, 1) ) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>If the function is templated, you must specify the needed templates: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Po<span class="keywordtype">int</span>&gt;</div>
<div class="line"><span class="keyword">inline</span></div>
<div class="line"><span class="keyword">typename</span> Point::Component</div>
<div class="line"><a class="code hl_function" href="exampleFunctorHolder_8cpp.html#a8c41fc3212565f9503f1eb15abca1eea">templated_signed_dist_to_unit_circle</a>(<a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> <span class="keyword">const</span>&amp; pt)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> pt.<a class="code hl_function" href="classMyPointD.html#a15ffe8c0e06e20391238a161665616f0">norm</a>() - <span class="keyword">typename</span> Point::Component(1);</div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="keyword">using </span><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> = <a class="code hl_class" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a>( <a class="code hl_function" href="exampleFunctorHolder_8cpp.html#a8c41fc3212565f9503f1eb15abca1eea">templated_signed_dist_to_unit_circle&lt;Point&gt;</a> );</div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(1, 1) ) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>In both cases, the function will be passed by reference. You can also explicitly pass it by pointer using the <span class="tt">&amp;</span> keyword.</p>
<dl class="section warning"><dt>Warning</dt><dd>However, please note that passing a function by reference or by pointer will prevent the compiler from inlining it (you may have a chance by reference).</dd>
<dd>
To avoid this possible performance penalty, you should pass the function through a lambda: <div class="fragment"><div class="line">    <span class="keyword">using </span><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> = <a class="code hl_class" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a>( [] (<a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> <span class="keyword">const</span>&amp; pt) { <span class="keywordflow">return</span> <a class="code hl_function" href="exampleFunctorHolder_8cpp.html#a65616cde20c32b627a9256ee9a2177a9">signed_dist_to_unit_circle</a>(pt); } );</div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(1, 1) ) &lt;&lt; std::endl;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="keyword">using </span><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> = <a class="code hl_class" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a>( [] (<a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> <span class="keyword">const</span>&amp; pt) { <span class="keywordflow">return</span> <a class="code hl_function" href="exampleFunctorHolder_8cpp.html#a8c41fc3212565f9503f1eb15abca1eea">templated_signed_dist_to_unit_circle</a>(pt); } );</div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(1, 1) ) &lt;&lt; std::endl;</div>
</div><!-- fragment --> thus giving the compiler free hands to inline it.</dd>
<dd>
Even better: if you have enable C++14 support, you can use generic lambdas so that you don't have to specify any type, even for templated functions (the type is resolved at the effective call): <div class="fragment"><div class="line">    <span class="keyword">auto</span> fn = <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a>( [] (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; pt) { <span class="keywordflow">return</span> <a class="code hl_function" href="exampleFunctorHolder_8cpp.html#a8c41fc3212565f9503f1eb15abca1eea">templated_signed_dist_to_unit_circle</a>(pt); } );</div>
<div class="line">    <span class="keyword">using </span><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> = <a class="code hl_class" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(1, 1) ) &lt;&lt; std::endl; <span class="comment">// &lt;- template parameter is resolved to Point</span></div>
</div><!-- fragment --> Enjoy the genericity !</dd></dl>
<h2 class="doxsection"><a class="anchor" id="holding_a_functor"></a>
Holding a functor</h2>
<p>If you want to refer to a functor, you can pass it by (left-value) reference: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Po<span class="keywordtype">int</span>&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structSignedDistToCircle.html">SignedDistToCircle</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using </span><a class="code hl_typedef" href="structSignedDistToCircle.html#ad35ba2c400e0b2208e3863e425fb9692">Real</a> = <span class="keyword">typename</span> Point::Component;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> <a class="code hl_variable" href="structSignedDistToCircle.html#ac178f379ec8ccc7e58a07df5c4b786c9">center</a>;</div>
<div class="line">  <a class="code hl_typedef" href="structSignedDistToCircle.html#ad35ba2c400e0b2208e3863e425fb9692">Real</a>  <a class="code hl_variable" href="structSignedDistToCircle.html#adb1e5e157d4fec652bf002431436ceb4">radius</a>;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="structSignedDistToCircle.html#a80d1432af6ea67d45685b05f2c506a71">SignedDistToCircle</a>(<a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> <span class="keyword">const</span>&amp; pt, <a class="code hl_typedef" href="structSignedDistToCircle.html#ad35ba2c400e0b2208e3863e425fb9692">Real</a> r)</div>
<div class="line">    : <a class="code hl_variable" href="structSignedDistToCircle.html#ac178f379ec8ccc7e58a07df5c4b786c9">center</a>(pt), <a class="code hl_variable" href="structSignedDistToCircle.html#adb1e5e157d4fec652bf002431436ceb4">radius</a>(r)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">inline</span></div>
<div class="line">  <a class="code hl_typedef" href="structSignedDistToCircle.html#ad35ba2c400e0b2208e3863e425fb9692">Real</a> <a class="code hl_function" href="structSignedDistToCircle.html#a2ee322c2cd220553d3ecce803de1dbdb">operator() </a>(<a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> <span class="keyword">const</span>&amp; pt)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">return</span> (pt - <a class="code hl_variable" href="structSignedDistToCircle.html#ac178f379ec8ccc7e58a07df5c4b786c9">center</a>).norm() - <a class="code hl_variable" href="structSignedDistToCircle.html#adb1e5e157d4fec652bf002431436ceb4">radius</a>;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="keyword">using </span><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> = <a class="code hl_class" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    <a class="code hl_struct" href="structSignedDistToCircle.html">SignedDistToCircle&lt;Point&gt;</a> dist(<a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(0, 1), 2);</div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a>( dist );</div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(1, 1) ) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>You wan also inline the construction of the functor directly in the <a class="el" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a> call: </p><div class="fragment"><div class="line">    <span class="keyword">using </span><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> = <a class="code hl_class" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a>( <a class="code hl_struct" href="structSignedDistToCircle.html">SignedDistToCircle&lt;Point&gt;</a>( <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(0, 1), 2 ) );</div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(1, 1) ) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> or, to increase code readability, you can first construct the functor and then transfer its ownership to <a class="el" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a> by using the move semantic: </p><div class="fragment"><div class="line">    <span class="keyword">using </span><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> = <a class="code hl_class" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    <a class="code hl_struct" href="structSignedDistToCircle.html">SignedDistToCircle&lt;Point&gt;</a> dist(<a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(0, 1), 2);</div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a>( std::move(dist) );</div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(1, 1) ) &lt;&lt; std::endl;</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>Moving the functor to <a class="el" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a> is also a way to increase its lifetime, for example when returning a <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> that depends on a local functor. See also the section <a class="el" href="#held_object_lifetime">Held object lifetime</a>.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="holding_a_lambda"></a>
Holding a lambda</h2>
<p>Without surprise, holding a lambda works the same way: </p><div class="fragment"><div class="line">    <span class="keyword">using </span><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> = <a class="code hl_class" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> <a class="code hl_function" href="namespaceDGtal_1_1detail.html#a9b056b7d2516565a223eb8c9ec3702c8">center</a>(0, 1);</div>
<div class="line">    <span class="keywordtype">double</span> radius = 2;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a>(</div>
<div class="line">        [&amp;center, &amp;radius] (<a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> <span class="keyword">const</span>&amp; pt) {</div>
<div class="line">            <span class="keywordflow">return</span> (pt - center).norm() - radius;</div>
<div class="line">        }</div>
<div class="line">    );</div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(1, 1) ) &lt;&lt; std::endl;</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="holding_something_else"></a>
Holding something else</h2>
<p><a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> should be able to hold any callable object. However, as warned before, if you are concerned by performance, you should avoid holding a function by reference or pointer or, even worse, holding a <a href="https://en.cppreference.com/w/cpp/utility/functional/function"><span class="tt">std::function</span></a> that is more or less a pointer with an additional cost due to the polymorphism.</p>
<h2 class="doxsection"><a class="anchor" id="held_object_lifetime"></a>
Held object lifetime</h2>
<p>When passing a functor to <a class="el" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a> by lvalue reference (ie the functor has a name), the functor lifetime must exceed the <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> lifetime.</p>
<p>Otherwise, consider constructing the functor directly during the <a class="el" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a> call or transfer its ownership by using the move semantic. See the examples in section <a class="el" href="#holding_a_functor">Holding a functor</a>.</p>
<h2 class="doxsection"><a class="anchor" id="auto_holdfunctor"></a>
Why using the auto keyword ?</h2>
<p>Since the exact storage type used in <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> is choosen by <a class="el" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a> depending on the passing mode of the callable object, it is not easily possible to known the template parameters of <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>.</p>
<p>Thus, it is recommended to use the <a href="https://en.cppreference.com/w/cpp/language/auto"><span class="tt">auto</span></a> keyword as the type placeholder for any instance of <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>.</p>
<p>See also the section about <a class="el" href="#storing_functorholder">Storing a FunctorHolder</a>.</p>
<h1 class="doxsection"><a class="anchor" id="calling_the_held_object"></a>
Calling the held object</h1>
<p>Calling the held object is done naturally by using the <span class="tt">operator()</span>, like in the previous examples: </p><div class="fragment"><div class="line">    <span class="keyword">using </span><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> = <a class="code hl_class" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a>( <a class="code hl_struct" href="structSignedDistToCircle.html">SignedDistToCircle&lt;Point&gt;</a>( <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(0, 1), 2 ) );</div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(1, 1) ) &lt;&lt; std::endl;</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="parameters_return_types"></a>
What about the parameters and return value types ?</h2>
<p>You may have notice that we never have to specify the types of the parameters used when calling the held object, neither the type of the returned object.</p>
<p>The trick behind this is the use of variadic templates and perfect forwarding so that the call of the held object is transparent for <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>. The returned value type is also automatically deduced.</p>
<h2 class="doxsection"><a class="anchor" id="functor_arity"></a>
What about the callable object arity ?</h2>
<p>The use of variadic templates for the <span class="tt">operator()</span> allows holding a callable object of any arity: </p><div class="fragment"><div class="line">    <span class="keyword">using </span><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> = <a class="code hl_class" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> dist = [] (<a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> <span class="keyword">const</span>&amp; pt, <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> <span class="keyword">const</span>&amp; <a class="code hl_function" href="namespaceDGtal_1_1detail.html#a9b056b7d2516565a223eb8c9ec3702c8">center</a>, <span class="keywordtype">double</span> radius)</div>
<div class="line">      {</div>
<div class="line">        <span class="keywordflow">return</span> (pt - center).norm() - radius;</div>
<div class="line">      };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a>( dist );</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(1, 1), <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(0, 1), 2 ) &lt;&lt; std::endl;</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="copy_and_assignment"></a>
Copying and assigning a FunctorHolder</h1>
<p><a class="el" href="structA.html">A</a> <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> instance is copyable, movable and assignable, thus making it a <a class="el" href="structboost_1_1Assignable.html">boost::Assignable</a> model and of any other concept that trivially inherit from it (e.g. <a class="el" href="structDGtal_1_1concepts_1_1CUnaryFunctor.html">concepts::CUnaryFunctor</a>).</p>
<dl class="section warning"><dt>Warning</dt><dd>When copying or assigning a <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>, the two involved instances will afterward both refer to the same callable object (i.e. the held object is not copied). For example, modifying a functor attribute after the copy will modify the result of all original and copied instances of <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> that hold it: <div class="fragment"><div class="line">    <span class="keyword">using </span><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> = <a class="code hl_class" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    <a class="code hl_struct" href="structSignedDistToCircle.html">SignedDistToCircle&lt;Point&gt;</a> dist(<a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(0, 1), 2);</div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a>( dist );</div>
<div class="line">    <span class="keyword">auto</span> fn2 = fn;</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(1, 1) ) &lt;&lt; std::endl;  <span class="comment">// Output: -1</span></div>
<div class="line">    std::cout &lt;&lt; fn2( <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(1, 1) ) &lt;&lt; std::endl; <span class="comment">// Output: -1</span></div>
<div class="line"> </div>
<div class="line">    dist.radius = 3; <span class="comment">// fn and fn2 both refer to the same functor dist.</span></div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; fn( <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(1, 1) ) &lt;&lt; std::endl;  <span class="comment">// Output: -2</span></div>
<div class="line">    std::cout &lt;&lt; fn2( <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(1, 1) ) &lt;&lt; std::endl; <span class="comment">// Output: -2</span></div>
</div><!-- fragment --></dd>
<dd>
It is also the case when passing the object by rvalue reference to <a class="el" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a> since it moves it to a dynamically allocated memory place, managed by <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="tt">std::shared_ptr</span></a>. Copying or assigning the resulting <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> is like copying or assigning the underlying <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="tt">std::shared_ptr</span></a>: <div class="fragment"><div class="line">    <span class="keywordtype">int</span> init_cnt = 0;</div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a>( [init_cnt] () <span class="keyword">mutable</span> { <span class="keywordflow">return</span> ++init_cnt; } );</div>
<div class="line">    std::cout &lt;&lt; fn() &lt;&lt; std::endl;  <span class="comment">// Output: 1</span></div>
<div class="line">    <span class="keyword">auto</span> fn2 = fn;</div>
<div class="line">    std::cout &lt;&lt; fn2() &lt;&lt; std::endl; <span class="comment">// Output: 2</span></div>
<div class="line">    std::cout &lt;&lt; fn() &lt;&lt; std::endl;  <span class="comment">// Output: 3</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="structA.html">A</a> counterpart of this design it that <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> instances are lightweight.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="type_of_functorholder"></a>
The type of a FunctorHolder instance</h1>
<dl class="section note"><dt>Note</dt><dd>Note that the next topics are not specific to <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>. They may be useful in many cases where you can't or don't want to guess the result type of an expression.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="storing_functorholder"></a>
Storing a FunctorHolder</h2>
<p>As explained before (see <a class="el" href="#auto_holdfunctor">Why using the auto keyword ?</a>), you cannot easily guess the result type of a <a class="el" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a> call. Moreover, it becomes impossible when passing a lambda in an inline way.</p>
<p>Thus, it is recommended to use the <a href="https://en.cppreference.com/w/cpp/language/auto"><span class="tt">auto</span></a> keyword as the type placeholder for any instance of <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>: </p><div class="fragment"><div class="line">    <span class="keyword">using </span><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> = <a class="code hl_class" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt;2, double&gt;</a>;</div>
<div class="line">    <span class="keyword">auto</span> fn = <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a>( <a class="code hl_struct" href="structSignedDistToCircle.html">SignedDistToCircle&lt;Point&gt;</a>( <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(0, 1), 2 ) );</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="passing_functorholder"></a>
Passing a FunctorHolder as a parameter</h2>
<p>However, when passing a <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>, especially to a class constructor, you may still need to known the <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> exact type (including the template parameters).</p>
<p>In those cases, a solution is to first store the <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> and then to deduce its type by using the <a href="https://en.cppreference.com/w/cpp/language/decltype"><span class="tt">decltype</span></a> keyword: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> binarizer = <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a>( [] (<a class="code hl_typedef" href="classDGtal_1_1ImageContainerBySTLVector.html#a969107fe40d0efab29fe28f72813cb66">Image::Value</a> v) { <span class="keywordflow">return</span> v &lt;= 135; } );</div>
<div class="line">    <a class="code hl_struct" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate</a>&lt;<a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a852ab282e5168b5711ef7a87b3aefa68">Image</a>, <span class="keyword">decltype</span>(binarizer)&gt; predicate(<a class="code hl_function" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a614d1b1c043b31763c1eb50f64666737">image</a>, binarizer);</div>
</div><!-- fragment --><p>To ease such usage, you may want to search if there exist an helper (or factory) for that class (see also <a class="el" href="#creating_a_helper">Creating a helper</a>).</p>
<h2 class="doxsection"><a class="anchor" id="returning_functorholder"></a>
Returning a FunctorHolder</h2>
<p>The most tricky part begins when you need a function to return a <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>.</p>
<p>The problem comes from the fact that up to C++11 standard, you need to somehow specify the function's return type. In C++11, you can slightly delay this type specification using the trailing return syntax but the type still needs to be known in the signature. Basically, you need to duplicate the line of code that generates the <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> (optionaly using the function's parameters) into the function signature and deduce its type using <a href="https://en.cppreference.com/w/cpp/language/decltype"><span class="tt">decltype</span></a>: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structBinarizer.html">Binarizer</a></div>
<div class="line">{</div>
<div class="line">  T <a class="code hl_variable" href="structBinarizer.html#a716a7fac3a2ed8139d8672091dd403f2">threshold</a>;</div>
<div class="line">  <span class="keyword">explicit</span> <a class="code hl_function" href="structBinarizer.html#ac1821cbf40ff1804afe2cf0fce0dbdd6">Binarizer</a>(T v) : <a class="code hl_variable" href="structBinarizer.html#a716a7fac3a2ed8139d8672091dd403f2">threshold</a>(v) {}</div>
<div class="line">  <a class="code hl_function" href="structBinarizer.html#ac1821cbf40ff1804afe2cf0fce0dbdd6">Binarizer</a>&amp; <a class="code hl_function" href="structBinarizer.html#af963e7eb25157c5afb0c2173e2b6d3da">operator= </a>(<a class="code hl_function" href="structBinarizer.html#ac1821cbf40ff1804afe2cf0fce0dbdd6">Binarizer</a> <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>; <span class="comment">// This is not a model of boost::Assignable</span></div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code hl_function" href="structBinarizer.html#a697bec0009877094d5a5db30388afd18">operator() </a>(T v)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> v &lt;= <a class="code hl_variable" href="structBinarizer.html#a716a7fac3a2ed8139d8672091dd403f2">threshold</a>; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">inline</span></div>
<div class="line"><span class="keyword">decltype</span>(<a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a>(<a class="code hl_struct" href="structBinarizer.html">Binarizer&lt;T&gt;</a>(128))) <span class="comment">// Deduced return type</span></div>
<div class="line"><a class="code hl_function" href="exampleFunctorHolder_8cpp.html#a62380de244141c559210a6905bd2b3ea">get_trivial_binarizer</a>()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a>( <a class="code hl_struct" href="structBinarizer.html">Binarizer&lt;T&gt;</a>(128) );</div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="keyword">auto</span> binarizer = <a class="code hl_function" href="exampleFunctorHolder_8cpp.html#a62380de244141c559210a6905bd2b3ea">get_trivial_binarizer&lt;int&gt;</a>();</div>
</div><!-- fragment --><p>If it is easier to get the return type using the actual parameters, you can use the trailing return syntax: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="exampleFunctorHolder_8cpp.html#aa31c0f42bbc8c9da6dca73690c027a63">get_mean_binarizer_from_range</a>(Iterator first, Iterator last) <span class="comment">// auto as return type</span></div>
<div class="line">     -&gt; <span class="keyword">decltype</span>(<a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a>(<a class="code hl_struct" href="structBinarizer.html">Binarizer</a>&lt;<span class="keyword">decltype</span>(*first / std::distance(first, last))&gt;(0)))</div>
<div class="line">     <span class="comment">// with trailing return type specification using -&gt;</span></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using </span>value_type = <span class="keyword">typename</span> std::iterator_traits&lt;Iterator&gt;::value_type;</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> mean = std::accumulate(first, last, value_type(0));</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> size = std::distance(first, last);</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a>(<a class="code hl_struct" href="structBinarizer.html">Binarizer</a>&lt;<span class="keyword">decltype</span>(mean / size)&gt;(mean / size));</div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="keyword">auto</span> binarizer = <a class="code hl_function" href="exampleFunctorHolder_8cpp.html#aa31c0f42bbc8c9da6dca73690c027a63">get_mean_binarizer_from_range</a>(<a class="code hl_function" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a614d1b1c043b31763c1eb50f64666737">image</a>.begin(), <a class="code hl_function" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a614d1b1c043b31763c1eb50f64666737">image</a>.end());</div>
<div class="line">    <a class="code hl_struct" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate</a>&lt;<a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a852ab282e5168b5711ef7a87b3aefa68">Image</a>, <span class="keyword">decltype</span>(binarizer)&gt; predicate(<a class="code hl_function" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a614d1b1c043b31763c1eb50f64666737">image</a>, binarizer);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Note that you don't have to put the exact same expression in the trailing return type deduction and in the actual return. Like in the previous snippet, you can simply use another expression you know the result type will be the same as the actual return expression.</dd>
<dd>
Going further, if writting such simplier expression is difficult, you can use <a href="https://en.cppreference.com/w/cpp/utility/declval"><span class="tt">std::declval</span></a> function that constructs a fake instance of any given type: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Image&gt;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="exampleFunctorHolder_8cpp.html#a024528ac00c71adf2ed4208a601d8218">get_mean_binarizer_from_an_image</a>(std::string <span class="keyword">const</span>&amp; file_name)</div>
<div class="line">    -&gt; <span class="keyword">decltype</span>(<a class="code hl_function" href="exampleFunctorHolder_8cpp.html#aa31c0f42bbc8c9da6dca73690c027a63">get_mean_binarizer_from_range</a>(</div>
<div class="line">          std::declval&lt;Image&gt;().begin(), std::declval&lt;Image&gt;().end() ))</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a852ab282e5168b5711ef7a87b3aefa68">Image</a> <span class="keyword">const</span> <a class="code hl_function" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a614d1b1c043b31763c1eb50f64666737">image</a> = <a class="code hl_function" href="structDGtal_1_1GenericReader.html#a7e2fbfbe0d3c94e6bc4ca67e96c01f7c">DGtal::GenericReader&lt;Image&gt;::import</a>(file_name);</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="exampleFunctorHolder_8cpp.html#aa31c0f42bbc8c9da6dca73690c027a63">get_mean_binarizer_from_range</a>(<a class="code hl_function" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a614d1b1c043b31763c1eb50f64666737">image</a>.begin(), <a class="code hl_function" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a614d1b1c043b31763c1eb50f64666737">image</a>.end());</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<p>Starting with C++14 standard, you can simply use the <a href="https://en.cppreference.com/w/cpp/language/auto"><span class="tt">auto</span></a> keyword as a return type and the compiler should deduce the actual type from the <span class="tt">return</span> statements of the function: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line"><span class="keyword">auto</span> get_mean_binarizer_from_range_cpp14(Iterator first, Iterator last)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using </span>value_type = <span class="keyword">typename</span> std::iterator_traits&lt;Iterator&gt;::value_type;</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> mean = std::accumulate(first, last, value_type(0));</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> size = std::distance(first, last);</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a>(<a class="code hl_struct" href="structBinarizer.html">Binarizer</a>&lt;<span class="keyword">decltype</span>(mean / size)&gt;(mean / size));</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="creating_a_helper"></a>
Creating a helper</h2>
<p>Usage of <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> (as other kind of objects whose type is difficult to guess) can be simplified by adding helpers (or factories) to classes whose template parameters depend on such objects.</p>
<p><a class="el" href="structA.html">A</a> helper is only a templated function that benefits from the auto-deduction of template parameters in order to deduce the appropriate class type: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">inline</span></div>
<div class="line"><a class="code hl_struct" href="structBinarizer.html">Binarizer&lt;T&gt;</a> <a class="code hl_function" href="exampleFunctorHolder_8cpp.html#a616bdf33b6f55dd1acfcff6d3cac3976">makeBinarizer</a>( T <span class="keyword">const</span>&amp; v ) <span class="comment">// T auto-deduced from the parameter v</span></div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_struct" href="structBinarizer.html">Binarizer&lt;T&gt;</a>(v);</div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="keyword">auto</span> binarizer = <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a>( <a class="code hl_function" href="exampleFunctorHolder_8cpp.html#a616bdf33b6f55dd1acfcff6d3cac3976">makeBinarizer</a>(135) );</div>
<div class="line">    <a class="code hl_struct" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate</a>&lt;<a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a852ab282e5168b5711ef7a87b3aefa68">Image</a>, <span class="keyword">decltype</span>(binarizer)&gt; predicate(<a class="code hl_function" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a614d1b1c043b31763c1eb50f64666737">image</a>, binarizer);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Starting with C++17, these helpers can be replaced by deduction guides that are custom rules for deducing class template parameters from a direct call to the constructor (without specifying the deductible template parameters): <div class="fragment"><div class="line">    <span class="keyword">auto</span> binarizer = <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a>( <a class="code hl_struct" href="structBinarizer.html">Binarizer</a>(135) ); <span class="comment">// Binarizer template parameter is not specified.</span></div>
<div class="line">    <a class="code hl_struct" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate</a>&lt;<a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a852ab282e5168b5711ef7a87b3aefa68">Image</a>, <span class="keyword">decltype</span>(binarizer)&gt; predicate(<a class="code hl_function" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a614d1b1c043b31763c1eb50f64666737">image</a>, binarizer);</div>
</div><!-- fragment --></dd></dl>
<p>For more complex classes, like <a class="el" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate</a> that use <a class="el" href="classDGtal_1_1ConstAlias.html">DGtal::ConstAlias</a> in the constructor parameters, you cannot simply use <a class="el" href="classDGtal_1_1ConstAlias.html">DGtal::ConstAlias</a> in the factory and hope that the compiler will deduce the aliases type: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">typename</span> PointFunctor,</div>
<div class="line">  <span class="keyword">typename</span> Predicate</div>
<div class="line">&gt;</div>
<div class="line"><a class="code hl_struct" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate&lt;PointFunctor, Predicate&gt;</a></div>
<div class="line"><a class="code hl_function" href="exampleFunctorHolder_8cpp.html#a65d6d18e8e8b140368f9143558c800f2">makePointFunctorPredicate_Example</a>(</div>
<div class="line">    <a class="code hl_class" href="classDGtal_1_1ConstAlias.html">DGtal::ConstAlias&lt;PointFunctor&gt;</a> aFun,</div>
<div class="line">    <a class="code hl_class" href="classDGtal_1_1ConstAlias.html">DGtal::ConstAlias&lt;Predicate&gt;</a> aPred)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_struct" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate&lt;PointFunctor, Predicate&gt;</a>( aFun, aPred );</div>
<div class="line">}</div>
</div><!-- fragment --><p>The problem here is that implicit conversions (like the one needed from <span class="tt">PointFunctor</span> to <span class="tt"><a class="el" href="classDGtal_1_1ConstAlias.html" title="Aim: This class encapsulates its parameter class so that to indicate to the user that the object/poin...">ConstAlias</a>&lt;PointFunctor&gt;</span>) are ignored during the template deduction step. In this case, the first solution is to remove the <a class="el" href="classDGtal_1_1ConstAlias.html">DGtal::ConstAlias</a> from the helper signature: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">typename</span> PointFunctor,</div>
<div class="line">  <span class="keyword">typename</span> Predicate</div>
<div class="line">&gt;</div>
<div class="line"><a class="code hl_struct" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate&lt;PointFunctor, Predicate&gt;</a></div>
<div class="line"><a class="code hl_function" href="exampleFunctorHolder_8cpp.html#a65d6d18e8e8b140368f9143558c800f2">makePointFunctorPredicate_Example</a>( PointFunctor <span class="keyword">const</span>&amp; aFun, Predicate <span class="keyword">const</span>&amp; aPred )</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_struct" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate&lt;PointFunctor, Predicate&gt;</a>( aFun, aPred );</div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="keyword">auto</span> binarizer = <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a>( <a class="code hl_function" href="exampleFunctorHolder_8cpp.html#a616bdf33b6f55dd1acfcff6d3cac3976">makeBinarizer</a>(135) );</div>
<div class="line">    <span class="keyword">auto</span> predicate = <a class="code hl_function" href="exampleFunctorHolder_8cpp.html#a65d6d18e8e8b140368f9143558c800f2">makePointFunctorPredicate_Example</a>( <a class="code hl_function" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a614d1b1c043b31763c1eb50f64666737">image</a>, binarizer );</div>
</div><!-- fragment --><p>Another problem arises here: the constructor of <a class="el" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate</a> will get as parameters only left-value references because the parameters have a name in the factory. Thus, you might miss some optimizations for right-value references.</p>
<p>In order to make a factory that doesn't change the parameters type, you must use <a href="https://en.cppreference.com/w/cpp/language/reference#Forwarding_references">forwarding references</a> (by using <span class="tt">&amp;&amp;</span> references together with template paremeter deduction, also known as universal references) and perfect forwarding using <a href="https://en.cppreference.com/w/cpp/utility/forward"><span class="tt">std::forward</span></a>: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">typename</span> PointFunctor,</div>
<div class="line">  <span class="keyword">typename</span> Predicate</div>
<div class="line">&gt;</div>
<div class="line"><a class="code hl_struct" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate</a>&lt;</div>
<div class="line">  <span class="keyword">typename</span> std::decay&lt;PointFunctor&gt;::type,</div>
<div class="line">  <span class="keyword">typename</span> std::decay&lt;Predicate&gt;::type</div>
<div class="line">&gt;</div>
<div class="line"><a class="code hl_function" href="exampleFunctorHolder_8cpp.html#a9fd4de60021962199d00417d7157d360">makePointFunctorPredicate_Example2</a>( PointFunctor &amp;&amp; aFun, Predicate &amp;&amp; aPred )</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_struct" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">DGtal::functors::PointFunctorPredicate</a>&lt;</div>
<div class="line">      <span class="keyword">typename</span> std::decay&lt;PointFunctor&gt;::type,</div>
<div class="line">      <span class="keyword">typename</span> std::decay&lt;Predicate&gt;::type</div>
<div class="line">  &gt;(</div>
<div class="line">    std::forward&lt;PointFunctor&gt;(aFun),</div>
<div class="line">    std::forward&lt;Predicate&gt;(aPred)</div>
<div class="line">  );</div>
<div class="line">}</div>
</div><!-- fragment --><p> Note the use of <a href="https://en.cppreference.com/w/cpp/types/decay"><span class="tt">std::decay</span></a> because the template parameter will be deduced with an included reference specification that you don't want to be part of the returned class specification (<a href="https://en.cppreference.com/w/cpp/types/decay"><span class="tt">std::decay</span></a> removes reference and constness from a given type).</p>
<h1 class="doxsection"><a class="anchor" id="marking_cunaryfunctor"></a>
Making a C(Unary)Functor model based on FunctorHolder</h1>
<p>In the following sections, we will explain how to create new <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> functor models using <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> as an internal storage in order to accept any kind of callable objects (lambdas included).</p>
<p>You may want to add such classes because some concepts derived from <a class="el" href="structDGtal_1_1concepts_1_1CUnaryFunctor.html">DGtal::concepts::CUnaryFunctor</a> may need additional data or typedef, like <a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html">DGtal::concepts::CPointFunctor</a>.</p>
<h2 class="doxsection"><a class="anchor" id="tutorial_pointfunctorholder"></a>
A simple CUnaryFunctor model with additional typedef</h2>
<p>In this section, we will explain how to write a <a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html">concepts::CPointFunctor</a> model that is basically a <a class="el" href="structDGtal_1_1concepts_1_1CUnaryFunctor.html">concepts::CUnaryFunctor</a> model with additional typedef (the point and value types).</p>
<p>The resulting class is more or less the <a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html">PointFunctorHolder</a> class which source code is visible in <a class="el" href="PointFunctorHolder_8h_source.html">PointFunctorHolder.h</a> .</p>
<h3 class="doxsection"><a class="anchor" id="pointfunctorholder_core_skeleton"></a>
The core skeleton</h3>
<p><a class="el" href="structA.html">A</a> basic implementation of such a class would be: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">typename</span> TPoint,</div>
<div class="line">  <span class="keyword">typename</span> TValue,</div>
<div class="line">  <span class="keyword">typename</span> TFunctor</div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">class </span>PointFunctorHolder</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// DGtal types</span></div>
<div class="line">  <span class="keyword">using </span><a class="code hl_typedef" href="classDGtal_1_1functors_1_1PointFunctorHolder.html#ab3bb99c9e1d5518bee5016183fc480f7">Self</a>    = <a class="code hl_function" href="classDGtal_1_1functors_1_1PointFunctorHolder.html#a9b362748aaa71a04f7fa91f303f44a2c">PointFunctorHolder&lt;TPoint, TValue, TFunctor&gt;</a>;</div>
<div class="line">  <span class="keyword">using </span><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>   = TPoint;</div>
<div class="line">  <span class="keyword">using </span><a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Value</a>   = TValue;</div>
<div class="line">  <span class="keyword">using </span><a class="code hl_struct" href="structFunctor.html">Functor</a> = TFunctor;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Storing the functor</span></div>
<div class="line">  <span class="keyword">explicit</span> <a class="code hl_function" href="classDGtal_1_1functors_1_1PointFunctorHolder.html#a9b362748aaa71a04f7fa91f303f44a2c">PointFunctorHolder</a>(TFunctor <span class="keyword">const</span>&amp; fn)</div>
<div class="line">      : <a class="code hl_variable" href="classDGtal_1_1functors_1_1PointFunctorHolder.html#af9ae4eec22e3132acee4828f8612010c">myFunctor</a>(fn)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Evaluating the functor</span></div>
<div class="line">  <span class="keyword">inline</span> <a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Value</a> <a class="code hl_function" href="classDGtal_1_1functors_1_1PointFunctorHolder.html#a9cf86ca14c700bcb6d07cf196e4eb836">operator() </a>( <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> <span class="keyword">const</span>&amp; <a class="code hl_variable" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a2354f3606a9fc718d40aecabda7e9615">aPoint</a> )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">return</span> <a class="code hl_variable" href="classDGtal_1_1functors_1_1PointFunctorHolder.html#af9ae4eec22e3132acee4828f8612010c">myFunctor</a>( <a class="code hl_variable" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a2354f3606a9fc718d40aecabda7e9615">aPoint</a> );</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <a class="code hl_struct" href="structFunctor.html">Functor</a> <a class="code hl_variable" href="classDGtal_1_1functors_1_1PointFunctorHolder.html#af9ae4eec22e3132acee4828f8612010c">myFunctor</a>;</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1PointFunctorHolder_html_a9b362748aaa71a04f7fa91f303f44a2c"><div class="ttname"><a href="classDGtal_1_1functors_1_1PointFunctorHolder.html#a9b362748aaa71a04f7fa91f303f44a2c">DGtal::functors::PointFunctorHolder::PointFunctorHolder</a></div><div class="ttdeci">PointFunctorHolder(Function &amp;&amp;fn)</div><div class="ttdoc">Constructor.</div><div class="ttdef"><b>Definition</b> <a href="PointFunctorHolder_8h_source.html#l00119">PointFunctorHolder.h:119</a></div></div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1PointFunctorHolder_html_a9cf86ca14c700bcb6d07cf196e4eb836"><div class="ttname"><a href="classDGtal_1_1functors_1_1PointFunctorHolder.html#a9cf86ca14c700bcb6d07cf196e4eb836">DGtal::functors::PointFunctorHolder::operator()</a></div><div class="ttdeci">Value operator()(Point const &amp;aPoint) const</div><div class="ttdoc">Evaluates the functor at the given point.</div><div class="ttdef"><b>Definition</b> <a href="PointFunctorHolder_8h_source.html#l00132">PointFunctorHolder.h:132</a></div></div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1PointFunctorHolder_html_ab3bb99c9e1d5518bee5016183fc480f7"><div class="ttname"><a href="classDGtal_1_1functors_1_1PointFunctorHolder.html#ab3bb99c9e1d5518bee5016183fc480f7">DGtal::functors::PointFunctorHolder::Self</a></div><div class="ttdeci">PointFunctorHolder&lt; TPoint, TValue, TFunctor &gt; Self</div><div class="ttdef"><b>Definition</b> <a href="PointFunctorHolder_8h_source.html#l00101">PointFunctorHolder.h:101</a></div></div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1PointFunctorHolder_html_af9ae4eec22e3132acee4828f8612010c"><div class="ttname"><a href="classDGtal_1_1functors_1_1PointFunctorHolder.html#af9ae4eec22e3132acee4828f8612010c">DGtal::functors::PointFunctorHolder::myFunctor</a></div><div class="ttdeci">Functor myFunctor</div><div class="ttdoc">The held functor.</div><div class="ttdef"><b>Definition</b> <a href="PointFunctorHolder_8h_source.html#l00160">PointFunctorHolder.h:160</a></div></div>
<div class="ttc" id="astructFunctor_html"><div class="ttname"><a href="structFunctor.html">Functor</a></div><div class="ttdef"><b>Definition</b> <a href="testFunctorHolder_8cpp_source.html#l00044">testFunctorHolder.cpp:45</a></div></div>
<div class="ttc" id="atestClone2_8cpp_html_a4075d279133f1952978300b7e135f83d"><div class="ttname"><a href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a></div><div class="ttdeci">MyPointD Point</div><div class="ttdef"><b>Definition</b> <a href="testClone2_8cpp_source.html#l00381">testClone2.cpp:381</a></div></div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_a2354f3606a9fc718d40aecabda7e9615"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a2354f3606a9fc718d40aecabda7e9615">aPoint</a></div><div class="ttdeci">const Point aPoint(3, 4)</div></div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_a566a00621638570a4186414035153a2e"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Value</a></div><div class="ttdeci">double Value</div><div class="ttdef"><b>Definition</b> <a href="testSimpleRandomAccessRangeFromPoint_8cpp_source.html#l00041">testSimpleRandomAccessRangeFromPoint.cpp:41</a></div></div>
</div><!-- fragment --><p>There is nothing special to say about this first draft except that there is no references to <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> because it is the helper (factory) that will actually choose <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> as the <em class="arg">TFunctor</em> template parameter of this class.</p>
<h3 class="doxsection"><a class="anchor" id="pointfunctorholder_helper"></a>
The helper (factory)</h3>
<p>Before continuing, you should read the previous section about <a class="el" href="#creating_a_helper">Creating a helper</a> .</p>
<p>The helper of the above draft should be: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">typename</span> TPoint,</div>
<div class="line">  <span class="keyword">typename</span> TValue,</div>
<div class="line">  <span class="keyword">typename</span> TFunctor</div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span></div>
<div class="line"><a class="code hl_function" href="namespaceDGtal_1_1functors.html#a2edeed82668eb0dd5c4a11c199794237">holdPointFunctor</a>( TFunctor &amp;&amp; aFunctor )</div>
<div class="line">    -&gt; PointFunctorHolder&lt;TPoint, TValue, decltype(holdFunctor(std::forward&lt;TFunctor&gt;(aFunctor)))&gt;</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> PointFunctorHolder&lt;TPoint, TValue, decltype(holdFunctor(std::forward&lt;TFunctor&gt;(aFunctor)))&gt;{</div>
<div class="line">        <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor))</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="ttc" id="anamespaceDGtal_1_1functors_html_a2edeed82668eb0dd5c4a11c199794237"><div class="ttname"><a href="namespaceDGtal_1_1functors.html#a2edeed82668eb0dd5c4a11c199794237">DGtal::functors::holdPointFunctor</a></div><div class="ttdeci">auto holdPointFunctor(TFunctor &amp;&amp;aFunctor) -&gt; PointFunctorHolder&lt; TPoint, TValue, decltype(holdFunctor(std::forward&lt; TFunctor &gt;(aFunctor)))&gt;</div><div class="ttdoc">PointFunctorHolder construction helper with specification of the return type.</div><div class="ttdef"><b>Definition</b> <a href="PointFunctorHolder_8h_source.html#l00196">PointFunctorHolder.h:196</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1functors_html_a6de5bf68b79330b1bf1b18c5d527538f"><div class="ttname"><a href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">DGtal::functors::holdFunctor</a></div><div class="ttdeci">auto holdFunctor(Function &amp;&amp;fn) -&gt; decltype(holdFunctorImpl(std::forward&lt; Function &gt;(fn), typename std::is_lvalue_reference&lt; Function &gt;{}))</div><div class="ttdoc">Hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model.</div><div class="ttdef"><b>Definition</b> <a href="FunctorHolder_8h_source.html#l00279">FunctorHolder.h:279</a></div></div>
</div><!-- fragment --><p>Here we use the trailing return type (<a href="https://en.cppreference.com/w/cpp/language/auto"><span class="tt">auto</span></a> as returned type, followed by <span class="tt">-&gt;</span>) in order to choose the <em class="arg">TFunctor</em> template parameter type of our class depending on the result of <a class="el" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a>.</p>
<p>As explained before, this type is not easily guessable and it is why we use the <a href="https://en.cppreference.com/w/cpp/language/decltype"><span class="tt">decltype</span></a> keyword.</p>
<p>Also note the perfect forwarding syntax (using <a href="https://en.cppreference.com/w/cpp/language/reference#Forwarding_references">universal references</a> and <a href="https://en.cppreference.com/w/cpp/utility/forward"><span class="tt">std::forward</span></a>) to avoid modifying the actual type of the given callable object (particulary keeping lvalue and rvalue references).</p>
<dl class="section remark"><dt>Remarks</dt><dd>There is many repetitions in this helper. Starting with C++14 standard, the trailing return type (after the <span class="tt">-&gt;</span>) could be removed.</dd></dl>
<h3 class="doxsection"><a class="anchor" id="pointfunctorholder_usage"></a>
First test</h3>
<p>That's it ! You can enjoy using this <a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html">concepts::CPointFunctor</a> model, for example to hold a lambda returning the point norm: </p><div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> = PointVector&lt;2, int&gt;;</div>
<div class="line"><span class="keyword">auto</span> fn = <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a2edeed82668eb0dd5c4a11c199794237">holdPointFunctor&lt;Point, double&gt;</a>(</div>
<div class="line">  [] (<a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> <span class="keyword">const</span>&amp; pt) { <span class="keywordflow">return</span> pt.<a class="code hl_function" href="classMyPointD.html#a15ffe8c0e06e20391238a161665616f0">norm</a>(); }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">BOOST_CONCEPT_ASSERT( (concepts::CPointFunctor&lt;<span class="keyword">decltype</span>(fn)&gt;) );</div>
<div class="ttc" id="aclassMyPointD_html_a15ffe8c0e06e20391238a161665616f0"><div class="ttname"><a href="classMyPointD.html#a15ffe8c0e06e20391238a161665616f0">MyPointD::norm</a></div><div class="ttdeci">double norm() const</div><div class="ttdef"><b>Definition</b> <a href="testClone2_8cpp_source.html#l00361">testClone2.cpp:361</a></div></div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="pointfunctorholder_advanced_helper"></a>
Auto-deducing the return type of the functor</h3>
<p>Since the functor's return type can be easily deduced by calling it with a point, we can then provide an additional helper that needs only one template parameter: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">typename</span> TPoint,</div>
<div class="line">  <span class="keyword">typename</span> TFunctor</div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span></div>
<div class="line"><a class="code hl_function" href="namespaceDGtal_1_1functors.html#a2edeed82668eb0dd5c4a11c199794237">holdPointFunctor</a>( TFunctor &amp;&amp; aFunctor )</div>
<div class="line">    -&gt; PointFunctorHolder&lt;</div>
<div class="line">          TPoint,</div>
<div class="line">          <span class="keyword">typename</span> std::decay&lt;decltype(aFunctor(std::declval&lt;TPoint&gt;()))&gt;::type,</div>
<div class="line">          <span class="keyword">decltype</span>(<a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)))</div>
<div class="line">        &gt;</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> PointFunctorHolder&lt;</div>
<div class="line">        TPoint,</div>
<div class="line">        <span class="keyword">typename</span> std::decay&lt;decltype(aFunctor(std::declval&lt;TPoint&gt;()))&gt;::type,</div>
<div class="line">        <span class="keyword">decltype</span>(<a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)))</div>
<div class="line">      &gt;{ <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)) };</div>
<div class="line">  }</div>
</div><!-- fragment --><p>It is a little bit more tricky: we use <a href="https://en.cppreference.com/w/cpp/utility/declval"><span class="tt">std::declval</span></a> in order to generate a fake point, we give it as a parameter to the functor and we deduce the result type using <a href="https://en.cppreference.com/w/cpp/language/decltype"><span class="tt">decltype</span></a>. The use of <a href="https://en.cppreference.com/w/cpp/types/decay"><span class="tt">std::decay</span></a> allows us to remove any reference and const specifier from the deduced type.</p>
<p>The usage is very similar: </p><div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> = PointVector&lt;2, int&gt;;</div>
<div class="line"><span class="keyword">auto</span> fn = <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a2edeed82668eb0dd5c4a11c199794237">holdPointFunctor&lt;Point&gt;</a>( <span class="comment">// Value template parameter deduced to double</span></div>
<div class="line">  [] (<a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> <span class="keyword">const</span>&amp; pt) { <span class="keywordflow">return</span> pt.<a class="code hl_function" href="classMyPointD.html#a15ffe8c0e06e20391238a161665616f0">norm</a>(); }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">BOOST_CONCEPT_ASSERT( (concepts::CPointFunctor&lt;<span class="keyword">decltype</span>(fn)&gt;) );</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="pointfunctorholder_advanced_constructor"></a>
Perfect forwarding in the constructor</h3>
<p>You may have notice that the constructor accepts the functor by constant reference. Since this functor will be a <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>, it shouldn't be a problem because copying a <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> is costless.</p>
<p>However, if you want more genericity in order to use another storage mode, you should consider using perfect forwarding in the constructor: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> Function &gt;</div>
<div class="line"><span class="keyword">explicit</span> PointFunctorHolder(Function &amp;&amp; fn)</div>
<div class="line">    : myFunctor(<a class="code hl_namespace" href="namespacestd.html">std</a>::forward&lt;Function&gt;(fn))</div>
<div class="line">{}</div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdoc">STL namespace.</div></div>
</div><!-- fragment --><p> so that the transfer from the given functor to its storage is unaffected.</p>
<p>However, the problem is that the compiler may choose this constructor as a better overload for the copy constructor, even if you define it: for example, if you copy construct from a mutable <a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html" title="Aim: hold any object callable on points as a DGtal::concepts::CPointFunctor model.">PointFunctorHolder</a>, the perfect forwarding constructor will be a better choice than the copy construction from a constant reference.</p>
<p>One of the possible solutions to avoid this is to disable this constructor when the given type is related to the current class. To do this, we can rely on SFINAE.</p>
<dl class="section note"><dt>Note</dt><dd>The idea behind <a href="https://en.cppreference.com/w/cpp/language/sfinae">SFINAE (Substitution Failure Is Not An Error)</a> is that, during the phase when the compiler lists all possible overloads that may fit a given call, if substituting the template parameters of a considered function fails (i.e. the function signature becomes invalid), then this specialization is discarded without generating a compilation error.</dd>
<dd>
So, the idea is to modify the function signature so that it becomes invalid for some types. To do so, we can add some code in:<ul>
<li>the template parameters declaration,</li>
<li>the arguments list,</li>
<li>the return type.</li>
</ul>
</dd>
<dd>
This trick works before C++11 but this standard makes it easier with the <a href="https://en.cppreference.com/w/cpp/types/enable_if"><span class="tt">std::enable_if</span></a> structure and the trailing return type.</dd>
<dd>
Using the trailing return type, you can easily disable a function overload if a given expression is invalid: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> do_something_if_addable(T v) <span class="comment">// Considered only if v is addable</span></div>
<div class="line">    -&gt; <span class="keyword">decltype</span>(v + v)</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --></dd>
<dd>
If the type deduced by <a href="https://en.cppreference.com/w/cpp/language/decltype"><span class="tt">decltype</span></a> is not the actual return type, you can use the comma operator to specify an additional expression: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> do_something_if_addable(T v) <span class="comment">// Considered only if v is addable</span></div>
<div class="line">    -&gt; <span class="keyword">decltype</span>(v + v, void())    <span class="comment">// This function doesn&#39;t return</span></div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<p>So here is a viable solution: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">typename</span> Function,</div>
<div class="line">  <span class="comment">// SFINAE trick to disable this constructor in a copy/move construction context.</span></div>
<div class="line">  <span class="keyword">typename</span> std::enable_if&lt;!std::is_base_of&lt;PointFunctorHolder, typename std::decay&lt;Function&gt;::type&gt;::value, <span class="keywordtype">int</span>&gt;::type = 0</div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">explicit</span> PointFunctorHolder(Function &amp;&amp; fn)</div>
<div class="line">    : myFunctor(<a class="code hl_namespace" href="namespacestd.html">std</a>::forward&lt;Function&gt;(fn))</div>
<div class="line">{}</div>
</div><!-- fragment --><p> that uses <a href="https://en.cppreference.com/w/cpp/types/is_base_of"><span class="tt">std::is_base_of</span></a> type traits to check if the given parameter is a or inherits from <a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html">PointFunctorHolder</a>.</p>
<h3 class="doxsection"><a class="anchor" id="pointfunctorholder_documentation"></a>
Documenting</h3>
<p>When documenting such a class, it is important to warn the user about two things:</p><ol type="1">
<li>the class is not meant to be used directly but only through the associated helper or factory.</li>
<li>a copied instance of this class will point to the exact same underlying object as the original instance.</li>
</ol>
<p>In addition, for performance reason, you may remark that functions should be wrapped into a lambda before being stored into your class, as explained in the section about <a class="el" href="#holding_a_function">Holding a function</a> .</p>
<p>Finally, you should link to this module page for more informations.</p>
<h2 class="doxsection"><a class="anchor" id="tutorial_functorconstimage"></a>
A more complex example with variable functor arity</h2>
<p>In this section, we will explain how to write a class that may hold an unary or binary functor. It will be based on the <a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html">ConstImageFunctorHolder</a> class that transforms a given callable object into a <a class="el" href="structDGtal_1_1concepts_1_1CConstImage.html">concepts::CConstImage</a> model.</p>
<p>Basically, to define an image, a <a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html">concepts::CPointFunctor</a> model (i.e a functor that returns a value from a given point) would be enough but we want to allow the user to pass a functor that also depends on the image's domain (e.g. when calculating distance to the bounds).</p>
<p>To do so, using SFINAE, we can detect the arity of the given functor and even its parameter's types.</p>
<h3 class="doxsection"><a class="anchor" id="functorconstimage_core_skeleton"></a>
The core skeleton</h3>
<p>Here is the core skeleton of the <a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html">ConstImageFunctorHolder</a> class, without the <span class="tt">operator()</span> that will be introduced later: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">typename</span> TDomain,</div>
<div class="line">  <span class="keyword">typename</span> TValue,</div>
<div class="line">  <span class="keyword">typename</span> TFunctor</div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">class </span>ConstImageFunctorHolder</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// DGtal types</span></div>
<div class="line">  <span class="keyword">using </span><a class="code hl_typedef" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a83322dad8065e2de6aadfd93b22fb88d">Self</a>      = <a class="code hl_function" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a3dbe206c4f6aa733683273d9ca4610fa">ConstImageFunctorHolder&lt;TDomain, TValue, TFunctor&gt;</a>;</div>
<div class="line">  <span class="keyword">using </span><a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a>    = TDomain;</div>
<div class="line">  <span class="keyword">using </span><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>     = <span class="keyword">typename</span> <a class="code hl_typedef" href="classDGtal_1_1HyperRectDomain.html#ad710ac3a2d91d351b55ca6841cb789f5">Domain::Point</a>;</div>
<div class="line">  <span class="keyword">using </span><a class="code hl_typedef" href="examplePlaneProbingParallelepipedEstimator_8cpp.html#a23c0623485ed9af765bab12ac424843c">Vector</a>    = <span class="keyword">typename</span> <a class="code hl_typedef" href="classDGtal_1_1HyperRectDomain.html#a132e9344848ac81fdeccf1e176be4cae">Domain::Vector</a>;</div>
<div class="line">  <span class="keyword">using </span><a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Value</a>     = TValue;</div>
<div class="line">  <span class="keyword">using </span><a class="code hl_struct" href="structFunctor.html">Functor</a>   = TFunctor;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Ranges and iterators</span></div>
<div class="line">  <span class="keyword">using </span><a class="code hl_typedef" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a> = boost::transform_iterator&lt; std::reference_wrapper&lt;const Self&gt;, <span class="keyword">typename</span> <a class="code hl_typedef" href="classDGtal_1_1HyperRectDomain.html#ad460a9309eb81ab5391a57f7d2a17055">Domain::ConstIterator</a> &gt;;</div>
<div class="line">  <span class="keyword">using </span><a class="code hl_typedef" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a02157fa9b645d454bfc9efcd4a9d8429">ConstReverseIterator</a> = boost::reverse_iterator&lt; ConstIterator &gt;;</div>
<div class="line">  <span class="keyword">class </span><a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a9c3b2a52e2ae40bddbe4046c1fe8f8ba">ConstRange</a>; <span class="comment">// To be defined...</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Constructor</span></div>
<div class="line">  <span class="keyword">template</span> &lt; <span class="keyword">class</span> TGivenFunctor &gt;</div>
<div class="line">  <span class="keyword">explicit</span> <a class="code hl_function" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a3dbe206c4f6aa733683273d9ca4610fa">ConstImageFunctorHolder</a>( <a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> <span class="keyword">const</span>&amp; aDomain, TGivenFunctor &amp;&amp; aFunctor )</div>
<div class="line">    : <a class="code hl_variable" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a7da68e4c222fcbe2f7bf31d569eee86e">myDomain</a>( aDomain )</div>
<div class="line">    , <a class="code hl_variable" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#ad340b962631f15f890e229600482fc7f">myFunctor</a>( <a class="code hl_namespace" href="namespacestd.html">std</a>::forward&lt;TGivenFunctor&gt;(aFunctor) )</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Return the associated domain.</span></div>
<div class="line">  <span class="keyword">inline</span> <a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> <span class="keyword">const</span>&amp; <a class="code hl_function" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a54cd42a8678997e520fc3bed1fe845ad">domain</a>()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">return</span> <a class="code hl_variable" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a7da68e4c222fcbe2f7bf31d569eee86e">myDomain</a>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a>  <a class="code hl_variable" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a7da68e4c222fcbe2f7bf31d569eee86e">myDomain</a>;</div>
<div class="line">  <a class="code hl_struct" href="structFunctor.html">Functor</a> <a class="code hl_variable" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#ad340b962631f15f890e229600482fc7f">myFunctor</a>;</div>
<div class="line">};</div>
<div class="ttc" id="aclassDGtal_1_1HyperRectDomain_html_a132e9344848ac81fdeccf1e176be4cae"><div class="ttname"><a href="classDGtal_1_1HyperRectDomain.html#a132e9344848ac81fdeccf1e176be4cae">DGtal::HyperRectDomain&lt; Space &gt;::Vector</a></div><div class="ttdeci">Space::Vector Vector</div><div class="ttdef"><b>Definition</b> <a href="HyperRectDomain_8h_source.html#l00115">HyperRectDomain.h:115</a></div></div>
<div class="ttc" id="aclassDGtal_1_1HyperRectDomain_html_ad460a9309eb81ab5391a57f7d2a17055"><div class="ttname"><a href="classDGtal_1_1HyperRectDomain.html#ad460a9309eb81ab5391a57f7d2a17055">DGtal::HyperRectDomain&lt; Space &gt;::ConstIterator</a></div><div class="ttdeci">Iterator ConstIterator</div><div class="ttdef"><b>Definition</b> <a href="HyperRectDomain_8h_source.html#l00125">HyperRectDomain.h:125</a></div></div>
<div class="ttc" id="aclassDGtal_1_1HyperRectDomain_html_ad710ac3a2d91d351b55ca6841cb789f5"><div class="ttname"><a href="classDGtal_1_1HyperRectDomain.html#ad710ac3a2d91d351b55ca6841cb789f5">DGtal::HyperRectDomain&lt; Space &gt;::Point</a></div><div class="ttdeci">Space::Point Point</div><div class="ttdef"><b>Definition</b> <a href="HyperRectDomain_8h_source.html#l00113">HyperRectDomain.h:113</a></div></div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1ConstImageFunctorHolder_html_a02157fa9b645d454bfc9efcd4a9d8429"><div class="ttname"><a href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a02157fa9b645d454bfc9efcd4a9d8429">DGtal::functors::ConstImageFunctorHolder::ConstReverseIterator</a></div><div class="ttdeci">boost::reverse_iterator&lt; ConstIterator &gt; ConstReverseIterator</div><div class="ttdef"><b>Definition</b> <a href="ConstImageFunctorHolder_8h_source.html#l00124">ConstImageFunctorHolder.h:124</a></div></div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1ConstImageFunctorHolder_html_a3dbe206c4f6aa733683273d9ca4610fa"><div class="ttname"><a href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a3dbe206c4f6aa733683273d9ca4610fa">DGtal::functors::ConstImageFunctorHolder::ConstImageFunctorHolder</a></div><div class="ttdeci">ConstImageFunctorHolder(Domain const &amp;aDomain, TGivenFunctor &amp;&amp;aFunctor)</div><div class="ttdoc">Constructor.</div><div class="ttdef"><b>Definition</b> <a href="ConstImageFunctorHolder_8h_source.html#l00144">ConstImageFunctorHolder.h:144</a></div></div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1ConstImageFunctorHolder_html_a54cd42a8678997e520fc3bed1fe845ad"><div class="ttname"><a href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a54cd42a8678997e520fc3bed1fe845ad">DGtal::functors::ConstImageFunctorHolder::domain</a></div><div class="ttdeci">Domain const &amp; domain() const</div><div class="ttdoc">Returns the associated domain.</div><div class="ttdef"><b>Definition</b> <a href="ConstImageFunctorHolder_8h_source.html#l00155">ConstImageFunctorHolder.h:155</a></div></div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1ConstImageFunctorHolder_html_a7da68e4c222fcbe2f7bf31d569eee86e"><div class="ttname"><a href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a7da68e4c222fcbe2f7bf31d569eee86e">DGtal::functors::ConstImageFunctorHolder::myDomain</a></div><div class="ttdeci">Domain myDomain</div><div class="ttdoc">The image domain.</div><div class="ttdef"><b>Definition</b> <a href="ConstImageFunctorHolder_8h_source.html#l00133">ConstImageFunctorHolder.h:133</a></div></div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1ConstImageFunctorHolder_html_a83322dad8065e2de6aadfd93b22fb88d"><div class="ttname"><a href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#a83322dad8065e2de6aadfd93b22fb88d">DGtal::functors::ConstImageFunctorHolder::Self</a></div><div class="ttdeci">ConstImageFunctorHolder&lt; TDomain, TValue, TFunctor &gt; Self</div><div class="ttdef"><b>Definition</b> <a href="ConstImageFunctorHolder_8h_source.html#l00112">ConstImageFunctorHolder.h:112</a></div></div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1ConstImageFunctorHolder_html_ad340b962631f15f890e229600482fc7f"><div class="ttname"><a href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#ad340b962631f15f890e229600482fc7f">DGtal::functors::ConstImageFunctorHolder::myFunctor</a></div><div class="ttdeci">Functor myFunctor</div><div class="ttdoc">The functor that generates the image.</div><div class="ttdef"><b>Definition</b> <a href="ConstImageFunctorHolder_8h_source.html#l00134">ConstImageFunctorHolder.h:134</a></div></div>
<div class="ttc" id="aexamplePlaneProbingParallelepipedEstimator_8cpp_html_a23c0623485ed9af765bab12ac424843c"><div class="ttname"><a href="examplePlaneProbingParallelepipedEstimator_8cpp.html#a23c0623485ed9af765bab12ac424843c">Vector</a></div><div class="ttdeci">DigitalPlane::Point Vector</div><div class="ttdef"><b>Definition</b> <a href="examplePlaneProbingParallelepipedEstimator_8cpp_source.html#l00045">examplePlaneProbingParallelepipedEstimator.cpp:45</a></div></div>
<div class="ttc" id="agreedy-plane-segmentation-ex2_8cpp_html_a6d06fad433cff067dfcbbbf16d6e2dbf"><div class="ttname"><a href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a></div><div class="ttdeci">MyDigitalSurface::ConstIterator ConstIterator</div><div class="ttdef"><b>Definition</b> <a href="greedy-plane-segmentation-ex2_8cpp_source.html#l00090">greedy-plane-segmentation-ex2.cpp:90</a></div></div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_a9c3b2a52e2ae40bddbe4046c1fe8f8ba"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a9c3b2a52e2ae40bddbe4046c1fe8f8ba">ConstRange</a></div><div class="ttdeci">Image::ConstRange ConstRange</div><div class="ttdef"><b>Definition</b> <a href="testSimpleRandomAccessRangeFromPoint_8cpp_source.html#l00047">testSimpleRandomAccessRangeFromPoint.cpp:47</a></div></div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_acd532b318489cd93df57e0b3d136d050"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a></div><div class="ttdeci">HyperRectDomain&lt; Space &gt; Domain</div><div class="ttdef"><b>Definition</b> <a href="testSimpleRandomAccessRangeFromPoint_8cpp_source.html#l00044">testSimpleRandomAccessRangeFromPoint.cpp:44</a></div></div>
</div><!-- fragment --><p>Note that using perfect forwarding in the constructor doesn't imply here to add SFINAE like in <a class="el" href="#pointfunctorholder_advanced_constructor">Perfect forwarding in the constructor</a> because a binary constructor cannot be choosen as a valid overload during a copy construction.</p>
<h3 class="doxsection"><a class="anchor" id="functorconstimage_helper"></a>
The helper (factory)</h3>
<p>The helper is very similar to the one introduced in <a class="el" href="#pointfunctorholder_helper">The helper (factory)</a>: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">typename</span> TValue,</div>
<div class="line">  <span class="keyword">typename</span> TDomain,</div>
<div class="line">  <span class="keyword">typename</span> TFunctor</div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span></div>
<div class="line"><a class="code hl_function" href="namespaceDGtal_1_1functors.html#ae078b1e517d167341988d5a5d6366a91">holdConstImageFunctor</a>( TDomain <span class="keyword">const</span>&amp; aDomain, TFunctor &amp;&amp; aFunctor )</div>
<div class="line">    -&gt; ConstImageFunctorHolder&lt;TDomain, TValue, decltype(holdFunctor(std::forward&lt;TFunctor&gt;(aFunctor)))&gt;</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> ConstImageFunctorHolder&lt;TDomain, TValue, decltype(holdFunctor(std::forward&lt;TFunctor&gt;(aFunctor)))&gt;{</div>
<div class="line">        aDomain, <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor))</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="ttc" id="anamespaceDGtal_1_1functors_html_ae078b1e517d167341988d5a5d6366a91"><div class="ttname"><a href="namespaceDGtal_1_1functors.html#ae078b1e517d167341988d5a5d6366a91">DGtal::functors::holdConstImageFunctor</a></div><div class="ttdeci">auto holdConstImageFunctor(TDomain const &amp;aDomain, TFunctor &amp;&amp;aFunctor) -&gt; ConstImageFunctorHolder&lt; TDomain, TValue, decltype(holdFunctor(std::forward&lt; TFunctor &gt;(aFunctor)))&gt;</div><div class="ttdoc">ConstImageFunctorHolder construction helper with specification of the return type.</div><div class="ttdef"><b>Definition</b> <a href="ConstImageFunctorHolder_8h_source.html#l00278">ConstImageFunctorHolder.h:278</a></div></div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="functorconstimage_evaluation"></a>
The evaluation operator</h3>
<p>Here, in order to take into account the fact that the held functor may by unary (accepting only a point) or binary (accepting a point and the image's domain), we must rely on the SFINAE trick explained in <a class="el" href="#pointfunctorholder_advanced_constructor">Perfect forwarding in the constructor</a> so that the compiler chooses the right implementation: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TPo<span class="keywordtype">int</span>&gt; <span class="comment">// Needed template parameter to enable SFINAE trick</span></div>
<div class="line"><span class="keyword">inline</span></div>
<div class="line"><span class="keyword">auto</span> operator() ( TPoint <span class="keyword">const</span>&amp; <a class="code hl_variable" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a2354f3606a9fc718d40aecabda7e9615">aPoint</a> ) <span class="keyword">const</span></div>
<div class="line">    -&gt; <span class="keyword">decltype</span>( myFunctor( <a class="code hl_variable" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a2354f3606a9fc718d40aecabda7e9615">aPoint</a> ) ) <span class="comment">// Using SFINAE to enable this overload for unary functor</span></div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> myFunctor( <a class="code hl_variable" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a2354f3606a9fc718d40aecabda7e9615">aPoint</a> );</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TPo<span class="keywordtype">int</span>&gt; <span class="comment">// Needed template parameter to enable SFINAE trick</span></div>
<div class="line"><span class="keyword">inline</span></div>
<div class="line"><span class="keyword">auto</span> operator() ( TPoint <span class="keyword">const</span>&amp; <a class="code hl_variable" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a2354f3606a9fc718d40aecabda7e9615">aPoint</a> ) <span class="keyword">const</span></div>
<div class="line">    -&gt; <span class="keyword">decltype</span>( myFunctor( <a class="code hl_variable" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a2354f3606a9fc718d40aecabda7e9615">aPoint</a>, myDomain ) ) <span class="comment">// Using SFINAE to enable this overload for binary functor</span></div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> myFunctor( <a class="code hl_variable" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a2354f3606a9fc718d40aecabda7e9615">aPoint</a>, myDomain );</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Here, the first overload is valid only if the <span class="tt">myFunctor(aPoint)</span> expression is valid, that is if the held functor is unary and accept a point as parameter. Likewise, the second overload is valid only if the functor is binary and accept a point as the first argument and a domain as the second argument.</p>
<dl class="section note"><dt>Note</dt><dd>If the functor is unary and binary at the same time, this will lead to a compilation error. However, if it makes sense to handle such functors, it is possible to prioritize the two overloads.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>SFINAE trick needs to know the <em class="arg">myDomain</em> member at the method declaration. Thus, it is important to declare <em class="arg">myDomain</em> before declaring the two overloads of <span class="tt">operator()</span>.</dd></dl>
<h3 class="doxsection"><a class="anchor" id="functorconstimage_advanced_helper"></a>
Auto-deducing the return type of the functor</h3>
<p>If you want to automatically deduce the <em class="arg">TValue</em> template parameter, the solution is quite similar to the one proposed in <a class="el" href="#pointfunctorholder_advanced_helper">Auto-deducing the return type of the functor</a> but in two versions, one for each possible arity of the given functor: </p><div class="fragment"><div class="line"><span class="comment">// Helper for a unary functor</span></div>
<div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">typename</span> TDomain,</div>
<div class="line">  <span class="keyword">typename</span> TFunctor</div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span></div>
<div class="line"><a class="code hl_function" href="namespaceDGtal_1_1functors.html#ae078b1e517d167341988d5a5d6366a91">holdConstImageFunctor</a>( TDomain <span class="keyword">const</span>&amp; aDomain, TFunctor &amp;&amp; aFunctor )</div>
<div class="line">    -&gt; ConstImageFunctorHolder&lt;</div>
<div class="line">          TDomain,</div>
<div class="line">          <span class="keyword">typename</span> std::decay&lt;decltype(aFunctor(std::declval&lt;typename TDomain::Point&gt;()))&gt;::type,</div>
<div class="line">          <span class="keyword">decltype</span>(<a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)))</div>
<div class="line">        &gt;</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> ConstImageFunctorHolder&lt;</div>
<div class="line">        TDomain,</div>
<div class="line">        <span class="keyword">typename</span> std::decay&lt;decltype(aFunctor(std::declval&lt;typename TDomain::Point&gt;()))&gt;::type,</div>
<div class="line">        <span class="keyword">decltype</span>(<a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)))</div>
<div class="line">      &gt;{ aDomain, <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)) };</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Helper for a binary functor</span></div>
<div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">  <span class="keyword">typename</span> TDomain,</div>
<div class="line">  <span class="keyword">typename</span> TFunctor</div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span></div>
<div class="line"><a class="code hl_function" href="namespaceDGtal_1_1functors.html#ae078b1e517d167341988d5a5d6366a91">holdConstImageFunctor</a>( TDomain <span class="keyword">const</span>&amp; aDomain, TFunctor &amp;&amp; aFunctor )</div>
<div class="line">    -&gt; ConstImageFunctorHolder&lt;</div>
<div class="line">          TDomain,</div>
<div class="line">          <span class="keyword">typename</span> std::decay&lt;decltype(aFunctor(std::declval&lt;typename TDomain::Point&gt;(), aDomain))&gt;::type,</div>
<div class="line">          <span class="keyword">decltype</span>(<a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)))</div>
<div class="line">        &gt;</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> ConstImageFunctorHolder&lt;</div>
<div class="line">        TDomain,</div>
<div class="line">        <span class="keyword">typename</span> std::decay&lt;decltype(aFunctor(std::declval&lt;typename TDomain::Point&gt;(), aDomain))&gt;::type,</div>
<div class="line">        <span class="keyword">decltype</span>(<a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)))</div>
<div class="line">      &gt;{ aDomain, <a class="code hl_function" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)) };</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Finally, an image can be easily defined from a functor with a syntax like: </p><div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> domain1(<a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(1,1), <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(16,16));</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> image1 = <a class="code hl_function" href="namespaceDGtal_1_1functors.html#ae078b1e517d167341988d5a5d6366a91">DGtal::functors::holdConstImageFunctor</a>(</div>
<div class="line">      domain1,</div>
<div class="line">      [] (<a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> <span class="keyword">const</span>&amp; pt) { <span class="keywordflow">return</span> 25 * ( std::cos( (pt - <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(4,4)).norm() ) + 1 ); }</div>
<div class="line">  );</div>
</div><!-- fragment --><p> resulting in: </p><div class="image">
<img src="ConstImageFunctorHolder_example1.png" alt=""/>
<div class="caption">
Image generated from a point-dependent lambda.</div></div>
 </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="index.html">DGtal - Digital Geometry Tools and Algorithms Library.</a></li><li class="navelem"><a href="packageBase.html">Base package</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for DGtal by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
