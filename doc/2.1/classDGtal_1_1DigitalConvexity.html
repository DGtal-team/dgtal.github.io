<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: DGtal::DigitalConvexity&lt; TKSpace &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;2.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classDGtal_1_1DigitalConvexity.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">DGtal::DigitalConvexity&lt; TKSpace &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Aim: <a class="el" href="structA.html">A</a> helper class to build polytopes from digital sets and to check digital k-convexity and full convexity.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="DigitalConvexity_8h_source.html">DGtal/geometry/volumes/DigitalConvexity.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DGtal::DigitalConvexity&lt; TKSpace &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="classDGtal_1_1DigitalConvexity__inherit__graph.svg" width="171" height="163"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9e2b772563ea30ed18152853163e2b4c" id="r_a9e2b772563ea30ed18152853163e2b4c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="#a5370d2b125f0a16d42cb646fa25e7b4d">DigitalConvexity</a>&lt; TKSpace &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e2b772563ea30ed18152853163e2b4c">Self</a></td></tr>
<tr class="memitem:a645bebee5bef19212d3c4328e9054ca3" id="r_a645bebee5bef19212d3c4328e9054ca3"><td class="memItemLeft" align="right" valign="top">typedef TKSpace&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a645bebee5bef19212d3c4328e9054ca3">KSpace</a></td></tr>
<tr class="memitem:abda40d4d7309cb343b799c6acd658c8f" id="r_abda40d4d7309cb343b799c6acd658c8f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a1101d4adbc2a87db33afcb42209b6f04">KSpace::Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abda40d4d7309cb343b799c6acd658c8f">Integer</a></td></tr>
<tr class="memitem:a872846f72d723e634ba406584a4e0db9" id="r_a872846f72d723e634ba406584a4e0db9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a70d1b8007551de58a7b8ccee328bed00">KSpace::Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a></td></tr>
<tr class="memitem:a0fb2995953a0d6d85c48704065bad6ac" id="r_a0fb2995953a0d6d85c48704065bad6ac"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ad73ce442a5ecb094572646903f561cd2">KSpace::Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fb2995953a0d6d85c48704065bad6ac">Vector</a></td></tr>
<tr class="memitem:a27904f1cb66cc2f0723a23673a62be75" id="r_a27904f1cb66cc2f0723a23673a62be75"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#af87a8fec76262bec1a3b33881fa38f1f">KSpace::Cell</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27904f1cb66cc2f0723a23673a62be75">Cell</a></td></tr>
<tr class="memitem:ae8b5e2363e6fa2711516d6790b4491d2" id="r_ae8b5e2363e6fa2711516d6790b4491d2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ab2215bc032ca075e029b33eaf129feec">KSpace::Space</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8b5e2363e6fa2711516d6790b4491d2">Space</a></td></tr>
<tr class="memitem:aeaefb58e537bffc356950285789f3b54" id="r_aeaefb58e537bffc356950285789f3b54"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeaefb58e537bffc356950285789f3b54">Size</a></td></tr>
<tr class="memitem:af385f66bfd58c7ff172c00fa7bd6f506" id="r_af385f66bfd58c7ff172c00fa7bd6f506"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">DGtal::BoundedLatticePolytope</a>&lt; <a class="el" href="#ae8b5e2363e6fa2711516d6790b4491d2">Space</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af385f66bfd58c7ff172c00fa7bd6f506">Polytope</a></td></tr>
<tr class="memitem:aae900cf944b90e595dedd3b73be31f4e" id="r_aae900cf944b90e595dedd3b73be31f4e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">DGtal::BoundedLatticePolytope</a>&lt; <a class="el" href="#ae8b5e2363e6fa2711516d6790b4491d2">Space</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a></td></tr>
<tr class="memitem:a796d52417c67dda07012d3d954db973a" id="r_a796d52417c67dda07012d3d954db973a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">DGtal::BoundedRationalPolytope</a>&lt; <a class="el" href="#ae8b5e2363e6fa2711516d6790b4491d2">Space</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a796d52417c67dda07012d3d954db973a">RationalPolytope</a></td></tr>
<tr class="memitem:a7d43e151b418e62ff4afe64fae751986" id="r_a7d43e151b418e62ff4afe64fae751986"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classDGtal_1_1CellGeometry.html">DGtal::CellGeometry</a>&lt; <a class="el" href="#a645bebee5bef19212d3c4328e9054ca3">KSpace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d43e151b418e62ff4afe64fae751986">CellGeometry</a></td></tr>
<tr class="memitem:a6ca2be6c9d11457094c57044df502040" id="r_a6ca2be6c9d11457094c57044df502040"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a></td></tr>
<tr class="memitem:abafff2559e37c61d30f888324a85ff09" id="r_abafff2559e37c61d30f888324a85ff09"><td class="memItemLeft" align="right" valign="top">typedef std::unordered_set&lt; <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abafff2559e37c61d30f888324a85ff09">PointSet</a></td></tr>
<tr class="memitem:aed802707b26b5d46af8bea7ddaf62120" id="r_aed802707b26b5d46af8bea7ddaf62120"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classDGtal_1_1BoundedLatticePolytopeCounter.html">DGtal::BoundedLatticePolytopeCounter</a>&lt; <a class="el" href="#ae8b5e2363e6fa2711516d6790b4491d2">Space</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed802707b26b5d46af8bea7ddaf62120">Counter</a></td></tr>
<tr class="memitem:a73270b9de14411262d459879edcceedd" id="r_a73270b9de14411262d459879edcceedd"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classDGtal_1_1BoundedLatticePolytopeCounter.html#adeaeda543e323378dbb7f7f43797b00d">Counter::Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73270b9de14411262d459879edcceedd">Interval</a></td></tr>
<tr class="memitem:aab180574b64e761af7f666d855e952ad" id="r_aab180574b64e761af7f666d855e952ad"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classDGtal_1_1LatticeSetByIntervals.html">DGtal::LatticeSetByIntervals</a>&lt; <a class="el" href="#ae8b5e2363e6fa2711516d6790b4491d2">Space</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Standard services (construction, initialization, assignment)</div></td></tr>
<tr class="memitem:af0c48f6a56644a168d420871e9c42802" id="r_af0c48f6a56644a168d420871e9c42802"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0c48f6a56644a168d420871e9c42802">~DigitalConvexity</a> ()=default</td></tr>
<tr class="memitem:a5370d2b125f0a16d42cb646fa25e7b4d" id="r_a5370d2b125f0a16d42cb646fa25e7b4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5370d2b125f0a16d42cb646fa25e7b4d">DigitalConvexity</a> ()=default</td></tr>
<tr class="memitem:a41e261ca030aabb291bd6a2be87e11f8" id="r_a41e261ca030aabb291bd6a2be87e11f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41e261ca030aabb291bd6a2be87e11f8">DigitalConvexity</a> (const <a class="el" href="#a9e2b772563ea30ed18152853163e2b4c">Self</a> &amp;other)=default</td></tr>
<tr class="memitem:a75f106982cd96699ad78dff64d8e5efc" id="r_a75f106982cd96699ad78dff64d8e5efc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75f106982cd96699ad78dff64d8e5efc">DigitalConvexity</a> (<a class="el" href="classDGtal_1_1Clone.html">Clone</a>&lt; <a class="el" href="#a645bebee5bef19212d3c4328e9054ca3">KSpace</a> &gt; <a class="el" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, bool safe=false)</td></tr>
<tr class="memitem:aae4b831c3b47b6b5ce7c0c069b0875cc" id="r_aae4b831c3b47b6b5ce7c0c069b0875cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae4b831c3b47b6b5ce7c0c069b0875cc">DigitalConvexity</a> (<a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> lo, <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> hi, bool safe=false)</td></tr>
<tr class="memitem:aa408ee883fd42069e0b4500e0e651b1b" id="r_aa408ee883fd42069e0b4500e0e651b1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a9e2b772563ea30ed18152853163e2b4c">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa408ee883fd42069e0b4500e0e651b1b">operator=</a> (const <a class="el" href="#a9e2b772563ea30ed18152853163e2b4c">Self</a> &amp;other)=default</td></tr>
<tr class="memitem:af1b96331550862a751ee769060041f2b" id="r_af1b96331550862a751ee769060041f2b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a645bebee5bef19212d3c4328e9054ca3">KSpace</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1b96331550862a751ee769060041f2b">space</a> () const</td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Cell geometry services</div></td></tr>
<tr class="memitem:af588213a1371bc38f45973ef3fc331f4" id="r_af588213a1371bc38f45973ef3fc331f4"><td class="memTemplParams" colspan="2">template&lt;typename PointIterator&gt; </td></tr>
<tr class="memitem:af588213a1371bc38f45973ef3fc331f4 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7d43e151b418e62ff4afe64fae751986">CellGeometry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af588213a1371bc38f45973ef3fc331f4">makeCellCover</a> (PointIterator itB, PointIterator itE, <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> i=0, <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> k=<a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae2b2dcf34c36a5e3eae4bf13291f1578">KSpace::dimension</a>) const</td></tr>
<tr class="memitem:a8c6af4cccb2953fa776865635baa59e6" id="r_a8c6af4cccb2953fa776865635baa59e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7d43e151b418e62ff4afe64fae751986">CellGeometry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c6af4cccb2953fa776865635baa59e6">makeCellCover</a> (const <a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a> &amp;P, <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> i=0, <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> k=<a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae2b2dcf34c36a5e3eae4bf13291f1578">KSpace::dimension</a>) const</td></tr>
<tr class="memitem:a66b3ed08c90a988c3291d224abd9f5bc" id="r_a66b3ed08c90a988c3291d224abd9f5bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7d43e151b418e62ff4afe64fae751986">CellGeometry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66b3ed08c90a988c3291d224abd9f5bc">makeCellCover</a> (const <a class="el" href="#a796d52417c67dda07012d3d954db973a">RationalPolytope</a> &amp;P, <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> i=0, <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> k=<a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae2b2dcf34c36a5e3eae4bf13291f1578">KSpace::dimension</a>) const</td></tr>
<tr id="pub-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Morphological services</div></td></tr>
<tr class="memitem:af4528961df07c0a68287a7744c93e22f" id="r_af4528961df07c0a68287a7744c93e22f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4528961df07c0a68287a7744c93e22f">makePolytope</a> (const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;X, bool make_minkowski_summable=false) const</td></tr>
<tr class="memitem:a302be61022a992c9ddc6c0b8b3f11735" id="r_a302be61022a992c9ddc6c0b8b3f11735"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a302be61022a992c9ddc6c0b8b3f11735">U</a> (<a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> i, const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;X) const</td></tr>
<tr class="memitem:a4b5bf83b01cd9b62e92cc2572e8df5a8" id="r_a4b5bf83b01cd9b62e92cc2572e8df5a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b5bf83b01cd9b62e92cc2572e8df5a8">is0Convex</a> (const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;X) const</td></tr>
<tr class="memitem:a3cd5bd9f858176e274f5320674ca2026" id="r_a3cd5bd9f858176e274f5320674ca2026"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cd5bd9f858176e274f5320674ca2026">isFullyConvex</a> (const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;X, bool convex0=false) const</td></tr>
<tr class="memitem:a3b7d5a39596ba6d88525ce46b0755ccf" id="r_a3b7d5a39596ba6d88525ce46b0755ccf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b7d5a39596ba6d88525ce46b0755ccf">isFullyConvexFast</a> (const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;X) const</td></tr>
<tr class="memitem:abb35a70653904c9ca2b308221ff70565" id="r_abb35a70653904c9ca2b308221ff70565"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb35a70653904c9ca2b308221ff70565">isFullySubconvex</a> (const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;Y, const <a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> &amp;StarX) const</td></tr>
<tr class="memitem:a5735d8c593127d6467ba9f78ccad23b4" id="r_a5735d8c593127d6467ba9f78ccad23b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5735d8c593127d6467ba9f78ccad23b4">isFullySubconvex</a> (const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;a, const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;b, const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;c, const <a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> &amp;StarX) const</td></tr>
<tr class="memitem:a0e3e22c3d6898ec1453cec5c98023587" id="r_a0e3e22c3d6898ec1453cec5c98023587"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e3e22c3d6898ec1453cec5c98023587">isFullyCovered</a> (const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;a, const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;b, const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;c, const <a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> &amp;cells) const</td></tr>
<tr class="memitem:a58b461f84cc13a0f21c5c9ee5e9c031d" id="r_a58b461f84cc13a0f21c5c9ee5e9c031d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58b461f84cc13a0f21c5c9ee5e9c031d">isFullyCovered</a> (const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;a, const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;b, const <a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> &amp;cells) const</td></tr>
<tr class="memitem:afd802e9db0008dc0bc6cb07c1ac023e8" id="r_afd802e9db0008dc0bc6cb07c1ac023e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd802e9db0008dc0bc6cb07c1ac023e8">isOpenTriangleFullySubconvex</a> (const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;a, const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;b, const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;c, const <a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> &amp;StarX) const</td></tr>
<tr class="memitem:a9a691e049c521f4ee81d365ea82e23dd" id="r_a9a691e049c521f4ee81d365ea82e23dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a691e049c521f4ee81d365ea82e23dd">isKSubconvex</a> (const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;a, const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;b, const <a class="el" href="#a7d43e151b418e62ff4afe64fae751986">CellGeometry</a> &amp;C, const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> k) const</td></tr>
<tr class="memitem:a494195664f3c6e6fce305df9f152315c" id="r_a494195664f3c6e6fce305df9f152315c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a494195664f3c6e6fce305df9f152315c">isFullySubconvex</a> (const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;a, const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;b, const <a class="el" href="#a7d43e151b418e62ff4afe64fae751986">CellGeometry</a> &amp;C) const</td></tr>
<tr class="memitem:a7cb0abf0fbcc02387ac64f932cb3148a" id="r_a7cb0abf0fbcc02387ac64f932cb3148a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cb0abf0fbcc02387ac64f932cb3148a">isFullySubconvex</a> (const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;a, const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;b, const <a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> &amp;StarX) const</td></tr>
<tr class="memitem:a3bfa3e199bb8c80908fedee176898c30" id="r_a3bfa3e199bb8c80908fedee176898c30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bfa3e199bb8c80908fedee176898c30">CvxH</a> (const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;X) const</td></tr>
<tr class="memitem:a472d893d2d1736c7fc662a39f0756179" id="r_a472d893d2d1736c7fc662a39f0756179"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a472d893d2d1736c7fc662a39f0756179">ExtrCvxH</a> (const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;X) const</td></tr>
<tr class="memitem:abd689cce05efc14754c8aceb90159be9" id="r_abd689cce05efc14754c8aceb90159be9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd689cce05efc14754c8aceb90159be9">StarCvxH</a> (const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;X, <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> axis=<a class="el" href="#a83a99607075cb1757245a62b71a36a49">dimension</a>) const</td></tr>
<tr class="memitem:a0623dcc5e54f21ea53a84248a864f619" id="r_a0623dcc5e54f21ea53a84248a864f619"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0623dcc5e54f21ea53a84248a864f619">StarCvxH</a> (const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;a, const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;b, const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;c, <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> axis=<a class="el" href="#a83a99607075cb1757245a62b71a36a49">dimension</a>) const</td></tr>
<tr class="memitem:a76ba6cf1955ac564030adc2081763ac9" id="r_a76ba6cf1955ac564030adc2081763ac9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76ba6cf1955ac564030adc2081763ac9">StarOpenTriangle</a> (const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;a, const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;b, const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;c, <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> axis=<a class="el" href="#a83a99607075cb1757245a62b71a36a49">dimension</a>) const</td></tr>
<tr class="memitem:a351ac0c6f16600fae5f1cd89a438c936" id="r_a351ac0c6f16600fae5f1cd89a438c936"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#abda40d4d7309cb343b799c6acd658c8f">Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a351ac0c6f16600fae5f1cd89a438c936">sizeStarCvxH</a> (const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;X) const</td></tr>
<tr class="memitem:a2029a6225cad0c5db0f6334ed2833a9f" id="r_a2029a6225cad0c5db0f6334ed2833a9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2029a6225cad0c5db0f6334ed2833a9f">Star</a> (const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;X, <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> axis=<a class="el" href="#a83a99607075cb1757245a62b71a36a49">dimension</a>) const</td></tr>
<tr class="memitem:a245ed38f44d5bb34b8693b052f4a9105" id="r_a245ed38f44d5bb34b8693b052f4a9105"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a245ed38f44d5bb34b8693b052f4a9105">StarCells</a> (const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;C, <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> axis=<a class="el" href="#a83a99607075cb1757245a62b71a36a49">dimension</a>) const</td></tr>
<tr class="memitem:a5f8e046968925ce2b36313e6a97b6382" id="r_a5f8e046968925ce2b36313e6a97b6382"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f8e046968925ce2b36313e6a97b6382">Extr</a> (const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;C) const</td></tr>
<tr class="memitem:a07b4850daa74067d742ef16e54d68d12" id="r_a07b4850daa74067d742ef16e54d68d12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07b4850daa74067d742ef16e54d68d12">Extr</a> (const <a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> &amp;C) const</td></tr>
<tr class="memitem:ab60b6a17f4d1defa5a720ec14eb86ec6" id="r_ab60b6a17f4d1defa5a720ec14eb86ec6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab60b6a17f4d1defa5a720ec14eb86ec6">Skel</a> (const <a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> &amp;C) const</td></tr>
<tr class="memitem:ace8e05ee36ff537409e7d37c09264bb4" id="r_ace8e05ee36ff537409e7d37c09264bb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace8e05ee36ff537409e7d37c09264bb4">ExtrSkel</a> (const <a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> &amp;C) const</td></tr>
<tr class="memitem:ab7677f3e5eabebf589500dadb3043149" id="r_ab7677f3e5eabebf589500dadb3043149"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7677f3e5eabebf589500dadb3043149">CoverCvxH</a> (const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;a, const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;b, <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> axis=<a class="el" href="#a83a99607075cb1757245a62b71a36a49">dimension</a>) const</td></tr>
<tr class="memitem:ac20d0b1fd677da8c1636e5ba2498dcd1" id="r_ac20d0b1fd677da8c1636e5ba2498dcd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac20d0b1fd677da8c1636e5ba2498dcd1">CoverCvxH</a> (const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;a, const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;b, const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;c, <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> axis=<a class="el" href="#a83a99607075cb1757245a62b71a36a49">dimension</a>) const</td></tr>
<tr class="memitem:a0cf6fcb3429bc769113e428ba3bb80ca" id="r_a0cf6fcb3429bc769113e428ba3bb80ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cf6fcb3429bc769113e428ba3bb80ca">toLatticeSet</a> (const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;X, <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> axis=<a class="el" href="#a83a99607075cb1757245a62b71a36a49">dimension</a>) const</td></tr>
<tr class="memitem:aa5d8709b29cfef087f56f04e1f33a8ac" id="r_aa5d8709b29cfef087f56f04e1f33a8ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5d8709b29cfef087f56f04e1f33a8ac">toPointRange</a> (const <a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> &amp;L) const</td></tr>
<tr id="pub-methods-3" class="groupHeader"><td colspan="2"><div class="groupHeader">Convexity services for lattice polytopes</div></td></tr>
<tr class="memitem:a1c68ee37d58620cf8e70f901f86cea5c" id="r_a1c68ee37d58620cf8e70f901f86cea5c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c68ee37d58620cf8e70f901f86cea5c">isKConvex</a> (const <a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a> &amp;P, const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> k) const</td></tr>
<tr class="memitem:a7d2a2137cf7d22c982b7c73c68ec6094" id="r_a7d2a2137cf7d22c982b7c73c68ec6094"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d2a2137cf7d22c982b7c73c68ec6094">isFullyConvex</a> (const <a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a> &amp;P) const</td></tr>
<tr class="memitem:a8ad8e913928fa3ea5629512a8c93a38c" id="r_a8ad8e913928fa3ea5629512a8c93a38c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ad8e913928fa3ea5629512a8c93a38c">isKSubconvex</a> (const <a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a> &amp;P, const <a class="el" href="#a7d43e151b418e62ff4afe64fae751986">CellGeometry</a> &amp;C, const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> k) const</td></tr>
<tr class="memitem:ab85164421d1ec12169837162aaee0529" id="r_ab85164421d1ec12169837162aaee0529"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab85164421d1ec12169837162aaee0529">isFullySubconvex</a> (const <a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a> &amp;P, const <a class="el" href="#a7d43e151b418e62ff4afe64fae751986">CellGeometry</a> &amp;C) const</td></tr>
<tr class="memitem:ab17ce84b1c830185002c5e52bd00c942" id="r_ab17ce84b1c830185002c5e52bd00c942"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab17ce84b1c830185002c5e52bd00c942">isFullySubconvex</a> (const <a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a> &amp;P, const <a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> &amp;StarX) const</td></tr>
<tr id="pub-methods-4" class="groupHeader"><td colspan="2"><div class="groupHeader">Convexity services for rational polytopes</div></td></tr>
<tr class="memitem:aa00aac6781df4daf05b243364f8e0505" id="r_aa00aac6781df4daf05b243364f8e0505"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa00aac6781df4daf05b243364f8e0505">isKConvex</a> (const <a class="el" href="#a796d52417c67dda07012d3d954db973a">RationalPolytope</a> &amp;P, const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> k) const</td></tr>
<tr class="memitem:a113c4e885d5d16ec663b9e7e8b8da86c" id="r_a113c4e885d5d16ec663b9e7e8b8da86c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a113c4e885d5d16ec663b9e7e8b8da86c">isFullyConvex</a> (const <a class="el" href="#a796d52417c67dda07012d3d954db973a">RationalPolytope</a> &amp;P) const</td></tr>
<tr class="memitem:a7d4c10d94e7311186e4f39850d1f99fb" id="r_a7d4c10d94e7311186e4f39850d1f99fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d4c10d94e7311186e4f39850d1f99fb">isKSubconvex</a> (const <a class="el" href="#a796d52417c67dda07012d3d954db973a">RationalPolytope</a> &amp;P, const <a class="el" href="#a7d43e151b418e62ff4afe64fae751986">CellGeometry</a> &amp;C, const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> k) const</td></tr>
<tr class="memitem:a8d858c7d041cd58235e41554469699bd" id="r_a8d858c7d041cd58235e41554469699bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d858c7d041cd58235e41554469699bd">isFullySubconvex</a> (const <a class="el" href="#a796d52417c67dda07012d3d954db973a">RationalPolytope</a> &amp;P, const <a class="el" href="#a7d43e151b418e62ff4afe64fae751986">CellGeometry</a> &amp;C) const</td></tr>
<tr id="pub-methods-5" class="groupHeader"><td colspan="2"><div class="groupHeader">Interface services</div></td></tr>
<tr class="memitem:ab94e882cab27e98d281885f08b21acad" id="r_ab94e882cab27e98d281885f08b21acad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab94e882cab27e98d281885f08b21acad">selfDisplay</a> (std::ostream &amp;out) const</td></tr>
<tr class="memitem:a737413cf5fcf1ce26dba45348ca71071" id="r_a737413cf5fcf1ce26dba45348ca71071"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a737413cf5fcf1ce26dba45348ca71071">isValid</a> () const</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr id="pub-static-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Lattice and rational polytope services</div></td></tr>
<tr class="memitem:a02884b4960ea77330822c7b3d5b10444" id="r_a02884b4960ea77330822c7b3d5b10444"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02884b4960ea77330822c7b3d5b10444">insidePoints</a> (const <a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a> &amp;polytope)</td></tr>
<tr class="memitem:afe2a661668dc2d1837d93a86d685437f" id="r_afe2a661668dc2d1837d93a86d685437f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe2a661668dc2d1837d93a86d685437f">interiorPoints</a> (const <a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a> &amp;polytope)</td></tr>
<tr class="memitem:a8d5f960ea09389c2240db46f1f42e4ee" id="r_a8d5f960ea09389c2240db46f1f42e4ee"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d5f960ea09389c2240db46f1f42e4ee">insidePoints</a> (const <a class="el" href="#a796d52417c67dda07012d3d954db973a">RationalPolytope</a> &amp;polytope)</td></tr>
<tr class="memitem:a80247137d0189aec3785e3677c91d89f" id="r_a80247137d0189aec3785e3677c91d89f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80247137d0189aec3785e3677c91d89f">interiorPoints</a> (const <a class="el" href="#a796d52417c67dda07012d3d954db973a">RationalPolytope</a> &amp;polytope)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a83a99607075cb1757245a62b71a36a49" id="r_a83a99607075cb1757245a62b71a36a49"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83a99607075cb1757245a62b71a36a49">dimension</a> = <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae2b2dcf34c36a5e3eae4bf13291f1578">KSpace::dimension</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-attribs" class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ade0ce0fbf443414698b879b9c92ef685" id="r_ade0ce0fbf443414698b879b9c92ef685"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bebee5bef19212d3c4328e9054ca3">KSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade0ce0fbf443414698b879b9c92ef685">myK</a></td></tr>
<tr class="memdesc:ade0ce0fbf443414698b879b9c92ef685"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cellular grid space where computations are done.  <br /></td></tr>
<tr class="memitem:ab66399583bfd6e03d765d9644611553c" id="r_ab66399583bfd6e03d765d9644611553c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab66399583bfd6e03d765d9644611553c">mySafe</a></td></tr>
<tr class="memitem:a6540a3cdf5bb2615fff664801802be80" id="r_a6540a3cdf5bb2615fff664801802be80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aeaefb58e537bffc356950285789f3b54">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6540a3cdf5bb2615fff664801802be80">myDepthLastFCE</a></td></tr>
<tr class="memdesc:a6540a3cdf5bb2615fff664801802be80"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of iterations of the last FullyConvexEnvelope operation.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pri-methods" class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a8db8f871dfd94f6db7022681c0c745cc" id="r_a8db8f871dfd94f6db7022681c0c745cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8db8f871dfd94f6db7022681c0c745cc">BOOST_CONCEPT_ASSERT</a> ((<a class="el" href="structDGtal_1_1concepts_1_1CCellularGridSpaceND.html">concepts::CCellularGridSpaceND</a>&lt; TKSpace &gt;))</td></tr>
<tr class="memitem:ad7f77e98ad81d47bd394d27a9f942e9d" id="r_ad7f77e98ad81d47bd394d27a9f942e9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7f77e98ad81d47bd394d27a9f942e9d">FC_direct</a> (const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;Z) const</td></tr>
<tr class="memitem:a37662e560f356365d4f64b3a59c7b608" id="r_a37662e560f356365d4f64b3a59c7b608"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37662e560f356365d4f64b3a59c7b608">FC_LatticeSet</a> (const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;Z) const</td></tr>
<tr class="memitem:a9060e94977f81c9475f8eee040c2beeb" id="r_a9060e94977f81c9475f8eee040c2beeb"><td class="memTemplParams" colspan="2">template&lt;typename TPolytope&gt; </td></tr>
<tr class="memitem:a9060e94977f81c9475f8eee040c2beeb template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9060e94977f81c9475f8eee040c2beeb">CoverPolytope</a> (const TPolytope &amp;P, <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> axis=<a class="el" href="#a83a99607075cb1757245a62b71a36a49">dimension</a>) const</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pri-static-methods" class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a54760af00e24bbb36ee7ce58b1702f92" id="r_a54760af00e24bbb36ee7ce58b1702f92"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54760af00e24bbb36ee7ce58b1702f92">eraseInterval</a> (<a class="el" href="#a73270b9de14411262d459879edcceedd">Interval</a> I, std::vector&lt; <a class="el" href="#a73270b9de14411262d459879edcceedd">Interval</a> &gt; &amp;V)</td></tr>
<tr class="memitem:aa937d026c2ad247965577c32e66708dc" id="r_aa937d026c2ad247965577c32e66708dc"><td class="memTemplParams" colspan="2">template&lt;typename Predicate&gt; </td></tr>
<tr class="memitem:aa937d026c2ad247965577c32e66708dc template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa937d026c2ad247965577c32e66708dc">filter</a> (const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;E, const Predicate &amp;Pred)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Simplex services</h2></td></tr>
<tr class="memitem:a346b3d21e164cc7d12d1b1c1ed1c0ccc" id="r_a346b3d21e164cc7d12d1b1c1ed1c0ccc"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a346b3d21e164cc7d12d1b1c1ed1c0ccc">SimplexType</a> { <a class="el" href="#a346b3d21e164cc7d12d1b1c1ed1c0cccaccc0377a8afbf50e7094f5c23a8af223">INVALID</a>
, <a class="el" href="#a346b3d21e164cc7d12d1b1c1ed1c0cccaf4e099c113130fefb383bf30511991a3">DEGENERATED</a>
, <a class="el" href="#a346b3d21e164cc7d12d1b1c1ed1c0ccca90bf49c52ada611f7d9892cab80c310f">UNITARY</a>
, <a class="el" href="#a346b3d21e164cc7d12d1b1c1ed1c0cccadda4b7de10e14445366494f0a76e1435">COMMON</a>
 }</td></tr>
<tr class="memdesc:a346b3d21e164cc7d12d1b1c1ed1c0ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible types for simplices.  <a href="#a346b3d21e164cc7d12d1b1c1ed1c0ccc">More...</a><br /></td></tr>
<tr class="memitem:a1f7509afa782b4513656ac5600cba55d" id="r_a1f7509afa782b4513656ac5600cba55d"><td class="memTemplParams" colspan="2">template&lt;typename PointIterator&gt; </td></tr>
<tr class="memitem:a1f7509afa782b4513656ac5600cba55d template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f7509afa782b4513656ac5600cba55d">makeSimplex</a> (PointIterator itB, PointIterator itE)</td></tr>
<tr class="memitem:a4a42d3bcb8d7eb9837aa73b977cbc7f5" id="r_a4a42d3bcb8d7eb9837aa73b977cbc7f5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a42d3bcb8d7eb9837aa73b977cbc7f5">makeSimplex</a> (std::initializer_list&lt; <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &gt; l)</td></tr>
<tr class="memitem:a03423890027c65b5d42ec327fd251c53" id="r_a03423890027c65b5d42ec327fd251c53"><td class="memTemplParams" colspan="2">template&lt;typename PointIterator&gt; </td></tr>
<tr class="memitem:a03423890027c65b5d42ec327fd251c53 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a796d52417c67dda07012d3d954db973a">RationalPolytope</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03423890027c65b5d42ec327fd251c53">makeRationalSimplex</a> (<a class="el" href="#abda40d4d7309cb343b799c6acd658c8f">Integer</a> d, PointIterator itB, PointIterator itE)</td></tr>
<tr class="memitem:a6943f4ca052e4badf5b12e7ab4180d55" id="r_a6943f4ca052e4badf5b12e7ab4180d55"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a796d52417c67dda07012d3d954db973a">RationalPolytope</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6943f4ca052e4badf5b12e7ab4180d55">makeRationalSimplex</a> (std::initializer_list&lt; <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &gt; l)</td></tr>
<tr class="memitem:a1d6b24ed0bb76b2290b5fcf899a01ce0" id="r_a1d6b24ed0bb76b2290b5fcf899a01ce0"><td class="memTemplParams" colspan="2">template&lt;typename PointIterator&gt; </td></tr>
<tr class="memitem:a1d6b24ed0bb76b2290b5fcf899a01ce0 template"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d6b24ed0bb76b2290b5fcf899a01ce0">isSimplexFullDimensional</a> (PointIterator itB, PointIterator itE)</td></tr>
<tr class="memitem:a0ae6751cef9f9f86499988b66e07af87" id="r_a0ae6751cef9f9f86499988b66e07af87"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ae6751cef9f9f86499988b66e07af87">isSimplexFullDimensional</a> (std::initializer_list&lt; <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &gt; l)</td></tr>
<tr class="memitem:af64332b6960ab4b06ee86afd022a71f8" id="r_af64332b6960ab4b06ee86afd022a71f8"><td class="memTemplParams" colspan="2">template&lt;typename PointIterator&gt; </td></tr>
<tr class="memitem:af64332b6960ab4b06ee86afd022a71f8 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a346b3d21e164cc7d12d1b1c1ed1c0ccc">SimplexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af64332b6960ab4b06ee86afd022a71f8">simplexType</a> (PointIterator itB, PointIterator itE)</td></tr>
<tr class="memitem:a369ba759d761f6f53c5a171b6b8f9c40" id="r_a369ba759d761f6f53c5a171b6b8f9c40"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a346b3d21e164cc7d12d1b1c1ed1c0ccc">SimplexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a369ba759d761f6f53c5a171b6b8f9c40">simplexType</a> (std::initializer_list&lt; <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &gt; l)</td></tr>
<tr class="memitem:a3af7c3766f87499faeb68d43b1bc439c" id="r_a3af7c3766f87499faeb68d43b1bc439c"><td class="memTemplParams" colspan="2">template&lt;typename PointIterator&gt; </td></tr>
<tr class="memitem:a3af7c3766f87499faeb68d43b1bc439c template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3af7c3766f87499faeb68d43b1bc439c">displaySimplex</a> (std::ostream &amp;out, PointIterator itB, PointIterator itE)</td></tr>
<tr class="memitem:ad47e66a9e3989a826cfd09c07cb8b344" id="r_ad47e66a9e3989a826cfd09c07cb8b344"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad47e66a9e3989a826cfd09c07cb8b344">displaySimplex</a> (std::ostream &amp;out, std::initializer_list&lt; <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &gt; l)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Convex envelope services</h2></td></tr>
<tr class="memitem:a014a1aa8d9e98f13bf9610aaf75832bb" id="r_a014a1aa8d9e98f13bf9610aaf75832bb"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a014a1aa8d9e98f13bf9610aaf75832bb">EnvelopeAlgorithm</a> { <a class="el" href="#a014a1aa8d9e98f13bf9610aaf75832bba4c5d06b02c97731aaa976179c62dcf76">DIRECT</a>
, <a class="el" href="#a014a1aa8d9e98f13bf9610aaf75832bbaf8c3cb52426b5b81178667bd0a3bf6f0">LATTICE_SET</a>
 }</td></tr>
<tr class="memitem:a15bbab0bbc615f5088fa767efd41819f" id="r_a15bbab0bbc615f5088fa767efd41819f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15bbab0bbc615f5088fa767efd41819f">FC</a> (const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;Z, <a class="el" href="#a014a1aa8d9e98f13bf9610aaf75832bb">EnvelopeAlgorithm</a> algo=<a class="el" href="#a014a1aa8d9e98f13bf9610aaf75832bba4c5d06b02c97731aaa976179c62dcf76">EnvelopeAlgorithm::DIRECT</a>) const</td></tr>
<tr class="memitem:a8c1f8c406bf52d7654ebdcd91542e107" id="r_a8c1f8c406bf52d7654ebdcd91542e107"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c1f8c406bf52d7654ebdcd91542e107">envelope</a> (const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;Z, <a class="el" href="#a014a1aa8d9e98f13bf9610aaf75832bb">EnvelopeAlgorithm</a> algo=<a class="el" href="#a014a1aa8d9e98f13bf9610aaf75832bba4c5d06b02c97731aaa976179c62dcf76">EnvelopeAlgorithm::DIRECT</a>) const</td></tr>
<tr class="memitem:a94893f395ee00f8bd8d8b5c964ab28ce" id="r_a94893f395ee00f8bd8d8b5c964ab28ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94893f395ee00f8bd8d8b5c964ab28ce">relativeEnvelope</a> (const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;Z, const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;Y, <a class="el" href="#a014a1aa8d9e98f13bf9610aaf75832bb">EnvelopeAlgorithm</a> algo=<a class="el" href="#a014a1aa8d9e98f13bf9610aaf75832bba4c5d06b02c97731aaa976179c62dcf76">EnvelopeAlgorithm::DIRECT</a>) const</td></tr>
<tr class="memitem:a82c3e8fb60c0ace35bc1a4bb5632ee53" id="r_a82c3e8fb60c0ace35bc1a4bb5632ee53"><td class="memTemplParams" colspan="2">template&lt;typename Predicate&gt; </td></tr>
<tr class="memitem:a82c3e8fb60c0ace35bc1a4bb5632ee53 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82c3e8fb60c0ace35bc1a4bb5632ee53">relativeEnvelope</a> (const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;Z, const Predicate &amp;PredY, <a class="el" href="#a014a1aa8d9e98f13bf9610aaf75832bb">EnvelopeAlgorithm</a> algo=<a class="el" href="#a014a1aa8d9e98f13bf9610aaf75832bba4c5d06b02c97731aaa976179c62dcf76">EnvelopeAlgorithm::DIRECT</a>) const</td></tr>
<tr class="memitem:aec7cc41539c4895a98cb69b625b1bc8b" id="r_aec7cc41539c4895a98cb69b625b1bc8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aeaefb58e537bffc356950285789f3b54">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec7cc41539c4895a98cb69b625b1bc8b">depthLastEnvelope</a> () const</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename TKSpace&gt;<br />
class DGtal::DigitalConvexity&lt; TKSpace &gt;</div><p>Aim: <a class="el" href="structA.html">A</a> helper class to build polytopes from digital sets and to check digital k-convexity and full convexity. </p>
<p>Description of template class '<a class="el" href="classDGtal_1_1DigitalConvexity.html" title="Aim: A helper class to build polytopes from digital sets and to check digital k-convexity and full co...">DigitalConvexity</a>' </p>
<dl class="section see"><dt>See also</dt><dd>moduleDigitalConvexity</dd></dl>
<p>It is a model of <a class="el" href="structboost_1_1CopyConstructible.html" title="Go to http://www.sgi.com/tech/stl/CopyConstructible.html.">boost::CopyConstructible</a>, <a class="el" href="structboost_1_1DefaultConstructible.html" title="Go to http://www.sgi.com/tech/stl/DefaultConstructible.html.">boost::DefaultConstructible</a>, <a class="el" href="structboost_1_1Assignable.html" title="Go to http://www.sgi.com/tech/stl/Assignable.html.">boost::Assignable</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>an arbitrary model of CCellularGridSpaceND. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="geometry_2curves_2exampleDigitalConvexity_8cpp-example.html#_a10">geometry/curves/exampleDigitalConvexity.cpp</a>, <a class="el" href="geometry_2curves_2exampleRationalConvexity_8cpp-example.html#_a3">geometry/curves/exampleRationalConvexity.cpp</a>, <a class="el" href="geometry_2volumes_2checkFullConvexityTheorems_8cpp-example.html#_a16">geometry/volumes/checkFullConvexityTheorems.cpp</a>, <a class="el" href="geometry_2volumes_2digitalPolyhedronBuilder3D_8cpp-example.html#_a24">geometry/volumes/digitalPolyhedronBuilder3D.cpp</a>, and <a class="el" href="geometry_2volumes_2standardDigitalPolyhedronBuilder3D_8cpp-example.html#_a33">geometry/volumes/standardDigitalPolyhedronBuilder3D.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l00077">77</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a27904f1cb66cc2f0723a23673a62be75" name="a27904f1cb66cc2f0723a23673a62be75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27904f1cb66cc2f0723a23673a62be75">&#9670;&#160;</a></span>Cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#af87a8fec76262bec1a3b33881fa38f1f">KSpace::Cell</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::Cell</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l00087">87</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>

</div>
</div>
<a id="a7d43e151b418e62ff4afe64fae751986" name="a7d43e151b418e62ff4afe64fae751986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d43e151b418e62ff4afe64fae751986">&#9670;&#160;</a></span>CellGeometry</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classDGtal_1_1CellGeometry.html">DGtal::CellGeometry</a>&lt; <a class="el" href="#a645bebee5bef19212d3c4328e9054ca3">KSpace</a> &gt; <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::CellGeometry</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l00093">93</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>

</div>
</div>
<a id="aed802707b26b5d46af8bea7ddaf62120" name="aed802707b26b5d46af8bea7ddaf62120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed802707b26b5d46af8bea7ddaf62120">&#9670;&#160;</a></span>Counter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classDGtal_1_1BoundedLatticePolytopeCounter.html">DGtal::BoundedLatticePolytopeCounter</a>&lt; <a class="el" href="#ae8b5e2363e6fa2711516d6790b4491d2">Space</a> &gt; <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::Counter</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l00096">96</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>

</div>
</div>
<a id="abda40d4d7309cb343b799c6acd658c8f" name="abda40d4d7309cb343b799c6acd658c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda40d4d7309cb343b799c6acd658c8f">&#9670;&#160;</a></span>Integer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a1101d4adbc2a87db33afcb42209b6f04">KSpace::Integer</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;<a class="el" href="examplePlaneProbingParallelepipedEstimator_8cpp.html#ad31c3eca44cf6770809bc47f2b456212">::Integer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l00084">84</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>

</div>
</div>
<a id="a73270b9de14411262d459879edcceedd" name="a73270b9de14411262d459879edcceedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73270b9de14411262d459879edcceedd">&#9670;&#160;</a></span>Interval</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classDGtal_1_1BoundedLatticePolytopeCounter.html#adeaeda543e323378dbb7f7f43797b00d">Counter::Interval</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::Interval</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l00097">97</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>

</div>
</div>
<a id="a645bebee5bef19212d3c4328e9054ca3" name="a645bebee5bef19212d3c4328e9054ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645bebee5bef19212d3c4328e9054ca3">&#9670;&#160;</a></span>KSpace</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TKSpace <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;<a class="el" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">::KSpace</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l00083">83</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>

</div>
</div>
<a id="aae900cf944b90e595dedd3b73be31f4e" name="aae900cf944b90e595dedd3b73be31f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae900cf944b90e595dedd3b73be31f4e">&#9670;&#160;</a></span>LatticePolytope</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">DGtal::BoundedLatticePolytope</a>&lt; <a class="el" href="#ae8b5e2363e6fa2711516d6790b4491d2">Space</a> &gt; <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::LatticePolytope</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l00091">91</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>

</div>
</div>
<a id="aab180574b64e761af7f666d855e952ad" name="aab180574b64e761af7f666d855e952ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab180574b64e761af7f666d855e952ad">&#9670;&#160;</a></span>LatticeSet</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classDGtal_1_1LatticeSetByIntervals.html">DGtal::LatticeSetByIntervals</a>&lt; <a class="el" href="#ae8b5e2363e6fa2711516d6790b4491d2">Space</a> &gt; <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::LatticeSet</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l00098">98</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>

</div>
</div>
<a id="a872846f72d723e634ba406584a4e0db9" name="a872846f72d723e634ba406584a4e0db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872846f72d723e634ba406584a4e0db9">&#9670;&#160;</a></span>Point</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a70d1b8007551de58a7b8ccee328bed00">KSpace::Point</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;<a class="el" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">::Point</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l00085">85</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>

</div>
</div>
<a id="a6ca2be6c9d11457094c57044df502040" name="a6ca2be6c9d11457094c57044df502040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca2be6c9d11457094c57044df502040">&#9670;&#160;</a></span>PointRange</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a>&gt; <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;<a class="el" href="digitalPolyhedronBuilder3D_8cpp.html#a7e851e605c414ed13c6604af4bba8107">::PointRange</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l00094">94</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>

</div>
</div>
<a id="abafff2559e37c61d30f888324a85ff09" name="abafff2559e37c61d30f888324a85ff09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abafff2559e37c61d30f888324a85ff09">&#9670;&#160;</a></span>PointSet</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::unordered_set&lt;<a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a>&gt; <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::PointSet</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l00095">95</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>

</div>
</div>
<a id="af385f66bfd58c7ff172c00fa7bd6f506" name="af385f66bfd58c7ff172c00fa7bd6f506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af385f66bfd58c7ff172c00fa7bd6f506">&#9670;&#160;</a></span>Polytope</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html">DGtal::BoundedLatticePolytope</a>&lt; <a class="el" href="#ae8b5e2363e6fa2711516d6790b4491d2">Space</a> &gt; <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::Polytope</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l00090">90</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>

</div>
</div>
<a id="a796d52417c67dda07012d3d954db973a" name="a796d52417c67dda07012d3d954db973a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a796d52417c67dda07012d3d954db973a">&#9670;&#160;</a></span>RationalPolytope</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html">DGtal::BoundedRationalPolytope</a>&lt; <a class="el" href="#ae8b5e2363e6fa2711516d6790b4491d2">Space</a> &gt; <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::RationalPolytope</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l00092">92</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>

</div>
</div>
<a id="a9e2b772563ea30ed18152853163e2b4c" name="a9e2b772563ea30ed18152853163e2b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2b772563ea30ed18152853163e2b4c">&#9670;&#160;</a></span>Self</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="#a5370d2b125f0a16d42cb646fa25e7b4d">DigitalConvexity</a>&lt;TKSpace&gt; <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::Self</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l00082">82</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>

</div>
</div>
<a id="aeaefb58e537bffc356950285789f3b54" name="aeaefb58e537bffc356950285789f3b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaefb58e537bffc356950285789f3b54">&#9670;&#160;</a></span>Size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;<a class="el" href="testHalfEdgeDataStructure_8cpp.html#a1aba5499fd29449181365ce424303a10">::Size</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l00089">89</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>

</div>
</div>
<a id="ae8b5e2363e6fa2711516d6790b4491d2" name="ae8b5e2363e6fa2711516d6790b4491d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b5e2363e6fa2711516d6790b4491d2">&#9670;&#160;</a></span>Space</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ab2215bc032ca075e029b33eaf129feec">KSpace::Space</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;<a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a38dfaf1641eab4d3fb805df4b52ab10d">::Space</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l00088">88</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>

</div>
</div>
<a id="a0fb2995953a0d6d85c48704065bad6ac" name="a0fb2995953a0d6d85c48704065bad6ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb2995953a0d6d85c48704065bad6ac">&#9670;&#160;</a></span>Vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ad73ce442a5ecb094572646903f561cd2">KSpace::Vector</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;<a class="el" href="examplePlaneProbingParallelepipedEstimator_8cpp.html#a23c0623485ed9af765bab12ac424843c">::Vector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l00086">86</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Member Enumeration Documentation</h2>
<a id="a014a1aa8d9e98f13bf9610aaf75832bb" name="a014a1aa8d9e98f13bf9610aaf75832bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014a1aa8d9e98f13bf9610aaf75832bb">&#9670;&#160;</a></span>EnvelopeAlgorithm</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a014a1aa8d9e98f13bf9610aaf75832bb">DGtal::DigitalConvexity::EnvelopeAlgorithm</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Choice of algorithm for computing the fully convex envelope of a digital set. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a014a1aa8d9e98f13bf9610aaf75832bba4c5d06b02c97731aaa976179c62dcf76" name="a014a1aa8d9e98f13bf9610aaf75832bba4c5d06b02c97731aaa976179c62dcf76"></a>DIRECT&#160;</td><td class="fielddoc"><p>Slightly faster but quite ugly big function </p>
</td></tr>
<tr><td class="fieldname"><a id="a014a1aa8d9e98f13bf9610aaf75832bbaf8c3cb52426b5b81178667bd0a3bf6f0" name="a014a1aa8d9e98f13bf9610aaf75832bbaf8c3cb52426b5b81178667bd0a3bf6f0"></a>LATTICE_SET&#160;</td><td class="fielddoc"><p>Slightly slower function but decomposes well the algorithm </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l00817">817</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  818</span>      { DIRECT ,</div>
<div class="line"><span class="lineno">  819</span>        LATTICE_SET  </div>
<div class="line"><span class="lineno">  820</span>      };</div>
</div><!-- fragment -->
</div>
</div>
<a id="a346b3d21e164cc7d12d1b1c1ed1c0ccc" name="a346b3d21e164cc7d12d1b1c1ed1c0ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346b3d21e164cc7d12d1b1c1ed1c0ccc">&#9670;&#160;</a></span>SimplexType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a346b3d21e164cc7d12d1b1c1ed1c0ccc">DGtal::DigitalConvexity::SimplexType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The possible types for simplices. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a346b3d21e164cc7d12d1b1c1ed1c0cccaccc0377a8afbf50e7094f5c23a8af223" name="a346b3d21e164cc7d12d1b1c1ed1c0cccaccc0377a8afbf50e7094f5c23a8af223"></a>INVALID&#160;</td><td class="fielddoc"><p>When there are not the right number of vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a346b3d21e164cc7d12d1b1c1ed1c0cccaf4e099c113130fefb383bf30511991a3" name="a346b3d21e164cc7d12d1b1c1ed1c0cccaf4e099c113130fefb383bf30511991a3"></a>DEGENERATED&#160;</td><td class="fielddoc"><p>When the points of the simplex are not in general position. </p>
</td></tr>
<tr><td class="fieldname"><a id="a346b3d21e164cc7d12d1b1c1ed1c0ccca90bf49c52ada611f7d9892cab80c310f" name="a346b3d21e164cc7d12d1b1c1ed1c0ccca90bf49c52ada611f7d9892cab80c310f"></a>UNITARY&#160;</td><td class="fielddoc"><p>When its edges form a unit parallelotope (det = +/- 1). </p>
</td></tr>
<tr><td class="fieldname"><a id="a346b3d21e164cc7d12d1b1c1ed1c0cccadda4b7de10e14445366494f0a76e1435" name="a346b3d21e164cc7d12d1b1c1ed1c0cccadda4b7de10e14445366494f0a76e1435"></a>COMMON&#160;</td><td class="fielddoc"><p>Common simplex. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l00237">237</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  237</span>                          {</div>
<div class="line"><span class="lineno">  238</span>      INVALID,     </div>
<div class="line"><span class="lineno">  239</span>      DEGENERATED, </div>
<div class="line"><span class="lineno">  240</span>      UNITARY,     </div>
<div class="line"><span class="lineno">  241</span>      COMMON       </div>
<div class="line"><span class="lineno">  242</span>    };</div>
</div><!-- fragment -->
</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af0c48f6a56644a168d420871e9c42802" name="af0c48f6a56644a168d420871e9c42802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c48f6a56644a168d420871e9c42802">&#9670;&#160;</a></span>~DigitalConvexity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::~<a class="el" href="#a5370d2b125f0a16d42cb646fa25e7b4d">DigitalConvexity</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<a id="a5370d2b125f0a16d42cb646fa25e7b4d" name="a5370d2b125f0a16d42cb646fa25e7b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5370d2b125f0a16d42cb646fa25e7b4d">&#9670;&#160;</a></span>DigitalConvexity() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::DigitalConvexity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<a id="a41e261ca030aabb291bd6a2be87e11f8" name="a41e261ca030aabb291bd6a2be87e11f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e261ca030aabb291bd6a2be87e11f8">&#9670;&#160;</a></span>DigitalConvexity() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::DigitalConvexity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a9e2b772563ea30ed18152853163e2b4c">Self</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the object to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75f106982cd96699ad78dff64d8e5efc" name="a75f106982cd96699ad78dff64d8e5efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f106982cd96699ad78dff64d8e5efc">&#9670;&#160;</a></span>DigitalConvexity() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::DigitalConvexity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1Clone.html">Clone</a>&lt; <a class="el" href="#a645bebee5bef19212d3c4328e9054ca3">KSpace</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>K</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>safe</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor from cellular space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">K</td><td>any cellular grid space. </td></tr>
    <tr><td class="paramname">safe</td><td>when 'true' performs convex hull computations with arbitrary precision integer (if available), otherwise chooses a compromise between speed and precision (<a class="el" href="namespaceDGtal.html#a45f076335dc184c6b7267b006362f5aa" title="signed 94-bit integer.">int64_t</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae4b831c3b47b6b5ce7c0c069b0875cc" name="aae4b831c3b47b6b5ce7c0c069b0875cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4b831c3b47b6b5ce7c0c069b0875cc">&#9670;&#160;</a></span>DigitalConvexity() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::DigitalConvexity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a></td>          <td class="paramname"><span class="paramname"><em>lo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a></td>          <td class="paramname"><span class="paramname"><em>hi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>safe</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor from lower and upper points. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>the lowest point of the domain (bounding box for computations). </td></tr>
    <tr><td class="paramname">hi</td><td>the highest point of the domain (bounding box for computations). </td></tr>
    <tr><td class="paramname">safe</td><td>when 'true' performs convex hull computations with arbitrary precision integer (if available), otherwise chooses a compromise between speed and precision (<a class="el" href="namespaceDGtal.html#a45f076335dc184c6b7267b006362f5aa" title="signed 94-bit integer.">int64_t</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a8db8f871dfd94f6db7022681c0c745cc" name="a8db8f871dfd94f6db7022681c0c745cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db8f871dfd94f6db7022681c0c745cc">&#9670;&#160;</a></span>BOOST_CONCEPT_ASSERT()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::BOOST_CONCEPT_ASSERT </td>
          <td>(</td>
          <td class="paramtype">(<a class="el" href="structDGtal_1_1concepts_1_1CCellularGridSpaceND.html">concepts::CCellularGridSpaceND</a>&lt; TKSpace &gt;)</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac20d0b1fd677da8c1636e5ba2498dcd1" name="ac20d0b1fd677da8c1636e5ba2498dcd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac20d0b1fd677da8c1636e5ba2498dcd1">&#9670;&#160;</a></span>CoverCvxH() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::CoverCvxH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a83a99607075cb1757245a62b71a36a49">dimension</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds the cell complex <span class="tt">Cover(<a class="el" href="#a3bfa3e199bb8c80908fedee176898c30">CvxH</a>({a,b,c}))</span> for <span class="tt">a,b,c</span> a non-degenerate 3D triangle, represented as a lattice set (stacked row representation). The cover of a Euclidean set X is the set of grid cells that have a non-empty intersection with X. It is always included in the star of X, which is the of cells whose closure has a non-empty intersection with X. However the cover of X is not necessarily closed or open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>any 3D point (distinct from the two others) </td></tr>
    <tr><td class="paramname">b</td><td>any 3D point (distinct from the two others) </td></tr>
    <tr><td class="paramname">c</td><td>any 3D point (distinct from the two others) <br  />
</td></tr>
    <tr><td class="paramname">axis</td><td>specifies the projection axis for the row representation if below space dimension, otherwise chooses the axis that minimizes memory/computations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range of cells intersecting the triangle <span class="tt">abc</span>, represented as a lattice set (cells are represented with Khalimsky coordinates). If the triangle is degenerate (a,b,c not distinct or aligned), then it returns an empty range of cells.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is useful to specify an axis if you wish later to compare or make operations with several lattice sets. They must indeed have the same axis. </dd></dl>

</div>
</div>
<a id="ab7677f3e5eabebf589500dadb3043149" name="ab7677f3e5eabebf589500dadb3043149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7677f3e5eabebf589500dadb3043149">&#9670;&#160;</a></span>CoverCvxH() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::CoverCvxH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a83a99607075cb1757245a62b71a36a49">dimension</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds the cell complex <span class="tt">Cover(<a class="el" href="#a3bfa3e199bb8c80908fedee176898c30">CvxH</a>({a,b}))</span> for <span class="tt">a,b</span> a non-degenerate 3D segment, represented as a lattice set (stacked row representation). The cover of a Euclidean set X is the set of grid cells that have a non-empty intersection with X. It is always included in the star of X, which is the of cells whose closure has a non-empty intersection with X. However the cover of X is not necessarily closed or open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>any 3D point (distinct from the other) </td></tr>
    <tr><td class="paramname">b</td><td>any 3D point (distinct from the other)</td></tr>
    <tr><td class="paramname">axis</td><td>specifies the projection axis for the row representation if below space dimension, otherwise chooses the axis that minimizes memory/computations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range of cells intersecting the segment <span class="tt">ab</span>, represented as a lattice set (cells are represented with Khalimsky coordinates). If the segment is degenerate (a,b not distinct), then it returns an empty range of cells.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is useful to specify an axis if you wish later to compare or make operations with several lattice sets. They must indeed have the same axis. </dd></dl>

</div>
</div>
<a id="a9060e94977f81c9475f8eee040c2beeb" name="a9060e94977f81c9475f8eee040c2beeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9060e94977f81c9475f8eee040c2beeb">&#9670;&#160;</a></span>CoverPolytope()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename TPolytope&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::CoverPolytope </td>
          <td>(</td>
          <td class="paramtype">const TPolytope &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a83a99607075cb1757245a62b71a36a49">dimension</a></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Builds the cell complex <span class="tt">Cover(P))</span> for <span class="tt">P</span> a Minkowski summable polytope, represented as a lattice set (stacked row representation). The cover of a Euclidean set X is the set of grid cells that have a non-empty intersection with X. It is always included in the star of X, which is the of cells whose closure has a non-empty intersection with X. However the cover of X is not necessarily closed or open.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TPolytope</td><td>an instance of <a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>any Minkowski summable lattice polytope (see <a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a>).</td></tr>
    <tr><td class="paramname">axis</td><td>specifies the projection axis for the row representation if below space dimension, otherwise chooses the axis that minimizes memory/computations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range of cells intersecting the polytope represented as a lattice set (cells are represented with Khalimsky coordinates).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Used by CoverCvxH.</dd>
<dd>
It is useful to specify an axis if you wish later to compare or make operations with several lattice sets. They must indeed have the same axis. </dd></dl>

</div>
</div>
<a id="a3bfa3e199bb8c80908fedee176898c30" name="a3bfa3e199bb8c80908fedee176898c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bfa3e199bb8c80908fedee176898c30">&#9670;&#160;</a></span>CvxH()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::CvxH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a range of distinct points <em class="arg">X</em>, computes the tightiest polytope that enclosed it. Note that this polytope may contain more lattice points than the given input points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>any range of <b>pairwise</b> <b>distinct</b> points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding lattice polytope.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>alias for <a class="el" href="#af4528961df07c0a68287a7744c93e22f">DigitalConvexity::makePolytope</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l00573">573</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  574</span>    {</div>
<div class="line"><span class="lineno">  575</span>      <span class="keywordflow">return</span> <a class="code hl_function" href="#af4528961df07c0a68287a7744c93e22f">makePolytope</a>( <a class="code hl_class" href="classDGtal_1_1DigitalConvexity.html">X</a> );</div>
<div class="line"><span class="lineno">  576</span>    }</div>
<div class="ttc" id="aclassDGtal_1_1DigitalConvexity_html"><div class="ttname"><a href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a></div><div class="ttdoc">Aim: A helper class to build polytopes from digital sets and to check digital k-convexity and full co...</div><div class="ttdef"><b>Definition</b> <a href="DigitalConvexity_8h_source.html#l00077">DigitalConvexity.h:78</a></div></div>
<div class="ttc" id="aclassDGtal_1_1DigitalConvexity_html_af4528961df07c0a68287a7744c93e22f"><div class="ttname"><a href="#af4528961df07c0a68287a7744c93e22f">DGtal::DigitalConvexity::makePolytope</a></div><div class="ttdeci">LatticePolytope makePolytope(const PointRange &amp;X, bool make_minkowski_summable=false) const</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aec7cc41539c4895a98cb69b625b1bc8b" name="aec7cc41539c4895a98cb69b625b1bc8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7cc41539c4895a98cb69b625b1bc8b">&#9670;&#160;</a></span>depthLastEnvelope()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aeaefb58e537bffc356950285789f3b54">Size</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::depthLastEnvelope </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of iterations of the last process <span class="tt">FC^*(Z):=<a class="el" href="#a15bbab0bbc615f5088fa767efd41819f">FC</a>(<a class="el" href="#a15bbab0bbc615f5088fa767efd41819f">FC</a>(....FC(Z)...))</span>, i.e. the last call to <a class="el" href="#a8c1f8c406bf52d7654ebdcd91542e107">DigitalConvexity::envelope</a> or <a class="el" href="#a94893f395ee00f8bd8d8b5c964ab28ce">DigitalConvexity::relativeEnvelope</a> . </dd></dl>

</div>
</div>
<a id="a3af7c3766f87499faeb68d43b1bc439c" name="a3af7c3766f87499faeb68d43b1bc439c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af7c3766f87499faeb68d43b1bc439c">&#9670;&#160;</a></span>displaySimplex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename PointIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::displaySimplex </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointIterator</td>          <td class="paramname"><span class="paramname"><em>itB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointIterator</td>          <td class="paramname"><span class="paramname"><em>itE</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Displays information about the simplex formed by the given range [itB,itE) of lattice points.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointIterator</td><td>any model of forward iterator on <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>the output stream where information is outputed. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">itB</td><td>the start of the range of n+1 points defining the simplex. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">itE</td><td>past the end the range of n+1 points defining the simplex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad47e66a9e3989a826cfd09c07cb8b344" name="ad47e66a9e3989a826cfd09c07cb8b344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47e66a9e3989a826cfd09c07cb8b344">&#9670;&#160;</a></span>displaySimplex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::displaySimplex </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Displays information about simplex formed by the given list <em class="arg">l</em> of lattice points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>the output stream where information is outputed. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">l</td><td>any list of lattice points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c1f8c406bf52d7654ebdcd91542e107" name="a8c1f8c406bf52d7654ebdcd91542e107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1f8c406bf52d7654ebdcd91542e107">&#9670;&#160;</a></span>envelope()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::envelope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a014a1aa8d9e98f13bf9610aaf75832bb">EnvelopeAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>algo</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a014a1aa8d9e98f13bf9610aaf75832bba4c5d06b02c97731aaa976179c62dcf76">EnvelopeAlgorithm::DIRECT</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the fully convex envelope of <em class="arg">Z</em>, i.e. \( FC^*(Z):=FC(FC( \ldots FC(Z) \ldots )) \), for <em class="arg">Z</em> a range of points, until stabilization of the iterative process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Z</td><td>any range of points (must be sorted). </td></tr>
    <tr><td class="paramname">algo</td><td>the chosen method of computation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\( FC^*( Z ) \)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <em class="arg">Z</em> is fully convex, then the output is <em class="arg">Z</em> itself. Otherwise, the returned set of points includes <em class="arg">Z</em> and is fully convex. </dd></dl>

</div>
</div>
<a id="a54760af00e24bbb36ee7ce58b1702f92" name="a54760af00e24bbb36ee7ce58b1702f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54760af00e24bbb36ee7ce58b1702f92">&#9670;&#160;</a></span>eraseInterval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::eraseInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a73270b9de14411262d459879edcceedd">Interval</a></td>          <td class="paramname"><span class="paramname"><em>I</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="#a73270b9de14411262d459879edcceedd">Interval</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>V</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erase the interval I from the intervals in V such that the integer in I are not part of V anymore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>is a closed interval </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">V</td><td>is a sorted list of closed intervals </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07b4850daa74067d742ef16e54d68d12" name="a07b4850daa74067d742ef16e54d68d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b4850daa74067d742ef16e54d68d12">&#9670;&#160;</a></span>Extr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::Extr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>a range of cells represented as a lattice set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range of digital points that are the extremal vertices to the cells in <em class="arg">C</em>. </dd></dl>

</div>
</div>
<a id="a5f8e046968925ce2b36313e6a97b6382" name="a5f8e046968925ce2b36313e6a97b6382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8e046968925ce2b36313e6a97b6382">&#9670;&#160;</a></span>Extr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::Extr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>a range of cells represented with points in Khalimsky coordinates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range of digital points that are the extremal vertices to the cells in <em class="arg">C</em>. </dd></dl>

</div>
</div>
<a id="a472d893d2d1736c7fc662a39f0756179" name="a472d893d2d1736c7fc662a39f0756179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472d893d2d1736c7fc662a39f0756179">&#9670;&#160;</a></span>ExtrCvxH()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::ExtrCvxH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a range of distinct points <em class="arg">X</em>, computes the vertices of the tightiest polytope that enclosed it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>any range of <b>pairwise</b> <b>distinct</b> points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vertices or extrema of <span class="tt">CvxH(X)</span>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The method works in nD for full dimensional convex hulls. It can handle not full dimensional convex hull up to dimension 3 included. </dd></dl>

</div>
</div>
<a id="ace8e05ee36ff537409e7d37c09264bb4" name="ace8e05ee36ff537409e7d37c09264bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8e05ee36ff537409e7d37c09264bb4">&#9670;&#160;</a></span>ExtrSkel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::ExtrSkel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>a range of cells represented as a lattice set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range of digital points that are the extremal vertices to the skeleton of the cells in <em class="arg">C</em>. </dd></dl>

</div>
</div>
<a id="a15bbab0bbc615f5088fa767efd41819f" name="a15bbab0bbc615f5088fa767efd41819f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15bbab0bbc615f5088fa767efd41819f">&#9670;&#160;</a></span>FC()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::FC </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a014a1aa8d9e98f13bf9610aaf75832bb">EnvelopeAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>algo</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a014a1aa8d9e98f13bf9610aaf75832bba4c5d06b02c97731aaa976179c62dcf76">EnvelopeAlgorithm::DIRECT</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes <span class="tt">FC(Z):=<a class="el" href="#a5f8e046968925ce2b36313e6a97b6382">Extr</a>(<a class="el" href="#ab60b6a17f4d1defa5a720ec14eb86ec6">Skel</a>(Star(CvxH(Z))))</span>, for <em class="arg">Z</em> a range of points </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Z</td><td>any range of points (must be sorted). </td></tr>
    <tr><td class="paramname">algo</td><td>the chosen method of computation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FC( Z ) </dd></dl>

</div>
</div>
<a id="ad7f77e98ad81d47bd394d27a9f942e9d" name="ad7f77e98ad81d47bd394d27a9f942e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f77e98ad81d47bd394d27a9f942e9d">&#9670;&#160;</a></span>FC_direct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::FC_direct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Z</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes <span class="tt">FC(Z):=<a class="el" href="#a5f8e046968925ce2b36313e6a97b6382">Extr</a>(<a class="el" href="#ab60b6a17f4d1defa5a720ec14eb86ec6">Skel</a>(Star(CvxH(Z))))</span>, for <em class="arg">Z</em> a range of points </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Z</td><td>any range of points (must be sorted). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FC( Z ) </dd></dl>

</div>
</div>
<a id="a37662e560f356365d4f64b3a59c7b608" name="a37662e560f356365d4f64b3a59c7b608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37662e560f356365d4f64b3a59c7b608">&#9670;&#160;</a></span>FC_LatticeSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::FC_LatticeSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Z</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes <span class="tt">FC(Z):=<a class="el" href="#a5f8e046968925ce2b36313e6a97b6382">Extr</a>(<a class="el" href="#ab60b6a17f4d1defa5a720ec14eb86ec6">Skel</a>(Star(CvxH(Z))))</span>, for <em class="arg">Z</em> a range of points </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Z</td><td>any range of points (must be sorted). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FC( Z ) </dd></dl>

</div>
</div>
<a id="aa937d026c2ad247965577c32e66708dc" name="aa937d026c2ad247965577c32e66708dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa937d026c2ad247965577c32e66708dc">&#9670;&#160;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename Predicate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>E</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;</td>          <td class="paramname"><span class="paramname"><em>Pred</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Filters the points of <em class="arg">E</em> and outputs only the ones that satisfies the given predicate <em class="arg">Pred</em>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>the type of a predicate <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> -&gt; boolean </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>any range of point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pred</td><td>the predicate <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> -&gt; boolean </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the subset of E whose elements satisfy the predicate <em class="arg">Pred</em>. </dd></dl>

</div>
</div>
<a id="a02884b4960ea77330822c7b3d5b10444" name="a02884b4960ea77330822c7b3d5b10444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02884b4960ea77330822c7b3d5b10444">&#9670;&#160;</a></span>insidePoints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::insidePoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>polytope</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polytope</td><td>any lattice polytope. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range of digital points that belongs to the polytope. </dd></dl>

</div>
</div>
<a id="a8d5f960ea09389c2240db46f1f42e4ee" name="a8d5f960ea09389c2240db46f1f42e4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5f960ea09389c2240db46f1f42e4ee">&#9670;&#160;</a></span>insidePoints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::insidePoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a796d52417c67dda07012d3d954db973a">RationalPolytope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>polytope</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polytope</td><td>any rational polytope. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range of digital points that belongs to the polytope. </dd></dl>

</div>
</div>
<a id="afe2a661668dc2d1837d93a86d685437f" name="afe2a661668dc2d1837d93a86d685437f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2a661668dc2d1837d93a86d685437f">&#9670;&#160;</a></span>interiorPoints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::interiorPoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>polytope</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polytope</td><td>any lattice polytope. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range of digital points that belongs to the interior of the polytope. </dd></dl>

</div>
</div>
<a id="a80247137d0189aec3785e3677c91d89f" name="a80247137d0189aec3785e3677c91d89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80247137d0189aec3785e3677c91d89f">&#9670;&#160;</a></span>interiorPoints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::interiorPoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a796d52417c67dda07012d3d954db973a">RationalPolytope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>polytope</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polytope</td><td>any rational polytope. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range of digital points that belongs to the interior of the polytope. </dd></dl>

</div>
</div>
<a id="a4b5bf83b01cd9b62e92cc2572e8df5a8" name="a4b5bf83b01cd9b62e92cc2572e8df5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b5bf83b01cd9b62e92cc2572e8df5a8">&#9670;&#160;</a></span>is0Convex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::is0Convex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells if a given point range <em class="arg">X</em> is digitally 0-convex, i.e. \( \mathrm{Cvxh}(X) \cap \mathbb{Z}^d = X \). It works for arbitrary set of points in arbitrary dimenion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>any range of <b>pairwise</b> <b>distinct</b> points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' iff <em class="arg">X</em> is fully digitally convex. </dd></dl>

</div>
</div>
<a id="a7d2a2137cf7d22c982b7c73c68ec6094" name="a7d2a2137cf7d22c982b7c73c68ec6094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d2a2137cf7d22c982b7c73c68ec6094">&#9670;&#160;</a></span>isFullyConvex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::isFullyConvex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells if a given polytope <em class="arg">P</em> is fully digitally convex. The digital 0-convexity is the usual property  \( Conv( P \cap Z^d
) = P \cap Z^d) \). Otherwise the property asks that the points inside P touch as many k-cells that the convex hull of P, for any valid dimension k. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>any lattice polytope such that <span class="tt">P.canBeSummed() == true</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' iff the polytope <em class="arg">P</em> is fully digitally convex.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="structA.html">A</a> polytope is always digitally 0-convex. Furthermore, if it is not digitally d-1-convex then it is digitally d-convex (d := <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae2b2dcf34c36a5e3eae4bf13291f1578">KSpace::dimension</a>). Hence, we only check k-convexity for 1 &lt;= k &lt;= d-1. </dd></dl>

</div>
</div>
<a id="a3cd5bd9f858176e274f5320674ca2026" name="a3cd5bd9f858176e274f5320674ca2026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd5bd9f858176e274f5320674ca2026">&#9670;&#160;</a></span>isFullyConvex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::isFullyConvex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>convex0</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells if a given point range <em class="arg">X</em> is fully digitally convex. The test uses the morphological characterization of full convexity. It is slightly slower than testing full convexity on simplices, but it works for arbitrary set of points in arbitrary dimenion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>any range of <b>pairwise</b> <b>distinct</b> points</td></tr>
    <tr><td class="paramname">convex0</td><td>when 'true' indicates that <em class="arg">X</em> is known to be digitally 0-convex, otherwise the method will check it also.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' iff <em class="arg">X</em> is fully digitally convex. </dd></dl>

</div>
</div>
<a id="a113c4e885d5d16ec663b9e7e8b8da86c" name="a113c4e885d5d16ec663b9e7e8b8da86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113c4e885d5d16ec663b9e7e8b8da86c">&#9670;&#160;</a></span>isFullyConvex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::isFullyConvex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a796d52417c67dda07012d3d954db973a">RationalPolytope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells if a given polytope <em class="arg">P</em> is fully digitally convex. The digital 0-convexity is the usual property  \( Conv( P \cap Z^d
) = P \cap Z^d) \). Otherwise the property asks that the points inside P touch as many k-cells that the convex hull of P, for any valid dimension k. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>any rational polytope such that <span class="tt">P.canBeSummed() == true</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' iff the polytope <em class="arg">P</em> is fully digitally convex.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="structA.html">A</a> polytope is always digitally 0-convex. Furthermore, if it is not digitally d-1-convex then it is digitally d-convex (d := <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae2b2dcf34c36a5e3eae4bf13291f1578">KSpace::dimension</a>). Hence, we only check k-convexity for 1 &lt;= k &lt;= d-1. </dd></dl>

</div>
</div>
<a id="a3b7d5a39596ba6d88525ce46b0755ccf" name="a3b7d5a39596ba6d88525ce46b0755ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7d5a39596ba6d88525ce46b0755ccf">&#9670;&#160;</a></span>isFullyConvexFast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::isFullyConvexFast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells if a given point range <em class="arg">X</em> is fully digitally convex. The test uses the morphological characterization of full convexity and a fast way to compute lattice points within a polytope. It works for arbitrary set of points in arbitrary dimenion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>any range of <b>pairwise</b> <b>distinct</b> points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' iff <em class="arg">X</em> is fully digitally convex.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is generally faster than <a class="el" href="#a3cd5bd9f858176e274f5320674ca2026">DigitalConvexity::isFullyConvex</a> if (1) the set is indeed is fully convex, (2) the dimension is high (&gt;= 3 or 4). </dd></dl>

</div>
</div>
<a id="a58b461f84cc13a0f21c5c9ee5e9c031d" name="a58b461f84cc13a0f21c5c9ee5e9c031d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b461f84cc13a0f21c5c9ee5e9c031d">&#9670;&#160;</a></span>isFullyCovered() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::isFullyCovered </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cells</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells if the non-degenerated 3D segment a,b is fully covered by some lattice set of cells <em class="arg">cells</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>any 3D point (distinct from the other) </td></tr>
    <tr><td class="paramname">b</td><td>any 3D point (distinct from the other)</td></tr>
    <tr><td class="paramname">cells</td><td>any lattice set representing a set of cells.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' iff <span class="tt">Cvxh({a,b})</span> is fully covered by <em class="arg">cells</em>, i.e. all the cells intersected by the triangle belong to <em class="arg">cells</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is limited to 3D segments. </dd></dl>

</div>
</div>
<a id="a0e3e22c3d6898ec1453cec5c98023587" name="a0e3e22c3d6898ec1453cec5c98023587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3e22c3d6898ec1453cec5c98023587">&#9670;&#160;</a></span>isFullyCovered() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::isFullyCovered </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cells</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells if the non-degenerated 3D triangle a,b,c is fully covered by some lattice set of cells <em class="arg">cells</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>any 3D point (distinct from the two others) </td></tr>
    <tr><td class="paramname">b</td><td>any 3D point (distinct from the two others) </td></tr>
    <tr><td class="paramname">c</td><td>any 3D point (distinct from the two others)</td></tr>
    <tr><td class="paramname">cells</td><td>any lattice set representing a set of cells.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' iff <span class="tt">Cvxh({a,b,c})</span> is fully covered by <em class="arg">cells</em>, i.e. all the cells intersected by the triangle belong to <em class="arg">cells</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is limited to 3D triangles. </dd></dl>

</div>
</div>
<a id="ab85164421d1ec12169837162aaee0529" name="ab85164421d1ec12169837162aaee0529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85164421d1ec12169837162aaee0529">&#9670;&#160;</a></span>isFullySubconvex() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::isFullySubconvex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a7d43e151b418e62ff4afe64fae751986">CellGeometry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells if a given polytope <em class="arg">P</em> is digitally fully subconvex to some cell cover <em class="arg">C</em>. The digital 0-subconvexity is the usual property  \( Conv( P \cap Z^d ) \subset C \cap Z^d)
\). Otherwise the property asks that the k-cells intersected by the convex hull of P is a subset of the k-cells of C. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>any lattice polytope such that <span class="tt">P.canBeSummed() == true</span>. </td></tr>
    <tr><td class="paramname">C</td><td>any cell cover geometry (i.e. a cubical complex). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' iff the polytope <em class="arg">P</em> is digitally fully subconvex to C.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method only checks the k-subconvexity for valid dimensions stored in <em class="arg">C</em>. </dd></dl>

</div>
</div>
<a id="ab17ce84b1c830185002c5e52bd00c942" name="ab17ce84b1c830185002c5e52bd00c942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17ce84b1c830185002c5e52bd00c942">&#9670;&#160;</a></span>isFullySubconvex() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::isFullySubconvex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>StarX</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells if a given polytope <em class="arg">P</em> is digitally fully subconvex to some lattice set <em class="arg">Star_X</em>, i.e. the cell cover of some set X represented by lattice points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>any lattice polytope such that <span class="tt">P.canBeSummed() == true</span>. </td></tr>
    <tr><td class="paramname">StarX</td><td>any lattice set representing an open cubical complex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' iff Y is digitally fully subconvex to X. </dd></dl>

</div>
</div>
<a id="a494195664f3c6e6fce305df9f152315c" name="a494195664f3c6e6fce305df9f152315c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a494195664f3c6e6fce305df9f152315c">&#9670;&#160;</a></span>isFullySubconvex() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::isFullySubconvex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a7d43e151b418e62ff4afe64fae751986">CellGeometry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells if a given segment from <em class="arg">a</em> to <em class="arg">b</em> is digitally fully subconvex (i.e. tangent) to some cell cover <em class="arg">C</em>. The digital 0-subconvexity is the usual property  \( Conv( P \cap Z^d )
\subset C \cap Z^d) \). Otherwise the property asks that the k-cells intersected by the convex hull of the segment is a subset of the k-cells of C.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>any point </td></tr>
    <tr><td class="paramname">b</td><td>any point </td></tr>
    <tr><td class="paramname">C</td><td>any cell cover geometry (i.e. a cubical complex).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' iff the segment is a digitally fully subconvex of C, i.e. the two points are cotangent.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Three times faster than building a (degenerated) lattice polytope and then checking if it subconvex. </dd></dl>

</div>
</div>
<a id="a7cb0abf0fbcc02387ac64f932cb3148a" name="a7cb0abf0fbcc02387ac64f932cb3148a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb0abf0fbcc02387ac64f932cb3148a">&#9670;&#160;</a></span>isFullySubconvex() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::isFullySubconvex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>StarX</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells if a given segment from <em class="arg">a</em> to <em class="arg">b</em> is digitally fully subconvex (i.e. tangent) to some open complex <em class="arg">StarX</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>any point </td></tr>
    <tr><td class="paramname">b</td><td>any point </td></tr>
    <tr><td class="paramname">StarX</td><td>any lattice set representing an open cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' iff the segment is a digitally fully subconvex of C, i.e. the two points are cotangent.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Three times faster than building a (degenerated) lattice polytope and then checking if it subconvex. </dd></dl>

</div>
</div>
<a id="a5735d8c593127d6467ba9f78ccad23b4" name="a5735d8c593127d6467ba9f78ccad23b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5735d8c593127d6467ba9f78ccad23b4">&#9670;&#160;</a></span>isFullySubconvex() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::isFullySubconvex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>StarX</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells if the non-degenerated 3D triangle a,b,c is digitally fully subconvex to some lattice set <em class="arg">Star_X</em>, i.e. the cell cover of some set X represented by lattice points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>any 3D point (distinct from the two others) </td></tr>
    <tr><td class="paramname">b</td><td>any 3D point (distinct from the two others) </td></tr>
    <tr><td class="paramname">c</td><td>any 3D point (distinct from the two others)</td></tr>
    <tr><td class="paramname">StarX</td><td>any lattice set representing an open cubical complex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' iff Y is digitally fully subconvex to X.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is supposed to be faster than the others, but is limited to 3D triangles. </dd></dl>

</div>
</div>
<a id="abb35a70653904c9ca2b308221ff70565" name="abb35a70653904c9ca2b308221ff70565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb35a70653904c9ca2b308221ff70565">&#9670;&#160;</a></span>isFullySubconvex() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::isFullySubconvex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>StarX</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells if a given set of points Y is digitally fully subconvex to some lattice set <em class="arg">Star_X</em>, i.e. the cell cover of some set X represented by lattice points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Y</td><td>any set of points </td></tr>
    <tr><td class="paramname">StarX</td><td>any lattice set representing an open cubical complex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' iff Y is digitally fully subconvex to X.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is slower than the two others, since it builds the polytope embracing <em class="arg">Y</em>. However it is much more generic since the two other methods require a Minkowski summable polytope, i.e. <span class="tt">P.canBeSummed() == true</span>. </dd></dl>

</div>
</div>
<a id="a8d858c7d041cd58235e41554469699bd" name="a8d858c7d041cd58235e41554469699bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d858c7d041cd58235e41554469699bd">&#9670;&#160;</a></span>isFullySubconvex() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::isFullySubconvex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a796d52417c67dda07012d3d954db973a">RationalPolytope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a7d43e151b418e62ff4afe64fae751986">CellGeometry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells if a given polytope <em class="arg">P</em> is digitally fully subconvex to some cell cover <em class="arg">C</em>. The digital 0-subconvexity is the usual property  \( Conv( P \cap Z^d ) \subset C \cap Z^d)
\). Otherwise the property asks that the k-cells intersected by the convex hull of P is a subset of the k-cells of C. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>any rational polytope such that <span class="tt">P.canBeSummed() == true</span>. </td></tr>
    <tr><td class="paramname">C</td><td>any cell cover geometry (i.e. a cubical complex). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' iff the polytope <em class="arg">P</em> is digitally fully subconvex to C.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method only checks the k-subconvexity for valid dimensions stored in <em class="arg">C</em>. </dd></dl>

</div>
</div>
<a id="a1c68ee37d58620cf8e70f901f86cea5c" name="a1c68ee37d58620cf8e70f901f86cea5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c68ee37d58620cf8e70f901f86cea5c">&#9670;&#160;</a></span>isKConvex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::isKConvex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells if a given polytope <em class="arg">P</em> is digitally k-convex. The digital 0-convexity is the usual property  \( Conv( P \cap Z^d ) = P
\cap Z^d) \). Otherwise the property asks that the points inside P touch as many k-cells that the convex hull of P. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>any lattice polytope such that <span class="tt">P.canBeSummed() == true</span>. </td></tr>
    <tr><td class="paramname">k</td><td>the dimension for which the digital k-convexity is checked, 0 &lt;= k &lt;= <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae2b2dcf34c36a5e3eae4bf13291f1578">KSpace::dimension</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' iff the polytope <em class="arg">P</em> is digitally <em class="arg">k-convex</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="structA.html">A</a> polytope is always digitally 0-convex. Furthermore, if it is not digitally d-1-convex then it is digitally not d-convex (d := <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae2b2dcf34c36a5e3eae4bf13291f1578">KSpace::dimension</a>). </dd></dl>

</div>
</div>
<a id="aa00aac6781df4daf05b243364f8e0505" name="aa00aac6781df4daf05b243364f8e0505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00aac6781df4daf05b243364f8e0505">&#9670;&#160;</a></span>isKConvex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::isKConvex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a796d52417c67dda07012d3d954db973a">RationalPolytope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells if a given polytope <em class="arg">P</em> is digitally k-convex. The digital 0-convexity is the usual property  \( Conv( P \cap Z^d ) = P
\cap Z^d) \). Otherwise the property asks that the points inside P touch as many k-cells that the convex hull of P. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>any rational polytope such that <span class="tt">P.canBeSummed() == true</span>. </td></tr>
    <tr><td class="paramname">k</td><td>the dimension for which the digital k-convexity is checked, 0 &lt;= k &lt;= <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae2b2dcf34c36a5e3eae4bf13291f1578">KSpace::dimension</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' iff the polytope <em class="arg">P</em> is digitally <em class="arg">k-convex</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="structA.html">A</a> polytope is always digitally 0-convex. Furthermore, if it is not digitally d-1-convex then it is digitally not d-convex (d := <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae2b2dcf34c36a5e3eae4bf13291f1578">KSpace::dimension</a>). </dd></dl>

</div>
</div>
<a id="a8ad8e913928fa3ea5629512a8c93a38c" name="a8ad8e913928fa3ea5629512a8c93a38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad8e913928fa3ea5629512a8c93a38c">&#9670;&#160;</a></span>isKSubconvex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::isKSubconvex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a7d43e151b418e62ff4afe64fae751986">CellGeometry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells if a given polytope <em class="arg">P</em> is digitally k-subconvex of some cell cover <em class="arg">C</em>. The digital 0-subconvexity is the usual property  \( Conv( P \cap Z^d ) \subset C \cap Z^d)
\). Otherwise the property asks that the k-cells intersected by the convex hull of P is a subset of the k-cells of C. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>any lattice polytope such that <span class="tt">P.canBeSummed() == true</span>. </td></tr>
    <tr><td class="paramname">C</td><td>any cell cover geometry (i.e. a cubical complex). </td></tr>
    <tr><td class="paramname">k</td><td>the dimension for which the digital k-convexity is checked, 0 &lt;= k &lt;= <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae2b2dcf34c36a5e3eae4bf13291f1578">KSpace::dimension</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' iff the polytope <em class="arg">P</em> is a digitally <em class="arg">k-subconvex</em> of C. </dd></dl>

</div>
</div>
<a id="a9a691e049c521f4ee81d365ea82e23dd" name="a9a691e049c521f4ee81d365ea82e23dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a691e049c521f4ee81d365ea82e23dd">&#9670;&#160;</a></span>isKSubconvex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::isKSubconvex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a7d43e151b418e62ff4afe64fae751986">CellGeometry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells if a given segment from <em class="arg">a</em> to <em class="arg">b</em> is digitally k-subconvex (i.e. k-tangent) to some cell cover <em class="arg">C</em>. The digital 0-subconvexity is the usual property  \( Conv( P \cap
Z^d ) \subset C \cap Z^d) \). Otherwise the property asks that the k-cells intersected by the convex hull of the segment is a subset of the k-cells of C.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>any point </td></tr>
    <tr><td class="paramname">b</td><td>any point </td></tr>
    <tr><td class="paramname">C</td><td>any cell cover geometry (i.e. a cubical complex). </td></tr>
    <tr><td class="paramname">k</td><td>the dimension for which the digital k-convexity is checked, 0 &lt;= k &lt;= <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae2b2dcf34c36a5e3eae4bf13291f1578">KSpace::dimension</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' iff the segment is a digitally <em class="arg">k-subconvex</em> of C, i.e. the two points are k-cotangent.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Three times faster than building a (degenerated) lattice polytope and then checking if it subconvex. </dd></dl>

</div>
</div>
<a id="a7d4c10d94e7311186e4f39850d1f99fb" name="a7d4c10d94e7311186e4f39850d1f99fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4c10d94e7311186e4f39850d1f99fb">&#9670;&#160;</a></span>isKSubconvex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::isKSubconvex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a796d52417c67dda07012d3d954db973a">RationalPolytope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a7d43e151b418e62ff4afe64fae751986">CellGeometry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells if a given polytope <em class="arg">P</em> is digitally k-subconvex of some cell cover <em class="arg">C</em>. The digital 0-subconvexity is the usual property  \( Conv( P \cap Z^d ) \subset C \cap Z^d)
\). Otherwise the property asks that the k-cells intersected by the convex hull of P is a subset of the k-cells of C. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>any rational polytope such that <span class="tt">P.canBeSummed() == true</span>. </td></tr>
    <tr><td class="paramname">C</td><td>any cell cover geometry (i.e. a cubical complex). </td></tr>
    <tr><td class="paramname">k</td><td>the dimension for which the digital k-convexity is checked, 0 &lt;= k &lt;= <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae2b2dcf34c36a5e3eae4bf13291f1578">KSpace::dimension</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' iff the polytope <em class="arg">P</em> is a digitally <em class="arg">k-subconvex</em> of C. </dd></dl>

</div>
</div>
<a id="afd802e9db0008dc0bc6cb07c1ac023e8" name="afd802e9db0008dc0bc6cb07c1ac023e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd802e9db0008dc0bc6cb07c1ac023e8">&#9670;&#160;</a></span>isOpenTriangleFullySubconvex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::isOpenTriangleFullySubconvex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>StarX</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells if the non-degenerated 3D open triangle a,b,c (ie without its edges and vertices) is digitally fully subconvex to some lattice set <em class="arg">Star_X</em>, i.e. the cell cover of some set X represented by lattice points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>any 3D point (distinct from the two others) </td></tr>
    <tr><td class="paramname">b</td><td>any 3D point (distinct from the two others) </td></tr>
    <tr><td class="paramname">c</td><td>any 3D point (distinct from the two others)</td></tr>
    <tr><td class="paramname">StarX</td><td>any lattice set representing an open cubical complex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' iff Y is digitally fully subconvex to X.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is supposed to be faster than the others, but is limited to 3D open triangles. </dd></dl>

</div>
</div>
<a id="a1d6b24ed0bb76b2290b5fcf899a01ce0" name="a1d6b24ed0bb76b2290b5fcf899a01ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6b24ed0bb76b2290b5fcf899a01ce0">&#9670;&#160;</a></span>isSimplexFullDimensional() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename PointIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::isSimplexFullDimensional </td>
          <td>(</td>
          <td class="paramtype">PointIterator</td>          <td class="paramname"><span class="paramname"><em>itB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointIterator</td>          <td class="paramname"><span class="paramname"><em>itE</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the given range [itB,itE) of lattice points form a full dimensional simplex, i.e. it must contain <a class="el" href="classDGtal_1_1SpaceND.html#aae87d3efb1051dbdeac28e159781ba92">Space::dimension</a>+1 points in general position.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointIterator</td><td>any model of forward iterator on <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itB</td><td>the start of the range of n+1 points defining the simplex. </td></tr>
    <tr><td class="paramname">itE</td><td>past the end the range of n+1 points defining the simplex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ae6751cef9f9f86499988b66e07af87" name="a0ae6751cef9f9f86499988b66e07af87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae6751cef9f9f86499988b66e07af87">&#9670;&#160;</a></span>isSimplexFullDimensional() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::isSimplexFullDimensional </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>l</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the given list of lattice points <em class="arg">l</em> form a full dimensional simplex, i.e. it must contain <a class="el" href="classDGtal_1_1SpaceND.html#aae87d3efb1051dbdeac28e159781ba92">Space::dimension</a>+1 points in general position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>any list of d+1 points in general positions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a737413cf5fcf1ce26dba45348ca71071" name="a737413cf5fcf1ce26dba45348ca71071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737413cf5fcf1ce26dba45348ca71071">&#9670;&#160;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::isValid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks the validity/consistency of the object. If the polytope has been default constructed, it is invalid.</p>
<dl class="section return"><dt>Returns</dt><dd>'true' if the object is valid, 'false' otherwise. </dd></dl>

</div>
</div>
<a id="a8c6af4cccb2953fa776865635baa59e6" name="a8c6af4cccb2953fa776865635baa59e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6af4cccb2953fa776865635baa59e6">&#9670;&#160;</a></span>makeCellCover() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7d43e151b418e62ff4afe64fae751986">CellGeometry</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::makeCellCover </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td>          <td class="paramname"><span class="paramname"><em>k</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae2b2dcf34c36a5e3eae4bf13291f1578">KSpace::dimension</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds the cell geometry containing all the j-cells touching the lattice polytope P, for i &lt;= j &lt;= k. It conbains thus all the j-cells intersecting the convex hull of P.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>any lattice polytope such that <span class="tt">P.canBeSummed() == true</span>. </td></tr>
    <tr><td class="paramname">i</td><td>the first dimension for which the cell cover is computed. </td></tr>
    <tr><td class="paramname">k</td><td>the last dimension for which the cell cover is computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66b3ed08c90a988c3291d224abd9f5bc" name="a66b3ed08c90a988c3291d224abd9f5bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b3ed08c90a988c3291d224abd9f5bc">&#9670;&#160;</a></span>makeCellCover() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7d43e151b418e62ff4afe64fae751986">CellGeometry</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::makeCellCover </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a796d52417c67dda07012d3d954db973a">RationalPolytope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td>          <td class="paramname"><span class="paramname"><em>k</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae2b2dcf34c36a5e3eae4bf13291f1578">KSpace::dimension</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds the cell geometry containing all the j-cells touching the rational polytope P, for i &lt;= j &lt;= k. It conbains thus all the j-cells intersecting the convex hull of P.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>any rational polytope such that <span class="tt">P.canBeSummed() == true</span>. </td></tr>
    <tr><td class="paramname">i</td><td>the first dimension for which the cell cover is computed. </td></tr>
    <tr><td class="paramname">k</td><td>the last dimension for which the cell cover is computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af588213a1371bc38f45973ef3fc331f4" name="af588213a1371bc38f45973ef3fc331f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af588213a1371bc38f45973ef3fc331f4">&#9670;&#160;</a></span>makeCellCover() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename PointIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7d43e151b418e62ff4afe64fae751986">CellGeometry</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::makeCellCover </td>
          <td>(</td>
          <td class="paramtype">PointIterator</td>          <td class="paramname"><span class="paramname"><em>itB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointIterator</td>          <td class="paramname"><span class="paramname"><em>itE</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td>          <td class="paramname"><span class="paramname"><em>k</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae2b2dcf34c36a5e3eae4bf13291f1578">KSpace::dimension</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds the cell geometry containing all the j-cells touching a point of [itB,itE), for i &lt;= j &lt;= k.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointIterator</td><td>any model of input iterator on Points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itB</td><td>start of a range of arbitrary points. </td></tr>
    <tr><td class="paramname">itE</td><td>past the end of a range of arbitrary points. </td></tr>
    <tr><td class="paramname">i</td><td>the first dimension for which the cell cover is computed. </td></tr>
    <tr><td class="paramname">k</td><td>the last dimension for which the cell cover is computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4528961df07c0a68287a7744c93e22f" name="af4528961df07c0a68287a7744c93e22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4528961df07c0a68287a7744c93e22f">&#9670;&#160;</a></span>makePolytope()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::makePolytope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>make_minkowski_summable</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a range of distinct points <em class="arg">X</em>, computes the tightiest polytope that enclosed it. Note that this polytope may contain more lattice points than the given input points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">X</td><td>any range of <b>pairwise</b> <b>distinct</b> points</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">make_minkowski_summable</td><td>Other constraints are added so that we can perform axis aligned Minkowski sums on this polytope. Useful in 2D/3D for checking digital k-convexity (see moduleDigitalConvexity).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding lattice polytope. </dd></dl>

<p class="reference">Referenced by <a class="el" href="DigitalConvexity_8h_source.html#l00573">DGtal::DigitalConvexity&lt; KSpace &gt;::CvxH()</a>.</p>

</div>
</div>
<a id="a03423890027c65b5d42ec327fd251c53" name="a03423890027c65b5d42ec327fd251c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03423890027c65b5d42ec327fd251c53">&#9670;&#160;</a></span>makeRationalSimplex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename PointIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a796d52417c67dda07012d3d954db973a">RationalPolytope</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::makeRationalSimplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#abda40d4d7309cb343b799c6acd658c8f">Integer</a></td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointIterator</td>          <td class="paramname"><span class="paramname"><em>itB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointIterator</td>          <td class="paramname"><span class="paramname"><em>itE</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a rational polytope from a rational simplex given as a range [itB,itE) of lattice points. Note that the range must contain <a class="el" href="classDGtal_1_1SpaceND.html#aae87d3efb1051dbdeac28e159781ba92">Space::dimension</a>+1 points or less in general position.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointIterator</td><td>any model of forward iterator on <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>the common denominator of all given lattice point coordinates. </td></tr>
    <tr><td class="paramname">itB</td><td>the start of the range of no more than n+1 points defining the simplex. </td></tr>
    <tr><td class="paramname">itE</td><td>past the end the range of no more than n+1 points defining the simplex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If your range is <span class="tt">[itB,itE) = { (3,2), (1,7), (6,6) }</span> and the denominator <span class="tt">d = 4</span>, then your polytope has vertices <span class="tt">{
(3/4,2/4), (1/4,7/4), (6/4,6/4) }</span>. </dd></dl>

</div>
</div>
<a id="a6943f4ca052e4badf5b12e7ab4180d55" name="a6943f4ca052e4badf5b12e7ab4180d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6943f4ca052e4badf5b12e7ab4180d55">&#9670;&#160;</a></span>makeRationalSimplex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a796d52417c67dda07012d3d954db973a">RationalPolytope</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::makeRationalSimplex </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>l</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a rational polytope from a simplex given as an initializer_list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>any list where the first point give the denominator and then no more than d+1 points in general positions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If your list is <span class="tt">l = { (4,x), (3,2), (1,7), (6,6) }</span>, then the denominator is <span class="tt">d = 4</span> and your polytope has vertices <span class="tt">{
(3/4,2/4), (1/4,7/4), (6/4,6/4) }</span>. </dd></dl>

</div>
</div>
<a id="a1f7509afa782b4513656ac5600cba55d" name="a1f7509afa782b4513656ac5600cba55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7509afa782b4513656ac5600cba55d">&#9670;&#160;</a></span>makeSimplex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename PointIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::makeSimplex </td>
          <td>(</td>
          <td class="paramtype">PointIterator</td>          <td class="paramname"><span class="paramname"><em>itB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointIterator</td>          <td class="paramname"><span class="paramname"><em>itE</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a lattice polytope from a simplex given as a range [itB,itE) of lattice points. Note that the range must contain <a class="el" href="classDGtal_1_1SpaceND.html#aae87d3efb1051dbdeac28e159781ba92">Space::dimension</a>+1 points or less in general position.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointIterator</td><td>any model of forward iterator on <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itB</td><td>the start of the range of no more than n+1 points defining the simplex. </td></tr>
    <tr><td class="paramname">itE</td><td>past the end the range of no more than n+1 points defining the simplex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a42d3bcb8d7eb9837aa73b977cbc7f5" name="a4a42d3bcb8d7eb9837aa73b977cbc7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a42d3bcb8d7eb9837aa73b977cbc7f5">&#9670;&#160;</a></span>makeSimplex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aae900cf944b90e595dedd3b73be31f4e">LatticePolytope</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::makeSimplex </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>l</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a lattice polytope from a simplex given as an initializer_list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>any list of no more than d+1 points in general positions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Note that the list must contain no more than <a class="el" href="classDGtal_1_1SpaceND.html#aae87d3efb1051dbdeac28e159781ba92">Space::dimension</a>+1 points in general position. </dd></dl>

</div>
</div>
<a id="aa408ee883fd42069e0b4500e0e651b1b" name="aa408ee883fd42069e0b4500e0e651b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa408ee883fd42069e0b4500e0e651b1b">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9e2b772563ea30ed18152853163e2b4c">Self</a> &amp; <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a9e2b772563ea30ed18152853163e2b4c">Self</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the object to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference on 'this'. </dd></dl>

</div>
</div>
<a id="a94893f395ee00f8bd8d8b5c964ab28ce" name="a94893f395ee00f8bd8d8b5c964ab28ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94893f395ee00f8bd8d8b5c964ab28ce">&#9670;&#160;</a></span>relativeEnvelope() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::relativeEnvelope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a014a1aa8d9e98f13bf9610aaf75832bb">EnvelopeAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>algo</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a014a1aa8d9e98f13bf9610aaf75832bba4c5d06b02c97731aaa976179c62dcf76">EnvelopeAlgorithm::DIRECT</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the fully convex envelope of <em class="arg">Z</em> relative to fully convex digital set <em class="arg">Y</em>, i.e.  \( FC^*_Y(Z):=FC_Y(FC_Y( \ldots
FC_Y(Z) \ldots )) \) for <em class="arg">Z</em> a range of points, until stabilization of the iterative process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Z</td><td>any range of points (must be sorted). </td></tr>
    <tr><td class="paramname">Y</td><td>any range of points (must be sorted) that is fully convex. </td></tr>
    <tr><td class="paramname">algo</td><td>the chosen method of computation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\( FC^*_Y( Z ) \)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <em class="arg">Z</em> is fully convex, then the output is <em class="arg">Z</em> itself. Otherwise, the returned set of points includes <em class="arg">Z</em> and is fully convex. </dd></dl>

</div>
</div>
<a id="a82c3e8fb60c0ace35bc1a4bb5632ee53" name="a82c3e8fb60c0ace35bc1a4bb5632ee53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c3e8fb60c0ace35bc1a4bb5632ee53">&#9670;&#160;</a></span>relativeEnvelope() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename Predicate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::relativeEnvelope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;</td>          <td class="paramname"><span class="paramname"><em>PredY</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a014a1aa8d9e98f13bf9610aaf75832bb">EnvelopeAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>algo</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a014a1aa8d9e98f13bf9610aaf75832bba4c5d06b02c97731aaa976179c62dcf76">EnvelopeAlgorithm::DIRECT</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the fully convex envelope of <em class="arg">Z</em> relative to fully convex digital set <em class="arg">Y</em> defined by a corresponding predicate <em class="arg">PredY</em>. It computes  \( FC^*_Y(Z):=FC_Y(FC_Y( \ldots FC_Y(Z) \ldots
)) \) for <em class="arg">Z</em> a range of points, until stabilization of the iterative process.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>the type of a predicate <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> -&gt; boolean </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Z</td><td>any range of points (must be sorted). </td></tr>
    <tr><td class="paramname">PredY</td><td>a <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> predicate such that <span class="tt">PredY(p)==true</span> iff <em class="arg">p</em> belongs to <em class="arg">Y</em>. </td></tr>
    <tr><td class="paramname">algo</td><td>the chosen method of computation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\( FC^*_Y( Z ) \)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <em class="arg">Z</em> is fully convex, then the output is <em class="arg">Z</em> itself. Otherwise, the returned set of points includes <em class="arg">Z</em> and is fully convex. </dd></dl>

</div>
</div>
<a id="ab94e882cab27e98d281885f08b21acad" name="ab94e882cab27e98d281885f08b21acad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94e882cab27e98d281885f08b21acad">&#9670;&#160;</a></span>selfDisplay()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::selfDisplay </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes/Displays the object on an output stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af64332b6960ab4b06ee86afd022a71f8" name="af64332b6960ab4b06ee86afd022a71f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64332b6960ab4b06ee86afd022a71f8">&#9670;&#160;</a></span>simplexType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename PointIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a346b3d21e164cc7d12d1b1c1ed1c0ccc">SimplexType</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::simplexType </td>
          <td>(</td>
          <td class="paramtype">PointIterator</td>          <td class="paramname"><span class="paramname"><em>itB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointIterator</td>          <td class="paramname"><span class="paramname"><em>itE</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the type of simplex formed by the given range [itB,itE) of lattice points.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointIterator</td><td>any model of forward iterator on <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itB</td><td>the start of the range of n+1 points defining the simplex. </td></tr>
    <tr><td class="paramname">itE</td><td>past the end the range of n+1 points defining the simplex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type of simplex formed by the given range [itB,itE) of lattice points. </dd></dl>

</div>
</div>
<a id="a369ba759d761f6f53c5a171b6b8f9c40" name="a369ba759d761f6f53c5a171b6b8f9c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369ba759d761f6f53c5a171b6b8f9c40">&#9670;&#160;</a></span>simplexType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a346b3d21e164cc7d12d1b1c1ed1c0ccc">SimplexType</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::simplexType </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>l</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the type of simplex formed by the given list <em class="arg">l</em> of lattice points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>any list of lattice points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type of simplex formed by the given list of lattice points. </dd></dl>

</div>
</div>
<a id="a351ac0c6f16600fae5f1cd89a438c936" name="a351ac0c6f16600fae5f1cd89a438c936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351ac0c6f16600fae5f1cd89a438c936">&#9670;&#160;</a></span>sizeStarCvxH()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#abda40d4d7309cb343b799c6acd658c8f">Integer</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::sizeStarCvxH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the number of cells in Star(CvxH(X)) for X a digital set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>any range of lattice points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of cells touching the convex hull of X, represented as lattice points with Khalimsky coordinates. </dd></dl>

</div>
</div>
<a id="ab60b6a17f4d1defa5a720ec14eb86ec6" name="ab60b6a17f4d1defa5a720ec14eb86ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab60b6a17f4d1defa5a720ec14eb86ec6">&#9670;&#160;</a></span>Skel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::Skel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>a range of cells represented as a lattice set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set of cells, represented as a lattice set, that form the skeleton of the given range of cells <em class="arg">C</em>. </dd></dl>

</div>
</div>
<a id="af1b96331550862a751ee769060041f2b" name="af1b96331550862a751ee769060041f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b96331550862a751ee769060041f2b">&#9670;&#160;</a></span>space()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a645bebee5bef19212d3c4328e9054ca3">KSpace</a> &amp; <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::space </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const reference to the cellular grid space used by this object. </dd></dl>

</div>
</div>
<a id="a2029a6225cad0c5db0f6334ed2833a9f" name="a2029a6225cad0c5db0f6334ed2833a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2029a6225cad0c5db0f6334ed2833a9f">&#9670;&#160;</a></span>Star()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::Star </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a83a99607075cb1757245a62b71a36a49">dimension</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds the cell complex Star(X) for X a digital set, represented as a lattice set (stacked row representation).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>any range of lattice points</td></tr>
    <tr><td class="paramname">axis</td><td>specifies the projection axis for the row representation if below space dimension, otherwise chooses the axis that minimizes memory/computations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set of cells, represented as a lattice set, that touches points of <em class="arg">X</em>, i.e. <span class="tt">Star(X)</span>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is useful to specify an axis if you wish later to compare or make operations with several lattice sets. They must indeed have the same axis. </dd></dl>

</div>
</div>
<a id="a245ed38f44d5bb34b8693b052f4a9105" name="a245ed38f44d5bb34b8693b052f4a9105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245ed38f44d5bb34b8693b052f4a9105">&#9670;&#160;</a></span>StarCells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::StarCells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a83a99607075cb1757245a62b71a36a49">dimension</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds the cell complex Star(C) for C a range of cells, represented as a lattice set (stacked row representation).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>a range of cells represented with points in Khalimsky coordinates.</td></tr>
    <tr><td class="paramname">axis</td><td>specifies the projection axis for the row representation if below space dimension, otherwise chooses the axis that minimizes memory/computations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set of cells, represented as a lattice set, that touches cells of <em class="arg">C</em>, i.e. <span class="tt">Star(C)</span>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is useful to specify an axis if you wish later to compare or make operations with several lattice sets. They must indeed have the same axis. </dd></dl>

</div>
</div>
<a id="a0623dcc5e54f21ea53a84248a864f619" name="a0623dcc5e54f21ea53a84248a864f619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0623dcc5e54f21ea53a84248a864f619">&#9670;&#160;</a></span>StarCvxH() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::StarCvxH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a83a99607075cb1757245a62b71a36a49">dimension</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds the cell complex <span class="tt"><a class="el" href="#a2029a6225cad0c5db0f6334ed2833a9f">Star</a>(<a class="el" href="#a3bfa3e199bb8c80908fedee176898c30">CvxH</a>({a,b,c}))</span> for <span class="tt">a,b,c</span> a non-degenerate 3D triangle, represented as a lattice set (stacked row representation).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>any 3D point (distinct from the two others) </td></tr>
    <tr><td class="paramname">b</td><td>any 3D point (distinct from the two others) </td></tr>
    <tr><td class="paramname">c</td><td>any 3D point (distinct from the two others) <br  />
</td></tr>
    <tr><td class="paramname">axis</td><td>specifies the projection axis for the row representation if below space dimension, otherwise chooses the axis that minimizes memory/computations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range of cells touching the triangle <span class="tt">abc</span>, represented as a lattice set (cells are represented with Khalimsky coordinates). If the triangle is degenerate (a,b,c not distinct or aligned), then it returns an empty range of cells.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is useful to specify an axis if you wish later to compare or make operations with several lattice sets. They must indeed have the same axis. </dd></dl>

</div>
</div>
<a id="abd689cce05efc14754c8aceb90159be9" name="abd689cce05efc14754c8aceb90159be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd689cce05efc14754c8aceb90159be9">&#9670;&#160;</a></span>StarCvxH() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::StarCvxH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a83a99607075cb1757245a62b71a36a49">dimension</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds the cell complex Star(CvxH(X)) for X a digital set, represented as a lattice set (stacked row representation).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>any range of lattice points</td></tr>
    <tr><td class="paramname">axis</td><td>specifies the projection axis for the row representation if below space dimension, otherwise chooses the axis that minimizes memory/computations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range of cells touching the convex hull of X, represented as a lattice set (cells are represented with Khalimsky coordinates).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is useful to specify an axis if you wish later to compare or make operations with several lattice sets. They must indeed have the same axis. </dd></dl>

</div>
</div>
<a id="a76ba6cf1955ac564030adc2081763ac9" name="a76ba6cf1955ac564030adc2081763ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ba6cf1955ac564030adc2081763ac9">&#9670;&#160;</a></span>StarOpenTriangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::StarOpenTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a872846f72d723e634ba406584a4e0db9">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a83a99607075cb1757245a62b71a36a49">dimension</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds the cell complex <span class="tt"><a class="el" href="#a2029a6225cad0c5db0f6334ed2833a9f">Star</a>(OpenTriangle({a,b,c}))</span> for <span class="tt">a,b,c</span> the vertices of a non-degenerate open 3D triangle (ie without edges or vertices), represented as a lattice set (stacked row representation).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>any 3D point (distinct from the two others) </td></tr>
    <tr><td class="paramname">b</td><td>any 3D point (distinct from the two others) </td></tr>
    <tr><td class="paramname">c</td><td>any 3D point (distinct from the two others) <br  />
</td></tr>
    <tr><td class="paramname">axis</td><td>specifies the projection axis for the row representation if below space dimension, otherwise chooses the axis that minimizes memory/computations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range of cells touching the open triangle <span class="tt">abc</span>, represented as a lattice set (cells are represented with Khalimsky coordinates). If the triangle is degenerate (a,b,c not distinct or aligned), then it returns an empty range of cells.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is useful to specify an axis if you wish later to compare or make operations with several lattice sets. They must indeed have the same axis. </dd></dl>

</div>
</div>
<a id="a0cf6fcb3429bc769113e428ba3bb80ca" name="a0cf6fcb3429bc769113e428ba3bb80ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf6fcb3429bc769113e428ba3bb80ca">&#9670;&#160;</a></span>toLatticeSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::toLatticeSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td>          <td class="paramname"><span class="paramname"><em>axis</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a83a99607075cb1757245a62b71a36a49">dimension</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds the lattice set (stacked row representation) associated to the given range of points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>any range of lattice points</td></tr>
    <tr><td class="paramname">axis</td><td>specifies the projection axis for the row representation if below space dimension, otherwise chooses the axis that minimizes memory/computations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the lattice set that represents the exact same points as <em class="arg">X</em> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is useful to specify an axis if you wish later to compare or make operations with several lattice sets. They must indeed have the same axis. </dd></dl>

</div>
</div>
<a id="aa5d8709b29cfef087f56f04e1f33a8ac" name="aa5d8709b29cfef087f56f04e1f33a8ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d8709b29cfef087f56f04e1f33a8ac">&#9670;&#160;</a></span>toPointRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::toPointRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aab180574b64e761af7f666d855e952ad">LatticeSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>L</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds the range of lattice points associated to the given lattice set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>any lattice set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the point range that represents the exact same points as <em class="arg">L</em> </dd></dl>

</div>
</div>
<a id="a302be61022a992c9ddc6c0b8b3f11735" name="a302be61022a992c9ddc6c0b8b3f11735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302be61022a992c9ddc6c0b8b3f11735">&#9670;&#160;</a></span>U()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::U </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a6ca2be6c9d11457094c57044df502040">PointRange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs the digital Minkowski sum of <em class="arg">X</em> along direction <em class="arg">i</em> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any valid dimension </td></tr>
    <tr><td class="paramname">X</td><td>any <b>sorted</b> range of digital points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <b>sorted</b> range of digital points X union the translation of X of one along direction <em class="arg">i</em>. </dd></dl>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Field Documentation</h2>
<a id="a83a99607075cb1757245a62b71a36a49" name="a83a99607075cb1757245a62b71a36a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a99607075cb1757245a62b71a36a49">&#9670;&#160;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::dimension = <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae2b2dcf34c36a5e3eae4bf13291f1578">KSpace::dimension</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l00100">100</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>

</div>
</div>
<a id="a6540a3cdf5bb2615fff664801802be80" name="a6540a3cdf5bb2615fff664801802be80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6540a3cdf5bb2615fff664801802be80">&#9670;&#160;</a></span>myDepthLastFCE</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aeaefb58e537bffc356950285789f3b54">Size</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::myDepthLastFCE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel mutable">mutable</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of iterations of the last FullyConvexEnvelope operation. </p>

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l01055">1055</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>

</div>
</div>
<a id="ade0ce0fbf443414698b879b9c92ef685" name="ade0ce0fbf443414698b879b9c92ef685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0ce0fbf443414698b879b9c92ef685">&#9670;&#160;</a></span>myK</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bebee5bef19212d3c4328e9054ca3">KSpace</a> <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::myK</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The cellular grid space where computations are done. </p>

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l01047">1047</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>

</div>
</div>
<a id="ab66399583bfd6e03d765d9644611553c" name="ab66399583bfd6e03d765d9644611553c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66399583bfd6e03d765d9644611553c">&#9670;&#160;</a></span>mySafe</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity</a>&lt; TKSpace &gt;::mySafe</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>when 'true' performs convex hull computations with arbitrary precision integer (if available), otherwise chooses a compromise between speed and precision (<a class="el" href="namespaceDGtal.html#a45f076335dc184c6b7267b006362f5aa" title="signed 94-bit integer.">int64_t</a>). </p>

<p class="definition">Definition at line <a class="el" href="DigitalConvexity_8h_source.html#l01052">1052</a> of file <a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="DigitalConvexity_8h_source.html">DigitalConvexity.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceDGtal.html">DGtal</a></li><li class="navelem"><a href="classDGtal_1_1DigitalConvexity.html">DigitalConvexity</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for DGtal by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
