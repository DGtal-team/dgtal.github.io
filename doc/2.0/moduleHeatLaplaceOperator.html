<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Heat Kernel Laplace&ndash;Beltrami Operator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('moduleHeatLaplaceOperator.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Heat Kernel Laplace&ndash;Beltrami Operator </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Caissard Thomas</dd></dl>
<h1 class="doxsection"><a class="anchor" id="sectHeatIntro"></a>
Continuous Laplace&ndash;Beltrami operator</h1>
<p>Let \(M\) be a smooth manifold. The linear operator  \(\Delta : C^2(\partial
M) \rightarrow C^2(\partial M)\) (where \(C^2(\partial M)\) is the set of twice differentiable function acting on \(\partial M\)) defined by </p><p class="formulaDsp">
\[ \Delta u = \nabla^2 u = \nabla \cdot \nabla u, \]
</p>
<p> is called the Laplace&ndash;Beltrami operator. </p><dl class="section note"><dt>Note</dt><dd>The sign of the operator is arbitrary, and one may found in the litterature the alternative definition \(-\nabla \cdot \nabla u\) for \(\Delta u\).</dd></dl>
<p>For example, in \( \mathbb{R}^d \), the operator is the sum of the second derivatives:  </p><p class="formulaDsp">
\[ \Delta_{\mathbb{R}^d} u(x) = \sum_i
\frac{\partial^2}{\partial x_i^2}u(x). \]
</p>
<p> This operator can be expressed in local coordinates system on a manifold given the metric tensor \(g_{ij}\):   </p><p class="formulaDsp">
\[ \Delta
u = \frac{1}{\sqrt{g}} \partial_i \left( \sqrt{|g|}g^{ij}\partial_j u \right),
\]
</p>
<p> with the Einstein notation implied (meaning that repeated indexes are summed over), \( \sqrt{|g|}\) is the absolute value of the determinant of  \( g_{ij}
\) and \( \partial_i = \frac{\partial}{\partial x^i}\) is the basis of the tangent plane \(T_p M\) at a point \(p\).</p>
<p>The operator can also be written in a coordinate-free manner using the exterior calculus theory. Given a function \(w\) (ie. a 0-form) we have  </p><p class="formulaDsp">
\[ \Delta w =
\star d \star d w, \]
</p>
<p> where \(\star\) is the hodge operator and \( d \) the exterior derivative.</p>
<h1 class="doxsection"><a class="anchor" id="subBelkin"></a>
The Laplace&ndash;Beltrami operator from the Heat Equation</h1>
<p>Let \(g : \partial M \times (0, T) \rightarrow \mathbb{R}\) be a time-dependent function which solves the partial differential equation called the heat equation: </p><p class="formulaDsp">
\[ \Delta g(x, t) = \frac{\partial}{\partial t}g(x, t), \]
</p>
<p> with initial condition \(u = g(\cdot, 0) : \partial M \rightarrow \mathbb{R}\) which is the initial temperature distribution.</p>
<div class="image">
<img src="heat_diffusion_manifold.png" alt=""/>
<div class="caption">
The heat diffusion on a manifold. The heat kernel is represented in green, the geodesic distance in blue.</div></div>
<p>An exact solution is: </p><p class="formulaDsp">
\[ \int_{y\in \partial M} p(t, x, y) u(y) dy, \]
</p>
<p> where \(p \in C^\infty(\mathbb{R}^+ \times \partial M \times \partial M)\) is the heat kernel <a class="el" href="citelist.html#CITEREF_rosenberg">[103]</a>.</p>
<p>There is a wide range of studies on the behavior of \(p\) when \(t\) tends to zero (called small time asymptotics of diffusion process). Early works include the famous Varadhan formula <a class="el" href="citelist.html#CITEREF_varadhan">[119]</a> on closed manifolds with or without borders later extended by Molchanov <a class="el" href="citelist.html#CITEREF_molchanov">[94]</a> on a wider class of shapes:  </p><p class="formulaDsp">
\[ p(t,x,y) \mathrel{\mathop{\sim}\limits_{t \rightarrow 0}} \frac{e^{-
\frac{d(x,y)^2}{4 t}}}{(4\pi t)^{\frac{d}{2}}} \]
</p>
<p> where \(d(\cdot,\cdot)\) corresponds to the intrinsic geodesic distance. This approximation is not robust in practice and very sensitive to both geodesic distance approximation and numerical errors <a class="el" href="citelist.html#CITEREF_crane2013">[41]</a>. Fortunately we know from Belkin et al. <a class="el" href="citelist.html#CITEREF_belkinn08">[11]</a> that in small time asymptotics, the geodesic distance can be approximated by the \(l_2\) distance:   </p><p class="formulaDsp">
\[ p(t,x,y)
\mathrel{\mathop{\sim}\limits_{t \rightarrow 0}} \tilde{p}(t,x,y) := \frac{e^{ -
\frac{||x - y||^2}{4t} }}{(4 \pi t)^{\frac{d}{2}}}, \]
</p>
<p> which leads to the following approximated solution of the heat equation:  </p><p class="formulaDsp">
\[ g(x,t) = \int_{y \in
\partial M} \tilde{p}(t,x,y) u(y)dy. \]
</p>
<p>By injecting the approximation into the heat equation we obtain:   </p><p class="formulaDsp">
\[ \Delta g(x,
t) = \frac{\partial}{\partial t} \int_{ y\in \partial M } \tilde{p}(t, x, y)
u(y)dy. \]
</p>
<p> Using a finite difference on \(t\), and the basic property that the integral of the heat kernel must be one:   </p><p class="formulaDsp">
\[ \Delta g(x, t) = \lim\limits_{t
\rightarrow 0} \frac{1}{t} \int_{y\in \partial M } \tilde{p}(t, x, y) (u(y) -
u(x))dy. \]
</p>
<h1 class="doxsection"><a class="anchor" id="secDiscre"></a>
The Discretization on Digital Surfaces</h1>
<p>We adapt the formulation of Belkin et al. on digital surfaces (see <a class="el" href="citelist.html#CITEREF_caissarddgci2017">[18]</a>). In the continuous heat kernel formulation, the parameter \(t\) must tend to zero. On digital surfaces, we set \(t\) as a function of the grid step \(h\), denoted \(t_h\), that tends to zero as \(h\) tends to zero.</p>
<dl class="section note"><dt>Note</dt><dd>Typically the time parameter is set to \(t_h = k \cdot h^{\alpha}\) with \(\alpha\) positive and \(k\) is a constant depending on the input shape.</dd></dl>
<p>The discretization on digital surfaces is     </p><p class="formulaDsp">
\[ (\Delta_{DIGI} \, f)({\mathbf{s}})
:= \frac{1}{t_h(4 \pi t_h)^{\frac{d}{2}}} \sum_{\mathbf{r}\in \mathbb{F}^d }
e^{- \frac{||\dot{\mathbf{r}}
        - \dot{\mathbf{s}}||^2}{4t_h}}  [f(\dot{{\mathbf{r}}})
    - f(\dot{{\mathbf{s}}})]\mu(\mathbf{r}), \]
</p>
<p> where \(\mathbb{F}^d\) is the set of elements dimension \(d\) (for example surfels in a 2D surface embedded in 3D), \(\dot{\mathbf{r}}\) (resp. \(\dot{\mathbf{s}}\)) is the centroid of the surfel \(\mathbf{r}\) (resp. \(\mathbf{s}\)), and \(\mu(\mathbf{r})\) is equal to the dot product between an estimated normal and the trivial normal orthogonal to the surfel \(\mathbf{s}\). We typically use the Integral Invariant estimator for normal computation.</p>
<h1 class="doxsection"><a class="anchor" id="secHowToHeatLaplace"></a>
Hands on the Operator in DGtal</h1>
<p>This section provides an overview on how to use the Heat Laplace in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>. The operator is embedded inside the DEC structure of <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>. The following code comes from the file <a class="el" href="exampleHeatLaplace_8cpp_source.html">exampleHeatLaplace.cpp</a>. We demonstrate the usage of the heat operator on a function defined on the unit sphere. The laplace operator in spherical coordinates on the unit sphere is   </p><p class="formulaDsp">
\[ \Delta = \frac{1}{
\sin^2(\theta) } \frac{\partial^2}{\partial \theta^2} + \frac{1}{\sin(\phi)}
\frac{\partial}{\partial \phi}( \sin(\phi) \frac{\partial}{\partial \phi} ) \]
</p>
<p> We choose the function \(f(x,y,z) = x^2\). Its Laplacian is then   \( \Delta
f(r, \theta, \phi) = 2 \cos(\theta)^2 ( 2 \cos(\phi)^2 - \sin(\phi)^2 ) + 2(
\sin(\theta)^2 - cos(\theta)^2 ) \).</p>
<p>You must first compute the boundary of the surface, that is here for example the set of surfels of the boundary of the unit sphere.</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1GaussDigitizer.html">GaussDigitizer&lt;Z3i::Space, Shape&gt;</a> Digitizer;</div>
<div class="line"> </div>
<div class="line">  Digitizer digitizer;</div>
<div class="line">  digitizer.<a class="code hl_function" href="classDGtal_1_1GaussDigitizer.html#a551a9b8729b70c0ce4c35c5d52391ce2">attach</a>(shape);</div>
<div class="line">  digitizer.init(shape.getLowerBound() + <a class="code hl_typedef" href="namespaceDGtal_1_1Z3i.html#ae17e112888e54316e9523b52d2b78245">Z3i::Vector</a>(-1,-1,-1), shape.getUpperBound() + <a class="code hl_typedef" href="namespaceDGtal_1_1Z3i.html#ae17e112888e54316e9523b52d2b78245">Z3i::Vector</a>(1,1,1), options.<a class="code hl_variable" href="structOptions.html#ad345c740ff94c483319d90c65010e335">h</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_typedef" href="namespaceDGtal_1_1Z3i.html#a39a69f8da09f1094df563ca067927c61">Z3i::Domain</a> <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a> = digitizer.getDomain();</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_typedef" href="namespaceDGtal_1_1Z3i.html#a4c1b0b50dafb838783bc2347a840147d">Z3i::KSpace</a> kspace;</div>
<div class="line">  <span class="keywordtype">bool</span> ok = kspace.<a class="code hl_function" href="classDGtal_1_1KhalimskySpaceND.html#a15dcbcaae831dd1c36090e6336c177d4">init</a>(<a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.lowerBound(), <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.upperBound(), <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">if</span>( !ok ) std::cerr &lt;&lt; <span class="stringliteral">&quot;KSpace init failed&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_typedef" href="classDGtal_1_1KhalimskySpaceND.html#a0a02413be83a0f38f23ed5cb45c2bcc4">KSpace::SurfelSet</a> <a class="code hl_typedef" href="greedy-plane-segmentation-ex2_8cpp.html#a9e248ca0929052a040e6dfa7018611c2">SurfelSet</a>;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1SetOfSurfels.html">SetOfSurfels&lt; KSpace, SurfelSet &gt;</a> MySetOfSurfels;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1DigitalSurface.html">DigitalSurface&lt; MySetOfSurfels &gt;</a> <a class="code hl_typedef" href="greedy-plane-segmentation-ex2_8cpp.html#a03d731f44ed1110acdbefdc2357f84cf">MyDigitalSurface</a>;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency&lt;KSpace::dimension&gt;</a> MySurfelAdjacency;</div>
<div class="line"> </div>
<div class="line">  MySurfelAdjacency surfAdj( <span class="keyword">true</span> ); <span class="comment">// interior in all directions.</span></div>
<div class="line">  MySetOfSurfels theSetOfSurfels( kspace, surfAdj );</div>
<div class="line">  <a class="code hl_function" href="classDGtal_1_1Surfaces.html#af61619b3dbd948aea387202369bddd6f">Surfaces&lt;KSpace&gt;::sMakeBoundary</a>( theSetOfSurfels.surfelSet(),</div>
<div class="line">                   kspace, digitizer,</div>
<div class="line">                   <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.lowerBound(),</div>
<div class="line">                   <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.upperBound() );</div>
<div class="line">  <a class="code hl_typedef" href="greedy-plane-segmentation-ex2_8cpp.html#a03d731f44ed1110acdbefdc2357f84cf">MyDigitalSurface</a> digSurf( theSetOfSurfels );</div>
</div><!-- fragment --><p>Then, we need to compute the estimated area of a surfel, i.e. the quantity  \(\mu \). We use the Integral Invariant estimator to compute the estimated normals of the surfels (see <a class="el" href="moduleIntegralInvariant.html">Integral invariant curvature estimator 2D/3D</a>). We use the same parameter \( \alpha = 1 / 3\) for Integral Invariant and our Laplace&ndash;Beltrami estimator.</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> <a class="code hl_struct" href="structDGtal_1_1CanonicSCellEmbedder.html">CanonicSCellEmbedder&lt;KSpace&gt;</a> <a class="code hl_struct" href="structDGtal_1_1CanonicSCellEmbedder.html">CanonicSCellEmbedder</a>;</div>
<div class="line">  <a class="code hl_struct" href="structDGtal_1_1CanonicSCellEmbedder.html">CanonicSCellEmbedder</a> canonicSCellEmbedder(kspace);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1functors_1_1IINormalDirectionFunctor.html">functors::IINormalDirectionFunctor&lt;Space&gt;</a> MyIINormalFunctor;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1IntegralInvariantCovarianceEstimator.html">IntegralInvariantCovarianceEstimator&lt;KSpace, Digitizer, MyIINormalFunctor&gt;</a> MyIINormalEstimator;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> radius = options.<a class="code hl_variable" href="structOptions.html#a4f225904fa3e9bc0ae26cfb2958e6f8b">normal_radius</a> * pow(options.<a class="code hl_variable" href="structOptions.html#ad345c740ff94c483319d90c65010e335">h</a>, 1. / 3.);</div>
<div class="line"> </div>
<div class="line">  MyIINormalFunctor normalFunctor;</div>
<div class="line">  normalFunctor.init(options.<a class="code hl_variable" href="structOptions.html#ad345c740ff94c483319d90c65010e335">h</a>, radius);</div>
<div class="line"> </div>
<div class="line">  MyIINormalEstimator normalEstimator(normalFunctor);</div>
<div class="line">  normalEstimator.attach(kspace, digitizer);</div>
<div class="line">  normalEstimator.setParams(radius / options.<a class="code hl_variable" href="structOptions.html#ad345c740ff94c483319d90c65010e335">h</a>);</div>
<div class="line"> </div>
<div class="line">  normalEstimator.init(options.<a class="code hl_variable" href="structOptions.html#ad345c740ff94c483319d90c65010e335">h</a>, digSurf.begin(), digSurf.end());</div>
</div><!-- fragment --><p>The DEC structure is initialized using the normal estimator (if no normal estimators is given, the surface area will be one as default, which leads to a poor estimation of the laplace operator)</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1DiscreteExteriorCalculus.html">DiscreteExteriorCalculus&lt;2, 3, EigenLinearAlgebraBackend&gt;</a> Calculus;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1DiscreteExteriorCalculusFactory.html">DiscreteExteriorCalculusFactory&lt;EigenLinearAlgebraBackend&gt;</a> CalculusFactory;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> Calculus <a class="code hl_variable" href="dgtalCalculus-geodesic_8cpp.html#a4e9d205fb8308b3d07478e48bf63308c">calculus</a> = CalculusFactory::createFromNSCells&lt;2&gt;(digSurf.begin(), digSurf.end(), normalEstimator, options.<a class="code hl_variable" href="structOptions.html#ad345c740ff94c483319d90c65010e335">h</a>);</div>
</div><!-- fragment --><p>As we compute the laplace operator on surfels, the input function is represented by a 2-form in the dec structure.</p>
<dl class="section note"><dt>Note</dt><dd>The order of the input surfels is not the same as the internal order of DEC. You must use getCellIndex from DEC to retrieve the internal order of a cell.</dd></dl>
<div class="fragment"><div class="line">  Calculus::DualForm0 input_func(<a class="code hl_variable" href="dgtalCalculus-geodesic_8cpp.html#a4e9d205fb8308b3d07478e48bf63308c">calculus</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keyword">auto</span> itb = digSurf.begin(), ite = digSurf.end(); itb != ite; itb++)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> Calculus::Index i_calc = <a class="code hl_variable" href="dgtalCalculus-geodesic_8cpp.html#a4e9d205fb8308b3d07478e48bf63308c">calculus</a>.getCellIndex( kspace.<a class="code hl_function" href="classDGtal_1_1KhalimskySpaceND.html#a22d8a0b3bf9ab0c07596ff57af908f92">unsigns</a>( *itb ) );</div>
<div class="line">    input_func.myContainer( i_calc ) = input_function( options.<a class="code hl_variable" href="structOptions.html#ad345c740ff94c483319d90c65010e335">h</a> * canonicSCellEmbedder( *itb ) );</div>
<div class="line">  }</div>
</div><!-- fragment --><p>We can now construct the Laplace operator. It is a DualIdentity of 2-forms, i.e. a linear operator acting on 2-forms represented internally by a sparse matrix. The function heatLaplace of DEC is templated by the duality of the operator. If you want to compute the operator on 0-forms (on points), you must pass PRIMAL as template parameter. We use here the dual operator. The function takes as input the grid size \( h \), the time parameter for the convolution \( t_h \) and a variance multiplier for the integration \( K \).</p>
<dl class="section note"><dt>Note</dt><dd>As mentionned earlier, the time parameter is generaly set to  \( t_h = k
\cdot h^\alpha \) where \(k\) is a constant depending on the input shape which roughly corresponds to the size of the Gaussian kernel in the euclidean space (here \(k = 0.1\) for the unit sphere).</dd></dl>
<p>The integration is done within the cut locus range: we only sum points which euclidean distance is inferior to \( K \sigma = K \sqrt{2t} \) (where \(\sigma\) is the variance of the Gaussian function). Indeed it is known that almost all the mass under a Gaussian in contained within a few multiples of \( \sigma \) (typically two or three time \(\sigma\)).</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> t = options.<a class="code hl_variable" href="structOptions.html#a60b7bebd1e141b0ddf7802422cf9aff4">convolution_radius</a> * pow(options.<a class="code hl_variable" href="structOptions.html#ad345c740ff94c483319d90c65010e335">h</a>, 2. / 3.);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a> = log( - log1p( t ) ) + 2.;</div>
<div class="line">  <span class="keyword">const</span> Calculus::DualIdentity0 laplace = <a class="code hl_variable" href="dgtalCalculus-geodesic_8cpp.html#a4e9d205fb8308b3d07478e48bf63308c">calculus</a>.heatLaplace&lt;<a class="code hl_enumvalue" href="namespaceDGtal.html#ab8007ddbb5627666913e18c3b951745dac649578cee4b5463ded5048fdaa47a41">DUAL</a>&gt;(options.<a class="code hl_variable" href="structOptions.html#ad345c740ff94c483319d90c65010e335">h</a>, t, <a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>);</div>
</div><!-- fragment --><p>Finally, the result is computed with a simple matrix multiplication</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> Eigen::VectorXd laplace_result = (laplace * input_func).myContainer;</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="index.html">DGtal - Digital Geometry Tools and Algorithms Library.</a></li><li class="navelem"><a href="packageDEC.html">DEC package</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for DGtal by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
