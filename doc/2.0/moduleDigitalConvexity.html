<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Digital convexity, full convexity and P-convexity</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('moduleDigitalConvexity.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Digital convexity, full convexity and P-convexity </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Jacques-Olivier Lachaud</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1</dd></dl>
<p>Part of the <a class="el" href="packageGeometry.html">Geometry package</a>.</p>
<p>This part of the manual describes tools associated to a new definition of digital convexity, called the <b>full</b> <b>convexity</b> <a class="el" href="citelist.html#CITEREF_lachaud_dgmm_2021">[79]</a> <a class="el" href="citelist.html#CITEREF_lachaud_jmiv_2022">[80]</a> . This new definition solves many problems related to the usual definition of digital convexity, like possible non connectedness or non simple connectedness, while encompassing its desirable features. Fully convex sets are digitally convex, but are also connected and simply connected. They have a morphological characterisation, which induces a simple convexity test algorithm. As an important example, arithmetic planes are fully convex too. Since <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> release 1.5, <b>P-convexity</b> can also be checked in arbitrary dimension. It is worth to note that it is equivalent to full convexity, and is generally faster to check <a class="el" href="citelist.html#CITEREF_feschet_2024_dgmm">[55]</a> .</p>
<p>The following programs are related to this documentation: <a class="el" href="exampleDigitalConvexity_8cpp.html" title="An example file for DigitalConvexity in 2D.">geometry/curves/exampleDigitalConvexity.cpp</a>, <a class="el" href="exampleRationalConvexity_8cpp_source.html">geometry/curves/exampleRationalConvexity.cpp</a>, <a class="el" href="testBoundedLatticePolytope_8cpp.html">testBoundedLatticePolytope.cpp</a>, <a class="el" href="testBoundedLatticePolytopeCounter_8cpp.html">testBoundedLatticePolytopeCounter.cpp</a>, <a class="el" href="testCellGeometry_8cpp.html">testCellGeometry.cpp</a>, <a class="el" href="testDigitalConvexity_8cpp.html">testDigitalConvexity.cpp</a>, <a class="el" href="testEhrhartPolynomial_8cpp.html">testEhrhartPolynomial.cpp</a>, <a class="el" href="exampleBoundedLatticePolytopeCount2D_8cpp.html">geometry/volumes/exampleBoundedLatticePolytopeCount2D.cpp</a>, <a class="el" href="exampleBoundedLatticePolytopeCount3D_8cpp.html">geometry/volumes/exampleBoundedLatticePolytopeCount3D.cpp</a>, <a class="el" href="exampleBoundedLatticePolytopeCount4D_8cpp.html">geometry/volumes/exampleBoundedLatticePolytopeCount4D.cpp</a>, <a class="el" href="pConvexity-benchmark_8cpp.html">geometry/volumes/pConvexity-benchmark.cpp</a> .</p>
<p>This module relies on module <a class="el" href="moduleQuickHull.html">QuickHull algorithm in arbitrary dimension for convex hull and Delaunay cell complex computation</a> for convex hull computations in arbitrary dimensions.</p>
<p>You may also look at <a class="el" href="moduleDigitalConvexityApplications.html">Applications of full digital convexity</a> to see some applications of full convexity.</p>
<p>See <a class="el" href="moduleEnvelope.html">Fully convex envelope, relative fully convex envelope and digital polyhedra</a> to see how to build fully convex hulls and digital polyhedra.</p>
<h1 class="doxsection"><a class="anchor" id="dgtal_dconvexity_sec1"></a>
Introduction to full convexity</h1>
<p>The usual definition for <b>digital</b> <b>convexity</b> is as follows. For some digital set \( S \subset \mathbb{Z}^d \), \( S \) is said to be <em>digitally</em> <em>convex</em> whenever  \( \mathrm{Conv}(S) \cap \mathbb{Z}^d =
S \). Otherwise said, the convex hull of all the digital points contains exactly these digital points and no other.</p>
<p>Although handy and easy to check, this definition lacks many properties related to (continuous) convexity in the Euclidean plane.</p>
<p>We extend this definition as follows (see <a class="el" href="citelist.html#CITEREF_lachaud_dgmm_2021">[79]</a> <a class="el" href="citelist.html#CITEREF_lachaud_jmiv_2022">[80]</a> ). Let \( C^d \) be the usual regular cubical complex induced by the lattice \( \mathbb{Z}^d \), and let  \( C^d_k
\) be its <em class="arg">k-cells</em>, for \( 0 \le k \le d \). We have that the 0-cells of \( C^d_0 \) are exactly the lattice points, the 1-cells of \( C^d_1 \) are the open unit segment joining 2 neighboring lattice points, etc.</p>
<p>Finally, for an arbitrary subset \( Y \subset \mathbb{R}^d \), we denote by \( C^d_k \lbrack Y \rbrack \) the set of k-cells of  \(C^d \) whose closure have a non-empty intersection with \( Y \), i.e.  \( C^d_k \lbrack Y \rbrack := \{ c \in C^d_k,~\text{s.t.}~ \bar{c} \cap
Y \neq \emptyset \} \).</p>
<p><a class="el" href="structA.html">A</a> digital set \( S \subset \mathbb{Z}^d \) is said to be <b>digitally</b> <em class="arg">k-</em> <b>convex</b> whenever  \( C^d_k \lbrack \mathrm{Conv}(S)
\rbrack = C^d_k \lbrack S \rbrack \). \( S \) is said to be <b>fully</b> (digitally) <b>convex</b> whenever it is digitally <em class="arg">k-</em> convex for \( 0 \le k \le d \).</p>
<p><a class="el" href="structA.html">A</a> fully convex set is always \( 3^d-1 \)-connected (i.e. 8-connected in 2D, 26-connected in 3D). Furthermore its axis-aligned slices are connected (with the same kind of connectedness). It is also clear that digitally 0-convexity is the usual digital convexity.</p>
<div class="image">
<img src="non-fully-convex-triangles.png" alt=""/>
<div class="caption">
Examples of non fully digitally convex triangles in Z2. Missing 1-cells for 1-digital convexity are in blue, Missing 2-cells for 2-digital convexity are in green.</div></div>
<p></p>
<p><a class="el" href="structA.html">A</a> last useful notion is the <em>subconvexity</em>, or <em>tangency</em>. Let  \( X \subset
\mathbb{Z}^d \) some arbitrary digital set. Then the digital set  \(S \subset \mathbb{Z}^d \) is said to be <b>digitally</b> <em class="arg">k-</em> <b>subconvex</b> to \( X \) whenever  \( C^d_k \lbrack \mathrm{Conv}(S)
\rbrack \subset C^d_k \lbrack X \rbrack \). And \( S \) is said to be <b>fully</b> (digitally) <b>subconvex</b> to \( X \) whenever it is digitally <em class="arg">k-</em> subconvex to \( X \) for \( 0 \le k \le d \).</p>
<p>Subconvexity is a useful for notion for digital contour and surface analysis. It tells which subsets of these digital sets are <em>tangent</em> to them.</p>
<p>The notion of <b>P-convexity</b> has been proposed in <a class="el" href="citelist.html#CITEREF_feschet_2024_dgmm">[55]</a> . <a class="el" href="structA.html">A</a> set \( S \subset \mathbb{Z}^d \) is <b>P-convex</b> if and only if</p>
<ul>
<li>\( S \) is 0-convex,</li>
<li>and, if \( d &gt; 1 \), the $d$ projections of $S$ along each axis is P-convex (in \( \mathbb{Z}^{d-1} \)).</li>
</ul>
<p>P-convexity is equivalent to full convexity as shown in <a class="el" href="citelist.html#CITEREF_feschet_2024_dgmm">[55]</a> .</p>
<h1 class="doxsection"><a class="anchor" id="dgtal_dconvexity_sec2"></a>
Classes and functions related to digital convexity</h1>
<p>Three classes help to check digital convexity.</p>
<ul>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html" title="Aim: Represents an nD lattice polytope, i.e. a convex polyhedron bounded with vertices with integer c...">BoundedLatticePolytope</a> is the class that is used to build polytopes, i.e. intersections of half-spaces, which are a way to represent convex polyhedra.</li>
<li><a class="el" href="classDGtal_1_1CellGeometry.html" title="Aim: Computes and stores sets of cells and provides methods to compute intersections of lattice and r...">CellGeometry</a> is used to store sets of cells and provides methods to build the set of cells that intersect a polytope or the set of cells that touch a set of digital points.</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html" title="Aim: A helper class to build polytopes from digital sets and to check digital k-convexity and full co...">DigitalConvexity</a> provides many helper methods to build <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html" title="Aim: Represents an nD lattice polytope, i.e. a convex polyhedron bounded with vertices with integer c...">BoundedLatticePolytope</a> and <a class="el" href="classDGtal_1_1CellGeometry.html" title="Aim: Computes and stores sets of cells and provides methods to compute intersections of lattice and r...">CellGeometry</a> objects and to check digital convexity and subconvexity.</li>
<li><a class="el" href="classDGtal_1_1PConvexity.html" title="Aim: A class to check if digital sets are P-convex. The P-convexity is defined as follows: A digital ...">PConvexity</a> provides functions to check digital convexity and P-convexity, as well a full convexity measure that is characteristics of full convex sets (or equivalently P-convex sets).</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="dgtal_dconvexity_sec21"></a>
Lattice polytopes</h2>
<p><b>Construction</b>. You have different ways to build the lattice polytope:</p>
<ul>
<li>from a <em class="arg">full</em> <em class="arg">dimensional</em> <em class="arg">simplex:</em> you may build a polytope in dimension \( d \le 3 \) from a range of \( n \le d + 1 \) points in general position. The polytope is then a simplex. For dimensions higher than 3, you may only build the polytope from a full dimensional simplex, i.e. \( n = d + 1 \) in general position.</li>
<li>from a <em class="arg">domain</em> and a <em class="arg">range</em> <em class="arg">of</em> <em class="arg">half-spaces</em>: they define obviously a bounded H-polytope.</li>
<li>from an <em class="arg">arbitrary</em> <em class="arg">set</em> <em class="arg">of</em> <em class="arg">points</em> (full dimensional is the dimension is greater or equal to 4) using <a class="el" href="classDGtal_1_1DigitalConvexity.html#af4528961df07c0a68287a7744c93e22f">DigitalConvexity::makePolytope</a> or <a class="el" href="structDGtal_1_1ConvexityHelper.html#af88821410e5a9327537ee884249d7034">ConvexityHelper::computeLatticePolytope</a>.</li>
</ul>
<p><b>other</b> <b>operations</b>. You may also cut a polytope by a new halfspace (<a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a35105f2693a342337167d58d996609ea">BoundedLatticePolytope::cut</a>), count the number of lattice points inside, interior or on the boundary (<a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a1ee74413874f29908e018af444c8948b">BoundedLatticePolytope::count</a>, <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#aeb097d12b56ee838d381a37e8d6e3bce">BoundedLatticePolytope::countInterior</a>, <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a0aee76a181914932c55ac6ea9c0f6b82">BoundedLatticePolytope::countBoundary</a>) or enumerate them.</p>
<dl class="section note"><dt>Note</dt><dd>In versions before 1.3, lattice point counting was done in a naive way, by domain enumeration and constraints check. If <em class="arg">m</em> is the number of constraints and <em class="arg">n</em> the number of lattice points in the polytope domain, then complexity was in \( O(mn) \).</dd>
<dd>
Since 1.3, inside/interior point counting and retrieval have been considerably optimized and are between 5x to 200x faster. The code uses line intersection to compute the inside points as intervals. See examples <a class="el" href="exampleBoundedLatticePolytopeCount2D_8cpp.html">exampleBoundedLatticePolytopeCount2D.cpp</a> , <a class="el" href="exampleBoundedLatticePolytopeCount3D_8cpp.html">exampleBoundedLatticePolytopeCount3D.cpp</a> , <a class="el" href="exampleBoundedLatticePolytopeCount4D_8cpp.html">exampleBoundedLatticePolytopeCount4D.cpp</a> .</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/volumes/BoundedLatticePolytope.h&quot;</span></div>
<div class="line">...</div>
<div class="line">using <span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceDGtal_1_1Z3i.html">DGtal::Z3i</a>;</div>
<div class="line"><span class="keyword">typedef</span> BoundedLatticePolytope&lt; Space &gt; Simplex;</div>
<div class="line">Simplex S( { <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(0,0,0), <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(3,0,0), <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(1,5,0), <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(-3,2,4) } );</div>
<div class="line">std::cout &lt;&lt; S.count() &lt;&lt; std::endl;</div>
<div class="line">simplex += Simplex::UnitSegment( 0 ); <span class="comment">// Extend it along x</span></div>
<div class="line">std::cout &lt;&lt; S.count() &lt;&lt; std::endl;</div>
<div class="ttc" id="anamespaceDGtal_1_1Z3i_html"><div class="ttname"><a href="namespaceDGtal_1_1Z3i.html">DGtal::Z3i</a></div><div class="ttdoc">Z3i this namespace gathers the standard of types for 3D imagery.</div></div>
<div class="ttc" id="atestClone2_8cpp_html_a4075d279133f1952978300b7e135f83d"><div class="ttname"><a href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a></div><div class="ttdeci">MyPointD Point</div><div class="ttdef"><b>Definition</b> <a href="testClone2_8cpp_source.html#l00381">testClone2.cpp:381</a></div></div>
</div><!-- fragment --><p>Last, you may compute Minkowski sums of a polytope with axis-aligned segments, squares or (hyper)-cubes (<a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#ad800946bb21a37901ea1646b7b8455e0">BoundedLatticePolytope::operator+=</a>).</p>
<dl class="section note"><dt>Note</dt><dd>You can check if the result of a Minkowski sum will be valid by calling <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a84c9f2b23e3e4e2257719c1b09e87813">BoundedLatticePolytope::canBeSummed</a> before. The support is for now limited to polytopes built as simplices in 2D and 3D.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1DigitalConvexity.html#a1f7509afa782b4513656ac5600cba55d">DigitalConvexity::makeSimplex</a> </dd>
<dd>
<a class="el" href="classDGtal_1_1DigitalConvexity.html#af4528961df07c0a68287a7744c93e22f">DigitalConvexity::makePolytope</a></dd></dl>
<p><a class="el" href="classDGtal_1_1SpaceND.html">Point</a> check services:</p><ul>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a15d2ac4e2ad4b272b49eeb844fc00627">BoundedLatticePolytope::isInside</a> checks if some point belongs to the polytope.</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#ad68a34c51b920aebcef0a18828f4fa80">BoundedLatticePolytope::isDomainPointInside</a> checks if some point within the polytope bounding box belongs to the polytope.</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#aedf183d8561e8644fdd044be8e90c9f1">BoundedLatticePolytope::isInterior</a> checks if some point is strictly inside the polytope.</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a8c2eddafed81451d810ecfcf9eb413ec">BoundedLatticePolytope::isBoundary</a> checks if some point is lying on the polytope boundary.</li>
</ul>
<p>Standard polytope services:</p><ul>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a694126b98affa76503626080c0ce4eea">BoundedLatticePolytope::interiorPolytope</a> returns the corresponding interior polytope by making strict every constraint</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a35105f2693a342337167d58d996609ea">BoundedLatticePolytope::cut</a> cuts the polytope by the given half-space constraint</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a3ce419df24109a16a1fb9e8b9bd1afb0">BoundedLatticePolytope::swap</a> swaps this polytope with another one in constant time</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a027d8357c4f1b69028496c3499003a12">BoundedLatticePolytope::operator*=</a> dilates this polytope by a given factor</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#ad800946bb21a37901ea1646b7b8455e0">BoundedLatticePolytope::operator+=</a> performs Minkowski sum with some axis aligned unit segment/cell</li>
</ul>
<p>Enumeration services:</p><ul>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a1ee74413874f29908e018af444c8948b">BoundedLatticePolytope::count</a> counts the number of lattice points in the polytope</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#aeb097d12b56ee838d381a37e8d6e3bce">BoundedLatticePolytope::countInterior</a> counts the number of lattice points strictly inside the polytope</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a0aee76a181914932c55ac6ea9c0f6b82">BoundedLatticePolytope::countBoundary</a> counts the number of lattice points on the boundary of the polytope</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a0559c255374e60656cd069aa094bddb0">BoundedLatticePolytope::countWithin</a> counts the number of lattice points in some subdomain of the polytope</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#ac7a0781979b2887dec85f65d66ff782a">BoundedLatticePolytope::countUpTo</a> counts the number of lattice points in the polytope up to some maximal number</li>
</ul>
<p>Lattice point retrieval services:</p><ul>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#af641cdb97623643b2da06ed9439e5253">BoundedLatticePolytope::getPoints</a> outputs the lattice points in the polytope</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a08497899fc57e891f7e31d4c602cd20b">BoundedLatticePolytope::getInteriorPoints</a> outputs the lattice points in the interior of the polytope</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a7c45dd504a734a902bcb9341ab2c767e">BoundedLatticePolytope::getBoundaryPoints</a> outputs the lattice points on the boundary of the polytope</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#af3f7e63f778429a299d056e4fd5e31f3">BoundedLatticePolytope::insertPoints</a> inserts the lattice points in the polytope into some point set</li>
</ul>
<p>The class <a class="el" href="structDGtal_1_1ConvexityHelper.html" title="Aim: Provides a set of functions to facilitate the computation of convex hulls and polytopes,...">ConvexityHelper</a> also provides several static methods related to <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html" title="Aim: Represents an nD lattice polytope, i.e. a convex polyhedron bounded with vertices with integer c...">BoundedLatticePolytope</a>:</p><ul>
<li><a class="el" href="structDGtal_1_1ConvexityHelper.html#af88821410e5a9327537ee884249d7034">ConvexityHelper::computeLatticePolytope</a> computes a <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html" title="Aim: Represents an nD lattice polytope, i.e. a convex polyhedron bounded with vertices with integer c...">BoundedLatticePolytope</a> from an arbitrary range of points (use <a class="el" href="structDGtal_1_1QuickHull.html" title="Aim: Implements the quickhull algorithm by Barber et al. barber1996, a famous arbitrary dimensional c...">QuickHull</a> algorithm, see also <a class="el" href="moduleQuickHull.html">QuickHull algorithm in arbitrary dimension for convex hull and Delaunay cell complex computation</a> ).</li>
<li><a class="el" href="structDGtal_1_1ConvexityHelper.html#acf0712e736c29abed972506333b048ba">ConvexityHelper::compute3DTriangle</a> computes the <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html" title="Aim: Represents an nD lattice polytope, i.e. a convex polyhedron bounded with vertices with integer c...">BoundedLatticePolytope</a> enclosing a 3D triangle (faster way than above, but limited to 3D triangles).</li>
<li><a class="el" href="structDGtal_1_1ConvexityHelper.html#a6993e5f812474cafa35e030dd288de9c">ConvexityHelper::computeDegeneratedTriangle</a> computes the <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html" title="Aim: Represents an nD lattice polytope, i.e. a convex polyhedron bounded with vertices with integer c...">BoundedLatticePolytope</a> enclosing a degenerated triangle (the three points are aligned or non distinct, but may lie in arbitrary dimension).</li>
<li><a class="el" href="structDGtal_1_1ConvexityHelper.html#a631da3c93606979b8f651fb27da991a1">ConvexityHelper::computeSegment</a> computes the <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html" title="Aim: Represents an nD lattice polytope, i.e. a convex polyhedron bounded with vertices with integer c...">BoundedLatticePolytope</a> enclosing a segment in arbitrary dimension.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="dgtal_dconvexity_sec22"></a>
Building a set of lattice cells from digital points</h2>
<p>The class <a class="el" href="classDGtal_1_1CellGeometry.html" title="Aim: Computes and stores sets of cells and provides methods to compute intersections of lattice and r...">CellGeometry</a> can compute and store set of lattice cells of different dimensions. You specify at construction a Khalimsky space (any model of <a class="el" href="structDGtal_1_1concepts_1_1CCellularGridSpaceND.html" title="Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian produc...">concepts::CCellularGridSpaceND</a>), as well as the dimensions of the cells you are interested in. Internally it uses a variant of unordered set of points (see <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">UnorderedSetByBlock</a>) to store the lattice cells in a compact manner.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/volumes/CellGeometry.h&quot;</span></div>
<div class="line">...</div>
<div class="line">using <span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceDGtal_1_1Z3i.html">DGtal::Z3i</a>;</div>
<div class="line"><a class="code hl_typedef" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a> <a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>;</div>
<div class="line"><a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.init( <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(-5,-5,-5), <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(15,15,15) );</div>
<div class="line">CellGeometry&lt; KSpace &gt; cell_geometry( <a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, 1, 2 ); <span class="comment">// only 1-cells and 2-cells</span></div>
<div class="ttc" id="atestArithmeticalDSSComputerOnSurfels_8cpp_html_aebe586e91159919ccf2f565d4407fff7"><div class="ttname"><a href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a></div><div class="ttdeci">Z3i::KSpace KSpace</div><div class="ttdef"><b>Definition</b> <a href="testArithmeticalDSSComputerOnSurfels_8cpp_source.html#l00048">testArithmeticalDSSComputerOnSurfels.cpp:48</a></div></div>
<div class="ttc" id="atestCubicalComplex_8cpp_html_a2b87ed989d2519d025bd5d4fbcbac062"><div class="ttname"><a href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a></div><div class="ttdeci">KSpace K</div><div class="ttdef"><b>Definition</b> <a href="testCubicalComplex_8cpp_source.html#l00062">testCubicalComplex.cpp:62</a></div></div>
</div><!-- fragment --><p>Then you may add cells that touch a range of points, or cells intersected by a polytope, or cells belonging to another <a class="el" href="classDGtal_1_1CellGeometry.html" title="Aim: Computes and stores sets of cells and provides methods to compute intersections of lattice and r...">CellGeometry</a> object.</p>
<ul>
<li><a class="el" href="classDGtal_1_1CellGeometry.html#a5d8ab2da8ebbeac571dc49989a962bb5">CellGeometry::addCellsTouchingPoints</a>: Updates the cell cover with the cells touching a range of digital points [itB, itE).</li>
<li><a class="el" href="classDGtal_1_1CellGeometry.html#a47bcd59803e91e07d03df003ed0694c4">CellGeometry::addCellsTouchingPointels</a>: Updates the cell cover with the cells touching a range of digital pointels [itB, itE).</li>
<li><a class="el" href="classDGtal_1_1CellGeometry.html#aecfe3cefcabb945d131302cfe32bb6a9">CellGeometry::addCellsTouchingPolytopePoints</a>: Updates the cell cover with the cells touching the points of a polytope.</li>
<li><a class="el" href="classDGtal_1_1CellGeometry.html#a985ac5e2fa4673feac1dd8fa02f8b1fb">CellGeometry::addCellsTouchingPolytope</a>: Updates the cell cover with all the cells touching the polytope (all cells whose closure have a non empty intersection with the polytope).</li>
<li><a class="el" href="classDGtal_1_1CellGeometry.html#ae7f884457568ef9c4eb2fe07c8698db1">CellGeometry::addCellsTouchingSegment</a>: Updates the cell cover with all the cells touching the Euclidean straight segment between the two given lattice points (specialized version of <a class="el" href="classDGtal_1_1CellGeometry.html#a985ac5e2fa4673feac1dd8fa02f8b1fb">CellGeometry::addCellsTouchingPolytope</a>).</li>
<li><a class="el" href="classDGtal_1_1CellGeometry.html#a11de8b2e7c5eada4c56069ffa66de338">CellGeometry::operator+=( const CellGeometry&amp; other )</a>: Adds the cells of dimension k of object <em class="arg">other</em>, for <span class="tt">minCellDim() &lt;= k &lt;=
  maxCellDim()</span>, to this cell geometry.</li>
</ul>
<p>With respect to full digital convexity, <a class="el" href="classDGtal_1_1CellGeometry.html#a985ac5e2fa4673feac1dd8fa02f8b1fb">CellGeometry::addCellsTouchingPolytope</a> is very important since it allows to compute \( C^d_k \lbrack P \rbrack \) for an arbitrary polytope \( P \) and for any \( k \).</p>
<h2 class="doxsection"><a class="anchor" id="dgtal_dconvexity_sec23"></a>
Checking digital convexity</h2>
<p>Class <a class="el" href="classDGtal_1_1DigitalConvexity.html" title="Aim: A helper class to build polytopes from digital sets and to check digital k-convexity and full co...">DigitalConvexity</a> is a helper class to build polytopes from digital sets and to check digital k-convexity. It provides methods for checking if a simplex is full dimensional, building the corresponding polytope, methods for getting the lattice points in a polytope, computing the cells touching lattice points or touching a polytope, and a set of methods to check k-convexity or k-subconvexity (i.e. tangency).</p>
<dl class="section note"><dt>Note</dt><dd>Since 1.3, it can check full convexity of an <b>arbitrary</b> <b>digital</b> <b>set</b> in <b>arbitrary</b> <b>dimension</b>, using its morphological characterization and a generic convex hull algorithm (<a class="el" href="moduleQuickHull.html">QuickHull algorithm in arbitrary dimension for convex hull and Delaunay cell complex computation</a>).</dd></dl>
<p>Here are two ways for checking full convexity. The first is the simplest (but hides some details):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/volumes/DigitalConvexity.h&quot;</span></div>
<div class="line">...</div>
<div class="line">using <span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceDGtal.html">DGtal</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceDGtal_1_1Z3i.html">DGtal::Z3i</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1DigitalConvexity.html">DigitalConvexity&lt; KSpace &gt;</a>       DConvexity;</div>
<div class="line"><span class="comment">// Create DigitalConvexity object with a domain.</span></div>
<div class="line">DConvexity dconv( <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>( -5, -5 ), <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>( 10, 10 ) );</div>
<div class="line"><span class="comment">// Specify the vertices of the simplex.</span></div>
<div class="line">std::vector&lt;Point&gt; V = { <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(0,0), <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(4,-1), <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(2,5) };</div>
<div class="line"><span class="comment">// Create the (fat) simplex with all its inner points.</span></div>
<div class="line"><span class="keyword">auto</span> fat_simplex   = dconv.makeSimplex  ( V.begin(), V.end() );</div>
<div class="line"><span class="comment">// it is indeed a fully convex set</span></div>
<div class="line"><span class="keywordtype">bool</span> ok = dconv.isFullyConvex ( fat_simplex ); <span class="comment">// true</span></div>
<div class="ttc" id="aclassDGtal_1_1DigitalConvexity_html"><div class="ttname"><a href="classDGtal_1_1DigitalConvexity.html">DGtal::DigitalConvexity&lt; KSpace &gt;</a></div></div>
<div class="ttc" id="anamespaceDGtal_html"><div class="ttname"><a href="namespaceDGtal.html">DGtal</a></div><div class="ttdoc">DGtal is the top-level namespace which contains all DGtal functions and types.</div><div class="ttdef"><b>Definition</b> <a href="ClosedIntegerHalfPlane_8h_source.html#l00048">ClosedIntegerHalfPlane.h:49</a></div></div>
</div><!-- fragment --><p>Second way to do it, where we see the intermediate computations of points and cells.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/volumes/DigitalConvexity.h&quot;</span></div>
<div class="line">...</div>
<div class="line">using <span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceDGtal.html">DGtal</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceDGtal_1_1Z3i.html">DGtal::Z3i</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1DigitalConvexity.html">DigitalConvexity&lt; KSpace &gt;</a>       DConvexity;</div>
<div class="line"><span class="comment">// Create DigitalConvexity object with a domain.</span></div>
<div class="line">DConvexity dconv( <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>( -5, -5 ), <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>( 10, 10 ) );</div>
<div class="line"><span class="comment">// Specify the vertices of the simplex.</span></div>
<div class="line">std::vector&lt;Point&gt; V = { <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(0,0), <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(4,-1), <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(2,5) };</div>
<div class="line"><span class="comment">// Create the (fat) simplex</span></div>
<div class="line"><span class="keyword">auto</span> fat_simplex   = dconv.makeSimplex  ( V.begin(), V.end() );</div>
<div class="line"><span class="comment">// Get all the points in the simplex, i.e. creates the digital set Z.</span></div>
<div class="line"><span class="keyword">auto</span> inside_pts    = dconv.insidePoints ( fat_simplex );</div>
<div class="line"><span class="comment">// Get the lattice cells intersected by the simplex i.e. C^d[ Conv(Z) ]</span></div>
<div class="line"><span class="keyword">auto</span> simplex_cover = dconv.makeCellCover( fat_simplex );</div>
<div class="line"><span class="comment">// Get the lattice cells intersected by the lattice points in the simplex  i.e. C^d[ Z ]</span></div>
<div class="line"><span class="keyword">auto</span> point_cover   = dconv.makeCellCover( inside_pts.begin(), inside_pts.end() );</div>
<div class="line"><span class="comment">// Checks that C^d[ Conv(Z) ] is a subset of C^d[ Z ], i.e. Z is fully convex.</span></div>
<div class="line"><span class="keywordtype">bool</span> ok  = simplex_cover.subset( point_cover ); <span class="comment">// true</span></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="dgtal_dconvexity_sec24"></a>
Other convexity services, like digital subconvexity (or tangency)</h2>
<p>Morphological services (since 1.3):</p><ul>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#af4528961df07c0a68287a7744c93e22f">DigitalConvexity::makePolytope( const PointRange&amp; X, bool safe ) const </a>builds the tightest polytope enclosing the digital set <em class="arg">X</em> </li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a3cd5bd9f858176e274f5320674ca2026">DigitalConvexity::isFullyConvex( const PointRange&amp; X, bool convex0 ) const </a>checks the full convexity of the digital set <em class="arg">X</em> </li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a4b5bf83b01cd9b62e92cc2572e8df5a8">DigitalConvexity::is0Convex( const PointRange&amp; X ) const </a>checks the usual digital convexity (H-convexity or 0-convexity) of the digital set <em class="arg">X</em> </li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a302be61022a992c9ddc6c0b8b3f11735">DigitalConvexity::U( Dimension i, const PointRange&amp; X ) const </a>performs the digital Minkowski sum of <em class="arg">X</em> along direction <em class="arg">i</em> </li>
</ul>
<p>The following snippet shows that a 4D ball is indeed fully convex.</p>
<div class="fragment"><div class="line">    <span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1KhalimskySpaceND.html">KhalimskySpaceND&lt;4,int&gt;</a>          <a class="code hl_typedef" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a>;</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code hl_typedef" href="classDGtal_1_1KhalimskySpaceND.html#a70d1b8007551de58a7b8ccee328bed00">KSpace::Point</a>                    <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>;</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code hl_typedef" href="classDGtal_1_1KhalimskySpaceND.html#ab2215bc032ca075e029b33eaf129feec">KSpace::Space</a>                    <a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a38dfaf1641eab4d3fb805df4b52ab10d">Space</a>;</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1DigitalConvexity.html">DigitalConvexity&lt; KSpace &gt;</a>       DConvexity;</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1HyperRectDomain.html">HyperRectDomain&lt; Space &gt;</a>         <a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a>;</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1DigitalSetBySTLSet.html">DigitalSetBySTLSet&lt; Domain &gt;</a>     <a class="code hl_typedef" href="testVoronoiMapComplete_8cpp.html#ac14360761d68859fc57ca37aea0b5c93">DigitalSet</a>;</div>
<div class="line">    </div>
<div class="line">    <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>      lo = Point::diagonal( -7 );</div>
<div class="line">    <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>      hi = Point::diagonal(  7 );</div>
<div class="line">    <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>      c  = Point::zero;</div>
<div class="line">    <a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a>     <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>( lo, hi );</div>
<div class="line">    DConvexity dconv ( lo, hi );</div>
<div class="line">    <a class="code hl_typedef" href="testVoronoiMapComplete_8cpp.html#ac14360761d68859fc57ca37aea0b5c93">DigitalSet</a> ball  ( <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a> );</div>
<div class="line">    <a class="code hl_function" href="classDGtal_1_1Shapes.html#acde0e74411f8d24da89c93f6df58a84f">Shapes&lt; Domain &gt;::addNorm2Ball</a>( ball, c, 5 );</div>
<div class="line">    std::vector&lt;Point&gt; V( ball.begin(), ball.end() );</div>
<div class="line">    <span class="keywordtype">bool</span> cvx0 = dconv.is0Convex( V );     <span class="comment">// checks digital 0-convexity</span></div>
<div class="line">    <span class="keywordtype">bool</span> fcvx = dconv.isFullyConvex( V ); <span class="comment">// checks full convexity</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This method for checking full convexity is slightly slower than the method using the Minkowski sum on the polytope contraints, but it works in arbitrary dimension and for arbitrary digital set.</dd></dl>
<p>Simplex services:</p><ul>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a1f7509afa782b4513656ac5600cba55d">DigitalConvexity::makeSimplex</a> builds a simplex from lattice point iterators or initializer list</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a1d6b24ed0bb76b2290b5fcf899a01ce0">DigitalConvexity::isSimplexFullDimensional</a> checks that the given points form a full dimensional simplex</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#af64332b6960ab4b06ee86afd022a71f8">DigitalConvexity::simplexType</a> returns the simplex type in SimplexType::INVALID (when the number of points is less than d+1), SimplexType::DEGENERATED when it is not full dimensional, SimplexType::UNITARY when it is full dimensional and of determinant 1, SimplexType::COMMON otherwise.</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a3af7c3766f87499faeb68d43b1bc439c">DigitalConvexity::displaySimplex</a> outputs simplex information for debugging</li>
</ul>
<p>Polytope services:</p><ul>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a02884b4960ea77330822c7b3d5b10444">DigitalConvexity::insidePoints</a> returns the range of lattice points in the given polytope</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#afe2a661668dc2d1837d93a86d685437f">DigitalConvexity::interiorPoints</a> returns the range of lattice points in the interior of the given polytope</li>
</ul>
<p>Lattice cell geometry services:</p><ul>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#af588213a1371bc38f45973ef3fc331f4">DigitalConvexity::makeCellCover</a> either returns the lattice cells touching the given range of points or the lattice cells touching the given polytope</li>
</ul>
<p>Convexity services:</p><ul>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a1c68ee37d58620cf8e70f901f86cea5c">DigitalConvexity::isKConvex</a> tells if a given polytope is k-convex</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a3cd5bd9f858176e274f5320674ca2026">DigitalConvexity::isFullyConvex</a> tells if a given polytope is fully convex</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a9a691e049c521f4ee81d365ea82e23dd">DigitalConvexity::isKSubconvex</a> tells if a given polytope is k-subconvex to some cell cover (i.e. k-tangent)</li>
<li>DigitalConvexity::isKSubconvex( const Point&amp; a, const Point&amp; b, const CellGeometry&amp; C, const Dimension k ) const tells if the Euclidean straight segment \( \lbrack a,b \rbrack \) is k-subconvex (i.e. k-tangent) to the given cell cover.</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#abb35a70653904c9ca2b308221ff70565">DigitalConvexity::isFullySubconvex</a> tells if a given polytope is fully subconvex to some cell cover</li>
<li>DigitalConvexity::isFullySubconvex( const Point&amp; a, const Point&amp; b, const CellGeometry&amp; C ) const tells if the Euclidean straight segment \( \lbrack a,b \rbrack \) is fully k-subconvex (i.e. tangent) to the given cell cover.</li>
<li>DigitalConvexity::isFullySubconvex( const LatticePolytope&amp; P, const LatticeSet&amp; StarX ) const tells if a given polytope is fully subconvex to a set of cells, represented as a <a class="el" href="classDGtal_1_1LatticeSetByIntervals.html" title="Aim:">LatticeSetByIntervals</a>.</li>
<li>DigitalConvexity::isFullySubconvex( const PointRange&amp; Y, const LatticeSet&amp; StarX ) const tells is the given range of points is fully subconvex to a set of cells, represented as a <a class="el" href="classDGtal_1_1LatticeSetByIntervals.html" title="Aim:">LatticeSetByIntervals</a>.</li>
<li>DigitalConvexity::isFullySubconvex( const Point&amp; a, const Point&amp; b, const LatticeSet&amp; StarX ) const tells if the given pair of points is fully subconvex to a set of cells, represented as a <a class="el" href="classDGtal_1_1LatticeSetByIntervals.html" title="Aim:">LatticeSetByIntervals</a> (three times faster than previous generic method).</li>
<li>DigitalConvexity::isFullySubconvex( const Point&amp; a, const Point&amp; b, const Point&amp; c, const LatticeSet&amp; StarX ) const tells if the given triplets of points is fully subconvex to a set of cells, represented as a <a class="el" href="classDGtal_1_1LatticeSetByIntervals.html" title="Aim:">LatticeSetByIntervals</a> (five times faster than previous generic method).</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="dgtal_dconvexity_sec25"></a>
Ehrhart polynomial of a lattice polytope</h2>
<p>Any lattice polytope has a unique Ehrhart polynomial that encodes the relationship between the volume of the polytope and the number of integer points the polytope contains. It is a kind of extension of 2D Pick's theorem. More precisely, if \( P \) is a (bounded) polytope in \( \mathbb{R}^d \) with vertices lying in \( \mathbb{Z}^d \), and for any positive integer \( t \), let \( tP \) denotes the dilation of \( P \) by a factor \( t \).</p>
<p>We denote \( L(P,t) := \#( tP \cap \mathbb{Z}^d ) \), i.e. the number of lattice points included in the dilation of this polytope.</p>
<p>Then \( L(P,t) \) is a polynomial in \( t \) of degree  \( f
\). Its monomial coefficients \( L_k(P) \) are rational numbers, and some coefficients have a clear geometric meaning, e.g.:</p>
<ul>
<li>\( L_0(P) \) is the Euler characteristic of the polytope, which is 1.</li>
<li>\( L_d(P) \) is the volume of the polytope.</li>
</ul>
<p>Note also that, by Ehrhart-MacDonald reciprocity, the polynomial  \((-1)^d L(P,-t) \) counts the number of interior lattice points to  \(tP \).</p>
<p>Class <a class="el" href="classDGtal_1_1EhrhartPolynomial.html" title="Aim: This class implements the class Ehrhart Polynomial which is related to lattice point enumeration...">EhrhartPolynomial</a> provides an elementary method to determine the Ehrhart polynomial of any bounded lattice polytope.</p>
<ul>
<li><a class="el" href="classDGtal_1_1EhrhartPolynomial.html#a1a6cbf4cce35438352501d7cc1cff39c">EhrhartPolynomial::init</a> initializes the object with a polytope \( P \) (<a class="el" href="classDGtal_1_1BoundedLatticePolytope.html" title="Aim: Represents an nD lattice polytope, i.e. a convex polyhedron bounded with vertices with integer c...">BoundedLatticePolytope</a> object)</li>
<li><a class="el" href="classDGtal_1_1EhrhartPolynomial.html#abc2bce063e74bfa60a098899470339a6">EhrhartPolynomial::numerator</a> gives you the integral numerator of the Ehrhart polynomial of the polytope \( P \)</li>
<li><a class="el" href="classDGtal_1_1EhrhartPolynomial.html#a90a9fe574308124abadc30b4effbbafc" title="The (integral) denominator of the Ehrhart polynomial.">EhrhartPolynomial::denominator</a> gives you the integral denominator of Ehrhart polynomial of the polytope \( P \)</li>
<li><a class="el" href="classDGtal_1_1EhrhartPolynomial.html#ad54d8fe400cb774ef12451fe5e5f5302">EhrhartPolynomial::count</a> counts the number of lattice points in \( tP \)</li>
<li><a class="el" href="classDGtal_1_1EhrhartPolynomial.html#a196245e9e956b90d3e0be397b615c904">EhrhartPolynomial::countInterior</a> counts the number of lattice points in the interior of \( tP \)</li>
</ul>
<p>See <a class="el" href="testEhrhartPolynomial_8cpp.html">testEhrhartPolynomial.cpp</a> for examples.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/volumes/EhrhartPolynomial.h&quot;</span></div>
<div class="line">...</div>
<div class="line">using <span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceDGtal_1_1Z2i.html">Z2i</a>;</div>
<div class="line">std::vector&lt; Point &gt; T = { <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(0,0), <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(1,0), <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(2,1) };</div>
<div class="line"><a class="code hl_class" href="classDGtal_1_1DigitalConvexity.html">DigitalConvexity&lt; KSpace &gt;</a> dconv( <a class="code hl_function" href="classDGtal_1_1PointVector.html#aba9def1d899ca259f6fa532a6eb9a8b5">Point::diagonal</a>( -100 ), <a class="code hl_function" href="classDGtal_1_1PointVector.html#aba9def1d899ca259f6fa532a6eb9a8b5">Point::diagonal</a>( 100 ) );</div>
<div class="line"><span class="keyword">auto</span> P = dconv.makeSimplex( T.cbegin(), T.cend() );</div>
<div class="line"><a class="code hl_class" href="classDGtal_1_1EhrhartPolynomial.html">EhrhartPolynomial&lt; Space, int64_t &gt;</a> E( P );</div>
<div class="line"><span class="comment">// Its Ehrhart polynomial is 1/2( 2 + 3t + t^2 )</span></div>
<div class="line"><span class="keyword">auto</span> expP = <a class="code hl_function" href="namespaceDGtal.html#a49884cead890d282184d87fe019fcdb7">mmonomial&lt;Integer&gt;</a>( 2 ) + 3 * <a class="code hl_function" href="namespaceDGtal.html#a49884cead890d282184d87fe019fcdb7">mmonomial&lt;Integer&gt;</a>( 1 ) + 2;</div>
<div class="line"><a class="code hl_function" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#ad8a25b2bbbbdb64c30a5442284db5bfb">REQUIRE</a>( E.numerator()   == expP );</div>
<div class="line"><a class="code hl_function" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#ad8a25b2bbbbdb64c30a5442284db5bfb">REQUIRE</a>( E.denominator() == 2 );</div>
<div class="line"><span class="comment">// number of lattice points of its 4-fold dilated version </span></div>
<div class="line"><span class="keyword">auto</span> P4 = 4 * P;</div>
<div class="line"><span class="keyword">auto</span> n4 = E.count( 4 );</div>
<div class="line"><a class="code hl_function" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#ad8a25b2bbbbdb64c30a5442284db5bfb">REQUIRE</a>( P4.count() == n4 );</div>
<div class="line"><span class="comment">// number of interior lattice points of its 4-fold dilated version </span></div>
<div class="line"><span class="keyword">auto</span> P4 = 4 * P;</div>
<div class="line"><span class="keyword">auto</span> n4 = E.countInterior( 4 );</div>
<div class="line"><a class="code hl_function" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#ad8a25b2bbbbdb64c30a5442284db5bfb">REQUIRE</a>( P4.countInterior() == n4 );</div>
<div class="ttc" id="aclassDGtal_1_1EhrhartPolynomial_html"><div class="ttname"><a href="classDGtal_1_1EhrhartPolynomial.html">DGtal::EhrhartPolynomial</a></div><div class="ttdoc">Aim: This class implements the class Ehrhart Polynomial which is related to lattice point enumeration...</div><div class="ttdef"><b>Definition</b> <a href="EhrhartPolynomial_8h_source.html#l00066">EhrhartPolynomial.h:67</a></div></div>
<div class="ttc" id="aclassDGtal_1_1PointVector_html_aba9def1d899ca259f6fa532a6eb9a8b5"><div class="ttname"><a href="classDGtal_1_1PointVector.html#aba9def1d899ca259f6fa532a6eb9a8b5">DGtal::PointVector&lt; dim, Integer &gt;::diagonal</a></div><div class="ttdeci">static Self diagonal(Component val=1)</div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z2i_html"><div class="ttname"><a href="namespaceDGtal_1_1Z2i.html">DGtal::Z2i</a></div><div class="ttdoc">Z2i this namespace gathers the standard of types for 2D imagery.</div></div>
<div class="ttc" id="anamespaceDGtal_html_a49884cead890d282184d87fe019fcdb7"><div class="ttname"><a href="namespaceDGtal.html#a49884cead890d282184d87fe019fcdb7">DGtal::mmonomial</a></div><div class="ttdeci">MPolynomial&lt; 1, Ring, Alloc &gt; mmonomial(unsigned int e)</div><div class="ttdef"><b>Definition</b> <a href="MPolynomial_8h_source.html#l01701">MPolynomial.h:1701</a></div></div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_ad8a25b2bbbbdb64c30a5442284db5bfb"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#ad8a25b2bbbbdb64c30a5442284db5bfb">REQUIRE</a></div><div class="ttdeci">REQUIRE(domain.isInside(aPoint))</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The Ehrhart polynomial is determined by taking a series of dilation of the polytope <span class="tt">(1,2,...,d)</span> and counting by brute-force the number of lattice points within these dilated polytopes. We then compute the Lagrange interpolating polynomial (using class <a class="el" href="classDGtal_1_1LagrangeInterpolation.html" title="Aim: This class implements Lagrange basis functions and Lagrange interpolation.">LagrangeInterpolation</a>) and we know that this must be the Ehrhart polynomial. There exists faster ways to compute it, which are however much more complex. See for instance LattE software: <a href="https://www.math.ucdavis.edu/~latte">https://www.math.ucdavis.edu/~latte</a> .</dd></dl>
<h1 class="doxsection"><a class="anchor" id="dgtal_dconvexity_sec3"></a>
P-convexity and convexity measures</h1>
<p><b>P-convexity</b> is an equivalenr definition to full convexity, but with a recursive definition <a class="el" href="citelist.html#CITEREF_feschet_2024_dgmm">[55]</a> . It provides thus a quite simple characterization of full convexity, which is implemented in class <a class="el" href="classDGtal_1_1PConvexity.html" title="Aim: A class to check if digital sets are P-convex. The P-convexity is defined as follows: A digital ...">PConvexity</a>.</p>
<ul>
<li>constructor <a class="el" href="classDGtal_1_1PConvexity.html#a95e3d676f6d3b7c0f08b726d625873c0">PConvexity::PConvexity</a> allows you to force a safe internal integer representation for convexity computation (default choice induces <span class="tt"><a class="el" href="namespaceDGtal.html#a45f076335dc184c6b7267b006362f5aa" title="signed 94-bit integer.">int64_t</a></span>),</li>
<li>method <a class="el" href="classDGtal_1_1PConvexity.html#a862fa013d37ade39074e0fd50b0f7d75">PConvexity::is0Convex</a> checks if a given range of digital points is 0-convex,</li>
<li>method <a class="el" href="classDGtal_1_1PConvexity.html#a376c0d9053909002280918ba2ed6aff6">PConvexity::isPConvex</a> checks if a given range of digital points is P-convex</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Minimal examples</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/volumes/PConvexity.h&quot;</span></div>
<div class="line">...</div>
<div class="line">typedef <a class="code hl_class" href="classDGtal_1_1SpaceND.html">SpaceND&lt; 2, int &gt;</a>    <a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a38dfaf1641eab4d3fb805df4b52ab10d">Space</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_typedef" href="classDGtal_1_1SpaceND.html#a34beb5f81d0848e8ae393f39a1422ebc">Space::Point</a>         <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classDGtal_1_1PConvexity.html">PConvexity&lt; Space &gt;</a> pconv;</div>
<div class="line">std::vector&lt;Point&gt; V = { <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(0,0), <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(-1,0), <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(1,0), <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(0,1), <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(0,-1) };</div>
<div class="line"><span class="keywordtype">bool</span> ok1 = pconv.<a class="code hl_function" href="classDGtal_1_1PConvexity.html#a862fa013d37ade39074e0fd50b0f7d75">is0Convex</a>( V );  <span class="comment">// should be true</span></div>
<div class="line"><span class="keywordtype">bool</span> ok2 = pconv.<a class="code hl_function" href="classDGtal_1_1PConvexity.html#a376c0d9053909002280918ba2ed6aff6">isPConvex</a>( V ); <span class="comment">// should be true</span></div>
<div class="ttc" id="aclassDGtal_1_1PConvexity_html"><div class="ttname"><a href="classDGtal_1_1PConvexity.html">DGtal::PConvexity</a></div><div class="ttdoc">Aim: A class to check if digital sets are P-convex. The P-convexity is defined as follows: A digital ...</div><div class="ttdef"><b>Definition</b> <a href="PConvexity_8h_source.html#l00354">PConvexity.h:355</a></div></div>
<div class="ttc" id="aclassDGtal_1_1PConvexity_html_a376c0d9053909002280918ba2ed6aff6"><div class="ttname"><a href="classDGtal_1_1PConvexity.html#a376c0d9053909002280918ba2ed6aff6">DGtal::PConvexity::isPConvex</a></div><div class="ttdeci">bool isPConvex(const std::vector&lt; Point &gt; &amp;X) const</div><div class="ttdef"><b>Definition</b> <a href="PConvexity_8h_source.html#l00407">PConvexity.h:407</a></div></div>
<div class="ttc" id="aclassDGtal_1_1PConvexity_html_a862fa013d37ade39074e0fd50b0f7d75"><div class="ttname"><a href="classDGtal_1_1PConvexity.html#a862fa013d37ade39074e0fd50b0f7d75">DGtal::PConvexity::is0Convex</a></div><div class="ttdeci">bool is0Convex(const std::vector&lt; Point &gt; &amp;X) const</div><div class="ttdef"><b>Definition</b> <a href="PConvexity_8h_source.html#l00397">PConvexity.h:397</a></div></div>
<div class="ttc" id="aclassDGtal_1_1SpaceND_html"><div class="ttname"><a href="classDGtal_1_1SpaceND.html">DGtal::SpaceND&lt; 2, int &gt;</a></div></div>
<div class="ttc" id="aclassDGtal_1_1SpaceND_html_a34beb5f81d0848e8ae393f39a1422ebc"><div class="ttname"><a href="classDGtal_1_1SpaceND.html#a34beb5f81d0848e8ae393f39a1422ebc">DGtal::SpaceND::Point</a></div><div class="ttdeci">PointVector&lt; dim, Integer &gt; Point</div><div class="ttdoc">Points in DGtal::SpaceND.</div><div class="ttdef"><b>Definition</b> <a href="SpaceND_8h_source.html#l00110">SpaceND.h:110</a></div></div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_a38dfaf1641eab4d3fb805df4b52ab10d"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a38dfaf1641eab4d3fb805df4b52ab10d">Space</a></div><div class="ttdeci">SpaceND&lt; 2 &gt; Space</div><div class="ttdef"><b>Definition</b> <a href="testSimpleRandomAccessRangeFromPoint_8cpp_source.html#l00042">testSimpleRandomAccessRangeFromPoint.cpp:42</a></div></div>
</div><!-- fragment --><p>Furthermore, the recursive definition of P-convexity induces a natural measure of full convexity for digital sets. Indeed the classical d-dimensional <b>digital</b> <b>convexity</b> <b>measure</b> of digital set <em class="arg"><a class="el" href="structA.html">A</a></em> is </p><p class="formulaDsp">
\[ M_d(A):=\frac{\#(A)}{\#(\mathrm{CvxH}(A) \cap \mathbf{Z}^d)}, \]
</p>
<p> and \( M_d(\emptyset)=1 \).</p>
<p>The <b>full</b> <b>convexity</b> <b>measure</b> \( M_d^F \) for finite digital set <em class="arg"><a class="el" href="structA.html">A</a></em> is </p><p class="formulaDsp">
\[ M_1^F(A) := M_1(A), \quad M_d^F(A) := M_d(A) \Pi_{k=1}^d M_{d-1}^F( \pi_k(A) )\quad\text{for}\,\, d &gt; 1. \]
</p>
<p>It coincides with the digital convexity measure in dimension 1, but may differ starting from dimension 2, and is always less or equal to the convexity measure.</p>
<ul>
<li>method <a class="el" href="classDGtal_1_1PConvexity.html#a646a28997f1af639d063b834f1d255bf">PConvexity::convexityMeasure</a> returns the convexity measure \( M_d(A) \) of the given range of digital points <em class="arg"><a class="el" href="structA.html">A</a></em>,</li>
<li>method <a class="el" href="classDGtal_1_1PConvexity.html#a5d05c09feca8b6cb362df16cf4ffd468">PConvexity::fullConvexityMeasure</a> returns the full convexity measure \( M_d^F(A) \) of the given range of digital points <em class="arg"><a class="el" href="structA.html">A</a></em>.</li>
</ul>
<p>The figure below illustrates the links and the differences between the two convexity measures Md and MdF on simple 2D examples. As one can see, the usual convexity measure may not detect disconnectedness and it is sensitive to specific alignments of pixels. On the contrary, full convexity is globally more stable to perturbation and is never 1 when sets are disconnected.</p>
<div class="image">
<img src="full-convexity-measure.png" alt=""/>
<div class="caption">
Convexity measure M_d and full convexity measure M_d^F on small 2D digital sets.</div></div>
<h1 class="doxsection"><a class="anchor" id="dgtal_dconvexity_sec4"></a>
Best algorithm for checking full convexity</h1>
<p>There exists multiple equivalent characterizations of full convexity. Some of them induce algorithms for checking if a digital set is indeed fully convex, but the question `&lsquo;which is the fastest way&rsquo;' remains. We recap here the different characterizations for  \( X
\subset \mathbb{Z}^d \) being full convex, which lead to an arbitrary dimensional algorithm for checking if a given range of <em class="arg">n</em> points <em class="arg">X</em> is indeed fully convex:</p>
<ul>
<li><p class="startli"><b>discrete</b> <b>morphological</b> <b>characterization</b> <a class="el" href="citelist.html#CITEREF_lachaud_dgmm_2021">[79]</a> <a class="el" href="citelist.html#CITEREF_lachaud_jmiv_2022">[80]</a></p>
<p class="startli"><em class="arg">X</em> is fully convex iff  \( \forall \alpha \subset \{1, \ldots,
  d\}, U_\alpha(X) = \mathrm{CvxH}(U_\alpha(X)) \cap \mathbb{Z}^d \),</p>
<p class="startli">where \( U_\alpha \) is the discrete Minkowski sum defined as  \(  U_\emptyset(X):= X \), and for any subset of directions  \( \alpha
  \in \{1,\ldots,d\} \) and a direction \( i \in \alpha \),   \(  U_\alpha(X) := U_{\alpha \setminus \{i\}}(X) \cup \mathbf{e}_i (U_{\alpha
  \setminus \{i\}}(X)) \) (the latter being the unit translation of the set along direction <em class="arg">i</em>).</p>
<p class="startli">This is implemented as <a class="el" href="classDGtal_1_1DigitalConvexity.html#a3cd5bd9f858176e274f5320674ca2026">DigitalConvexity::isFullyConvex</a> .</p>
</li>
<li><p class="startli"><b>cellular</b> <b>characterization</b> <a class="el" href="citelist.html#CITEREF_feschet_2023_jmiv">[54]</a> (Lemma 13)</p>
<p class="startli"><em class="arg">X</em> is fully convex iff  \( X = \mathrm{Star}(\mathrm{Cvxh}(X))
  \cap \mathbb{Z}^d \).</p>
<p class="startli">Furthermore, Theorem 5 of <a class="el" href="citelist.html#CITEREF_feschet_2023_jmiv">[54]</a> tells that  \(  \mathrm{Star}(\mathrm{CvxH}(X)) \) is directly computable from  \(  \mathrm{CvxH}(U_{\{1,\ldots,d\}}(X)) \), so one convex hull computation is sufficient.</p>
<p class="startli">This is implemented as <a class="el" href="classDGtal_1_1DigitalConvexity.html#a3b7d5a39596ba6d88525ce46b0755ccf">DigitalConvexity::isFullyConvexFast</a> .</p>
</li>
<li><p class="startli"><b>envelope</b> <b>idempotence</b> <a class="el" href="citelist.html#CITEREF_feschet_2023_jmiv">[54]</a> (Theorem 2)</p>
<p class="startli"><em class="arg">X</em> is fully convex iff \( X = FC(X) \), where   \(  FC(X):=\mathrm{Extr}( \mathrm{Skel}( \mathrm{Star}( \mathrm{CvxH}( X
  ) ) ) ) \).</p>
<p class="startli">This is implemented as <a class="el" href="classDGtal_1_1DigitalConvexity.html#a8c1f8c406bf52d7654ebdcd91542e107">DigitalConvexity::envelope</a>, but its speed is not tested here, since it is similar to the previous one</p>
</li>
<li><p class="startli"><b>P-convexity</b> <b>characterization</b> <a class="el" href="citelist.html#CITEREF_feschet_2024_dgmm">[55]</a></p>
<p class="startli"><em class="arg">X</em> is fully convex iff \( X \) is 0-convex, and, if  \( d &gt; 1
\), the <em class="arg">d</em> projections of \( X \) along each axis is P-convex (in  \(  \mathbb{Z}^{d-1} \)).</p>
<p class="startli">This is implemented as <a class="el" href="classDGtal_1_1PConvexity.html#a376c0d9053909002280918ba2ed6aff6">PConvexity::isPConvex</a> .</p>
</li>
</ul>
<p>All three methods are tested for dimension 2, 3, and 4. In the first set of experiments (left of figures) we compare them on generic digital sets, which are randomly generated in a given range with a target density from \( 10\% \) to \( 90\% \). In the second set of experiments (right of figures), we limit our comparison to digital sets that are either digitally 0-convex or fully convex. We then distinguish the timings for checking full convexity depending on the output full convexity property of the input set, since it influences the computation time (typically increases it).</p>
<p>Figures below sum up the different computation times for dimension 2, 3, and 4.</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="timings-ncvx-Z2.png" alt="" width="98%"/>
</div>
 </td><td><div class="image">
<img src="timings-Z2.png" alt="" width="98%"/>
</div>
 </td></tr>
<tr>
<td colspan="2">This figure displays the respective computation times (ms) in \( \mathbb{Z}^2 \) of P-convexity (as squares), discrete morphological characterization (as diamonds) and cellular characterization (as disks), as a function of the cardinal of the digital set. <b>Left:</b> digital sets are randomly generated in a given range with a target point density from \( 10\% \) to \( 90\% \). <b>Right:</b> digital sets are randomly generated so that they are either 0-convex or fully convex. </td></tr>
</table>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="timings-ncvx-Z3.png" alt="" width="98%"/>
</div>
 </td><td><div class="image">
<img src="timings-Z3.png" alt="" width="98%"/>
</div>
 </td></tr>
<tr>
<td colspan="2">This figure displays the respective computation times (ms) in \( \mathbb{Z}^3 \) of P-convexity (as squares), discrete morphological characterization (as diamonds) and cellular characterization (as disks), as a function of the cardinal of the digital set. <b>Left:</b> digital sets are randomly generated in a given range with a target point density from \( 10\% \) to \( 90\% \). <b>Right:</b> digital sets are randomly generated so that they are either 0-convex or fully convex. </td></tr>
</table>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="timings-ncvx-Z4.png" alt="" width="98%"/>
</div>
 </td><td><div class="image">
<img src="timings-Z4.png" alt="" width="98%"/>
</div>
 </td></tr>
<tr>
<td colspan="2">This figure displays the respective computation times (ms) in \( \mathbb{Z}^4 \) of P-convexity (as squares), discrete morphological characterization (as diamonds) and cellular characterization (as disks), as a function of the cardinal of the digital set. <b>Left:</b> digital sets are randomly generated in a given range with a target point density from \( 10\% \) to \( 90\% \). <b>Right:</b> digital sets are randomly generated so that they are either 0-convex or fully convex. </td></tr>
</table>
<p>All approaches follow more or less a linearithmic or subquadratic complexity  \( O(n
\log n) \) (tests are limited to dimension lower or equal to 4). However, we can distinguish three cases:</p>
<ul>
<li>if <em class="arg">X</em> is not even convex, both P-convexity and the discrete morphological characterization are the fastest with similar results, since both their first step involves checking 0-convexity. The cellular characterization is the slowest since it computes directly a convex hull with additional vertices.</li>
<li>if <em class="arg">X</em> is convex but not fully convex, then the fastest method remains the P-convexity, followed by the discrete morphological characterization, and the slowest is the cellular characterization.</li>
<li>if <em class="arg">X</em> is fully convex, then the fastest method is again the P-convexity, followed by the cellular characterization, and the slowest is the discrete morphological characterization (especially when increasing the dimension).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Overall the <b>P-convexity</b> characterization (method <a class="el" href="classDGtal_1_1PConvexity.html#a376c0d9053909002280918ba2ed6aff6">PConvexity::isPConvex</a>) is <b>almost</b> <b>always</b> <b>the</b> <b>fastest</b> <b>way</b> <b>to</b> <b>check</b> <b>the</b> <b>full</b> <b>convexity</b> of a given range of digital points, with speed-up from 2 to 100 times faster especially when increasing the dimension. This new characterization of full convexity is thus for now the best way to check if a digital set is fully convex.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>One could be surprised by the last graph in 4D. Indeed we expect convex hull computations in \( O(n^2) \) in 4D. We observe here timings close to \( \Theta(n \log n) \). This is due to the fact that the digital sets we are considering are 0-convex, so "full
of digital points". Convex hull computations by <a class="el" href="structDGtal_1_1QuickHull.html" title="Aim: Implements the quickhull algorithm by Barber et al. barber1996, a famous arbitrary dimensional c...">QuickHull</a> are thus faster than expected since many points are "hidden" in the shape. It can also be seen on the left of this figure that timings depend more on the range of random points than on the density (e.g. see horizontal strokes of circles, corresponding to density increases), which confirms the above explanation.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="dgtal_dconvexity_sec5"></a>
Rational polytopes</h1>
<p>You can also create bounded rational polytopes, i.e. polytopes with vertices with rational coordinates, with class <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html" title="Aim: Represents an nD rational polytope, i.e. a convex polyhedron bounded by vertices with rational c...">BoundedRationalPolytope</a>. You must give a common denominator for all rational coordinates.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/volumes/BoundedRationalPolytope.h&quot;</span></div>
<div class="line">...</div>
<div class="line">typedef <a class="code hl_class" href="classDGtal_1_1SpaceND.html">SpaceND&lt;2,int&gt;</a>                    <a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a38dfaf1641eab4d3fb805df4b52ab10d">Space</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_typedef" href="classDGtal_1_1SpaceND.html#a34beb5f81d0848e8ae393f39a1422ebc">Space::Point</a>                      <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1BoundedRationalPolytope.html">BoundedRationalPolytope&lt; Space &gt;</a>  Polytope;</div>
<div class="line"><span class="comment">// A thin triangle P at (4/4,2/4), (2/4,4/4), (9/4,9/4)</span></div>
<div class="line"><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> a( 4, 2 );</div>
<div class="line"><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> b( 2, 4 );</div>
<div class="line"><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> c( 9, 9 );</div>
<div class="line">Polytope P { <a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a>(4,4), a, b, c };</div>
<div class="ttc" id="aclassDGtal_1_1BoundedRationalPolytope_html"><div class="ttname"><a href="classDGtal_1_1BoundedRationalPolytope.html">DGtal::BoundedRationalPolytope&lt; Space &gt;</a></div></div>
</div><!-- fragment --><p>Then the interface of <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html" title="Aim: Represents an nD rational polytope, i.e. a convex polyhedron bounded by vertices with rational c...">BoundedRationalPolytope</a> is almost the same as the one of <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html" title="Aim: Represents an nD lattice polytope, i.e. a convex polyhedron bounded with vertices with integer c...">BoundedLatticePolytope</a> (see <a class="el" href="#dgtal_dconvexity_sec21">Lattice polytopes</a> ).</p>
<p>The classs <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html" title="Aim: Represents an nD rational polytope, i.e. a convex polyhedron bounded by vertices with rational c...">BoundedRationalPolytope</a> offers dilatation by an arbitrary rational, e.g. as follows</p>
<div class="fragment"><div class="line">Polytope Q = Polytope::Rational( 10, 3 ) * P; <span class="comment">// 10/3 * P</span></div>
</div><!-- fragment --><p>You may also check digital convexity and compute cell covers with bounded rational polytopes, exactly in the same way as with <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html" title="Aim: Represents an nD lattice polytope, i.e. a convex polyhedron bounded with vertices with integer c...">BoundedLatticePolytope</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Big denominators increase with the same factor coefficients of half space constraints, hence the integer type should be chosen accordingly.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="dgtal_dconvexity_sec6"></a>
Further notes</h1>
<p>The class <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html" title="Aim: Represents an nD lattice polytope, i.e. a convex polyhedron bounded with vertices with integer c...">BoundedLatticePolytope</a> is different from the class <a class="el" href="classDGtal_1_1LatticePolytope2D.html" title="Aim: Represents a 2D polytope, i.e. a convex polygon, in the two-dimensional digital plane....">LatticePolytope2D</a> for the following two reasons:</p><ul>
<li>the class <a class="el" href="classDGtal_1_1LatticePolytope2D.html" title="Aim: Represents a 2D polytope, i.e. a convex polygon, in the two-dimensional digital plane....">LatticePolytope2D</a> is limited to 2D</li>
<li>the class <a class="el" href="classDGtal_1_1LatticePolytope2D.html" title="Aim: Represents a 2D polytope, i.e. a convex polygon, in the two-dimensional digital plane....">LatticePolytope2D</a> is a vertex representation (or V-representation) of a polytope while the class <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html" title="Aim: Represents an nD lattice polytope, i.e. a convex polyhedron bounded with vertices with integer c...">BoundedLatticePolytope</a> is a half-space representation (or H-representation) of a polytope.</li>
</ul>
<p>There are no simple conversion from one to the other. Class <a class="el" href="classDGtal_1_1LatticePolytope2D.html" title="Aim: Represents a 2D polytope, i.e. a convex polygon, in the two-dimensional digital plane....">LatticePolytope2D</a> is optimized for cuts and lattice points enumeration, and is very specific to 2D. Class <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html" title="Aim: Represents an nD lattice polytope, i.e. a convex polyhedron bounded with vertices with integer c...">BoundedLatticePolytope</a> is less optimized than the previous one but works in nD and provides Minkowski sum and dilation services. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="index.html">DGtal - Digital Geometry Tools and Algorithms Library.</a></li><li class="navelem"><a href="packageGeometry.html">Geometry package</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for DGtal by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
