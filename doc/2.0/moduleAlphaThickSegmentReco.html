<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Alpha-thick Segment Recognition</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('moduleAlphaThickSegmentReco.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Alpha-thick Segment Recognition </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><br  />
</p>
<dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Bertrand Kerautret</dd></dl>
<p>Part of the <a class="el" href="packageGeometry.html">Geometry package</a>.</p>
<p>The Digital Straight Segment primitive (described here: <a class="el" href="moduleArithDSSReco.html">Digital straight lines and segments</a>) is commonly used to extract geometric information from digital contours. It is exploited in various estimators as for instance in tangent <a class="el" href="citelist.html#CITEREF_lachaudivc2007">[74]</a> or curvature estimation <a class="el" href="citelist.html#CITEREF_kerautretlachaud2009">[66]</a> . However, this primitive is not efficient to directly process real contours with the potential presence of noise. To overcome this limitation the alpha-thick segments (called initially Blurred Segments) were first introduced by Debled-Rennesson <em>et</em> al <a class="el" href="citelist.html#CITEREF_debledfuzzy2005">[48]</a> which handle noise or contour irregularities.</p>
<p>We present here the recognition of alpha-thick segments as described in <a class="el" href="citelist.html#CITEREF_debledfuzzy2005">[48]</a> and <a class="el" href="citelist.html#CITEREF_fauretangential2008">[51]</a>. From a maximal thickness, it permits the recognition of a thick segment with the possibility to take into accounts some noise. Moreover the segment can be detected from points which are not necessarily connected nor necessarily digital points (<a class="el" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a> for instance).</p>
<dl class="section note"><dt>Note</dt><dd>The proposed implementation is mainly a backport from ImaGene with some various refactoring.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="moduleAlphaThickSegmentRecoIntro"></a>
Alpha-thick Segment</h1>
<p>The first definition of <b>blurred</b> <b>segment</b> <a class="el" href="citelist.html#CITEREF_debledfuzzy2005">[48]</a> relies on the definition of the digital straight lines (<a class="el" href="moduleArithDSSReco.html">Digital straight lines and segments</a>):</p>
<p><a class="el" href="structA.html">A</a> set \( \mathcal{S}_f \) of consecutive points (  \( \mathcal{S}_f
\geq 2 \)) of an 8-connected curve is a blurred segment with order \( d \) if there exists a discrete line  \( \mathcal{D}(a,b, \mu,
\omega) \) such that all points of \( \mathcal{S}_f \) belong to \( \mathcal{D} \) and  \( \frac{\omega}{max(|a|,|b|)} \leq d
\). The line \( D \) is said bounding for \( \mathcal{S}_f \).</p>
<p>Following this definition, the authors also propose an incremental linear time algorithm to segment a digital curve into blurred segments of order \( d \). The main drawback of such a decomposition is the non optimality (it implies over segmentation). Then the author introduce the notion of blurred segment of width \( \nu \) <a class="el" href="citelist.html#CITEREF_debledrennessonblurred2005">[47]</a>. The width \( \nu \) is associated to the isothetic thickness of a set of points, ie. the minimum value between its vertical and horizontal thicknesses (see figure below).</p>
<div class="image">
<img src="exampleConvexHullHV.png" alt=""/>
<div class="caption">
The isothetic thickness of this convexhull is the minimum between its vertical (dV) and horizontal (dH) thickness. The points P,Q and R are the antipodal pair.</div></div>
 <p>From this notion of isothetic thickness follows the <b>blurred</b> <b>segment</b> definition <a class="el" href="citelist.html#CITEREF_debledrennessonblurred2005">[47]</a> :</p>
<p><a class="el" href="structA.html">A</a> bounding line of a digital set \( \mathcal{S}_b \) is said optimal if its isothetic thickness is equal to the isothetic thickness of the convex hull \( conv(\mathcal{S}_b) \). \( \mathcal{S}_b \) is a blurred segment of width \( \nu \) if and only if its optimal bounding line has an isothetic distance less or equal to \( \nu \).</p>
<p>The implementation proposed here relies on the convex hull computed incrementally with the Melkman algorithm in linear time <a class="el" href="citelist.html#CITEREF_melkmanline1987">[91]</a> (by using the <a class="el" href="classDGtal_1_1MelkmanConvexHull.html" title="Aim: This class implements the on-line algorithm of Melkman for the computation of the convex hull of...">MelkmanConvexHull</a> class, see the module main documentation: <a class="el" href="moduleHull2D.html#subsectmoduleHull2D13">Melkman's algorithm</a>). It allows to add point on the front of the current segment and the value of vertical/horizontal thickness are computed in linear time by using the rotating caliper algorithm (see <a class="el" href="moduleHull2D.html#subsectmoduleHull2D14">Convex hull thickness</a>). The Buzer optimisation <a class="el" href="citelist.html#CITEREF_liliancomputing2007">[86]</a> to update the convex hull thickness with a coast of \(O(log\ n) \) or the linear time point substraction are not yet implemented. Note that you can use also the Euclidean thickness (see illustration below) also defined from the rotating caliper algorithm.</p>
<div class="image">
<img src="exampleConvexHullEucl.png" alt=""/>
<div class="caption">
Illustration of the Euclidean thickness (dE) of the convexhull defined from antipodal pair (P,Q) and R.</div></div>
 <h1 class="doxsection"><a class="anchor" id="moduleAlphaThickSegmentRecoDetails"></a>
Alpha-thick Segment Recognition</h1>
<h2 class="doxsection"><a class="anchor" id="moduleAlphaThickSegmentRecoDetails-TypeInputContours"></a>
Type of Input Points</h2>
<p>This implementation of the alpha-thick segments can take as input different types of points which just need to be given in the template parameter (TInputPoint). The input points are not necessary connected but the important constraint is that the sequence of point should not contains loop. Open or closed contours can be processed by the segment computer (if you use contour iterator in the initialisation you have just to check manually the end condition or the iterator type).</p>
<dl class="section note"><dt>Note</dt><dd>Contrary to the implementation proposed in <a class="el" href="citelist.html#CITEREF_debledrennessonblurred2005">[47]</a> the input points do not need to have axis increasing coordinates.</dd></dl>
<p>As illustration, the alpha-thick segments can be recognized on such contours: </p><div class="image">
<img src="alphThickSegmentInputPoints.png" alt=""/>
<div class="caption">
Examples of different input coutours which can be used with the alpha-thick segment. (1) Input contour with non increasing axis coordinates, (2) contour with non connected points, (3) polygonal contour with floating points. </div></div>
 <p>And the example of non-simple contour can produce some errors: </p><div class="image">
<img src="alphThickSegmentInputPointsLoop.png" alt=""/>
<div class="caption">
Example of input contour (1) containing loop which produce incorrect convexhull (2).</div></div>
 <h2 class="doxsection"><a class="anchor" id="moduleAlphaThickSegmentRecoDetails-Code"></a>
Recognizing an Alpha-thick Segment</h2>
<p>To recognize an alpha-thick segment, you need first to include the <a class="el" href="classDGtal_1_1AlphaThickSegmentComputer.html" title="Aim: This class is devoted to the recognition of alpha thick segments as described in fauretangential...">AlphaThickSegmentComputer</a> header (with eventually the different namespace defined in <a class="el" href="StdDefs_8h_source.html">StdDefs.h</a>): </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/curves/AlphaThickSegmentComputer.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/helpers/StdDefs.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/io/readers/PointListReader.h&quot;</span></div>
</div><!-- fragment --><p>Afterwards, you have to set the type of the primitive by choosing the input point type. For instance, if you have to recognize input non digital points (e.g. <a class="el" href="classDGtal_1_1SpaceND.html#a615c8017e5750e191610f48dcf968bb5">Space::RealPoint</a>), you can define:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span>  <a class="code hl_class" href="classDGtal_1_1AlphaThickSegmentComputer.html">AlphaThickSegmentComputer&lt; Z2i::RealPoint &gt;</a> AlphaThickSegmentComputer2D;</div>
</div><!-- fragment --><p>To import an input contour you can use the the <a class="el" href="structDGtal_1_1PointListReader.html" title="Aim: Implements method to read a set of points represented in each line of a file.">PointListReader</a> class: </p><div class="fragment"><div class="line">  std::vector&lt;Z2i::RealPoint&gt; aContour = <a class="code hl_function" href="structDGtal_1_1PointListReader.html#adee66cb7d35d6f1e5794d6285ba11b69">PointListReader&lt;Z2i::RealPoint&gt;::getPointsFromFile</a>(file);</div>
</div><!-- fragment --><p>Then, you can define and initialize a new segment with maximal thickness set to 15: </p><div class="fragment"><div class="line">  AlphaThickSegmentComputer2D anAlphaSegment(15);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The maximal thickness given in initialization is by default the Vertical/horizontal thickness.</dd></dl>
<p>You can extend the segment by adding point to the front: </p><div class="fragment"><div class="line">  AlphaThickSegmentComputer2D anAlphaSegment(15);</div>
<div class="line">  std::vector&lt;Z2i::RealPoint&gt;::const_iterator it =  aContour.begin();  </div>
<div class="line">  <span class="keywordflow">while</span> (anAlphaSegment.extendFront(*it)) {</div>
<div class="line">    it++;</div>
<div class="line">  }</div>
</div><!-- fragment --><p>The final alpha-thick segment can also be displayed with a Board3D as other 2D geometric primitives: </p><div class="fragment"><div class="line">  aBoard &lt;&lt; anAlphaSegment;  </div>
</div><!-- fragment --><p>As described in the Board3D documentation (<a class="el" href="moduleBoard2D.html#dgtal_dgtalboard_sec14">Useful modes for several drawable elements</a>), this primitive has two main display modes:</p><ul>
<li>default: the input point are displayed with its bounding box (the mode of the displayed points can also be changed).</li>
<li>BoundingBox: only the bounding box is displayed.</li>
</ul>
<p>You can also customize the segment color by using the <a class="el" href="structDGtal_1_1CustomStyle.html">CustomStyle</a> object: </p><div class="fragment"><div class="line">  aBoard &lt;&lt; <a class="code hl_struct" href="structDGtal_1_1CustomStyle.html">CustomStyle</a>( anAlphaSegment2.className(), <span class="keyword">new</span> <a class="code hl_struct" href="structDGtal_1_1CustomColors.html">CustomColors</a>( <a class="code hl_variable" href="classDGtal_1_1Color.html#aa42bc87bfec756eee51bc6bcdcf2d92e">DGtal::Color::Blue</a>, <a class="code hl_variable" href="classDGtal_1_1Color.html#a7e300b4cbafa252ccc1a03574d508fde">DGtal::Color::None</a> ) );  </div>
<div class="line">  aBoard &lt;&lt; anAlphaSegment2;  </div>
</div><!-- fragment --><p>As illustration the segment recognition given in <a class="el" href="exampleAlphaThickSegmentNoisy_8cpp.html">exampleAlphaThickSegmentNoisy.cpp</a> produces such a display:</p>
<div class="image">
<img src="exampleAlphaThickSegmentNoisy.png" alt=""/>
<div class="caption">
Simple example of some alpha-thick segments recognition with alpha = 2, 9 and 15.</div></div>
 <p>Other examples with other input types are given here: <a class="el" href="exampleAlphaThickSegment_8cpp.html">exampleAlphaThickSegment.cpp</a>.</p>
<h2 class="doxsection"><a class="anchor" id="moduleAlphaThickSegmentRecoDetails-CodeInitIter"></a>
AlphaThickSegmentComputer with a point iterator</h2>
<p>Since the <a class="el" href="classDGtal_1_1AlphaThickSegmentComputer.html" title="Aim: This class is devoted to the recognition of alpha thick segments as described in fauretangential...">AlphaThickSegmentComputer</a> class is a model of CForwardSegmentComputer, you can initialize it from a given input point iterator. Then, the computer will not store the segment points (but the convexhull points are always stored). With such an initialization the segment computer can be used in a quite similar way as in the previous example:</p>
<div class="fragment"><div class="line">  anAlphaSegment2.init(aContour.begin());</div>
<div class="line">  <span class="keywordflow">while</span> (anAlphaSegment2.end() != aContour.end() &amp;&amp; </div>
<div class="line">         anAlphaSegment2.extendFront()) {</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Since the iterator is defined from an open contour, we check that we are not at the end of the input contour before applying any extension.</p>
<h2 class="doxsection"><a class="anchor" id="moduleAlphaThickSegmentRecoDetails-ChangeThicknessDef"></a>
Changing the thickness definition</h2>
<p>The thickness definition can be changed at the <a class="el" href="classDGtal_1_1AlphaThickSegmentComputer.html" title="Aim: This class is devoted to the recognition of alpha thick segments as described in fauretangential...">AlphaThickSegmentComputer</a> construction: </p><div class="fragment"><div class="line">  AlphaThickSegmentComputer2D anAlphaSegment2Eucl(5, <a class="code hl_enumvalue" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ade3b11c94c4d3736bb8efc7abcc58735aff78d557b689bb7423b38a557884134e">functions::Hull2D::EuclideanThickness</a>);</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="moduleAlphaThickSegmentRecoGreedy"></a>
Example of greedy segmentation into Alpha-thick Segment</h1>
<p>To apply the greedy segmentation of a digital contour, we can use the <a class="el" href="classDGtal_1_1GreedySegmentation.html" title="Aim: Computes the greedy segmentation of a range given by a pair of ConstIterators....">GreedySegmentation</a> class (since the <a class="el" href="classDGtal_1_1AlphaThickSegmentComputer.html" title="Aim: This class is devoted to the recognition of alpha thick segments as described in fauretangential...">AlphaThickSegmentComputer</a> class is a model of the concept CForwardSegmentComputer): </p><div class="fragment"><div class="line">  DecompositionAT theDecomposition(aContour.begin(), aContour.end(), AlphaThickSegmentComputer2D(4)); </div>
</div><!-- fragment --><p>The resulting set of segments can be displayed using the bounding box mode: </p><div class="fragment"><div class="line">  aBoard &lt;&lt; <a class="code hl_struct" href="structDGtal_1_1SetMode.html">SetMode</a>(<span class="stringliteral">&quot;AlphaThickSegment&quot;</span>, <span class="stringliteral">&quot;BoundingBox&quot;</span>);</div>
</div><!-- fragment --><p>You should obtain such a visualization:</p>
<div class="image">
<img src="examplegreedyAlphaThickDecomposition.png" alt=""/>
<div class="caption">
Greedy decomposition with alpha-thick segments with alpha = 4</div></div>
 <p>The whole example can be found in <a class="el" href="greedyAlphaThickDecomposition_8cpp.html">greedyAlphaThickDecomposition.cpp</a>.</p>
<h1 class="doxsection"><a class="anchor" id="moduleAlphaThickSegmentTgtCover"></a>
Computing AlphaThickSegment tangential cover</h1>
<h2 class="doxsection"><a class="anchor" id="moduleAlphaThickSegmentTgtCoverSaturated"></a>
Tangential cover from saturated segmentation</h2>
<p>To compute the tangential cover of a single contour, a first possibility is to use the <a class="el" href="classDGtal_1_1SaturatedSegmentation.html" title="Aim: Computes the saturated segmentation, that is the whole set of maximal segments within a range gi...">SaturatedSegmentation</a> class. As in the previous section, since the <a class="el" href="classDGtal_1_1AlphaThickSegmentComputer.html" title="Aim: This class is devoted to the recognition of alpha thick segments as described in fauretangential...">AlphaThickSegmentComputer</a> is a model of the concept CForwardSegmentComputer, we can compute a saturated segmentation of the contour from maximal AlphaThickSegment (i.e a tangential cover) by using the <a class="el" href="classDGtal_1_1SaturatedSegmentation.html" title="Aim: Computes the saturated segmentation, that is the whole set of maximal segments within a range gi...">SaturatedSegmentation</a> class.</p>
<dl class="section see"><dt>See also</dt><dd>This section is illustrated by using the <a class="el" href="exampleFMM2D_8cpp.html#afa2b50f4716fc3b42221a72e676e1422" title="We use FMM to compute a distance field from a given point.">example</a> <a class="el" href="exampleAlphaThickSegmentTgtCover_8cpp.html">exampleAlphaThickSegmentTgtCover.cpp</a>.</dd></dl>
<p>To obtain the complete tangential cover of a closed contour, we need to define a <a class="el" href="classDGtal_1_1Circulator.html" title="Aim: Provides an adapter for classical iterators that can iterate through the underlying data structu...">Circulator</a> from the input contour. Thus, we have to include the the following headers:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/curves/AlphaThickSegmentComputer.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/curves/SaturatedSegmentation.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/base/Circulator.h&quot;</span></div>
</div><!-- fragment --><p>Then, we can define this following types:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> std::vector&lt;Z2i::RealPoint&gt;::const_iterator RAConstIterator;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1Circulator.html">Circulator&lt;RAConstIterator&gt;</a> ConstCirculator;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1AlphaThickSegmentComputer.html">AlphaThickSegmentComputer&lt;Z2i::RealPoint, ConstCirculator&gt;</a> AlphaThickSegmentComputer2D;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1SaturatedSegmentation.html">SaturatedSegmentation&lt;AlphaThickSegmentComputer2D&gt;</a> AlphaSegmentation;</div>
</div><!-- fragment --><p>The contour <a class="el" href="classDGtal_1_1Circulator.html">Circulator</a> is constructed from the a simple contour iterators:</p>
<div class="fragment"><div class="line">  <a class="code hl_class" href="classDGtal_1_1Circulator.html">Circulator&lt;RAConstIterator&gt;</a> circulator (aContour.begin(), aContour.begin(), aContour.end());</div>
</div><!-- fragment --><p>The segmentation object can now be constructed as follows:</p>
<div class="fragment"><div class="line">  AlphaThickSegmentComputer2D computer(4, <a class="code hl_enumvalue" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ade3b11c94c4d3736bb8efc7abcc58735aff78d557b689bb7423b38a557884134e">functions::Hull2D::EuclideanThickness</a>);</div>
<div class="line">  AlphaSegmentation segmentator(circulator, circulator, computer);</div>
</div><!-- fragment --><p>Finally we can access to the complete tangential cover and display it:</p>
<div class="fragment"><div class="line">  AlphaSegmentation::SegmentComputerIterator i = segmentator.begin();</div>
<div class="line">  AlphaSegmentation::SegmentComputerIterator end = segmentator.end();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> ( ; i != end; ++i) {</div>
<div class="line">    AlphaThickSegmentComputer2D current(*i);</div>
<div class="line">    aBoard &lt;&lt; <a class="code hl_struct" href="structDGtal_1_1SetMode.html">SetMode</a>(current.className(), <span class="stringliteral">&quot;BoundingBox&quot;</span>);</div>
<div class="line">    aBoard &lt;&lt; current;</div>
<div class="line">  }</div>
</div><!-- fragment --><p>You will obtain such a resulting visualization:</p>
<div class="image">
<img src="exampleAlphaThickSegmentTgtCover.png" alt=""/>
<div class="caption">
Tangential cover with alpha-thick segments with alpha = 4</div></div>
 <h2 class="doxsection"><a class="anchor" id="moduleAlphaThickSegmentTgtCoverSingle"></a>
Tangential cover on a single point</h2>
<p>Alternatively, if you only want the tangential cover associated to a single point, you can use the functions of the <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils</a>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/curves/SegmentComputerUtils.h&quot;</span></div>
</div><!-- fragment --><p>In particular, the function <a class="el" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">firstMaximalSegment</a> and <a class="el" href="namespaceDGtal.html#a19f04b5f095862ee00e620f8246df2f8">lastMaximalSegment</a> permit to compute respectively the first and last maximal segment covering a particular point:</p>
<div class="fragment"><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code hl_function" href="testBits_8cpp.html#abf1224ffcf053d0b7990122fcef93bc9">index</a> = 80;</div>
<div class="line">  <a class="code hl_function" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">firstMaximalSegment</a>(computer, circulator+<a class="code hl_function" href="testBits_8cpp.html#abf1224ffcf053d0b7990122fcef93bc9">index</a>, circulator, circulator);</div>
<div class="line">  AlphaThickSegmentComputer2D first (computer);</div>
<div class="line">  <a class="code hl_function" href="namespaceDGtal.html#a19f04b5f095862ee00e620f8246df2f8">lastMaximalSegment</a>(computer, circulator+<a class="code hl_function" href="testBits_8cpp.html#abf1224ffcf053d0b7990122fcef93bc9">index</a>, circulator, circulator);</div>
<div class="line">  AlphaThickSegmentComputer2D last (computer);</div>
</div><!-- fragment --><p>Then you will be able to access to all the maximal segments covering the point by using the function <a class="el" href="namespaceDGtal.html#a91c1293187f38e931f5f353d1a38f71c">nextMaximalSegment</a> : </p><div class="fragment"><div class="line">  <span class="keywordflow">while</span>(first.end() != last.end()){</div>
<div class="line">    aBoard2 &lt;&lt; <a class="code hl_struct" href="structDGtal_1_1SetMode.html">SetMode</a>(first.className(), <span class="stringliteral">&quot;BoundingBox&quot;</span>);</div>
<div class="line">    aBoard2 &lt;&lt; first;</div>
<div class="line">    <a class="code hl_function" href="namespaceDGtal.html#a91c1293187f38e931f5f353d1a38f71c">nextMaximalSegment</a>(first, circulator);</div>
<div class="line">  }</div>
<div class="line">  aBoard2 &lt;&lt; last;</div>
</div><!-- fragment --><p>You will obtain for instance such a resulting cover: </p><div class="image">
<img src="exampleAlphaThickSegmentTgtCoverSingle.png" alt=""/>
<div class="caption">
Tangential cover with alpha-thick segments with alpha = 4 for a point of index 80 (in blue)</div></div>
  </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="index.html">DGtal - Digital Geometry Tools and Algorithms Library.</a></li><li class="navelem"><a href="packageGeometry.html">Geometry package</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for DGtal by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
