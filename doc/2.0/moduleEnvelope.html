<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Fully convex envelope, relative fully convex envelope and digital polyhedra</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('moduleEnvelope.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Fully convex envelope, relative fully convex envelope and digital polyhedra </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Jacques-Olivier Lachaud</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.3</dd></dl>
<p>Part of the <a class="el" href="packageGeometry.html">Geometry package</a>.</p>
<p>This part of the manual describes convex hull tools associated to a new definition of digital convexity, called the <b>full</b> <b>convexity</b> <a class="el" href="citelist.html#CITEREF_lachaud_dgmm_2021">[79]</a> <a class="el" href="citelist.html#CITEREF_lachaud_jmiv_2022">[80]</a> . Most of the work presented here is related to <a class="el" href="citelist.html#CITEREF_feschet_2022_dgmm">[53]</a> . We talk about convex <b>envelopes</b> instead of convex <b>hulls</b>, since the presented operations do not satisfy all the usual hull operations. This is detailed below. Last, this module shows how the envelope operation is useful to build digital polyhedra.</p>
<p>The following programs are related to this documentation: <a class="el" href="testDigitalConvexity_8cpp.html">testDigitalConvexity.cpp</a>, <a class="el" href="geometry_2volumes_2digitalPolyhedronBuilder3D_8cpp-example.html">geometry/volumes/digitalPolyhedronBuilder3D.cpp</a>, <a class="el" href="geometry_2volumes_2standardDigitalPolyhedronBuilder3D_8cpp-example.html">geometry/volumes/standardDigitalPolyhedronBuilder3D.cpp</a> .</p>
<p>This module relies on module <a class="el" href="moduleQuickHull.html">QuickHull algorithm in arbitrary dimension for convex hull and Delaunay cell complex computation</a> for convex hull computations in arbitrary dimensions. You may also look at <a class="el" href="moduleDigitalConvexity.html">Digital convexity, full convexity and P-convexity</a> to see the theory of full convexity.</p>
<h1 class="doxsection"><a class="anchor" id="dgtal_envelope_sec1"></a>
Fully convex envelopes</h1>
<h2 class="doxsection"><a class="anchor" id="dgtal_envelope_sec11"></a>
Envelope of a digital set</h2>
<p>We build an <em class="arg">envelope</em> <em class="arg">operator</em> \( \mathrm{FC}^* \) for a digital set \( Z \subset \mathbb{Z}^d \) with the following properties:</p><ul>
<li>\( Z \subset \mathrm{FC}^*(Z) \) (inclusion)</li>
<li>\( \mathrm{FC}^*(Z) \) is always fully convex (full convexity)</li>
<li>\( \mathrm{FC}^*(Z)=Z \) if and only if \( Z \) is fully convex (characterization and idempotence)</li>
<li>\( \mathrm{FC}^*(Z) \) is included in the bounded box of \( Z \) (geometric consistency)</li>
</ul>
<p>However the following property is not true in general:</p><ul>
<li>\( Z_1 \subset Z_2 \) implies \( \mathrm{FC}^*(Z_1) \subset \mathrm{FC}^*(Z_2) \) (increasing)</li>
</ul>
<p>The envelope operator is itself built upon the \( \mathrm{FC} \) operator defined as:</p>
<p>\(\mathrm{FC}(Z):=\mathrm{Extr}(\mathrm{Skel}(\mathrm{Star}(\mathrm{CvxH}(Z))))
\)</p>
<p>where:</p><ul>
<li>\( \mathrm{CvxH} \) denotes the standard convex hull in Euclidean space,</li>
<li>\( \mathrm{Star} \) denotes the set of cells of the cubical grid complex induced by lattice points, whose closure intersects the given set,</li>
<li>\( \mathrm{Skel} \) denotes the skeleton of a cell complex, i.e. the smallest cell complex whose star is equal to the input cell complex,</li>
<li>\( \mathrm{Extr} \) returns the set of lattice points that are vertices of cells of the given cell complex.</li>
</ul>
<p>The envelope operator is the limit of the iterated repetition of operator \( \mathrm{FC} \). It is proven that this sequence achieves a fixed point in a bounded number of iterations. The figure below illustrates this operator in 2D.</p>
<div class="image">
<img src="operator-FC.jpg" alt="" width="50%"/>
<div class="caption">
Illustration of operator FC and its successive application, until idempotence. The result is a fully convex set.</div></div>
<h2 class="doxsection"><a class="anchor" id="dgtal_envelope_sec12"></a>
Envelope of a digital set relative to another fully convex set</h2>
<p>Given a fully convex set \( Y \subset \mathbb{Z}^d \) and a digital set \( X \subset Y \), we can define the <em class="arg">envelope</em> <em class="arg">of</em> \( X \) <em class="arg">relative</em> <em class="arg">to</em> \( Y \) as</p>
<p>\( \mathrm{FC}^*_{\mid Y}( X ) := \lim_{n \rightarrow +\infty}
\mathrm{FC}^n_{\mid Y}( X ) \) with  \( \mathrm{FC}_{\mid Y}( X ) :=
\mathrm{FC}(X) \cap Y \).</p>
<p>It satisfies the following properties:</p><ul>
<li>\( X \subset \mathrm{FC}^*_{\mid Y}( X ) \subset Y \) (inclusion)</li>
<li>\( \mathrm{FC}^*_{\mid Y}( X ) \) is fully convex (full convexity)</li>
<li>\( \mathrm{FC}^*_{\mid Y}( X ) = X \) if and only if \( X \) is fully convex (characterization and idempotence)</li>
<li>\( \mathrm{FC}^*_{\mid Y}( X ) \) is included in the bounding box of \( X \) (geometric consistency)</li>
</ul>
<p>Again it may not be an increasing operator. The interest of relative envelopes will appear clearly in section <a class="el" href="#dgtal_envelope_sec2">Digital polyhedra</a> .</p>
<h2 class="doxsection"><a class="anchor" id="dgtal_envelope_sec13"></a>
Computing fully convex envelopes</h2>
<p>Most operations are defined in class <a class="el" href="classDGtal_1_1DigitalConvexity.html">DigitalConvexity</a>. They allow to build the (relative or not) envelope, but also to compute intermediate steps, which can be useful in some contexts.</p>
<p><b>Envelope</b> <b>operations</b> </p><ul>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a8c1f8c406bf52d7654ebdcd91542e107">DigitalConvexity::envelope</a> builds the fully convex envelope of any digital set.</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a94893f395ee00f8bd8d8b5c964ab28ce">DigitalConvexity::relativeEnvelope</a> builds the relative fully convex envelope of any digital set relative to another fully convex set \( Y \). One variant takes as input for \( Y \) a set of lattice points; another variant takes a predicate for defining \( Y \). The second variant is useful when \( Y \) is infinite or can be quickly defined with a function, like arithmetic planes.</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#aec7cc41539c4895a98cb69b625b1bc8b">DigitalConvexity::depthLastEnvelope</a> gives the number of \( \mathrm{FC} \) iterations in the last call to an envelope operation.</li>
</ul>
<p><b>Intermediate</b> <b>computations</b> </p><ul>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a15bbab0bbc615f5088fa767efd41819f">DigitalConvexity::FC</a> computes the operation \( \mathrm{FC}(Z):=\mathrm{Extr}(\mathrm{Skel}(\mathrm{Star}(\mathrm{CvxH}(Z)))) \), for \( Z \) a digital set.</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a3bfa3e199bb8c80908fedee176898c30">DigitalConvexity::CvxH</a> computes the lattice polytope that is the convex hull of the given digital set.</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#abd689cce05efc14754c8aceb90159be9">DigitalConvexity::StarCvxH</a> computes the set of lattice cells \( \mathrm{Star}(\mathrm{CvxH}(Z)) \), i.e. the cells that touch the convex hull of the given digital set.</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a2029a6225cad0c5db0f6334ed2833a9f">DigitalConvexity::Star</a> computes the set of lattice cells \( \mathrm{Star}(Z) \), i.e. the cells that touch some point of the given digital set.</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a245ed38f44d5bb34b8693b052f4a9105">DigitalConvexity::StarCells</a> computes the set of lattice cells \( \mathrm{Star}(C) \), i.e. the cells that touch some cell of the given set of cells, represented with lattice point and Khalimsky coordinates.</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a351ac0c6f16600fae5f1cd89a438c936">DigitalConvexity::sizeStarCvxH</a> computes the cardinal of the set of lattice cells \( \mathrm{Star}(\mathrm{CvxH}(Z)) \), i.e. the number of cells that touch the convex hull of the given digital set. Slightly faster than the previous one.</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a5f8e046968925ce2b36313e6a97b6382">DigitalConvexity::Extr</a> computes the extremal vertices of a range of cells.</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a472d893d2d1736c7fc662a39f0756179">DigitalConvexity::ExtrCvxH</a> computes the extremal vertices of the convex hull of a range of lattice points.</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#ace8e05ee36ff537409e7d37c09264bb4">DigitalConvexity::ExtrSkel</a> computes the extremal vertices of the skeleton of a range of cells.</li>
</ul>
<p><b>Representations</b> and <b>conversions</b> </p>
<p>The previous static methods use two representations for lattice points and cells:</p>
<ul>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a6ca2be6c9d11457094c57044df502040">DigitalConvexity::PointRange</a> : a range of lattice points is represented by a <b>sorted</b> standard vector of points.</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#aab180574b64e761af7f666d855e952ad">DigitalConvexity::LatticeSet</a> : ranges and sets of cells are represented with a stacked row representation called <span class="tt">lattice set</span> (class <a class="el" href="classDGtal_1_1LatticeSetByIntervals.html" title="Aim:">LatticeSetByIntervals</a>): each cell is represented by a lattice point (its Khalimsky coordinates), cells of the same row are stacked as sorted intervals. This saves memory and speeds up a lot of procedures.</li>
</ul>
<p>You may switch from one representation to the other as follows:</p><ul>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a0cf6fcb3429bc769113e428ba3bb80ca">DigitalConvexity::toLatticeSet</a> builds the lattice set equivalent to the given range of points.</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#aa5d8709b29cfef087f56f04e1f33a8ac">DigitalConvexity::toPointRange</a> builds the range of points equivalent to the given lattice set.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="dgtal_envelope_sec2"></a>
Digital polyhedra</h1>
<p>Envelopes and relatives provide a very neat and unambiguous way to create a set of voxels associated to a given polyhedron.</p>
<p>Indeed for any convex facet \( \sigma \) of a polyhedron with vertices \( V(\sigma) \), it suffices to define the <em class="arg">generic</em> <em class="arg">digital</em> <em class="arg">facet</em> \( \sigma^* \) as  \( \mathrm{FC}^*( V(\sigma) )
\). Moreover, if the vertices \( V(\sigma) \) are coplanar (this is always the case for a simplex), we can define the <em class="arg">standard</em> <em class="arg">digital</em> <em class="arg">facet</em> \( \sigma^*_1 \) as the envelope of  \( V(\sigma)
\) relative to the standard median digital plane containing the vertices. An even thinner facet is achievable: the <em class="arg">naive</em> <em class="arg">digital</em> <em class="arg">facet</em> \( \sigma^*_\infty \) is the envelope of \( V(\sigma) \) relative to the naive median digital plane containing the vertices. This is illustrated below for a triangle defined by three vertices.</p>
<div class="image">
<img src="digital-facet.jpg" alt="" width="70%"/>
<div class="caption">
Illustration of generic, standard and naive digital facet with 3 vertices. Vertices are in black, edges are in black and grey, triangle is black, grey and white.</div></div>
<p>From any polydron defined by its vertices and the combinatorics of its facets, we can thus build several well-defined digital polyhedra, that are valid for any digitization step <em class="arg">h</em> and any dimension:</p>
<ol type="1">
<li>First digitize the vertices of the polyhedron at the desired resolution, i.e. if the vertex has real position \( x \), then its digital position is \( x^* := \mathrm{round}(x/h) \).</li>
<li>Choose if you wish to build a generic, standard or naive polyhedron, then digitize each facet (or edges) as the (relative or not) fully convex envelope of its digitized vertices.</li>
</ol>
<p>This is illustrated below in 3D at two different resolutions.</p>
<div class="image">
<img src="digital-lion-g.jpg" alt="" width="70%"/>
<div class="caption">
Illustration of generic digital polyhedron of lion.obj polyhedron at two different resolutions. Facets may not be planar.</div></div>
 <div class="image">
<img src="digital-lion-1.jpg" alt="" width="70%"/>
<div class="caption">
Illustration of standard digital polyhedron of lion-tri.obj polyhedron at two different resolutions. Each facet is planar.</div></div>
 <div class="image">
<img src="digital-lion-oo.jpg" alt="" width="70%"/>
<div class="caption">
Illustration of naive digital polyhedron of lion-tri.obj polyhedron at two different resolutions. Each facet is planar.</div></div>
<p>The digital polyhedron is guaranteed to cover all the faces and presents inclusions relations between facets and incident cells. The whole code for building digital polyhedra is given in examples <a class="el" href="geometry_2volumes_2digitalPolyhedronBuilder3D_8cpp-example.html">geometry/volumes/digitalPolyhedronBuilder3D.cpp</a> and <a class="el" href="geometry_2volumes_2standardDigitalPolyhedronBuilder3D_8cpp-example.html">geometry/volumes/standardDigitalPolyhedronBuilder3D.cpp</a> . </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="index.html">DGtal - Digital Geometry Tools and Algorithms Library.</a></li><li class="navelem"><a href="packageGeometry.html">Geometry package</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for DGtal by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
