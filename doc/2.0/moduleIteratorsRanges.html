<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Iterators and ranges</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('moduleIteratorsRanges.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Iterators and ranges </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Tristan Roussillon</dd></dl>
<p>This part of the manual describes basic concepts of iterators and ranges. It also presents several tools available in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> to ease their use: traits class, useful functions, adapters, etc.</p>
<p><a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> users usually have to play with ranges to iterate over finite sets of elements. <br  />
</p>
<h1 class="doxsection"><a class="anchor" id="secIteratorRangesIterators"></a>
Introduction to iterators</h1>
<p>The concept of <em>iterator</em> is one of the main concept introduced in the <a href="www.cplusplus.com/reference/std/iterator/" title="STL iterators">STL</a> in order to make data structures and algorithms independent: a programmer would be able to apply one algorithm on different data structures. Algorithms typically take iterators as arguments, so a data structure is only required to provide a way to access its elements using iterators. An iterator is any object that, pointing to some element stored in a data structure, can be incremented so that it points to the next element. An iterator has at least, the dereference (<span class="tt">*</span>) and increment (<span class="tt">++</span>) operators, but can have more operators to implement extra functionalities. Depending on the functionality they implement, <br  />
 they belong to one of the several categories of iterators. <br  />
 Following [The Boost.Iterator Library] (<a href="http://www.boost.org/doc/libs/1_49_0/libs/iterator/doc/index.html">http://www.boost.org/doc/libs/1_49_0/libs/iterator/doc/index.html</a> "Boost iterators"), which extends the hierarchy of concepts proposed in the STL and separates access and traversal functionalities, we consider in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> the following access and traversal categories:</p>
<ul>
<li>Readable iterator: <span class="tt">*i</span> returns an instance of V (value type) and <span class="tt">i-&gt;m</span> is equivalent to <span class="tt">(*i).m</span></li>
<li>Writable iterator: <span class="tt">*i = o</span></li>
<li>LValue iterator: <span class="tt">*i</span> returns an instance of <span class="tt">V&amp;</span></li>
</ul>
<ol type="1">
<li>Incrementable iterator: dereference (<span class="tt">*</span>), indirection (<span class="tt">-&gt;</span>) and increment (<span class="tt">++</span>) operators.</li>
<li>Single-pass iterator: equality operators (<span class="tt">==</span> and <span class="tt">!=</span>).</li>
<li>Forward iterator: default constructor.</li>
<li>Bidirectional iterator: decrement (<span class="tt">--</span>) operator. <br  />
</li>
<li>Random access iterator: arithmetic and comparison operators (<span class="tt">&lt;</span>, <span class="tt">&lt;=</span>, <span class="tt">&gt;</span>, <span class="tt">&gt;=</span>). <br  />
</li>
</ol>
<p>Each traversal category of level <em>l</em> obviously implements the functionalities of all the categories <em>k &lt; l</em> and one or more extra functionalities. For each category, the main difference with the previous categories is provided in the above list, but [The Boost.Iterator Library] (<a href="http://www.boost.org/doc/libs/1_49_0/libs/iterator/doc/index.html">http://www.boost.org/doc/libs/1_49_0/libs/iterator/doc/index.html</a> "Boost iterators") gives more details.</p>
<p>The following diagram sums up the main iterator concepts:</p>
<div class="dotgraph">
<iframe scrolling="no" loading="lazy" frameborder="0" src="dot_inline_dotgraph_2.svg" width="899" height="572"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<h1 class="doxsection"><a class="anchor" id="secIteratorRangesRanges"></a>
Introduction to ranges</h1>
<p><a class="el" href="structA.html">A</a> <em>range</em> of elements stored in a data structure (container) may be implicitly described by a well-chosen pair of iterators. Any pair does not define a valid range, even with iterators having nonsingular values. An iterator <span class="tt">j</span> is reachable from an iterator <span class="tt">i</span> if and only if <span class="tt">i</span> can be made equal to <span class="tt">j</span> with finitely many applications of the increment operator. If <span class="tt">j</span> is reachable from <span class="tt">i</span>, one can iterate over the range bounded by <span class="tt">i</span> and <span class="tt">j</span>, from the one pointed to by <span class="tt">i</span> and up to, but not including, the one pointed to by <span class="tt">j</span>. Such a range is valid and is denoted by [<span class="tt">i,j</span>).</p>
<p>In linear data structures, any iterator pointing to the last element is incremented so that it points to the <em>past-the-end</em> element, ie. it points past the last element (just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element of the array). <br  />
</p>
<p>If an iterator <span class="tt">begin</span> points to the first element of a data structure and an iterator <span class="tt">end</span> points to the past-the-end element, iterating over the range [<span class="tt">begin,end</span>) is a way of iterating over all the elements of the underlying data structure. Note that if the underlying data structure is empty, it only has a past-the-end element. As a consequence, a range [<span class="tt">i,i</span>) denotes an empty range. <br  />
 <a class="el" href="structA.html">A</a> range of a linear data structure is illustrated below (normal values are depicted with a small straight segment, whereas the past-the-end value is depicted with a cross). In this example, [<span class="tt">i,j</span>) is not a valid range because <span class="tt">j</span> cannot be reached from <span class="tt">i</span> and the whole range may be denoted by [<span class="tt">begin,end</span>).</p>
<div class="image">
<img src="linearRange.png" alt=""/>
<div class="caption">
Linear range</div></div>
 <h2 class="doxsection"><a class="anchor" id="subsecIteratorRangesRangesMainConcepts"></a>
Main concepts</h2>
<p>Some objects have the capability to provide a pair of iterators describing a (valid) range. For instance, methods <span class="tt">begin()</span> and <span class="tt">end()</span> of STL containers return two iterators bounding the range of elements contained in the data structure. Similarly, in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>, there are several concepts of range having at least these <span class="tt">begin()</span> and <span class="tt">end()</span> methods.</p>
<p>The concept <a class="el" href="structDGtal_1_1concepts_1_1CConstSinglePassRange.html">CConstSinglePassRange</a> describes any object for which, one can iterate at least one time over a range of elements. <br  />
 Models of <a class="el" href="structDGtal_1_1concepts_1_1CConstSinglePassRange.html" title="Aim: Defines the concept describing a const single pass range.">concepts::CConstSinglePassRange</a> have a nested type <a class="el" href="classDGtal_1_1IteratorCompletionTraits.html">ConstIterator</a>, which is a readable and (at least) single-pass iterator. <br  />
 Instances of <a class="el" href="classDGtal_1_1IteratorCompletionTraits.html">ConstIterator</a> are returned by <span class="tt">begin()</span> and <span class="tt">end()</span> methods. <br  />
</p>
<p>The concept <a class="el" href="structDGtal_1_1concepts_1_1CConstBidirectionalRange.html">CConstBidirectionalRange</a>, which is a refinement of <a class="el" href="structDGtal_1_1concepts_1_1CConstSinglePassRange.html" title="Aim: Defines the concept describing a const single pass range.">concepts::CConstSinglePassRange</a>, describes any collection of elements that can be scanned several times, either forward or backward. <br  />
 Models of this concept have obviously a nested type <a class="el" href="classDGtal_1_1IteratorCompletionTraits.html">ConstIterator</a>, but it is a readable and (at least) bidirectional iterator. They have in addition a nested type ConstReverseIterator, which is a readable and bidirectional iterator too. Finally, <span class="tt">begin()</span> and <span class="tt">end()</span> methods return instances of <a class="el" href="classDGtal_1_1IteratorCompletionTraits.html">ConstIterator</a>, whereas <span class="tt">rbegin()</span> and <span class="tt">rend()</span> methods return instances of ConstReverseIterator.</p>
<p>The concept <a class="el" href="structDGtal_1_1concepts_1_1CSinglePassRange.html">CSinglePassRange</a> (resp. <a class="el" href="structDGtal_1_1concepts_1_1CBidirectionalRange.html">CBidirectionalRange</a>) is a refinement of <a class="el" href="structDGtal_1_1concepts_1_1CConstSinglePassRange.html" title="Aim: Defines the concept describing a const single pass range.">concepts::CConstSinglePassRange</a> (resp. <a class="el" href="structDGtal_1_1concepts_1_1CConstBidirectionalRange.html" title="Aim: Defines the concept describing a bidirectional const range.">concepts::CConstBidirectionalRange</a>) for not constant, mutable elements. All their models have a nested type <a class="el" href="classDGtal_1_1IteratorCompletionTraits.html">Iterator</a> (resp. <a class="el" href="classDGtal_1_1ReverseIterator.html" title="This class adapts any bidirectional iterator so that operator++ calls operator-- and vice versa.">ReverseIterator</a>), which are the readable and writable counterparts of <a class="el" href="classDGtal_1_1IteratorCompletionTraits.html">ConstIterator</a> (resp. ConstReverseIterator). <br  />
</p>
<p>These four concepts and their links are depicted in the following figure:</p>
<div class="dotgraph">
<iframe scrolling="no" loading="lazy" frameborder="0" src="dot_inline_dotgraph_3.svg" width="587" height="327"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<h1 class="doxsection"><a class="anchor" id="secIteratorRangesAdatpers"></a>
Adapters to iterators</h1>
<p>In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>, several adapters to iterators are provided.</p>
<h2 class="doxsection"><a class="anchor" id="subsecIteratorRangesAdaptersReverse"></a>
Reverse iterator</h2>
<p>Any bidirectional iterator may have a reverse counterpart, ie. an adapter that enables a backward scanning by calling the decrement operator instead of the increment operator and conversely. Bidirectional ranges provide reverse iterators that can be used as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range&gt;</div>
<div class="line"><span class="keywordtype">void</span> anyProcedure(<span class="keyword">const</span> <a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#aa75176274164e46066e9778711973a42">Range</a>&amp; aRange)</div>
<div class="line">  {</div>
<div class="line">    BOOST_CONCEPT_ASSERT(( concepts::CBidirectionalRange&lt;Range&gt; )); </div>
<div class="line">    ...</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code hl_typedef" href="classDGtal_1_1SimpleRandomAccessRangeFromPoint.html#ac458826c440b7ee21af9f2c49ca07471">Range::ReverseIterator</a> ri = r.rbegin(), </div>
<div class="line">         <span class="keyword">typename</span> <a class="code hl_typedef" href="classDGtal_1_1SimpleRandomAccessRangeFromPoint.html#ac458826c440b7ee21af9f2c49ca07471">Range::ReverseIterator</a> riEnd = r.rend(); </div>
<div class="line">         ri != riEnd; ++ri)</div>
<div class="line">    {</div>
<div class="line">     ...</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="ttc" id="aclassDGtal_1_1SimpleRandomAccessRangeFromPoint_html_ac458826c440b7ee21af9f2c49ca07471"><div class="ttname"><a href="classDGtal_1_1SimpleRandomAccessRangeFromPoint.html#ac458826c440b7ee21af9f2c49ca07471">DGtal::SimpleRandomAccessRangeFromPoint&lt; ConstIterator, Iterator, DistanceFunctorFromPoint&lt; Self &gt; &gt;::ReverseIterator</a></div><div class="ttdeci">boost::reverse_iterator&lt; Iterator &gt; ReverseIterator</div><div class="ttdef"><b>Definition</b> <a href="SimpleRandomAccessRangeFromPoint_8h_source.html#l00090">SimpleRandomAccessRangeFromPoint.h:90</a></div></div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_aa75176274164e46066e9778711973a42"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#aa75176274164e46066e9778711973a42">Range</a></div><div class="ttdeci">Image::Range Range</div><div class="ttdef"><b>Definition</b> <a href="testSimpleRandomAccessRangeFromPoint_8cpp_source.html#l00046">testSimpleRandomAccessRangeFromPoint.cpp:46</a></div></div>
</div><!-- fragment --><p>In order to take profit of the whole <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> framework, you should use <a class="el" href="classDGtal_1_1ReverseIterator.html" title="This class adapts any bidirectional iterator so that operator++ calls operator-- and vice versa.">DGtal::ReverseIterator</a> instead of boost::reverse_iterator or even boost::reverse_iterator.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/base/ReverseIterator.h&quot;</span></div>
<div class="line">...</div>
<div class="line">template&lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line"><span class="keywordtype">void</span> anyProcedure(<span class="keyword">const</span> Iterator&amp; anIterator)</div>
<div class="line">  {</div>
<div class="line">  ...</div>
<div class="line">  <a class="code hl_class" href="classDGtal_1_1ReverseIterator.html">DGtal::ReverseIterator&lt;Iterator&gt;</a> ri(anIterator); </div>
<div class="line">  ASSERT( ri.base() == anIterator ); <span class="comment">//ie. anIterator is the underlying iterator of ri</span></div>
<div class="line">...</div>
<div class="line">  }</div>
<div class="ttc" id="aclassDGtal_1_1ReverseIterator_html"><div class="ttname"><a href="classDGtal_1_1ReverseIterator.html">DGtal::ReverseIterator</a></div><div class="ttdoc">This class adapts any bidirectional iterator so that operator++ calls operator-- and vice versa.</div><div class="ttdef"><b>Definition</b> <a href="ReverseIterator_8h_source.html#l00069">ReverseIterator.h:71</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Reverse iterators are a little tricky because <span class="tt">*ri == *--ri.base()</span> (or equivalently <span class="tt">*++ri == *ri.base()</span>), so that when an iterator is reversed, the reversed version does not point to the same element in the range, but to the one preceding it. <br  />
</dd>
<dd>
<b>Developer trick</b>: there is no erase or insert method taking a reverse iterator as input argument in STL containers. Static methods are provided to do that in a small struct called <a class="el" href="structDGtal_1_1OpInSTLContainers.html">OpInSTLContainers</a>. <br  />
</dd></dl>
<h2 class="doxsection"><a class="anchor" id="subsecIteratorRangesAdaptersAdapters"></a>
On-line transformations</h2>
<p><a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> also provides adapters to iterators that transforms the data returned by the dereference (and indirection) operator into other data, possibly of different type. The transformation is delegated to a <em>functor</em>. Dereferencing any adapted iterator consists in applying the functor on the data to which points the underlying iterator: <br  />
</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/base/ConstIteratorAdapter.h&quot;</span></div>
<div class="line">...</div>
<div class="line">template&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> <a class="code hl_struct" href="structFunctor.html">Functor</a>, <span class="keyword">typename</span> ReturnType&gt;</div>
<div class="line"><span class="keywordtype">void</span> anyProcedure(<span class="keyword">const</span> Iterator&amp; anIterator, <span class="keyword">const</span> <a class="code hl_struct" href="structFunctor.html">Functor</a>&amp; aFunctor)</div>
<div class="line">  {</div>
<div class="line">    ...</div>
<div class="line">    DGtal::ConstAdapterIterator&lt;Iterator, Functor, ReturnType&gt; a(i, f);</div>
<div class="line">    ASSERT( *a == f(*i) ); <span class="comment">//ie. *a and f(*i) return equivalent instances of ReturnType  </span></div>
<div class="line">    ...</div>
<div class="line">  } </div>
<div class="ttc" id="astructFunctor_html"><div class="ttname"><a href="structFunctor.html">Functor</a></div><div class="ttdef"><b>Definition</b> <a href="testFunctorHolder_8cpp_source.html#l00044">testFunctorHolder.cpp:45</a></div></div>
</div><!-- fragment --><p>The class <a class="el" href="classDGtal_1_1ConstIteratorAdapter.html" title="This class adapts any iterator so that operator* returns another element than the one pointed to by t...">ConstIteratorAdapter</a> adapts any (at least) readable and (at least) incremental iterator with any functor, whereas the class <a class="el" href="classDGtal_1_1IteratorAdapter.html" title="This class adapts any lvalue iterator so that operator* returns a member on the element pointed to by...">IteratorAdapter</a> adapts any readable, writable, Lvalue and (at least) incremental iterator.</p>
<h2 class="doxsection"><a class="anchor" id="subsecIteratorRangesAdaptersCirculators"></a>
Circulators</h2>
<p>Like <a href="http://www.cgal.org/" title="CGAL">Cgal</a>, <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> extends the concept of iterator to circular data structures by defining the concept of circular iterator or <em>circulator</em> for short.</p>
<p>The class <a class="el" href="classDGtal_1_1Circulator.html" title="Aim: Provides an adapter for classical iterators that can iterate through the underlying data structu...">Circulator</a> is an adapter that creates a circulator from a classic iterator.</p>
<p>In circular data structures, any pairs of iterators [<span class="tt">i,j</span>) always describes a valid range (ie. <span class="tt">j</span> is always reachable from <span class="tt">i</span>) and there is no past-the-end element. <a class="el" href="structA.html">A</a> range of a circular data structure is illustrated below. In this example, [<span class="tt">i,j</span>) is of course a valid range. <br  />
</p>
<div class="image">
<img src="circularRange.png" alt=""/>
<div class="caption">
Circular range</div></div>
 <p>As long as <span class="tt">i != j</span>, circulators are quite similar to classic iterator in the subrange [<span class="tt">i,j</span>). More precisely, forward and bidirectional circulators behave exactly like classic forward and bidirectional iterators (note that there is no incrementable or single-pass circulator). However, there is a semantic difference between random access circulators and iterators for some arithmetic and comparison operators. Indeed, even if we have <span class="tt">i + (j-i) = j</span>, (ie. <span class="tt">i</span> must be incremented <span class="tt">j-i</span> times so that it reaches <span class="tt">j</span>) for both circulators and iterators, we have two major differences, sum up in the following table:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">classic iterators  </th><th class="markdownTableHeadNone">circulators  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">(i &lt;= j) iff ((j-i) &gt;= 0)  </td><td class="markdownTableBodyNone">(i &lt;= j) is always true  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">(i-j) + (j-i) = 0  </td><td class="markdownTableBodyNone">(i-j) + (j-i) = range size  </td></tr>
</table>
<p>On the other hand, circulators and iterators are quite different for iterating over <b>all</b> the elements of a given range. In linear data structures, due to the existence of a past-the-end element, the whole range is not different from any subranges: it is described by a pair of iterators [<span class="tt">i,j</span>) such that <span class="tt">j</span> is reachable from <span class="tt">i</span>. If the data structure does not contain any element, an iterator <span class="tt">k</span> can point to the past-the-end element and [<span class="tt">k,k</span>) describes the valid and empty associated range. <br  />
</p>
<p>However, in (truly) circular data structures, there is no past-the-end element. How to describe a whole range using circulators ? Circulators have a specific state in the case of an empty data structure so that it is enough to consider one circulator <span class="tt">k</span> to check whether the underlying data structure is empty or not. Note that any default-constructed circulator, by convention, is in the same state as circulators provided by empty data structures.</p>
<p>Since the empty case is managed by this internal state, [<span class="tt">k,k</span>) can be viewed then as describing a whole range of elements, if a whole range is required. <br  />
</p>
<p>The do-while structure is the basic way of circulating over a range of elements:</p>
<div class="fragment"><div class="line"><span class="keywordflow">do</span> </div>
<div class="line">  {</div>
<div class="line">    ...</div>
<div class="line">    ++c; </div>
<div class="line">  } <span class="keywordflow">while</span>( c != cEnd);   </div>
</div><!-- fragment --><p>The generic way of iterating over a range of elements whatever the type of iterators (either iterator or circulator) uses the generic function <span class="tt"><a class="el" href="namespaceDGtal.html#a6f1b22211474c60437654c3a0decb8ef">isNotEmpty()</a></span>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/base/IteratorFunctions.h&quot;</span></div>
<div class="line">...</div>
<div class="line">template&lt;<span class="keyword">typename</span> IC&gt;</div>
<div class="line"><span class="keywordtype">void</span> anyProcedure(<span class="keyword">const</span> IC&amp; ic1, <span class="keyword">const</span> IC&amp; ic2)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> ( <a class="code hl_function" href="namespaceDGtal.html#a6f1b22211474c60437654c3a0decb8ef">isNotEmpty</a>( ic1, ic2 ) )</div>
<div class="line">      { <span class="comment">//if the range is not empty</span></div>
<div class="line">        IC ic = ic1; </div>
<div class="line">        <span class="keywordflow">do</span> </div>
<div class="line">          {<span class="comment">//iterating over the range</span></div>
<div class="line">          ...</div>
<div class="line">          ++ic; </div>
<div class="line">          } <span class="keywordflow">while</span>( ic != ic2);   </div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="ttc" id="anamespaceDGtal_html_a6f1b22211474c60437654c3a0decb8ef"><div class="ttname"><a href="namespaceDGtal.html#a6f1b22211474c60437654c3a0decb8ef">DGtal::isNotEmpty</a></div><div class="ttdeci">bool isNotEmpty(const IC &amp;itb, const IC &amp;ite)</div></div>
</div><!-- fragment --></div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="index.html">DGtal - Digital Geometry Tools and Algorithms Library.</a></li><li class="navelem"><a href="packageBase.html">Base package</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for DGtal by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
