<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Digital Spaces, Points, Vectors and Domains</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('moduleSpacePointVectorDomain.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Digital Spaces, Points, Vectors and Domains </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Authors</dt><dd>David Coeurjolly, Jacques-Olivier Lachaud, Guillaume Damiand</dd></dl>
<p>This part of the manual describes the <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> kernel and its classes. More precisely, we define several key concepts in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> such as <a class="el" href="structDGtal_1_1ArithmeticalDSLKernel.html">Space</a> or <a class="el" href="classDGtal_1_1VoronoiMap.html">Domain</a>. All classes and utilities defined in the <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> library require a specification of the digital space in which the objects are defined.</p>
<p>For <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> users, the specification of the digital <a class="el" href="structDGtal_1_1ArithmeticalDSLKernel.html">Space</a> usually corresponds to the first lines of <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> codes.</p>
<h1 class="doxsection"><a class="anchor" id="sectSpace"></a>
DGtal Space</h1>
<p><a class="el" href="structA.html">A</a> <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> <a class="el" href="structDGtal_1_1ArithmeticalDSLKernel.html">Space</a> parametrized by two things: a dimension (<a class="el" href="classDGtal_1_1SpaceND.html#aae87d3efb1051dbdeac28e159781ba92" title="static constants to store the dimension.">SpaceND::dimension</a>) and a type for integers (<a class="el" href="classDGtal_1_1SpaceND.html#a3217d099840050eb7135e24b1ed7940d" title="Arithmetic ring induced by (+,-,*) and Integer numbers.">SpaceND::Integer</a>). Using these information, we aim at approximating the digital space \(Z^n\) by \(Integer^{dimension}\). Hence, we have several constraints these parameters:</p><ul>
<li>the dimension should also be a integer;</li>
<li><a class="el" href="examplePlaneProbingParallelepipedEstimator_8cpp.html#ad31c3eca44cf6770809bc47f2b456212">Integer</a> should characterize a commutative ring with unity using the addition and multiplication operators.</li>
</ul>
<p>Since the <a class="el" href="structDGtal_1_1ArithmeticalDSLKernel.html">Space</a> is obtained by direct product of the range associated to the type <a class="el" href="examplePlaneProbingParallelepipedEstimator_8cpp.html#ad31c3eca44cf6770809bc47f2b456212">Integer</a>. Such type is also used to characterized the coordinates of points lying in this space.</p>
<p>In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>, <a class="el" href="structDGtal_1_1ArithmeticalDSLKernel.html">Space</a> specification is addresses by the class <a class="el" href="classDGtal_1_1SpaceND.html">DGtal::SpaceND</a>. More precisely, this class is templated by two arguments (the static dimension and the <a class="el" href="examplePlaneProbingParallelepipedEstimator_8cpp.html#ad31c3eca44cf6770809bc47f2b456212">Integer</a> type) and provides types for several objects that can be deduced from the template parameters. For example, once the parameter are specified, the class provides a type <a class="el" href="classDGtal_1_1SpaceND.html">Point</a> for all points in the space.</p>
<p>For example, digital spaces can be defined as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/base/Common.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/kernel/SpaceND.h&quot;</span></div>
<div class="line">{...}</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1SpaceND.html">DGtal::SpaceND&lt;3, DGtal::int32_t&gt;</a> MySpace32;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1SpaceND.html">DGtal::SpaceND&lt;1, DGtal::int64_t&gt;</a> MySpace64;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1SpaceND.html">DGtal::SpaceND&lt;3, DGtal::Integer&gt;</a> MySpaceBigInteger;</div>
<div class="ttc" id="aclassDGtal_1_1SpaceND_html"><div class="ttname"><a href="classDGtal_1_1SpaceND.html">DGtal::SpaceND</a></div><div class="ttdef"><b>Definition</b> <a href="SpaceND_8h_source.html#l00095">SpaceND.h:96</a></div></div>
</div><!-- fragment --><p>In the latter example, we construct a digital space using multiprecision intergers. For details, see the documentation page <a class="el" href="moduleNumber.html">Number and Integer Concepts</a>.</p>
<p>Using the shortcuts provides in <a class="el" href="StdDefs_8h_source.html">StdDefs.h</a>, the types defined in the namespace <a class="el" href="namespaceDGtal_1_1Z2i.html" title="Z2i this namespace gathers the standard of types for 2D imagery.">DGtal::Z2i</a> correspond to a digital space in dimension 2 based on int (<span class="tt"><a class="el" href="namespaceDGtal.html#a16d5d6c3faf5a8cb1d67a41634513404" title="signed 32-bit integer.">int32_t</a></span>). Hence, we can simple define <span class="tt">MySpace</span> as:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/base/Common.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/helpers/StdDefs.h&quot;</span></div>
<div class="line">{...}</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_typedef" href="namespaceDGtal_1_1Z2i.html#a9b96ab8175cf9c54b1f451858ccd46a4">DGtal::Z2i::Space</a> MySpace; </div>
<div class="ttc" id="anamespaceDGtal_1_1Z2i_html_a9b96ab8175cf9c54b1f451858ccd46a4"><div class="ttname"><a href="namespaceDGtal_1_1Z2i.html#a9b96ab8175cf9c54b1f451858ccd46a4">DGtal::Z2i::Space</a></div><div class="ttdeci">SpaceND&lt; 2, Integer &gt; Space</div><div class="ttdef"><b>Definition</b> <a href="StdDefs_8h_source.html#l00075">StdDefs.h:75</a></div></div>
</div><!-- fragment --><p>We can construct a point lying in this space as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/base/Common.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/helpers/StdDefs.h&quot;</span></div>
<div class="line">{...}</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceDGtal_1_1Z2i.html">DGtal::Z2i</a>;</div>
<div class="line"><span class="comment">//We use default types Z2i::Space and Z2i::Point</span></div>
<div class="line"><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> p(13,-5);</div>
<div class="ttc" id="anamespaceDGtal_1_1Z2i_html"><div class="ttname"><a href="namespaceDGtal_1_1Z2i.html">DGtal::Z2i</a></div><div class="ttdoc">Z2i this namespace gathers the standard of types for 2D imagery.</div></div>
<div class="ttc" id="atestClone2_8cpp_html_a4075d279133f1952978300b7e135f83d"><div class="ttname"><a href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a></div><div class="ttdeci">MyPointD Point</div><div class="ttdef"><b>Definition</b> <a href="testClone2_8cpp_source.html#l00381">testClone2.cpp:381</a></div></div>
</div><!-- fragment --><p>Beside the type <span class="tt"><a class="el" href="classDGtal_1_1SpaceND.html">Point</a></span> (defined as a specialization of the class <a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a>), <a class="el" href="classDGtal_1_1SpaceND.html">SpaceND</a> (or <a class="el" href="namespaceDGtal_1_1Z2i.html#a9b96ab8175cf9c54b1f451858ccd46a4">Z2i::Space</a>) provides several other types and methodes such as</p><ul>
<li>types associated to the canonical vector space (<a class="el" href="classDGtal_1_1SpaceND.html#a34beb5f81d0848e8ae393f39a1422ebc" title="Points in DGtal::SpaceND.">SpaceND::Point</a>, <a class="el" href="classDGtal_1_1SpaceND.html#ae194f4dfc28465ea14b437c066e69604" title="Vectors in DGtal::SpaceND.">SpaceND::Vector</a>,...)</li>
<li>types and methods for subspace and subcospace construction</li>
<li>...</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="sectPointVector"></a>
Points and Vectors</h1>
<p><span class="tt"><a class="el" href="classDGtal_1_1SpaceND.html">Point</a></span>s and <span class="tt"><a class="el" href="classDGtal_1_1SpaceND.html">Vector</a></span>s are fundamental objects in the digital space. Indeed, they allow us to access to grid point location or to represent displacements between grid points. Many methods are defined for <a class="el" href="classDGtal_1_1SpaceND.html">Point</a> and <a class="el" href="classDGtal_1_1SpaceND.html">Vector</a> instances. For example we have</p><ul>
<li>arithmetic operators (<span class="tt">*</span>, <span class="tt">-</span>, ...)</li>
<li>comparison operators (<span class="tt">&lt;</span> ,<span class="tt">&gt;</span>, ...)</li>
<li>methods associate to the canonical lattice associated to points (<span class="tt">inf</span>, <span class="tt">sup</span>, <span class="tt">isLower</span>,...)</li>
<li>methods to compute various norms of <span class="tt"><a class="el" href="classDGtal_1_1SpaceND.html">Point</a></span>s/<span class="tt"><a class="el" href="classDGtal_1_1SpaceND.html">Vector</a></span>s.</li>
<li>last but not least, the interface also provides iterators and accessors.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>For the sake of simplicity, both <a class="el" href="classDGtal_1_1SpaceND.html#a34beb5f81d0848e8ae393f39a1422ebc" title="Points in DGtal::SpaceND.">SpaceND::Point</a> and <a class="el" href="classDGtal_1_1SpaceND.html#ae194f4dfc28465ea14b437c066e69604" title="Vectors in DGtal::SpaceND.">SpaceND::Vector</a> in a space <a class="el" href="classDGtal_1_1SpaceND.html">DGtal::SpaceND</a> are aliases of the specialized type <a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">DGtal::PointVector</a>. In other words, these two types can be exchanged without any problem, even if it does not make sense in a mathematical. For instance, from a vector, we can define its opposite but the opposite does not make sense for a point.</dd></dl>
<p>An element of a <span class="tt"><a class="el" href="classDGtal_1_1SpaceND.html">Point</a></span> has type <span class="tt"><a class="el" href="structDGtal_1_1IteratorCirculatorTraits.html">Coordinate</a></span> and an element of a <span class="tt"><a class="el" href="classDGtal_1_1SpaceND.html">Vector</a></span> has type <span class="tt">Component</span>. For instance, the following code is valid in terms of type. </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> p;</div>
<div class="line"><a class="code hl_typedef" href="classDGtal_1_1PointVector.html#a6409a51203e0edc907d523fb19ed7e41">Point::Coordinate</a> coord = 24;</div>
<div class="line"><span class="keywordflow">for</span>(<a class="code hl_typedef" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> d = 0 ; d &lt; <a class="code hl_variable" href="classDGtal_1_1SpaceND.html#aae87d3efb1051dbdeac28e159781ba92">Space::dimension</a>; ++d)</div>
<div class="line">   p[d] = coord;</div>
<div class="ttc" id="aclassDGtal_1_1PointVector_html_a6409a51203e0edc907d523fb19ed7e41"><div class="ttname"><a href="classDGtal_1_1PointVector.html#a6409a51203e0edc907d523fb19ed7e41">DGtal::PointVector&lt; dim, Integer &gt;::Coordinate</a></div><div class="ttdeci">Component Coordinate</div><div class="ttdef"><b>Definition</b> <a href="PointVector_8h_source.html#l00617">PointVector.h:617</a></div></div>
<div class="ttc" id="aclassDGtal_1_1SpaceND_html_aae87d3efb1051dbdeac28e159781ba92"><div class="ttname"><a href="classDGtal_1_1SpaceND.html#aae87d3efb1051dbdeac28e159781ba92">DGtal::SpaceND::dimension</a></div><div class="ttdeci">static const Dimension dimension</div><div class="ttdoc">static constants to store the dimension.</div><div class="ttdef"><b>Definition</b> <a href="SpaceND_8h_source.html#l00132">SpaceND.h:132</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a8fbe8c8d47ca5c36ced14284ac62613d"><div class="ttname"><a href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">DGtal::Dimension</a></div><div class="ttdeci">DGtal::uint32_t Dimension</div><div class="ttdef"><b>Definition</b> <a href="Common_8h_source.html#l00119">Common.h:119</a></div></div>
</div><!-- fragment --><p> However, we encourage the use of iterators as follows </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> p;</div>
<div class="line"><a class="code hl_typedef" href="classDGtal_1_1PointVector.html#a6409a51203e0edc907d523fb19ed7e41">Point::Coordinate</a> coord = 24;</div>
<div class="line"><span class="keywordflow">for</span>(<a class="code hl_typedef" href="classDGtal_1_1PointVector.html#ae39deaab15a2ee5753553afa838ab0e9">Point::Iterator</a> it=p.begin(), itend=p.end() ; </div>
<div class="line">    it != itend;</div>
<div class="line">    ++it)</div>
<div class="line">    (*it) = coord;</div>
<div class="ttc" id="aclassDGtal_1_1PointVector_html_ae39deaab15a2ee5753553afa838ab0e9"><div class="ttname"><a href="classDGtal_1_1PointVector.html#ae39deaab15a2ee5753553afa838ab0e9">DGtal::PointVector&lt; dim, Integer &gt;::Iterator</a></div><div class="ttdeci">Container::iterator Iterator</div><div class="ttdef"><b>Definition</b> <a href="PointVector_8h_source.html#l00640">PointVector.h:640</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Similarly to the previous note and since <span class="tt"><a class="el" href="classDGtal_1_1SpaceND.html">Vector</a></span> and <span class="tt"><a class="el" href="structDGtal_1_1ArithmeticalDSLKernel.html">Space</a></span> are aliases, <a class="el" href="classDGtal_1_1PointVector.html#a6409a51203e0edc907d523fb19ed7e41">SpaceND::Point::Coordinate</a> and <a class="el" href="classDGtal_1_1PointVector.html#ab5f7548d4edc0d8edb4b64cc332db8f2">SpaceND::Vector::Component</a> are aliases of <a class="el" href="classDGtal_1_1SpaceND.html#a3217d099840050eb7135e24b1ed7940d" title="Arithmetic ring induced by (+,-,*) and Integer numbers.">SpaceND::Integer</a>. It does not lead to a strong typing of <span class="tt"><a class="el" href="classDGtal_1_1SpaceND.html">Point</a></span> and <span class="tt"><a class="el" href="classDGtal_1_1SpaceND.html">Vector</a></span> but it helps the user to design code as close as possible to a mathematical formulation.</dd></dl>
<p><a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a> class is parametrized by the following template parameters:</p><ul>
<li>the static dimension of the underlying space (of type <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">DGtal::Dimension</a>);</li>
<li>a model of <a class="el" href="structDGtal_1_1concepts_1_1CEuclideanRing.html" title="Aim: Defines the mathematical concept equivalent to a unitary commutative ring with a division operat...">concepts::CEuclideanRing</a> to be used as <a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a> components/coordinates;</li>
<li>a model of bidirectional random access iterator to store the point or vector (default container: <span class="tt">boost::array</span> with static size equals to the space dimension). In fact, we consider a weaker concept than <a class="el" href="structboost_1_1RandomAccessContainer.html" title="Go to http://www.sgi.com/tech/stl/RandomAccessContainer.html.">boost::RandomAccessContainer</a> since we only need iterators and reverse_iterators (<span class="tt">const</span> and non-<span class="tt">const</span>) to be defined, default/copy constructors and <span class="tt">operator[]</span>. Models can be <span class="tt">boost::array</span>, <span class="tt">std::vector</span> or even <span class="tt">std::array</span> (for <span class="tt">C++11</span> enabled projects).</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="sectDomain"></a>
Domains and HyperRectDomains</h1>
<h2 class="doxsection"><a class="anchor" id="sectDomDef"></a>
Definition</h2>
<p>Once we have defined the fundamental characteristics of our digital space, we can define a domain on which all the computations will done. <a class="el" href="structA.html">A</a> domain is characterized by a starting point <a class="el" href="structA.html">A</a>, an end point <a class="el" href="classB.html">B</a> and a way to scan all the point between <a class="el" href="structA.html">A</a> and <a class="el" href="classB.html">B</a>. In most situation, one may want the domain to be a finite isothetic subset of the digital space. Hence, an important model of the concept of domain (specified in the <a class="el" href="structDGtal_1_1concepts_1_1CDomain.html" title="Aim: This concept represents a digital domain, i.e. a non mutable subset of points of the given digit...">concepts::CDomain</a> class) is the class <a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a>. Since the domain lies on a digital space, the <a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a> class has a template argument which correspond to the type of space we consider.</p>
<p>For example, let us consider the following code snippet </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;DGtal/base/Common.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;DGtal/kernel/SpaceND.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;DGtal/helpers/StdDefs.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;DGtal/kernel/domains/HyperRectDomain.h&gt;</span></div>
<div class="line">{...}</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceDGtal_1_1Z2i.html">DGtal::Z2i</a>;</div>
</div><!-- fragment --><p>An instance of <a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a> can be created as follows: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1HyperRectDomain.html">HyperRectDomain&lt;Space&gt;</a> MyDomain;</div>
<div class="line"><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> a(-3,-4);</div>
<div class="line"><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> b(10,4);</div>
<div class="line">MyDomain <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>(a,b);</div>
<div class="ttc" id="aclassDGtal_1_1HyperRectDomain_html"><div class="ttname"><a href="classDGtal_1_1HyperRectDomain.html">DGtal::HyperRectDomain</a></div><div class="ttdoc">Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.</div><div class="ttdef"><b>Definition</b> <a href="HyperRectDomain_8h_source.html#l00099">HyperRectDomain.h:100</a></div></div>
<div class="ttc" id="atestProjection_8cpp_html_a1f1a69f8d8b037b72c2160ed12b3ef51"><div class="ttname"><a href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a></div><div class="ttdeci">Domain domain</div><div class="ttdef"><b>Definition</b> <a href="testProjection_8cpp_source.html#l00088">testProjection.cpp:88</a></div></div>
</div><!-- fragment --><p>The instance is thus an isothetic domain lying on the space <span class="tt"><a class="el" href="classDGtal_1_1SpaceND.html">SpaceND</a>&lt;2,<a class="el" href="namespaceDGtal.html#a6e465b385abeb74e42c21582511631d0" title="unsigned 32-bit integer.">DGtal::uint32_t</a>&gt;</span> defined by the bounding box of the points a and b. Note that type <a class="el" href="namespaceDGtal_1_1Z2i.html#aca523bebdae58eb19385aaefffff8bc5">Z2i::Domain</a> in <a class="el" href="StdDefs_8h_source.html">StdDefs.h</a> exactly corresponds to <a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a> on the <a class="el" href="namespaceDGtal_1_1Z2i.html#a9b96ab8175cf9c54b1f451858ccd46a4">Z2i::Space</a>. We can visualise the domain using the <a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (with &lt;&lt;)....">Board2D</a> stream mechanism (see <a class="el" href="moduleBoard2D.html">Board2D: a stream mechanism for displaying 2D digital objects</a>).</p>
<div class="image">
<img src="kernel-domain.png" alt=""/>
<div class="caption">
Illustration of a simple 2-D domain</div></div>
 <p>The <a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a> class provides several methods such as <a class="el" href="classDGtal_1_1HyperRectDomain.html#a3bea82f197b8b6ff235206724b5c8c2e">HyperRectDomain::isInside</a> to decide if a point is inside the domain or not.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="testClone2_8cpp.html#a4075d279133f1952978300b7e135f83d">Point</a> c(5,1);</div>
<div class="line"><span class="keywordflow">if</span> ( <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.isInside( c ) )</div>
<div class="line">   <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.info() &lt;&lt; <span class="stringliteral">&quot;C is inside the domain&quot;</span>&lt;&lt;endl;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">   <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.info() &lt;&lt; <span class="stringliteral">&quot;C is outside the domain&quot;</span>&lt;&lt;endl;</div>
<div class="ttc" id="anamespaceDGtal_html_a8fc7012708b0416880a5c8b12dfdf9dd"><div class="ttname"><a href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">DGtal::trace</a></div><div class="ttdeci">Trace trace</div></div>
</div><!-- fragment --><div class="image">
<img src="kernel-domain-point.png" alt=""/>
<div class="caption">
Illustration of a simple 2-D domain with a point</div></div>
 <h2 class="doxsection"><a class="anchor" id="sectDomIter"></a>
Iterating over an HyperRectDomain</h2>
<p>An important feature of <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> domain is based on iterators it defines to scan the grid points in various orders. For example, to scan the whole domain we can use</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>( MyDomain::ConstIterator it = <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.begin(), itend = <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.end();</div>
<div class="line">     it != itend;   </div>
<div class="line">     ++it)</div>
<div class="line">  <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.info() &lt;&lt; <span class="stringliteral">&quot;Processing point&quot;</span>&lt;&lt; (*it) &lt;&lt; endl;</div>
</div><!-- fragment --><p>By default, <a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a> iterators use the lexicographic order on the dimensions. To visualise this order in dimension 2, we can use the following code snippet in which we display each point by a color map from blue to red according to the order (blue point corresponds to the first point and the red one to the last point). Note that in this example, we use a specific drawing primitive (<span class="tt">draw</span>) in order to draw a <a class="el" href="classDGtal_1_1SpaceND.html#ae194f4dfc28465ea14b437c066e69604" title="Vectors in DGtal::SpaceND.">SpaceND::Vector</a> as an arrow..</p>
<p>Again, for details on the <a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (with &lt;&lt;)....">Board2D</a> mechanism, please refer to <a class="el" href="moduleBoard2D.html">Board2D: a stream mechanism for displaying 2D digital objects</a>.</p>
<div class="fragment"><div class="line"><span class="comment">//We draw an arrow between two consecutive points during the iteration.</span></div>
<div class="line">MyDomain::ConstIterator itPrec = <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.begin();</div>
<div class="line">MyDomain::ConstIterator it = itPrec;</div>
<div class="line">MyDomain::Vector shift;</div>
<div class="line">++it;</div>
<div class="line"> </div>
<div class="line">board &lt;&lt; (*itPrec); <span class="comment">//We display the first point as a pixel.</span></div>
<div class="line"><span class="keywordflow">for</span>( MyDomain::ConstIterator itend = <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.end();</div>
<div class="line">     it != itend;   </div>
<div class="line">     ++it, ++itPrec)</div>
<div class="line">  {</div>
<div class="line">    shift =   (*it) -(*itPrec);</div>
<div class="line">    <a class="code hl_function" href="testSegmentation_8cpp.html#ad3481e408a11633aeaa7732e7faf6b56">draw</a>(board, shift, (*itPrec));</div>
<div class="line">  }</div>
<div class="line">board.saveSVG(<span class="stringliteral">&quot;kernel-domain-it-arrow.svg&quot;</span>);</div>
<div class="ttc" id="atestSegmentation_8cpp_html_ad3481e408a11633aeaa7732e7faf6b56"><div class="ttname"><a href="testSegmentation_8cpp.html#ad3481e408a11633aeaa7732e7faf6b56">draw</a></div><div class="ttdeci">void draw(const Iterator &amp;itb, const Iterator &amp;ite, Board &amp;aBoard)</div><div class="ttdef"><b>Definition</b> <a href="testSegmentation_8cpp_source.html#l00075">testSegmentation.cpp:75</a></div></div>
</div><!-- fragment --><div class="image">
<img src="kernel-domain-it-arrow.png" alt=""/>
<div class="caption">
Iteration over a domain with displacements depicted as arrows.</div></div>
 <p>For each iterator ̀ XXX<span class="tt">, there is a corresponding </span>ReverseXXX` class allowing to run through the same elements but in reverse direction. For the whole domain, we wan use</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>( MyDomain::ReverseConstIterator it = <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.rbegin(), itend = <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.rend();</div>
<div class="line">     it != itend;   </div>
<div class="line">     ++it)</div>
<div class="line">  <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.info() &lt;&lt; <span class="stringliteral">&quot;Processing point&quot;</span>&lt;&lt; (*it) &lt;&lt; endl;</div>
</div><!-- fragment --><p>Note that the <a class="el" href="classDGtal_1_1HyperRectDomain.html#a4477d569db1e699feb289e8a1ab78605">HyperRectDomain::begin</a> and <a class="el" href="classDGtal_1_1HyperRectDomain.html#a6369feb21714dd5671507979a5c144a8">HyperRectDomain::rbegin</a> methods can take an optional <span class="tt"><a class="el" href="classDGtal_1_1SpaceND.html">Point</a></span> as parameter which is used as starting point for the iterator. In this case, the point must belongs to the domain.</p>
<p>There are some classes and methods to run through a given subdomain, and allowing to change the order in which dimension are considered. To facilitate their use, these subdomains use the range concept. <a class="el" href="structA.html">A</a> range provides iterators for accessing a half-open range <span class="tt">[first,one_past_last)</span> of elements. There iterators are accessible by <span class="tt">begin()</span> and <span class="tt">end()</span> methods of each range class. Moreover, a range can be iterated in reverse direction thanks to iterators returned by <span class="tt">rbegin()</span> and <span class="tt">rend()</span> methods. As for the <span class="tt">begin</span> and <span class="tt">rbegin</span> methods on the whole domain, the <span class="tt">begin</span> and <span class="tt">rbegin</span> range methods can have an optional point as parameter which is used as starting point for the iterator. In this case, the point must belongs to the given range.</p>
<p>To use these ranges, we need first to get a subrange thanks to one <a class="el" href="classDGtal_1_1HyperRectDomain.html#a8e72aa9573bf0481a4681d23f1bb3c41">HyperRectDomain::subRange</a> method. As illustrate below, the basic method take a <span class="tt">std::vector&lt;<a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a>&gt;</span> as first parameter, describing the dimensions of the subdomain, and a <span class="tt"><a class="el" href="classDGtal_1_1SpaceND.html">Point</a></span> as second parameter which give the position of the subdomain for the dimensions not in the vector. Other dimensions are not used. In the example below, <span class="tt"><a class="el" href="classDGtal_1_1SpaceND.html">Point</a> c(3,1,1)</span> is only used for its first dimension. Thus we would have obtained the same <span class="tt">subRange</span> by using for example <span class="tt"><a class="el" href="classDGtal_1_1SpaceND.html">Point</a> d(3,2,4)</span>.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1SpaceND.html">SpaceND&lt;3&gt;</a> TSpace;  </div>
<div class="line">TSpace::Point a(1, 1, 1);</div>
<div class="line">TSpace::Point b(5, 5, 5);</div>
<div class="line"><a class="code hl_class" href="classDGtal_1_1HyperRectDomain.html">HyperRectDomain&lt;TSpace&gt;</a> <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>(a,b);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;TSpace::Dimension&gt; v(2); v[0]=2; v[1]=1;</div>
<div class="line">TSpace::Point c(3,1,1);</div>
<div class="line"><span class="keywordflow">for</span>( <a class="code hl_class" href="classDGtal_1_1HyperRectDomain.html">HyperRectDomain&lt;TSpace&gt;::ConstSubRange::ReverseConstIterator</a> </div>
<div class="line">       it = <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.subRange(v, c).rbegin(), itend =  <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.subRange(v, c).rend();</div>
<div class="line">     it != itend; </div>
<div class="line">     ++it)</div>
<div class="line">  <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.info() &lt;&lt; <span class="stringliteral">&quot;Processing point&quot;</span>&lt;&lt; (*it) &lt;&lt; endl;</div>
</div><!-- fragment --><p>This example run through all the points in the plane <span class="tt">X=3</span> (if we suppose that dimension 0 is <span class="tt">X</span>, dimension 1 is <span class="tt">Y</span> and dimension 2 is <span class="tt">Z</span>) in reverse direction. Note that you can chose to instantiate <span class="tt">domain.subRange(v, c)</span> only once before the loop, but the gain is negligible regarding the given example where the subrange is instantiated twice. However, the gain can be important comparing with the bad version where the range is instantiated at each step of the loop to compare it with <span class="tt">domain.subRange(v, c).rend()</span>.</p>
<p>Note also that the vector gives not only the dimensions of the subrange but also the order in which these dimensions are considered. In the example above, we start to iterate through <span class="tt">Z</span>, then to <span class="tt">Y</span> since vector <span class="tt">v={2,1}</span>. For this reason, the subrange class can also be used to run through a whole given domain but considering the dimensions in a different order.</p>
<p>There are some shortcuts for the <a class="el" href="classDGtal_1_1HyperRectDomain.html#a8e72aa9573bf0481a4681d23f1bb3c41">HyperRectDomain::subRange</a> method to facilitate the iteration through subrange having 1, 2, and 3 dimensions: <span class="tt">subRange(<a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> adim, const <a class="el" href="classDGtal_1_1SpaceND.html">Point</a> &amp; startingPoint)</span>; <span class="tt">subRange(<a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> adim1, <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> adim2, const <a class="el" href="classDGtal_1_1SpaceND.html">Point</a> &amp; startingPoint)</span>; and <span class="tt">subRange(<a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> adim1, <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> adim2, <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> adim3, const <a class="el" href="classDGtal_1_1SpaceND.html">Point</a> &amp; startingPoint)</span>.</p>
<p>Lastly, if your compiler supports <span class="tt">C++11</span> initializer list, there is a custom <span class="tt">subRange</span> method taking an <span class="tt">std::initializer_list&lt;<a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a>&gt;</span> instead of the <span class="tt">std::vector&lt;<a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a>&gt;</span>. This simplifies the use as we can see in the following example since this avoid the creation of a <span class="tt">std::vector</span> and its initialization:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1SpaceND.html">SpaceND&lt;3&gt;</a> TSpace;  </div>
<div class="line">TSpace::Point a(1, 1, 1);</div>
<div class="line">TSpace::Point b(5, 5, 5);</div>
<div class="line"><a class="code hl_class" href="classDGtal_1_1HyperRectDomain.html">HyperRectDomain&lt;TSpace&gt;</a> <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>(a,b);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>( <a class="code hl_class" href="classDGtal_1_1HyperRectDomain.html">HyperRectDomain&lt;TSpace&gt;::ConstSubRange::ReverseConstIterator</a> </div>
<div class="line">       it = <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.subRange({2,1}, c).rbegin(), itend =  <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.subRange({2,1}, c).rend();</div>
<div class="line">     it != itend; </div>
<div class="line">     ++it)</div>
<div class="line">  <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.info() &lt;&lt; <span class="stringliteral">&quot;Processing point&quot;</span>&lt;&lt; (*it) &lt;&lt; endl;</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="sectDomParScan"></a>
Scanning an HyperRectDomain in parallel</h2>
<p>Iterators of <a class="el" href="classDGtal_1_1HyperRectDomain.html">HyperRectDomain</a> are random-access iterators thus allowing to easily split the scan of a domain in multiple parts, e.g. for parallelization purpose.</p>
<p>You first need to define how to split a range (begin and end iterators) given a total number of launched threads and the id of the current thread: </p><div class="fragment"><div class="line"><span class="comment">// Splits range in given parts count and returns the part of given idx</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIterator&gt;</div>
<div class="line"><a class="code hl_class" href="classDGtal_1_1SimpleConstRange.html">SimpleConstRange&lt;TIterator&gt;</a></div>
<div class="line"><a class="code hl_function" href="exampleHyperRectDomainParallelScan_8cpp.html#a4608b8380847c88e7751fc609096abb1">split_range</a>(TIterator it_begin, TIterator it_end, std::size_t idx, std::size_t count)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> range_size  = std::distance(it_begin, it_end);</div>
<div class="line">  <span class="keyword">auto</span> begin_shift = (range_size*idx) / count;</div>
<div class="line">  <span class="keyword">auto</span> end_shift   = (range_size*(idx+1)) / count;</div>
<div class="line">  <span class="keywordflow">return</span> { it_begin + begin_shift, it_begin + end_shift };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Splits range in given parts count and returns the part of given idx</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIterable&gt;</div>
<div class="line"><span class="keyword">auto</span></div>
<div class="line"><a class="code hl_function" href="exampleHyperRectDomainParallelScan_8cpp.html#a4608b8380847c88e7751fc609096abb1">split_range</a>(TIterable &amp; iterable, std::size_t idx, std::size_t count)</div>
<div class="line">    -&gt; <span class="keyword">decltype</span>(<a class="code hl_function" href="exampleHyperRectDomainParallelScan_8cpp.html#a4608b8380847c88e7751fc609096abb1">split_range</a>(iterable.begin(), iterable.end(), idx, count))</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="exampleHyperRectDomainParallelScan_8cpp.html#a4608b8380847c88e7751fc609096abb1">split_range</a>(iterable.begin(), iterable.end(), idx, count);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now, if you want for example to sum the result of a function applied on each point of a domain, you can first initiate a bunch of threads using an OpenMP parallel region and then iterate over the appropriate part of the point range depending on the current thread id: </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> sum = 0 * fn(<a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.lowerBound()); <span class="comment">// To initialize the sum depending on the function return type</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">  #pragma omp parallel reduction(+:sum)</span></div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// OpenMP context</span></div>
<div class="line">      std::size_t thread_idx = omp_get_thread_num();</div>
<div class="line">      std::size_t thread_cnt = omp_get_num_threads();</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; pt : <a class="code hl_function" href="exampleHyperRectDomainParallelScan_8cpp.html#a4608b8380847c88e7751fc609096abb1">split_range</a>(<a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>, thread_idx, thread_cnt))</div>
<div class="line">        sum += fn(pt);</div>
<div class="line">    }</div>
</div><!-- fragment --><p>Going further, if you want to use such strategy to initialize or modify an image, you can do: </p><div class="fragment"><div class="line"><span class="preprocessor">  #pragma omp parallel</span></div>
<div class="line">    {</div>
<div class="line">      std::size_t thread_idx = omp_get_thread_num();</div>
<div class="line">      std::size_t thread_cnt = omp_get_num_threads();</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; pt : <a class="code hl_function" href="exampleHyperRectDomainParallelScan_8cpp.html#a4608b8380847c88e7751fc609096abb1">split_range</a>(<a class="code hl_function" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a614d1b1c043b31763c1eb50f64666737">image</a>.domain(), thread_idx, thread_cnt))</div>
<div class="line">        <a class="code hl_function" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a614d1b1c043b31763c1eb50f64666737">image</a>.setValue(pt, fn(pt, <a class="code hl_function" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a614d1b1c043b31763c1eb50f64666737">image</a>(pt)));</div>
<div class="line">    }</div>
</div><!-- fragment --><p>Additionally, if your image also provides random-access iterators (like <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>), you can save the getter/setter overhead by using iterators (if the function is not too much CPU intensive): </p><div class="fragment"><div class="line"><span class="preprocessor">  #pragma omp parallel</span></div>
<div class="line">    {</div>
<div class="line">      std::size_t thread_idx = omp_get_thread_num();</div>
<div class="line">      std::size_t thread_cnt = omp_get_num_threads();</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">auto</span> domain_it = <a class="code hl_function" href="exampleHyperRectDomainParallelScan_8cpp.html#a4608b8380847c88e7751fc609096abb1">split_range</a>(<a class="code hl_function" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a614d1b1c043b31763c1eb50f64666737">image</a>.domain(), thread_idx, thread_cnt).begin();</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; v : <a class="code hl_function" href="exampleHyperRectDomainParallelScan_8cpp.html#a4608b8380847c88e7751fc609096abb1">split_range</a>(<a class="code hl_function" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a614d1b1c043b31763c1eb50f64666737">image</a>, thread_idx, thread_cnt))</div>
<div class="line">        {</div>
<div class="line">          v = fn(*domain_it, v);</div>
<div class="line">          ++domain_it;</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --><p>You can find the complete example and a benchmark in <a class="el" href="exampleHyperRectDomainParallelScan_8cpp.html">exampleHyperRectDomainParallelScan.cpp</a></p>
<h2 class="doxsection"><a class="anchor" id="sectDomEmpty"></a>
Empty domains</h2>
<p>Since version 0.9 of <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>, <a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a> can model an empty domain and it is what the default constructor returns now.</p>
<p>An empty domain is so that the difference between his lower bound and his upper bound has every component equal to 1. For example, here is some equivalent definitions of an empty domain: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1SpaceND.html">SpaceND&lt;3&gt;</a> TSpace;</div>
<div class="line"><span class="keyword">typedef</span> TSpace::Point TPoint;</div>
<div class="line">TPoint a = TPoint::diagonal(5);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classDGtal_1_1HyperRectDomain.html">HyperRectDomain&lt;TSpace&gt;</a> empty_domain1;</div>
<div class="line"><a class="code hl_class" href="classDGtal_1_1HyperRectDomain.html">HyperRectDomain&lt;TSpace&gt;</a> empty_domain2( TPoint(1, 1, 1), TPoint(0, 0, 0) );</div>
<div class="line"><a class="code hl_class" href="classDGtal_1_1HyperRectDomain.html">HyperRectDomain&lt;TSpace&gt;</a> empty_domain3( a, a - TPoint::diagonal(1) );</div>
</div><!-- fragment --><p>Furthermore, a new method, <a class="el" href="classDGtal_1_1HyperRectDomain.html#ace00b156c587e2b92b63bae045d30222">HyperRectDomain::isEmpty</a>, returns <span class="tt">true</span> if the domain is empty, <span class="tt">false</span> otherwise.</p>
<p>As expected, the following properties are observed if <span class="tt">domain</span> is an empty domain:</p><ul>
<li><span class="tt">domain.size()</span> returns 0,</li>
<li><span class="tt">domain.isInside(p)</span> returns <span class="tt">false</span> for every point <span class="tt">p</span>,</li>
<li><span class="tt">domain.begin() == domain.end()</span> is <span class="tt">true</span>, and similarly for the reverse iterators,</li>
<li><span class="tt">domain.subRange(v, domain.lowerBound()).begin() == domain.subRange(v, domain.lowerBound()).end()</span> is <span class="tt">true</span> for every subset <span class="tt">v</span> of dimensions, and similarly for the reverse iterators. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="index.html">DGtal - Digital Geometry Tools and Algorithms Library.</a></li><li class="navelem"><a href="packageKernel.html">Kernel package</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for DGtal by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
