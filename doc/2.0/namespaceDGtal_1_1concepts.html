<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: DGtal::concepts Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespaceDGtal_1_1concepts.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">DGtal::concepts Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Aim: Gathers several functions useful for concept checks.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:ConceptUtils" id="r_ConceptUtils"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1concepts_1_1ConceptUtils.html">ConceptUtils</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:C3DParametricCurve" id="r_C3DParametricCurve"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1C3DParametricCurve.html">C3DParametricCurve</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="structDGtal_1_1concepts_1_1C3DParametricCurve.html#details">More...</a><br /></td></tr>
<tr class="memitem:C3DParametricCurveDecorator" id="r_C3DParametricCurveDecorator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1C3DParametricCurveDecorator.html">C3DParametricCurveDecorator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="structDGtal_1_1concepts_1_1C3DParametricCurveDecorator.html#details">More...</a><br /></td></tr>
<tr class="memitem:CAdditivePrimitiveComputer" id="r_CAdditivePrimitiveComputer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CAdditivePrimitiveComputer.html">CAdditivePrimitiveComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing an object that computes some primitive from input points given group by group, while keeping some internal state. At any moment, the object is supposed to store at least one valid primitive for the formerly given input points. <a class="el" href="structA.html">A</a> primitive is an informal word that describes some family of objects that share common characteristics. Often, the primitives are geometric, e.g. digital planes.  <a href="structDGtal_1_1concepts_1_1CAdditivePrimitiveComputer.html#details">More...</a><br /></td></tr>
<tr class="memitem:CAdjacency" id="r_CAdjacency"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CAdjacency.html">CAdjacency</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The concept <a class="el" href="structDGtal_1_1concepts_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">CAdjacency</a> defines an elementary adjacency relation between points of a digital space.  <a href="structDGtal_1_1concepts_1_1CAdjacency.html#details">More...</a><br /></td></tr>
<tr class="memitem:CBackInsertable" id="r_CBackInsertable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CBackInsertable.html">CBackInsertable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents types for which a std::back_insert_iterator can be constructed with std::back_inserter. Back Insertion Sequence are refinements of <a class="el" href="structDGtal_1_1concepts_1_1CBackInsertable.html" title="Aim: Represents types for which a std::back_insert_iterator can be constructed with std::back_inserte...">CBackInsertable</a>. They require more services than <a class="el" href="structDGtal_1_1concepts_1_1CBackInsertable.html" title="Aim: Represents types for which a std::back_insert_iterator can be constructed with std::back_inserte...">CBackInsertable</a>, for instance read services or erase services.  <a href="structDGtal_1_1concepts_1_1CBackInsertable.html#details">More...</a><br /></td></tr>
<tr class="memitem:CBidirectionalRange" id="r_CBidirectionalRange"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CBidirectionalRange.html">CBidirectionalRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a bidirectional range.  <a href="structDGtal_1_1concepts_1_1CBidirectionalRange.html#details">More...</a><br /></td></tr>
<tr class="memitem:CBidirectionalRangeFromPoint" id="r_CBidirectionalRangeFromPoint"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CBidirectionalRangeFromPoint.html">CBidirectionalRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of single pass range with a begin() method from a point.  <a href="structDGtal_1_1concepts_1_1CBidirectionalRangeFromPoint.html#details">More...</a><br /></td></tr>
<tr class="memitem:CBidirectionalRangeWithWritableIterator" id="r_CBidirectionalRangeWithWritableIterator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CBidirectionalRangeWithWritableIterator.html">CBidirectionalRangeWithWritableIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of bidirectional range which require that a reverse output iterator exists.  <a href="structDGtal_1_1concepts_1_1CBidirectionalRangeWithWritableIterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:CBidirectionalRangeWithWritableIteratorFromPoint" id="r_CBidirectionalRangeWithWritableIteratorFromPoint"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CBidirectionalRangeWithWritableIteratorFromPoint.html">CBidirectionalRangeWithWritableIteratorFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of single pass range with an routputIterator() method from a point.  <a href="structDGtal_1_1concepts_1_1CBidirectionalRangeWithWritableIteratorFromPoint.html#details">More...</a><br /></td></tr>
<tr class="memitem:CBidirectionalSegmentComputer" id="r_CBidirectionalSegmentComputer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CBidirectionalSegmentComputer.html">CBidirectionalSegmentComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a bidirectional segment computer, <br  />
 ie. a model of <a class="el" href="structDGtal_1_1concepts_1_1CSegment.html" title="Aim: Defines the concept describing a segment, ie. a valid and not empty range.">concepts::CSegment</a> that can extend itself in the two possible directions.  <a href="structDGtal_1_1concepts_1_1CBidirectionalSegmentComputer.html#details">More...</a><br /></td></tr>
<tr class="memitem:CBinner" id="r_CBinner"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CBinner.html">CBinner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents an object that places a quantity into a bin, i.e. a functor that associates a natural integer to a continuous value.  <a href="structDGtal_1_1concepts_1_1CBinner.html#details">More...</a><br /></td></tr>
<tr class="memitem:CBoundedNumber" id="r_CBoundedNumber"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CBoundedNumber.html">CBoundedNumber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The concept <a class="el" href="structDGtal_1_1concepts_1_1CBoundedNumber.html" title="Aim: The concept CBoundedNumber specifies what are the bounded numbers. Models of this concept should...">CBoundedNumber</a> specifies what are the bounded numbers. Models of this concept should be listed in <a class="el" href="structDGtal_1_1NumberTraits.html" title="Aim: The traits class for all models of Cinteger.">NumberTraits</a> class and should have the isBounded property.  <a href="structDGtal_1_1concepts_1_1CBoundedNumber.html#details">More...</a><br /></td></tr>
<tr class="memitem:CCellEmbedder" id="r_CCellEmbedder"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CCellEmbedder.html">CCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: <a class="el" href="structA.html">A</a> cell embedder is a mapping from unsigned cells to Euclidean points. It adds inner types to functor.  <a href="structDGtal_1_1concepts_1_1CCellEmbedder.html#details">More...</a><br /></td></tr>
<tr class="memitem:CCellFunctor" id="r_CCellFunctor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CCellFunctor.html">CCellFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a functor on cells.  <a href="structDGtal_1_1concepts_1_1CCellFunctor.html#details">More...</a><br /></td></tr>
<tr class="memitem:CCellularGridSpaceND" id="r_CCellularGridSpaceND"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CCellularGridSpaceND.html">CCellularGridSpaceND</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian product, cells have a cubic shape that depends on the dimension: 0-cells are points, 1-cells are unit segments, 2-cells are squares, 3-cells are cubes, and so on.  <a href="structDGtal_1_1concepts_1_1CCellularGridSpaceND.html#details">More...</a><br /></td></tr>
<tr class="memitem:CColorMap" id="r_CColorMap"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CColorMap.html">CColorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a color map. <a class="el" href="structA.html">A</a> color map converts a value within a given range into an RGB triple.  <a href="structDGtal_1_1concepts_1_1CColorMap.html#details">More...</a><br /></td></tr>
<tr class="memitem:CCommutativeRing" id="r_CCommutativeRing"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CCommutativeRing.html">CCommutativeRing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the mathematical concept equivalent to a unitary commutative ring.  <a href="structDGtal_1_1concepts_1_1CCommutativeRing.html#details">More...</a><br /></td></tr>
<tr class="memitem:CConstBidirectionalRange" id="r_CConstBidirectionalRange"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CConstBidirectionalRange.html">CConstBidirectionalRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a bidirectional const range.  <a href="structDGtal_1_1concepts_1_1CConstBidirectionalRange.html#details">More...</a><br /></td></tr>
<tr class="memitem:CConstBidirectionalRangeFromPoint" id="r_CConstBidirectionalRangeFromPoint"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CConstBidirectionalRangeFromPoint.html">CConstBidirectionalRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of const bidirectional range with a begin() method from a point.  <a href="structDGtal_1_1concepts_1_1CConstBidirectionalRangeFromPoint.html#details">More...</a><br /></td></tr>
<tr class="memitem:CConstImage" id="r_CConstImage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CConstImage.html">CConstImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a read-only image, which is a refinement of <a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html" title="Aim: Defines a functor on points.">CPointFunctor</a>.  <a href="structDGtal_1_1concepts_1_1CConstImage.html#details">More...</a><br /></td></tr>
<tr class="memitem:CConstSinglePassRange" id="r_CConstSinglePassRange"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CConstSinglePassRange.html">CConstSinglePassRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a const single pass range.  <a href="structDGtal_1_1concepts_1_1CConstSinglePassRange.html#details">More...</a><br /></td></tr>
<tr class="memitem:CConstSinglePassRangeFromPoint" id="r_CConstSinglePassRangeFromPoint"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CConstSinglePassRangeFromPoint.html">CConstSinglePassRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of const single pass range with a begin() method from a point.  <a href="structDGtal_1_1concepts_1_1CConstSinglePassRangeFromPoint.html#details">More...</a><br /></td></tr>
<tr class="memitem:CCurveLocalGeometricEstimator" id="r_CCurveLocalGeometricEstimator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CCurveLocalGeometricEstimator.html">CCurveLocalGeometricEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept describes an object that can process a range so as to return one estimated quantity for each element of the range (or a given subrange).  <a href="structDGtal_1_1concepts_1_1CCurveLocalGeometricEstimator.html#details">More...</a><br /></td></tr>
<tr class="memitem:CDenseMatrix" id="r_CDenseMatrix"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDenseMatrix.html">CDenseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent any dynamic or static sized matrix having dense representation.  <a href="structDGtal_1_1concepts_1_1CDenseMatrix.html#details">More...</a><br /></td></tr>
<tr class="memitem:CDenseVector" id="r_CDenseVector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDenseVector.html">CDenseVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent any dynamic or static sized matrix having dense representation.  <a href="structDGtal_1_1concepts_1_1CDenseVector.html#details">More...</a><br /></td></tr>
<tr class="memitem:CDigitalBoundedShape" id="r_CDigitalBoundedShape"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDigitalBoundedShape.html">CDigitalBoundedShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: designs the concept of bounded shapes in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> (shape for which upper and lower bounding bounds are available).  <a href="structDGtal_1_1concepts_1_1CDigitalBoundedShape.html#details">More...</a><br /></td></tr>
<tr class="memitem:CDigitalMetricSpace" id="r_CDigitalMetricSpace"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDigitalMetricSpace.html">CDigitalMetricSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: defines the concept of digital metric spaces.  <a href="structDGtal_1_1concepts_1_1CDigitalMetricSpace.html#details">More...</a><br /></td></tr>
<tr class="memitem:CDigitalOrientedShape" id="r_CDigitalOrientedShape"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDigitalOrientedShape.html">CDigitalOrientedShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: characterizes models of digital oriented shapes. For example, models should provide an orientation method for points on a <a class="el" href="classDGtal_1_1SpaceND.html">SpaceND</a>. Returned value type corresponds to <a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41">DGtal::Orientation</a>.  <a href="structDGtal_1_1concepts_1_1CDigitalOrientedShape.html#details">More...</a><br /></td></tr>
<tr class="memitem:CDigitalSet" id="r_CDigitalSet"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDigitalSet.html">CDigitalSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a set of points within the given domain. This set of points is modifiable by the user. It is thus very close to the STL concept of simple associative container (like set std::set&lt;Point&gt;), except that there is a notion of maximal set of points (the whole domain).  <a href="structDGtal_1_1concepts_1_1CDigitalSet.html#details">More...</a><br /></td></tr>
<tr class="memitem:CDigitalSetArchetype" id="r_CDigitalSetArchetype"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1concepts_1_1CDigitalSetArchetype.html">CDigitalSetArchetype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The archetype of a container class for storing sets of digital points within some given domain.  <a href="classDGtal_1_1concepts_1_1CDigitalSetArchetype.html#details">More...</a><br /></td></tr>
<tr class="memitem:CDigitalSurfaceContainer" id="r_CDigitalSurfaceContainer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDigitalSurfaceContainer.html">CDigitalSurfaceContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The digital surface container concept describes a minimal set of inner types and methods so as to describe the data of digital surfaces.  <a href="structDGtal_1_1concepts_1_1CDigitalSurfaceContainer.html#details">More...</a><br /></td></tr>
<tr class="memitem:CDigitalSurfaceEmbedder" id="r_CDigitalSurfaceEmbedder"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDigitalSurfaceEmbedder.html">CDigitalSurfaceEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: <a class="el" href="structA.html">A</a> digital surface embedder is a specialized mapping from signed cells to Euclidean points. It adds inner types to functor as well as a method to access the digital surface.  <a href="structDGtal_1_1concepts_1_1CDigitalSurfaceEmbedder.html#details">More...</a><br /></td></tr>
<tr class="memitem:CDigitalSurfaceLocalEstimator" id="r_CDigitalSurfaceLocalEstimator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDigitalSurfaceLocalEstimator.html">CDigitalSurfaceLocalEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept describes an object that can process a range over some generic digital surface so as to return one estimated quantity for each element of the range (or a given subrange).  <a href="structDGtal_1_1concepts_1_1CDigitalSurfaceLocalEstimator.html#details">More...</a><br /></td></tr>
<tr class="memitem:CDigitalSurfaceTracker" id="r_CDigitalSurfaceTracker"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDigitalSurfaceTracker.html">CDigitalSurfaceTracker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="structDGtal_1_1concepts_1_1CDigitalSurfaceTracker.html#details">More...</a><br /></td></tr>
<tr class="memitem:CDiscreteExteriorCalculusVectorSpace" id="r_CDiscreteExteriorCalculusVectorSpace"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDiscreteExteriorCalculusVectorSpace.html">CDiscreteExteriorCalculusVectorSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Lift linear algebra container concept into the dec package.  <a href="structDGtal_1_1concepts_1_1CDiscreteExteriorCalculusVectorSpace.html#details">More...</a><br /></td></tr>
<tr class="memitem:CDomain" id="r_CDomain"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDomain.html">CDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept represents a digital domain, i.e. a non mutable subset of points of the given digital space.  <a href="structDGtal_1_1concepts_1_1CDomain.html#details">More...</a><br /></td></tr>
<tr class="memitem:CDomainAdjacency" id="r_CDomainAdjacency"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDomainAdjacency.html">CDomainAdjacency</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Refines the concept <a class="el" href="structDGtal_1_1concepts_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">CAdjacency</a> by telling that the adjacency is specific to a given domain of the embedding digital space.  <a href="structDGtal_1_1concepts_1_1CDomainAdjacency.html#details">More...</a><br /></td></tr>
<tr class="memitem:CDomainArchetype" id="r_CDomainArchetype"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1concepts_1_1CDomainArchetype.html">CDomainArchetype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The archetype of a class that represents a digital domain, i.e. a non mutable subset of points of the given digital space.  <a href="classDGtal_1_1concepts_1_1CDomainArchetype.html#details">More...</a><br /></td></tr>
<tr class="memitem:CDrawableWithBoard2D" id="r_CDrawableWithBoard2D"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDrawableWithBoard2D.html">CDrawableWithBoard2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The concept <a class="el" href="structDGtal_1_1concepts_1_1CDrawableWithBoard2D.html" title="Aim: The concept CDrawableWithBoard2D specifies what are the classes that admit an export with Board2...">CDrawableWithBoard2D</a> specifies what are the classes that admit an export with <a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (with &lt;&lt;)....">Board2D</a>.  <a href="structDGtal_1_1concepts_1_1CDrawableWithBoard2D.html#details">More...</a><br /></td></tr>
<tr class="memitem:CDrawableWithDisplay3D" id="r_CDrawableWithDisplay3D"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDrawableWithDisplay3D.html">CDrawableWithDisplay3D</a></td></tr>
<tr class="memitem:CDynamicBidirectionalSegmentComputer" id="r_CDynamicBidirectionalSegmentComputer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDynamicBidirectionalSegmentComputer.html">CDynamicBidirectionalSegmentComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie. a model of <a class="el" href="structDGtal_1_1concepts_1_1CSegment.html" title="Aim: Defines the concept describing a segment, ie. a valid and not empty range.">concepts::CSegment</a> that can extend and retract itself in either direction.  <a href="structDGtal_1_1concepts_1_1CDynamicBidirectionalSegmentComputer.html#details">More...</a><br /></td></tr>
<tr class="memitem:CDynamicMatrix" id="r_CDynamicMatrix"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDynamicMatrix.html">CDynamicMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent any dynamic sized matrix having sparse or dense representation.  <a href="structDGtal_1_1concepts_1_1CDynamicMatrix.html#details">More...</a><br /></td></tr>
<tr class="memitem:CDynamicSegmentComputer" id="r_CDynamicSegmentComputer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDynamicSegmentComputer.html">CDynamicSegmentComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a dynamic segment computer, <br  />
 ie. a model of <a class="el" href="structDGtal_1_1concepts_1_1CSegment.html" title="Aim: Defines the concept describing a segment, ie. a valid and not empty range.">CSegment</a> that can extend and retract itself (in the direction that is relative to the underlying iterator).  <a href="structDGtal_1_1concepts_1_1CDynamicSegmentComputer.html#details">More...</a><br /></td></tr>
<tr class="memitem:CDynamicVector" id="r_CDynamicVector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDynamicVector.html">CDynamicVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent any dynamic sized column vector having sparse or dense representation.  <a href="structDGtal_1_1concepts_1_1CDynamicVector.html#details">More...</a><br /></td></tr>
<tr class="memitem:CEuclideanBoundedShape" id="r_CEuclideanBoundedShape"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CEuclideanBoundedShape.html">CEuclideanBoundedShape</a></td></tr>
<tr class="memitem:CEuclideanOrientedShape" id="r_CEuclideanOrientedShape"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CEuclideanOrientedShape.html">CEuclideanOrientedShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: characterizes models of digital oriented shapes. For example, models should provide an orientation method for real points. Returned value type corresponds to <a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41">DGtal::Orientation</a>.  <a href="structDGtal_1_1concepts_1_1CEuclideanOrientedShape.html#details">More...</a><br /></td></tr>
<tr class="memitem:CEuclideanRing" id="r_CEuclideanRing"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CEuclideanRing.html">CEuclideanRing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the mathematical concept equivalent to a unitary commutative ring with a division operator.  <a href="structDGtal_1_1concepts_1_1CEuclideanRing.html#details">More...</a><br /></td></tr>
<tr class="memitem:CForwardSegmentComputer" id="r_CForwardSegmentComputer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CForwardSegmentComputer.html">CForwardSegmentComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a forward segment computer. Like any model of <a class="el" href="structDGtal_1_1concepts_1_1CIncrementalSegmentComputer.html" title="Aim: Defines the concept describing an incremental segment computer,   ie. a model of CSegmentFactory...">CIncrementalSegmentComputer</a>, it can control its own extension (in the direction that is relative to the underlying iterator) so that an implicit predicate P remains true. However, contrary to models of <a class="el" href="structDGtal_1_1concepts_1_1CIncrementalSegmentComputer.html" title="Aim: Defines the concept describing an incremental segment computer,   ie. a model of CSegmentFactory...">CIncrementalSegmentComputer</a>, it garantees that P is also true for any subrange of the whole segment at any time. This extra constraint is necessary to be able to incrementally check whether or not the segment is maximal.  <a href="structDGtal_1_1concepts_1_1CForwardSegmentComputer.html#details">More...</a><br /></td></tr>
<tr class="memitem:CGlobalGeometricEstimator" id="r_CGlobalGeometricEstimator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CGlobalGeometricEstimator.html">CGlobalGeometricEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept describes an object that can process a range so as to return one estimated quantity for the whole range.  <a href="structDGtal_1_1concepts_1_1CGlobalGeometricEstimator.html#details">More...</a><br /></td></tr>
<tr class="memitem:CGraphVisitor" id="r_CGraphVisitor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CGraphVisitor.html">CGraphVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept of a visitor onto a graph, that is an object that traverses vertices of the graph according to some order. The user can either use the visitor as is, or even constrain the traversal with a given predicate.  <a href="structDGtal_1_1concepts_1_1CGraphVisitor.html#details">More...</a><br /></td></tr>
<tr class="memitem:CImage" id="r_CImage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CImage.html">CImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a read/write image, having an output iterator.  <a href="structDGtal_1_1concepts_1_1CImage.html#details">More...</a><br /></td></tr>
<tr class="memitem:CImageCacheReadPolicy" id="r_CImageCacheReadPolicy"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CImageCacheReadPolicy.html">CImageCacheReadPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a cache read policy.  <a href="structDGtal_1_1concepts_1_1CImageCacheReadPolicy.html#details">More...</a><br /></td></tr>
<tr class="memitem:CImageCacheWritePolicy" id="r_CImageCacheWritePolicy"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CImageCacheWritePolicy.html">CImageCacheWritePolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a cache write policy.  <a href="structDGtal_1_1concepts_1_1CImageCacheWritePolicy.html#details">More...</a><br /></td></tr>
<tr class="memitem:CImageFactory" id="r_CImageFactory"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CImageFactory.html">CImageFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing an image factory.  <a href="structDGtal_1_1concepts_1_1CImageFactory.html#details">More...</a><br /></td></tr>
<tr class="memitem:CImplicitFunction" id="r_CImplicitFunction"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CImplicitFunction.html">CImplicitFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Describes any function of the form f(x), where x is some real point in the given space, and f(x) is some value.  <a href="structDGtal_1_1concepts_1_1CImplicitFunction.html#details">More...</a><br /></td></tr>
<tr class="memitem:CImplicitFunctionDiff1" id="r_CImplicitFunctionDiff1"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CImplicitFunctionDiff1.html">CImplicitFunctionDiff1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Describes a 1-differentiable function of the form f(x), where x is some real point in the given space, and f(x) is some value.  <a href="structDGtal_1_1concepts_1_1CImplicitFunctionDiff1.html#details">More...</a><br /></td></tr>
<tr class="memitem:CIncrementalPrimitiveComputer" id="r_CIncrementalPrimitiveComputer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CIncrementalPrimitiveComputer.html">CIncrementalPrimitiveComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing an object that computes some primitive from input points given one at a time, while keeping some internal state. At any moment, the object is supposed to store at least one valid primitive for the formerly given input points. <a class="el" href="structA.html">A</a> primitive is an informal word that describes some family of objects that share common characteristics. Often, the primitives are geometric, e.g. digital planes.  <a href="structDGtal_1_1concepts_1_1CIncrementalPrimitiveComputer.html#details">More...</a><br /></td></tr>
<tr class="memitem:CIncrementalSegmentComputer" id="r_CIncrementalSegmentComputer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CIncrementalSegmentComputer.html">CIncrementalSegmentComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing an incremental segment computer, <br  />
 ie. a model of <a class="el" href="structDGtal_1_1concepts_1_1CSegmentFactory.html" title="Aim: Defines the concept describing a segment ie. a valid and not empty subrange, which can construct...">CSegmentFactory</a> that can, in addition, incrementally check whether or not an implicit predicate P is true. In other words, it can control its own extension from a range of one element (in the direction that is relative to the underlying iterator) so that an implicit predicate P remains true.  <a href="structDGtal_1_1concepts_1_1CIncrementalSegmentComputer.html#details">More...</a><br /></td></tr>
<tr class="memitem:CInteger" id="r_CInteger"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CInteger.html">CInteger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Concept checking for <a class="el" href="examplePlaneProbingParallelepipedEstimator_8cpp.html#ad31c3eca44cf6770809bc47f2b456212">Integer</a> Numbers. More precisely, this concept is a refinement of both <a class="el" href="structDGtal_1_1concepts_1_1CEuclideanRing.html" title="Aim: Defines the mathematical concept equivalent to a unitary commutative ring with a division operat...">CEuclideanRing</a> and <a class="el" href="structDGtal_1_1concepts_1_1CIntegralNumber.html" title="Aim: Concept checking for Integral Numbers. Models of this concept should be listed in NumberTraits c...">CIntegralNumber</a>.  <a href="structDGtal_1_1concepts_1_1CInteger.html#details">More...</a><br /></td></tr>
<tr class="memitem:CIntegralNumber" id="r_CIntegralNumber"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CIntegralNumber.html">CIntegralNumber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Concept checking for Integral Numbers. Models of this concept should be listed in <a class="el" href="structDGtal_1_1NumberTraits.html" title="Aim: The traits class for all models of Cinteger.">NumberTraits</a> class and should have the isIntegral property.  <a href="structDGtal_1_1concepts_1_1CIntegralNumber.html#details">More...</a><br /></td></tr>
<tr class="memitem:CLabel" id="r_CLabel"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CLabel.html">CLabel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define the concept of <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> labels. Models of <a class="el" href="structDGtal_1_1concepts_1_1CLabel.html" title="Aim: Define the concept of DGtal labels. Models of CLabel can be default-constructible,...">CLabel</a> can be default-constructible, assignable and equality comparable.  <a href="structDGtal_1_1concepts_1_1CLabel.html#details">More...</a><br /></td></tr>
<tr class="memitem:CLinearAlgebra" id="r_CLinearAlgebra"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CLinearAlgebra.html">CLinearAlgebra</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Check right multiplication between matrix and vector and internal matrix multiplication. <a class="el" href="structDGtal_1_1concepts_1_1CLinearAlgebra.html#ab703f628623b7db076676cd68c33402c">Matrix</a> and vector scalar types should be the same.  <a href="structDGtal_1_1concepts_1_1CLinearAlgebra.html#details">More...</a><br /></td></tr>
<tr class="memitem:CLinearAlgebraSolver" id="r_CLinearAlgebraSolver"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CLinearAlgebraSolver.html">CLinearAlgebraSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Describe a linear solver defined over a linear algebra. Problems are of the form:  <a href="structDGtal_1_1concepts_1_1CLinearAlgebraSolver.html#details">More...</a><br /></td></tr>
<tr class="memitem:CLMSTDSSFilter" id="r_CLMSTDSSFilter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CLMSTDSSFilter.html">CLMSTDSSFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a functor which filters DSSes for L-MST calculations.  <a href="structDGtal_1_1concepts_1_1CLMSTDSSFilter.html#details">More...</a><br /></td></tr>
<tr class="memitem:CLMSTTangentFromDSS" id="r_CLMSTTangentFromDSS"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CLMSTTangentFromDSS.html">CLMSTTangentFromDSS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a functor which calculates a direction of the 2D DSS and an eccentricity <a class="el" href="citelist.html#CITEREF_lachaudivc2007">[74]</a> of a given point in this DSS.  <a href="structDGtal_1_1concepts_1_1CLMSTTangentFromDSS.html#details">More...</a><br /></td></tr>
<tr class="memitem:CLocalEstimatorFromSurfelFunctor" id="r_CLocalEstimatorFromSurfelFunctor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CLocalEstimatorFromSurfelFunctor.html">CLocalEstimatorFromSurfelFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: this concept describes functors on digtal surface surfel which can be used to define local estimator using the adapter <a class="el" href="classDGtal_1_1LocalEstimatorFromSurfelFunctorAdapter.html" title="Aim: this class adapts any local functor on digital surface element to define a local estimator....">LocalEstimatorFromSurfelFunctorAdapter</a>.  <a href="structDGtal_1_1concepts_1_1CLocalEstimatorFromSurfelFunctor.html#details">More...</a><br /></td></tr>
<tr class="memitem:CMatrix" id="r_CMatrix"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CMatrix.html">CMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent any static or dynamic sized matrix having sparse or dense representation.  <a href="structDGtal_1_1concepts_1_1CMatrix.html#details">More...</a><br /></td></tr>
<tr class="memitem:CMetricSpace" id="r_CMetricSpace"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CMetricSpace.html">CMetricSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: defines the concept of metric spaces.  <a href="structDGtal_1_1concepts_1_1CMetricSpace.html#details">More...</a><br /></td></tr>
<tr class="memitem:COrientationFunctor" id="r_COrientationFunctor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1COrientationFunctor.html">COrientationFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept gathers models implementing an orientation test of \( k+1 \) points in a space of dimension \( n \).  <a href="structDGtal_1_1concepts_1_1COrientationFunctor.html#details">More...</a><br /></td></tr>
<tr class="memitem:COrientationFunctor2" id="r_COrientationFunctor2"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1COrientationFunctor2.html">COrientationFunctor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept is a refinement of <a class="el" href="structDGtal_1_1concepts_1_1COrientationFunctor.html" title="Aim: This concept gathers models implementing an orientation test of  points in a space of dimension ...">COrientationFunctor</a>, useful for simple algebraic curves that can be uniquely defined by only two points.  <a href="structDGtal_1_1concepts_1_1COrientationFunctor2.html#details">More...</a><br /></td></tr>
<tr class="memitem:CPointEmbedder" id="r_CPointEmbedder"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CPointEmbedder.html">CPointEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: <a class="el" href="structA.html">A</a> point embedder is a mapping from digital points to Euclidean points. It adds inner types to functor.  <a href="structDGtal_1_1concepts_1_1CPointEmbedder.html#details">More...</a><br /></td></tr>
<tr class="memitem:CPointFunctor" id="r_CPointFunctor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html">CPointFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a functor on points.  <a href="structDGtal_1_1concepts_1_1CPointFunctor.html#details">More...</a><br /></td></tr>
<tr class="memitem:CPointPredicate" id="r_CPointPredicate"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html">CPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a predicate on a point.  <a href="structDGtal_1_1concepts_1_1CPointPredicate.html#details">More...</a><br /></td></tr>
<tr class="memitem:CPolarPointComparator2D" id="r_CPolarPointComparator2D"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CPolarPointComparator2D.html">CPolarPointComparator2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept gathers classes that are able to compare the position of two given points \( P, Q \) around a pole \( O \). More precisely, they compare the oriented angles lying between the horizontal line passing by \( O \) and the rays \( [OP) \) and \( [OQ) \) (in a counter-clockwise orientation). This is equivalent to compare the angle in radians from 0 (included) to 2 &pi; (excluded).  <a href="structDGtal_1_1concepts_1_1CPolarPointComparator2D.html#details">More...</a><br /></td></tr>
<tr class="memitem:CPositiveIrreducibleFraction" id="r_CPositiveIrreducibleFraction"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CPositiveIrreducibleFraction.html">CPositiveIrreducibleFraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines positive irreducible fractions, i.e. fraction p/q, p and q non-negative integers, with gcd(p,q)=1.  <a href="structDGtal_1_1concepts_1_1CPositiveIrreducibleFraction.html#details">More...</a><br /></td></tr>
<tr class="memitem:CPowerMetric" id="r_CPowerMetric"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CPowerMetric.html">CPowerMetric</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: defines the concept of special weighted metrics, so called power metrics.  <a href="structDGtal_1_1concepts_1_1CPowerMetric.html#details">More...</a><br /></td></tr>
<tr class="memitem:CPowerSeparableMetric" id="r_CPowerSeparableMetric"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CPowerSeparableMetric.html">CPowerSeparableMetric</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: defines the concept of separable metrics.  <a href="structDGtal_1_1concepts_1_1CPowerSeparableMetric.html#details">More...</a><br /></td></tr>
<tr class="memitem:CPreCellularGridSpaceND" id="r_CPreCellularGridSpaceND"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CPreCellularGridSpaceND.html">CPreCellularGridSpaceND</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept describes an unbounded cellular grid space in nD. In these spaces obtained by cartesian product, cells have a cubic shape that depends on the dimension: 0-cells are points, 1-cells are unit segments, 2-cells are squares, 3-cells are cubes, and so on.  <a href="structDGtal_1_1concepts_1_1CPreCellularGridSpaceND.html#details">More...</a><br /></td></tr>
<tr class="memitem:CPredicate" id="r_CPredicate"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CPredicate.html">CPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a predicate function, ie. a functor mapping a domain into the set of booleans.  <a href="structDGtal_1_1concepts_1_1CPredicate.html#details">More...</a><br /></td></tr>
<tr class="memitem:CPrimitiveComputer" id="r_CPrimitiveComputer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CPrimitiveComputer.html">CPrimitiveComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing an object that computes some primitive from input points, while keeping some internal state. At any moment, the object is supposed to store at least one valid primitive for the formerly given input points. <a class="el" href="structA.html">A</a> primitive is an informal word that describes some family of objects that share common characteristics. Often, the primitives are geometric, e.g. digital planes.  <a href="structDGtal_1_1concepts_1_1CPrimitiveComputer.html#details">More...</a><br /></td></tr>
<tr class="memitem:CQuantity" id="r_CQuantity"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CQuantity.html">CQuantity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: defines the concept of quantity in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>.  <a href="structDGtal_1_1concepts_1_1CQuantity.html#details">More...</a><br /></td></tr>
<tr class="memitem:CSCellEmbedder" id="r_CSCellEmbedder"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSCellEmbedder.html">CSCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: <a class="el" href="structA.html">A</a> cell embedder is a mapping from signed cells to Euclidean points. It adds inner types to functor.  <a href="structDGtal_1_1concepts_1_1CSCellEmbedder.html#details">More...</a><br /></td></tr>
<tr class="memitem:CSegment" id="r_CSegment"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSegment.html">CSegment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a segment, ie. a valid and not empty range.  <a href="structDGtal_1_1concepts_1_1CSegment.html#details">More...</a><br /></td></tr>
<tr class="memitem:CSegmentComputerEstimator" id="r_CSegmentComputerEstimator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSegmentComputerEstimator.html">CSegmentComputerEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept is a refinement of <a class="el" href="structDGtal_1_1concepts_1_1CCurveLocalGeometricEstimator.html" title="Aim: This concept describes an object that can process a range so as to return one estimated quantity...">CCurveLocalGeometricEstimator</a> devoted to the estimation of a geometric quantiy along a segment detected by a segment computer.  <a href="structDGtal_1_1concepts_1_1CSegmentComputerEstimator.html#details">More...</a><br /></td></tr>
<tr class="memitem:CSegmentFactory" id="r_CSegmentFactory"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSegmentFactory.html">CSegmentFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a segment ie. a valid and not empty subrange, which can construct instances of its own type or of derived type.  <a href="structDGtal_1_1concepts_1_1CSegmentFactory.html#details">More...</a><br /></td></tr>
<tr class="memitem:CSeparableMetric" id="r_CSeparableMetric"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSeparableMetric.html">CSeparableMetric</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: defines the concept of separable metrics.  <a href="structDGtal_1_1concepts_1_1CSeparableMetric.html#details">More...</a><br /></td></tr>
<tr class="memitem:CSignedNumber" id="r_CSignedNumber"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSignedNumber.html">CSignedNumber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Concept checking for Signed Numbers. Models of this concept should be listed in <a class="el" href="structDGtal_1_1NumberTraits.html" title="Aim: The traits class for all models of Cinteger.">NumberTraits</a> class and should have the isSigned property.  <a href="structDGtal_1_1concepts_1_1CSignedNumber.html#details">More...</a><br /></td></tr>
<tr class="memitem:CSinglePassRange" id="r_CSinglePassRange"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSinglePassRange.html">CSinglePassRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a range.  <a href="structDGtal_1_1concepts_1_1CSinglePassRange.html#details">More...</a><br /></td></tr>
<tr class="memitem:CSinglePassRangeFromPoint" id="r_CSinglePassRangeFromPoint"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSinglePassRangeFromPoint.html">CSinglePassRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of single pass range with a begin() method from a point.  <a href="structDGtal_1_1concepts_1_1CSinglePassRangeFromPoint.html#details">More...</a><br /></td></tr>
<tr class="memitem:CSinglePassRangeWithWritableIterator" id="r_CSinglePassRangeWithWritableIterator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSinglePassRangeWithWritableIterator.html">CSinglePassRangeWithWritableIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of const single pass range which require that an output iterator exists.  <a href="structDGtal_1_1concepts_1_1CSinglePassRangeWithWritableIterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:CSinglePassRangeWithWritableIteratorFromPoint" id="r_CSinglePassRangeWithWritableIteratorFromPoint"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSinglePassRangeWithWritableIteratorFromPoint.html">CSinglePassRangeWithWritableIteratorFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of single pass range with a outputIterator() method from a point.  <a href="structDGtal_1_1concepts_1_1CSinglePassRangeWithWritableIteratorFromPoint.html#details">More...</a><br /></td></tr>
<tr class="memitem:CSpace" id="r_CSpace"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSpace.html">CSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a digital space, ie a cartesian product of integer lines.  <a href="structDGtal_1_1concepts_1_1CSpace.html#details">More...</a><br /></td></tr>
<tr class="memitem:CSparseMatrix" id="r_CSparseMatrix"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSparseMatrix.html">CSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent any dynamic or static sized matrix having sparse representation.  <a href="structDGtal_1_1concepts_1_1CSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="memitem:CStack" id="r_CStack"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CStack.html">CStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept gathers classes that provide a stack interface.  <a href="structDGtal_1_1concepts_1_1CStack.html#details">More...</a><br /></td></tr>
<tr class="memitem:CStaticMatrix" id="r_CStaticMatrix"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CStaticMatrix.html">CStaticMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent any static sized matrix having sparse or dense representation.  <a href="structDGtal_1_1concepts_1_1CStaticMatrix.html#details">More...</a><br /></td></tr>
<tr class="memitem:CStaticVector" id="r_CStaticVector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CStaticVector.html">CStaticVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent any static sized column vector having sparse or dense representation.  <a href="structDGtal_1_1concepts_1_1CStaticVector.html#details">More...</a><br /></td></tr>
<tr class="memitem:CSTLAssociativeContainer" id="r_CSTLAssociativeContainer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSTLAssociativeContainer.html">CSTLAssociativeContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing an Associative Container of the STL (<a href="https://www.sgi.com/tech/stl/AssociativeContainer.html">https://www.sgi.com/tech/stl/AssociativeContainer.html</a>).  <a href="structDGtal_1_1concepts_1_1CSTLAssociativeContainer.html#details">More...</a><br /></td></tr>
<tr class="memitem:CSurfelLocalEstimator" id="r_CSurfelLocalEstimator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSurfelLocalEstimator.html">CSurfelLocalEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept describes an object that can process a range of surfels (that are supposed to belong to some (abstract) surface) so as to return one estimated quantity for each element of the range (or a given subrange).  <a href="structDGtal_1_1concepts_1_1CSurfelLocalEstimator.html#details">More...</a><br /></td></tr>
<tr class="memitem:CSurfelPredicate" id="r_CSurfelPredicate"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSurfelPredicate.html">CSurfelPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a predicate on a surfel.  <a href="structDGtal_1_1concepts_1_1CSurfelPredicate.html#details">More...</a><br /></td></tr>
<tr class="memitem:CTrivialConstImage" id="r_CTrivialConstImage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CTrivialConstImage.html">CTrivialConstImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a read-only image, which is a refinement of <a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html" title="Aim: Defines a functor on points.">CPointFunctor</a>.  <a href="structDGtal_1_1concepts_1_1CTrivialConstImage.html#details">More...</a><br /></td></tr>
<tr class="memitem:CTrivialImage" id="r_CTrivialImage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CTrivialImage.html">CTrivialImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing an image without extra ranges, which is a refinement of <a class="el" href="structDGtal_1_1concepts_1_1CTrivialConstImage.html" title="Aim: Defines the concept describing a read-only image, which is a refinement of CPointFunctor.">CTrivialConstImage</a>.  <a href="structDGtal_1_1concepts_1_1CTrivialImage.html#details">More...</a><br /></td></tr>
<tr class="memitem:CUnaryFunctor" id="r_CUnaryFunctor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CUnaryFunctor.html">CUnaryFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a unary functor, which associates arguments to results.  <a href="structDGtal_1_1concepts_1_1CUnaryFunctor.html#details">More...</a><br /></td></tr>
<tr class="memitem:CUnaryFunctor_3C_20X_2C_20A_20_26_2C_20R_20_26_20_3E" id="r_CUnaryFunctor_3C_20X_2C_20A_20_26_2C_20R_20_26_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CUnaryFunctor_3_01X_00_01A_01_6_00_01R_01_6_01_4.html">CUnaryFunctor&lt; X, A &amp;, R &amp; &gt;</a></td></tr>
<tr class="memitem:CUndirectedSimpleGraph" id="r_CUndirectedSimpleGraph"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CUndirectedSimpleGraph.html">CUndirectedSimpleGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not necessarily know all the vertices.  <a href="structDGtal_1_1concepts_1_1CUndirectedSimpleGraph.html#details">More...</a><br /></td></tr>
<tr class="memitem:CUndirectedSimpleLocalGraph" id="r_CUndirectedSimpleLocalGraph"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CUndirectedSimpleLocalGraph.html">CUndirectedSimpleLocalGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not necessarily know all the vertices.  <a href="structDGtal_1_1concepts_1_1CUndirectedSimpleLocalGraph.html#details">More...</a><br /></td></tr>
<tr class="memitem:CUnsignedNumber" id="r_CUnsignedNumber"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CUnsignedNumber.html">CUnsignedNumber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Concept checking for Unsigned numbers. Models of this concept should be listed in <a class="el" href="structDGtal_1_1NumberTraits.html" title="Aim: The traits class for all models of Cinteger.">NumberTraits</a> class and should have the isUnsigned property.  <a href="structDGtal_1_1concepts_1_1CUnsignedNumber.html#details">More...</a><br /></td></tr>
<tr class="memitem:CVector" id="r_CVector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CVector.html">CVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent any static or dynamic sized column vector having sparse or dense representation.  <a href="structDGtal_1_1concepts_1_1CVector.html#details">More...</a><br /></td></tr>
<tr class="memitem:CVectorSpace" id="r_CVectorSpace"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CVectorSpace.html">CVectorSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Base concept for vector space structure.  <a href="structDGtal_1_1concepts_1_1CVectorSpace.html#details">More...</a><br /></td></tr>
<tr class="memitem:CVertexMap" id="r_CVertexMap"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CVertexMap.html">CVertexMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: models of <a class="el" href="structDGtal_1_1concepts_1_1CVertexMap.html" title="Aim: models of CVertexMap concept implement mapping between graph vertices and values.">CVertexMap</a> concept implement mapping between graph vertices and values.  <a href="structDGtal_1_1concepts_1_1CVertexMap.html#details">More...</a><br /></td></tr>
<tr class="memitem:CVertexPredicate" id="r_CVertexPredicate"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CVertexPredicate.html">CVertexPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a predicate on a vertex.  <a href="structDGtal_1_1concepts_1_1CVertexPredicate.html#details">More...</a><br /></td></tr>
<tr class="memitem:CVertexPredicateArchetype" id="r_CVertexPredicateArchetype"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CVertexPredicateArchetype.html">CVertexPredicateArchetype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a an archetype for concept <a class="el" href="structDGtal_1_1concepts_1_1CVertexPredicate.html" title="Aim: Defines a predicate on a vertex.">CVertexPredicate</a>.  <a href="structDGtal_1_1concepts_1_1CVertexPredicateArchetype.html#details">More...</a><br /></td></tr>
<tr class="memitem:CWithGradientMap" id="r_CWithGradientMap"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CWithGradientMap.html">CWithGradientMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Such object provides a gradient map that associates to each argument some real vector.  <a href="structDGtal_1_1concepts_1_1CWithGradientMap.html#details">More...</a><br /></td></tr>
<tr class="memitem:Display3D" id="r_Display3D"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1concepts_1_1Display3D.html">Display3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The concept <a class="el" href="structDGtal_1_1concepts_1_1CDrawableWithDisplay3D.html">CDrawableWithDisplay3D</a> specifies what are the classes that admit an export with <a class="el" href="classDGtal_1_1concepts_1_1Display3D.html" title="Aim: The concept CDrawableWithDisplay3D specifies what are the classes that admit an export with Disp...">Display3D</a>.  <a href="classDGtal_1_1concepts_1_1Display3D.html#details">More...</a><br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Aim: Gathers several functions useful for concept checks. </p>
<p><code class="param">concepts</code> namespace gathers concepts in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> and concept utils.</p>
<p>Description of namespace '<a class="el" href="namespaceDGtal_1_1concepts_1_1ConceptUtils.html">ConceptUtils</a>' </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceDGtal.html">DGtal</a></li><li class="navelem"><a href="namespaceDGtal_1_1concepts.html">concepts</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for DGtal by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
