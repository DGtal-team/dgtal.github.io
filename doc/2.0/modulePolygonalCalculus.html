<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Discrete differential calculus on polygonal surfaces</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('modulePolygonalCalculus.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Discrete differential calculus on polygonal surfaces </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>David Coeurjolly, Baptiste GENEST</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.3</dd></dl>
<p>Part of package <a class="el" href="packageDEC.html">DEC package</a>.</p>
<p>In this documentation page, we detail the operators and tools for differential calculus computations on generic polygonal surfaces (<a class="el" href="classDGtal_1_1PolygonalCalculus.html" title="Implements differential operators on polygonal surfaces from degoes2020discrete.">PolygonalCalculus</a> class). Such polygonal surfaces could be generic meshes (with non-planar, non-convex faces), or an embeddeing of a digital surface.</p>
<p>The overall idea, compared to the <a class="el" href="moduleDECIntroduction.html">Discrete exterior calculus</a> approach, is to define per face operators which can be later combined to define global ones.</p>
<p>This module documents the operators defined in <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[45]</a>. An additional documentation page showcasing classical use cases of these operators for geometry processing on digital surfaces will be added.</p>
<dl class="section note"><dt>Note</dt><dd>The sign convention for the divergence and the Laplacian operator is opposite to the one of <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[45]</a>. This is to match the usual mathematical convention that the Laplacian (and the Laplacian-Beltrami) has negative eigenvalues (and is the sum of second derivatives in the cartesian grid). It also follows the formal adjointness of exterior derivative and opposite of divergence as relation  \( \langle \mathrm{d} u, v \rangle = - \langle u,
\mathrm{div} v \rangle \). See also <a href="https://en.wikipedia.org/wiki/Laplace–Beltrami_operator">https://en.wikipedia.org/wiki/Laplace–Beltrami_operator</a></dd>
<dd>
All illustrations below have been obtained using the DGtal+<a href="https://polyscope.run">polyscope</a> examples <a class="el" href="dgtalCalculus_8cpp_source.html">dgtalCalculus.cpp</a>, <a class="el" href="dgtalCalculus-single_8cpp.html">dgtalCalculus-single.cpp</a> and <a class="el" href="dgtalCalculus-poisson_8cpp.html">dgtalCalculus-poisson.cpp</a>. To build these examples, enable the <span class="tt">DGTAL_BUILD_POLYSCOPE_EXAMPLES</span> variable (e.g. <span class="tt">cmake .. -DDGTAL_BUILD_POLYSCOPE_EXAMPLES=ON</span>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The implementation heavily relies on implicit operators with many Eigen based small matrice constructions, which has a huge overhead in Debug mode. Please consider to build the examples in Release (<em>e.g.</em> <span class="tt">CMAKE_BUILD_TYPE</span> variable) for high performance on large geometrical objects.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="sectPolygonalCalculusIntro"></a>
Introduction</h1>
<p>The main idea of <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[45]</a> is to define discrete operators per face, which can be combined to obtain a global operator acting on meshes. For vertex valued scalar or vector fields, this class implements elementary differential operators (gradient, derivatives, sharp/flat, Laplace-Beltrami...) which can be combined to define more complex ones, or to be used when solving variational geometry processing problems on meshes or digital surfaces.</p>
<p>The operators detailed <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[45]</a> extend Mimetic Finite <a class="el" href="structDGtal_1_1IteratorCirculatorTraits.html">Difference</a> and Virtual Element Method operators to arbitrary 3d polygons and discrete surfaces.</p>
<h1 class="doxsection"><a class="anchor" id="sectPolygonalCalculus2"></a>
Per face operators</h1>
<p>Let us consider a single (non-planar, non-convex) face example. Using</p>
<div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="dgtalCalculus-bunny_8cpp.html#a0da7de0f9d769404c143f3d032eaa496">SurfMesh</a> = SurfaceMesh&lt;Z3i::RealPoint,Z3i::RealVector&gt;;</div>
<div class="line"><span class="keyword">using namespace </span>Z3i;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//Vertices</span></div>
<div class="line">std::vector&lt;RealPoint&gt; positions={ {0,0,0},{20,0,0},{20,10,0},{10,8,5}, {0,15,1} };</div>
<div class="line"><span class="comment">//Single face</span></div>
<div class="line">std::vector&lt;std::vector&lt;size_t&gt;&gt; faces={{ 0,1,2,3,4 }};</div>
<div class="line"> </div>
<div class="line">mesh = <a class="code hl_typedef" href="dgtalCalculus-bunny_8cpp.html#a0da7de0f9d769404c143f3d032eaa496">SurfMesh</a>(positions.begin(),positions.end(),faces.begin(),faces.end());</div>
<div class="line">  </div>
<div class="line"><a class="code hl_class" href="classDGtal_1_1PolygonalCalculus.html">PolygonalCalculus&lt;SurfMesh&gt;</a> <a class="code hl_variable" href="dgtalCalculus-geodesic_8cpp.html#a4e9d205fb8308b3d07478e48bf63308c">calculus</a>(mesh);</div>
<div class="ttc" id="aclassDGtal_1_1PolygonalCalculus_html"><div class="ttname"><a href="classDGtal_1_1PolygonalCalculus.html">DGtal::PolygonalCalculus</a></div><div class="ttdoc">Implements differential operators on polygonal surfaces from degoes2020discrete.</div><div class="ttdef"><b>Definition</b> <a href="PolygonalCalculus_8h_source.html#l00128">PolygonalCalculus.h:129</a></div></div>
<div class="ttc" id="adgtalCalculus-bunny_8cpp_html_a0da7de0f9d769404c143f3d032eaa496"><div class="ttname"><a href="dgtalCalculus-bunny_8cpp.html#a0da7de0f9d769404c143f3d032eaa496">SurfMesh</a></div><div class="ttdeci">SurfaceMesh&lt; RealPoint, RealVector &gt; SurfMesh</div><div class="ttdef"><b>Definition</b> <a href="dgtalCalculus-bunny_8cpp_source.html#l00052">dgtalCalculus-bunny.cpp:52</a></div></div>
<div class="ttc" id="adgtalCalculus-geodesic_8cpp_html_a4e9d205fb8308b3d07478e48bf63308c"><div class="ttname"><a href="dgtalCalculus-geodesic_8cpp.html#a4e9d205fb8308b3d07478e48bf63308c">calculus</a></div><div class="ttdeci">PolyCalculus * calculus</div><div class="ttdef"><b>Definition</b> <a href="dgtalCalculus-geodesic_8cpp_source.html#l00070">dgtalCalculus-geodesic.cpp:70</a></div></div>
</div><!-- fragment --><p>we obtain a <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> instance with a unique face and its associated <a class="el" href="classDGtal_1_1PolygonalCalculus.html" title="Implements differential operators on polygonal surfaces from degoes2020discrete.">PolygonalCalculus</a> object.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Example  </th><th class="markdownTableHeadNone">Example  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><div class="image">
<img src="face.png" alt=""/>
</div>
  </td><td class="markdownTableBodyNone"><div class="image">
<img src="face_rot.png" alt=""/>
</div>
  </td></tr>
</table>
<p>Let us add a scalar function on vertices. For instance, using Eigen syntax, we can use;</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="classDGtal_1_1PolygonalCalculus.html#af2b61b0f1effab17c35094e4c2ae29cd">PolygonalCalculus&lt;SurfMesh&gt;::Vector</a> <a class="code hl_function" href="dgtalCalculus-bunny_8cpp.html#af4d111f7bd995b3e0442b101cf84515b">phi</a>(5); <span class="comment">//5 vertices</span></div>
<div class="line"><a class="code hl_function" href="dgtalCalculus-bunny_8cpp.html#af4d111f7bd995b3e0442b101cf84515b">phi</a> &lt;&lt; 1.0, 2.0, 0.0, 5.0 ,1.5;</div>
<div class="ttc" id="aclassDGtal_1_1PolygonalCalculus_html_af2b61b0f1effab17c35094e4c2ae29cd"><div class="ttname"><a href="classDGtal_1_1PolygonalCalculus.html#af2b61b0f1effab17c35094e4c2ae29cd">DGtal::PolygonalCalculus::Vector</a></div><div class="ttdeci">LinAlg::DenseVector Vector</div><div class="ttdoc">Type of Vector.</div><div class="ttdef"><b>Definition</b> <a href="PolygonalCalculus_8h_source.html#l00154">PolygonalCalculus.h:154</a></div></div>
<div class="ttc" id="adgtalCalculus-bunny_8cpp_html_af4d111f7bd995b3e0442b101cf84515b"><div class="ttname"><a href="dgtalCalculus-bunny_8cpp.html#af4d111f7bd995b3e0442b101cf84515b">phi</a></div><div class="ttdeci">PolygonalCalculus&lt; SH3::RealPoint, SH3::RealVector &gt;::Vector phi(const Face f)</div><div class="ttdef"><b>Definition</b> <a href="dgtalCalculus-bunny_8cpp_source.html#l00069">dgtalCalculus-bunny.cpp:69</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>As the face is nonconvex / nonplanar, the vertex scalar quantity interpolation and the rendering in polyscope may be a bit odd.</dd></dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Phi  </th><th class="markdownTableHeadNone">Interpolated phi  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><div class="image">
<img src="face_phi.png" alt=""/>
</div>
  </td><td class="markdownTableBodyNone"><div class="image">
<img src="face_phi_interp.png" alt=""/>
</div>
  </td></tr>
</table>
<p>When constructing a <a class="el" href="classDGtal_1_1PolygonalCalculus.html" title="Implements differential operators on polygonal surfaces from degoes2020discrete.">PolygonalCalculus&lt;SurfMesh&gt;</a> instance, you can provide an external function to embed the vertex positions. By default, the positions of the surface mesh vertices (<em class="arg">positions</em> <em class="arg">in</em> the previous example) is used. If you want to update the embedding (could be useful on digital surfaces), the user can specify the mapping <span class="tt">(<a class="el" href="testTriangulatedSurface_8cpp.html#aa7e89e659ae870a9963bb6109a53da62">Face</a>,<a class="el" href="testTriangulatedSurface_8cpp.html#ae931baebcf0de56dd5f3b9342207e4fd">Vertex</a>)-&gt;<a class="el" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a></span>. Please refer to <a class="el" href="classDGtal_1_1PolygonalCalculus.html#aa2edd0f5bb50ed4fe0ae8a6c8144a130">PolygonalCalculus&lt;SurfMesh&gt;::setEmbedder</a> for an example.</p>
<dl class="section note"><dt>Note</dt><dd>As the <a class="el" href="testTriangulatedSurface_8cpp.html#aa7e89e659ae870a9963bb6109a53da62">Face</a> id is a parameter of the embedder, a given vertex can have different embeddings for all its incident faces.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="susub1"></a>
Basic operators</h2>
<p>We first describe some standard per face operators. Note that for all extrinsic operators that require the vertex position in  \(\mathbb{R}^3 \), the embedder is used. For these quantities, vector/point are encoded as Eigen 3x1 vectors and collections of n points as an \( n\times 3\) matrix.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operator  </th><th class="markdownTableHeadNone">Output  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">calculus.X(f)</span>  </td><td class="markdownTableBodyNone">\( n_f\times 3\)  </td><td class="markdownTableBodyNone">positions of the face vertices (n_f points in \( \mathbb{R}^3 \))  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">calculus.E(f)</span>  </td><td class="markdownTableBodyNone">\( n_f\times 3\)  </td><td class="markdownTableBodyNone">the edge vectors of the face (n_f vectors in \( \mathbb{R}^3 \))  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">calculus.A(f)</span>  </td><td class="markdownTableBodyNone">\( n_f\times n_f\)  </td><td class="markdownTableBodyNone">averaging operator that averages some values on vertices to values on edges (vectors \((p_{i+1}-p_{i})\in\mathbb{R}^3\))  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">calculus.B(f)</span>  </td><td class="markdownTableBodyNone">\( n_f\times 3\)  </td><td class="markdownTableBodyNone">the edge mid-points of the face (n_f points in \( \mathbb{R}^3 \))  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">calculus.vectorArea(f)</span>  </td><td class="markdownTableBodyNone">\( n_f\) vector  </td><td class="markdownTableBodyNone">the corrected vector area of the face (uses the embedder)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">calculus.faceArea(f)</span>  </td><td class="markdownTableBodyNone">scalar  </td><td class="markdownTableBodyNone">the corrected face area (uses the embedder)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">calculus.faceNormalVector(f)</span>  </td><td class="markdownTableBodyNone">vector in \(\mathbb{R}^3\)  </td><td class="markdownTableBodyNone">the corrected (unitary) normal vector of the face (uses the embedder)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">calculus.faceNormalAsDGtalVector(f)</span>  </td><td class="markdownTableBodyNone">RealVector  </td><td class="markdownTableBodyNone">the corrected (unitary) normal vector of the face (uses the embedder)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">calculus.centroid(f)</span>  </td><td class="markdownTableBodyNone">vector in \(\mathbb{R}^3\)  </td><td class="markdownTableBodyNone">the corrected centroid of the face  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">calculus.centroidAsDGtalVector(f)</span>  </td><td class="markdownTableBodyNone">RealVector  </td><td class="markdownTableBodyNone">the corrected centroid of the face  </td></tr>
</table>
<h3 class="doxsection"><a class="anchor" id="subderiv"></a>
Derivative operators</h3>
<p>Derivative operators act on a scalar field defined on the vertex of the face.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operator  </th><th class="markdownTableHeadNone">Output  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">calculus.D(f)</span>  </td><td class="markdownTableBodyNone">\( n_f\times n_f\)  </td><td class="markdownTableBodyNone">derivative operator (d0 in DEC) mapping scalar values on vertices to values on edges (vertex scalars to a 1-form)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">calculus.gradient(f)</span>  </td><td class="markdownTableBodyNone">\( 3 \times n_f\)  </td><td class="markdownTableBodyNone">the gradient operator for vertex valued scalar functions of the face f  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">calculus.coGradient(f)</span>  </td><td class="markdownTableBodyNone">\( 3 \times n_f\)  </td><td class="markdownTableBodyNone">the co-gradient operator for vertex valued scalar functions of the face f  </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">A*phi  </th><th class="markdownTableHeadNone">D*phi (discrete 1-form)  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><div class="image">
<img src="A_phi.png" alt=""/>
</div>
  </td><td class="markdownTableBodyNone"><div class="image">
<img src="D_phi.png" alt=""/>
</div>
  </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">gradient  </th><th class="markdownTableHeadNone">co-gradient  </th><th class="markdownTableHeadNone">corrected normal  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><div class="image">
<img src="gradient.png" alt=""/>
</div>
  </td><td class="markdownTableBodyNone"><div class="image">
<img src="cogradient.png" alt=""/>
</div>
  </td><td class="markdownTableBodyNone"><div class="image">
<img src="normal.png" alt=""/>
</div>
  </td></tr>
</table>
<h3 class="doxsection"><a class="anchor" id="subdflat"></a>
Flat/Sharp and Projection Operators</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operator  </th><th class="markdownTableHeadNone">Output  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">calculus.flat(f)</span>  </td><td class="markdownTableBodyNone">\( n_f\times 3\)  </td><td class="markdownTableBodyNone">Flat operator that maps an ambient vector to a local discrete 1-form  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">calculus.sharp(f)</span>  </td><td class="markdownTableBodyNone">\( 3 \times n_f\)  </td><td class="markdownTableBodyNone">Sharp operator that maps a discrete 1-form to an ambient vector  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">calculus.P(f)</span>  </td><td class="markdownTableBodyNone">\( n_f \times n_f\)  </td><td class="markdownTableBodyNone">Projection operator acting on a discrete 1-form that removes the associated non-tangential part of the vector reconstructed using the sharp operator  </td></tr>
</table>
<p>Discrete flat and sharp operators match with the DEC operators (see <a class="el" href="moduleDECIntroduction.html">Discrete exterior calculus</a>). For short, the flat operator embeds an ambient vector as a discrete 1-form (roughly values on the face edges) while the sharp operator pull-back a 1-form to reconstruct a vector in \(\mathbb{R}^3\). These operators are rank 2 and \( sharp_f flat_f s = s\) for any vector \(s\) in the face tangent plane, but \( flat_f sharp_f v = v\) for any vector v does not hold (due to rank deficiencies of the matrices). This is quantified by the projection operator \(P\) (see <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[45]</a> for structural lemmas, e.g. \( normal_f\cdot (sharp_f flat_f s)=0\quad \forall s\in \mathbb{R}^3\)...).</p>
<p>For interested readers, <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[45]</a> has a discussion about the relationship between these operators and the classical DEC or FEM ones.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">a vector in \(\mathbb{R}^3\)  </th><th class="markdownTableHeadNone">a vector in \(\mathbb{R}^3\)  </th><th class="markdownTableHeadNone">Flat (1-form)  </th><th class="markdownTableHeadNone">Sharp of the flat (green vector)  </th><th class="markdownTableHeadNone">Sharp and normal vector (orange vector)  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><div class="image">
<img src="face_vec.png" alt=""/>
</div>
  </td><td class="markdownTableBodyNone"><div class="image">
<img src="face_vec1.png" alt=""/>
</div>
  </td><td class="markdownTableBodyNone"><div class="image">
<img src="face_flat1form.png" alt=""/>
</div>
  </td><td class="markdownTableBodyNone"><div class="image">
<img src="face_sharp.png" alt=""/>
</div>
  </td><td class="markdownTableBodyNone"><div class="image">
<img src="face_sharpnorm.png" alt=""/>
</div>
  </td></tr>
</table>
<h2 class="doxsection"><a class="anchor" id="sublap"></a>
Inner Product and Laplace-Beltrami Operators</h2>
<p>For 0-forms, the inner product is the classical one induced by the \( l_2\) norm. For 1-forms, the inner product is given by <a class="el" href="classDGtal_1_1PolygonalCalculus.html#abc85984a071c6c8acec5871252b497c9">PolygonalCalculus&lt;SurfMesh&gt;::M()</a> (useful to define the Laplace-Beltrami operator).</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operator  </th><th class="markdownTableHeadNone">Output  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">calculus.M(f,lambda)</span>  </td><td class="markdownTableBodyNone">\( n_f\times n_f\)  </td><td class="markdownTableBodyNone">Inner product operator on discrete 1-forms operator (lambda is a regularization parameter, see <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[45]</a>)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">calculus.laplaceBeltrami(f,lambda)</span>  </td><td class="markdownTableBodyNone">\( n_f \times n_f\)  </td><td class="markdownTableBodyNone">Laplace-Beltrami operator \( D^tMD \) (lambda is a regularization parameter, see <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[45]</a>), the matrix is PSD  </td></tr>
</table>
<h2 class="doxsection"><a class="anchor" id="sectcovOPL"></a>
Operators on directional fields and Connection Laplacian</h2>
<p>In this section, we describe operators acting on directional fields (Levi-Civita connection, covariant gradient of a vector field &ndash;first-order derivative on VF&ndash;, and connection laplacian). Pleas refer to <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[45]</a>, section 5, for details.</p>
<p>As an example, these operators can be used to interpolate vector fields as illustrated in <a class="el" href="moduleVectorsInHeat.html">Vector Heat Method using discrete polygonal calculus</a>.</p>
<div class="image">
<img src="transport_to_face.png" alt=""/>
<div class="caption">
Transport of a vertex based vector field to face tangent plane</div></div>
<h3 class="doxsection"><a class="anchor" id="sectcovOP"></a>
Covariant Gradient and Projection</h3>
<p>Since these operators are themselves matrices they cannot be constructed in the same way as the others ( Operator builder Matrix * function restricted to face <a class="el" href="classDGtal_1_1SpaceND.html">Vector</a> ), you need the specify the local vector field as well, in the same format as in <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[45]</a>, i.e.   </p><p class="formulaDsp">
\begin{eqnarray*}    u_{f} = [u_{v_1}^t \ldots u_{v_{nf}}^t]^t
\end{eqnarray*}
</p>
<p> where \(u_{v_i}\) are the intrinsic vectors at each adjacent vertex expressed in their own tangent basis.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operator  </th><th class="markdownTableHeadNone">Output  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">calculus.covariantGradient(f,uf)</span>  </td><td class="markdownTableBodyNone">\( 2\times 2\)  </td><td class="markdownTableBodyNone">Covariant Gradient defined for intrinsic vector valued 0-forms at face f  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">calculus.covariantProjection(f,uf)</span>  </td><td class="markdownTableBodyNone">\( n_f \times 2\)  </td><td class="markdownTableBodyNone">Covariant Projection operator defined for intrinsic vector valued 0-forms at face f  </td></tr>
</table>
<h3 class="doxsection"><a class="anchor" id="sectVL"></a>
Vector Laplacian</h3>
<p>Using the same format for vector fields as above, we can define a <a class="el" href="classDGtal_1_1SpaceND.html">Vector</a> Laplacian operator per face. </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operator  </th><th class="markdownTableHeadNone">Output  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">calculus.connectionLaplacian(f,lambda)</span>  </td><td class="markdownTableBodyNone">\( 2n_f\times 2n_f\)  </td><td class="markdownTableBodyNone"><a class="el" href="classDGtal_1_1SpaceND.html">Vector</a> Laplacian defined as the associated Matrix with the Dirichlet energy for vector valued 0-forms (lambda is a regularization parameter, see <a class="el" href="citelist.html#CITEREF_degoes2020discrete">[45]</a>) at face f, PSD matrix  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="sectPolygonalCalculusGlo"></a>
Global calculus</h1>
<p>Given a scalar function defined on a generic surface mesh vertices, all previously mentioned operators can be applied to obtain consistent quantities on the overall mesh. For instance, from the <a class="el" href="dgtalCalculus_8cpp_source.html">dgtalCalculus.cpp</a> example using <a class="el" href="classDGtal_1_1Shortcuts.html" title="Aim: This class is used to simplify shape and surface creation. With it, you can create new shapes an...">Shortcuts</a> and <a class="el" href="classDGtal_1_1ShortcutsGeometry.html" title="Aim: This class is used to simplify shape and surface creation. With it, you can create new shapes an...">ShortcutsGeometry</a> to set up the surface:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><a class="el" href="exampleMaximalSegmentSliceEstimation_8cpp.html#a86f9b721e4e72a3388a69cb2ed596f8f">Surface</a>  </th><th class="markdownTableHeadNone">Phi  </th><th class="markdownTableHeadNone">Gradient  </th><th class="markdownTableHeadNone">Gradient+co-gradient  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><div class="image">
<img src="init.png" alt=""/>
</div>
  </td><td class="markdownTableBodyNone"><div class="image">
<img src="goursat_phi.png" alt=""/>
</div>
  </td><td class="markdownTableBodyNone"><div class="image">
<img src="goursat_grad.png" alt=""/>
</div>
  </td><td class="markdownTableBodyNone"><div class="image">
<img src="goursat_gradcograd.png" alt=""/>
</div>
  </td></tr>
</table>
<p>To solve some global PDE (e.g. Laplace/Poisson problems, see below), one can combine the local operators into a global one, gathering the contributions of each face.</p>
<p>For example, the <a class="el" href="classDGtal_1_1PolygonalCalculus.html#a9e371e89d60a14b67c560763133b342c">PolygonalCalculus&lt;SurfMesh&gt;::globalLaplaceBeltrami()</a> method outputs a global (sparse) Laplace-Beltrami operator which can later be used for diffusion.</p>
<p>You can also retrieve the global mass matrix via <a class="el" href="classDGtal_1_1PolygonalCalculus.html#ac73d777d276a934c23759a20a3b55838">PolygonalCalculus::globalLumpedMassMatrix</a>, which is used to define an inner product for 0-forms (i.e. scalar functions), as well as its inverse <a class="el" href="classDGtal_1_1PolygonalCalculus.html#a6f6bdfce2e62d44c05af3ef5c864d2c2">PolygonalCalculus::globalInverseLumpedMassMatrix()</a>, generally used when one solves a weak problem and wishes to get a pointwise per-vertex solution.</p>
<h1 class="doxsection"><a class="anchor" id="sectCorrected"></a>
Corrected Calculus using Estimated Normal Vectors</h1>
<p>On digital surfaces, solving PDE on original embedding with axis aligned quad surfaces may fail to correctly capture the surface metric. As discussed in <a class="el" href="citelist.html#CITEREF_coeurjolly2022simple">[26]</a>, given an estimation of the tangent bundle of the discrete surface (for instance using estimated normal vectors from <a class="el" href="moduleIntegralInvariant.html">Integral invariant curvature estimator 2D/3D</a>, or <a class="el" href="moduleVCM.html">Digital Voronoi Covariance Measure and geometry estimation</a>, cf <a class="el" href="moduleShortcuts.html">Shortcuts (for the impatient developper)</a>), one can implicitly project each face to a prescribed tangent plane and perform the computations on this new embedding of the geometry.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Geodesic distances without correction  </th><th class="markdownTableHeadNone">Geodesic distances with correction  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><div class="image">
<img src="corrected-without.png" alt=""/>
</div>
  </td><td class="markdownTableBodyNone"><div class="image">
<img src="corrected-with.png" alt=""/>
</div>
  </td></tr>
</table>
<p>The functor <a class="el" href="structDGtal_1_1functors_1_1EmbedderFromNormalVectors.html" title="Functor that projects a face vertex of a surface mesh onto the tangent plane given by a per-face norm...">functors::EmbedderFromNormalVectors</a> can be used to implicitly project <a class="el" href="testTriangulatedSurface_8cpp.html#aa7e89e659ae870a9963bb6109a53da62">Face</a> vertices onto the prescribed tangent plane. <a class="el" href="structA.html">A</a> classical usage is the following one:</p>
<div class="fragment"><div class="line"><span class="comment">//A surface mesh. Eg. primal surface of a digital surface</span></div>
<div class="line">SurfaceMesh&lt; Z3i::RealPoint, Z3i::RealVector &gt; <a class="code hl_variable" href="dgtalCalculus-bunny_8cpp.html#ae3ccdba7d575baf979261b4c02a6b9bb">surfmesh</a>(...);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//Per face normal vector estimation</span></div>
<div class="line">std::vector&lt;Z3i::RealVector&gt; ii_normals = ....</div>
<div class="line"> </div>
<div class="line"><span class="comment">//New embedder using tangent plane projection of face vertices</span></div>
<div class="line">functors::EmbedderFromNormalVectors&lt;Z3i::RealPoint, Z3i::RealVector&gt; embedderFromNormals(ii_normals,<a class="code hl_variable" href="dgtalCalculus-bunny_8cpp.html#ae3ccdba7d575baf979261b4c02a6b9bb">surfmesh</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//The calculus instance with the new embedder</span></div>
<div class="line">PolygonalCalculus&lt;Z3i::RealPoint,23i::RealVector&gt; <a class="code hl_variable" href="dgtalCalculus-geodesic_8cpp.html#a4e9d205fb8308b3d07478e48bf63308c">calculus</a>(<a class="code hl_variable" href="dgtalCalculus-bunny_8cpp.html#ae3ccdba7d575baf979261b4c02a6b9bb">surfmesh</a>);</div>
<div class="line"><a class="code hl_variable" href="dgtalCalculus-geodesic_8cpp.html#a4e9d205fb8308b3d07478e48bf63308c">calculus</a>-&gt;setEmbedder( embedderFromNormals );</div>
<div class="ttc" id="adgtalCalculus-bunny_8cpp_html_ae3ccdba7d575baf979261b4c02a6b9bb"><div class="ttname"><a href="dgtalCalculus-bunny_8cpp.html#ae3ccdba7d575baf979261b4c02a6b9bb">surfmesh</a></div><div class="ttdeci">SurfMesh surfmesh</div><div class="ttdef"><b>Definition</b> <a href="dgtalCalculus-bunny_8cpp_source.html#l00058">dgtalCalculus-bunny.cpp:58</a></div></div>
</div><!-- fragment --><p> <a class="el" href="structA.html">A</a> complete code is given in the <a class="el" href="dgtalCalculus-geodesic_8cpp.html">dgtalCalculus-geodesic.cpp</a> example.</p>
<h1 class="doxsection"><a class="anchor" id="secLap"></a>
Example: Solving a Laplace problem</h1>
<p>Let suppose we want to solve the following Laplace problem for data interpolation:    </p><p class="formulaDsp">
\begin{eqnarray*} \Delta_\Omega u&amp; = 0  \\
 &amp; s.t. u = g \text{ on } \partial\Omega
\end{eqnarray*}
</p>
<p>We want to solve that problem on a polygonal mesh \(\Omega\) (digital surface here) with a boundary and some scalar values attached to boundary vertices, or sampled on the object surface.</p>
<p>Furthermore, the discrete version of the Laplace problem boils down to a simple linear problem using on the discrete Laplace-Beltrami sparse matrix.</p>
<p>We also use class <a class="el" href="classDGtal_1_1DirichletConditions.html" title="Aim: A helper class to solve a system with Dirichlet boundary conditions.">DirichletConditions</a> to enforce Dirichlet boundary conditions on the system.</p>
<p>The overall code is: </p><div class="fragment"><div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1PolygonalCalculus.html">PolygonalCalculus&lt;SH3::RealPoint,SH3::RealVector&gt;</a> PolyDEC;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1DirichletConditions.html">DirichletConditions&lt; EigenLinearAlgebraBackend &gt;</a>  DC;</div>
<div class="line">  PolyDEC <a class="code hl_variable" href="dgtalCalculus-geodesic_8cpp.html#a4e9d205fb8308b3d07478e48bf63308c">calculus</a>(<a class="code hl_variable" href="dgtalCalculus-bunny_8cpp.html#ae3ccdba7d575baf979261b4c02a6b9bb">surfmesh</a>);</div>
<div class="line">  PolyDEC::SparseMatrix <a class="code hl_enumvalue" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ad20caec3b48a1eef164cb4ca81ba2587">L</a> = <a class="code hl_variable" href="dgtalCalculus-geodesic_8cpp.html#a4e9d205fb8308b3d07478e48bf63308c">calculus</a>.globalLaplaceBeltrami();</div>
<div class="line">  PolyDEC::Form g = <a class="code hl_variable" href="dgtalCalculus-geodesic_8cpp.html#a4e9d205fb8308b3d07478e48bf63308c">calculus</a>.form0();</div>
<div class="line">  DC::IntegerVector b = DC::IntegerVector::Zero( g.rows() );</div>
<div class="line">  </div>
<div class="line">  <span class="comment">//We set values on the boundary</span></div>
<div class="line">  <span class="keyword">auto</span> boundaryEdges = <a class="code hl_variable" href="dgtalCalculus-bunny_8cpp.html#ae3ccdba7d575baf979261b4c02a6b9bb">surfmesh</a>.computeManifoldBoundaryEdges();</div>
<div class="line">  std::cout&lt;&lt; <span class="stringliteral">&quot;Number of boundary edges= &quot;</span>&lt;&lt;boundaryEdges.size()&lt;&lt;std::endl;</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">auto</span> pihVertex=[&amp;](<span class="keyword">const</span> <a class="code hl_typedef" href="structDGtal_1_1SurfaceMesh.html#ac8fba76a794fd9912af755f620606cf0">SurfMesh::Vertex</a> &amp;v){<span class="keywordflow">return</span>  cos(<a class="code hl_variable" href="dgtalCalculus-bunny_8cpp.html#a1d28dec57cce925ad92342891bd71e7c">scale</a>*(<a class="code hl_variable" href="dgtalCalculus-bunny_8cpp.html#ae3ccdba7d575baf979261b4c02a6b9bb">surfmesh</a>.position(v)[0]))*(<a class="code hl_variable" href="dgtalCalculus-bunny_8cpp.html#a1d28dec57cce925ad92342891bd71e7c">scale</a>*<a class="code hl_variable" href="dgtalCalculus-bunny_8cpp.html#ae3ccdba7d575baf979261b4c02a6b9bb">surfmesh</a>.position(v)[1]);};</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;e: boundaryEdges)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">auto</span> adjVertices = <a class="code hl_variable" href="dgtalCalculus-bunny_8cpp.html#ae3ccdba7d575baf979261b4c02a6b9bb">surfmesh</a>.edgeVertices(e);</div>
<div class="line">    g(adjVertices.first)  = pihVertex(adjVertices.first);</div>
<div class="line">    g(adjVertices.second) = pihVertex(adjVertices.second);</div>
<div class="line">    b(adjVertices.first)  = 1;</div>
<div class="line">    b(adjVertices.second) = 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Solve Δu=0 with g as boundary conditions</span></div>
<div class="line">  PolyDEC::Solver solver;</div>
<div class="line">  PolyDEC::SparseMatrix L_dirichlet = DC::dirichletOperator( <a class="code hl_enumvalue" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ad20caec3b48a1eef164cb4ca81ba2587">L</a>, b );</div>
<div class="line">  solver.compute( L_dirichlet );</div>
<div class="line">  ASSERT(solver.info()==Eigen::Success);</div>
<div class="line">  PolyDEC::Form g_dirichlet = DC::dirichletVector( <a class="code hl_enumvalue" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49ad20caec3b48a1eef164cb4ca81ba2587">L</a>, g, b, g );</div>
<div class="line">  PolyDEC::Form x_dirichlet = solver.solve( g_dirichlet );</div>
<div class="line">  PolyDEC::Form u = DC::dirichletSolution( x_dirichlet, b, g );</div>
</div><!-- fragment --><p>Leading to the following results (see <a class="el" href="dgtalCalculus-poisson_8cpp.html">dgtalCalculus-poisson.cpp</a>):</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><a class="el" href="exampleMaximalSegmentSliceEstimation_8cpp.html#a86f9b721e4e72a3388a69cb2ed596f8f">Surface</a>  </th><th class="markdownTableHeadNone">Boundary condition \( g\)  </th><th class="markdownTableHeadNone">Solution \( u \)  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><div class="image">
<img src="poisson-surf.png" alt=""/>
</div>
  </td><td class="markdownTableBodyNone"><div class="image">
<img src="poisson-g.png" alt=""/>
</div>
  </td><td class="markdownTableBodyNone"><div class="image">
<img src="poisson-u.png" alt=""/>
</div>
  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><div class="image">
<img src="bunny-init.png" alt=""/>
</div>
  </td><td class="markdownTableBodyNone"><div class="image">
<img src="bunny-g.png" alt=""/>
</div>
  </td><td class="markdownTableBodyNone"><div class="image">
<img src="bunny-u.png" alt=""/>
</div>
  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><div class="image">
<img src="cat-init.png" alt=""/>
</div>
  </td><td class="markdownTableBodyNone"><div class="image">
<img src="cat-g.png" alt=""/>
</div>
  </td><td class="markdownTableBodyNone"><div class="image">
<img src="cat-u.png" alt=""/>
</div>
  </td></tr>
</table>
<h2 class="doxsection"><a class="anchor" id="Global"></a>
Vector Calculus</h2>
<p>Global <a class="el" href="classDGtal_1_1SpaceND.html">Vector</a> Laplace/Poisson problems can also be solved by the same way, using instead <a class="el" href="classDGtal_1_1PolygonalCalculus.html#af370c9e0153fd851a46ed930d9179ee2">PolygonalCalculus&lt;SurfMesh&gt;::globalConnectionLaplace()</a> and <a class="el" href="classDGtal_1_1PolygonalCalculus.html#a8d87e96e74d93e9e61f5686aa62e3c6a">PolygonalCalculus&lt;SurfMesh&gt;::doubledGlobalLumpedMassMatrix()</a>. One can find examples of such use in the <a class="el" href="classDGtal_1_1VectorsInHeat.html">VectorsInHeat</a> class.</p>
<h1 class="doxsection"><a class="anchor" id="sectMisc"></a>
Miscellaneous</h1>
<h2 class="doxsection"><a class="anchor" id="sectPolygonalCalculusHP"></a>
Cache mechanisms and high-performance computing</h2>
<p>The <a class="el" href="classDGtal_1_1PolygonalCalculus.html" title="Implements differential operators on polygonal surfaces from degoes2020discrete.">PolygonalCalculus</a> class has two cache mechanisms:</p>
<ul>
<li>An external cache strategy to store a given operator into a compact container. Typical use case is when the user wants to precompute a given operator, store it and efficiently reuse it while iterating over the faces. We detail this construction below.</li>
<li>The second one is a global internal cache strategy that will store <b>all</b> per face operators on the fly. In that case, each operator returning a <a class="el" href="testHeatLaplace_8cpp.html#ac5e355806c1c5ae35fbd16c24003bba3">DenseMatrix</a> is stored in a cache the first time the <span class="tt">calculus.operator(f)</span> is called. Typical use case is when the user wants to use many times a large set of different operators. To enable this strategy, you can use the <span class="tt">calculus.enableInternalGlobalCache()</span>, or from the last parameter of the class constructor (boolean set to true). E.g. <div class="fragment"><div class="line">PolygonalCalculus&lt;SH3::RealPoint,SH3::RealVector&gt; <a class="code hl_variable" href="dgtalCalculus-geodesic_8cpp.html#a4e9d205fb8308b3d07478e48bf63308c">calculus</a>(<a class="code hl_variable" href="dgtalCalculus-bunny_8cpp.html#ae3ccdba7d575baf979261b4c02a6b9bb">surfmesh</a>,<span class="keyword">true</span>);  <span class="comment">//global internal cache enabled.</span></div>
</div><!-- fragment --> By default, this behavior is disabled as it is memory expensive (all operators are explicitly stored when used for the first time), and may not have a huge running time impact for some applications. An example is given in the <a class="el" href="dgtalCalculus-bunny_8cpp.html">dgtalCalculus-bunny.cpp</a>. Once enabled, the class API remains the same, everything is transperent to the user.</li>
</ul>
<p>We describe here the first external cache strategy. For the sake of readability, each operator has been implemented implicitly. For example, the <em>M</em> <em>operator</em> per face is given by </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="testHeatLaplace_8cpp.html#ac5e355806c1c5ae35fbd16c24003bba3">DenseMatrix</a> M(<span class="keyword">const</span> <a class="code hl_typedef" href="testTriangulatedSurface_8cpp.html#aa7e89e659ae870a9963bb6109a53da62">Face</a> f, <span class="keyword">const</span> <span class="keywordtype">double</span> lambda=1.0)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keyword">auto</span> Uf=sharp(f);</div>
<div class="line">  <span class="keyword">auto</span> Pf=P(f);</div>
<div class="line">  <span class="keywordflow">return</span> faceArea(f) * Uf.transpose()*Uf + lambda * Pf.transpose()*Pf;</div>
<div class="line">}</div>
<div class="ttc" id="atestHeatLaplace_8cpp_html_ac5e355806c1c5ae35fbd16c24003bba3"><div class="ttname"><a href="testHeatLaplace_8cpp.html#ac5e355806c1c5ae35fbd16c24003bba3">DenseMatrix</a></div><div class="ttdeci">EigenLinearAlgebraBackend::DenseMatrix DenseMatrix</div><div class="ttdef"><b>Definition</b> <a href="testHeatLaplace_8cpp_source.html#l00051">testHeatLaplace.cpp:51</a></div></div>
<div class="ttc" id="atestTriangulatedSurface_8cpp_html_aa7e89e659ae870a9963bb6109a53da62"><div class="ttname"><a href="testTriangulatedSurface_8cpp.html#aa7e89e659ae870a9963bb6109a53da62">Face</a></div><div class="ttdeci">TriMesh::Face Face</div><div class="ttdef"><b>Definition</b> <a href="testTriangulatedSurface_8cpp_source.html#l00056">testTriangulatedSurface.cpp:56</a></div></div>
</div><!-- fragment --><p> which could be time consuming as the internal operators may be computed several times.</p>
<p>For high performance computations, we provide a generic cache mechanism to explicitly store all per face operators of a surface mesh (stored in a random access container).</p>
<p><a class="el" href="structA.html">A</a> typical usage is </p><div class="fragment"><div class="line"><span class="keyword">auto</span> cacheSharp    = getOperatorCacheMatrix( [&amp;](<a class="code hl_typedef" href="testTriangulatedSurface_8cpp.html#aa7e89e659ae870a9963bb6109a53da62">Face</a> f){ <span class="keywordflow">return</span>(<a class="code hl_variable" href="dgtalCalculus-geodesic_8cpp.html#a4e9d205fb8308b3d07478e48bf63308c">calculus</a>.sharp(f);} );</div>
<div class="line"><span class="keyword">auto</span> cachefaceArea = getOperatorCacheMatrix( [&amp;](<a class="code hl_typedef" href="testTriangulatedSurface_8cpp.html#aa7e89e659ae870a9963bb6109a53da62">Face</a> f){ <span class="keywordflow">return</span>(<a class="code hl_variable" href="dgtalCalculus-geodesic_8cpp.html#a4e9d205fb8308b3d07478e48bf63308c">calculus</a>.faceArea(f);} );</div>
<div class="line"><span class="keyword">auto</span> cacheP        = getOperatorCacheMatrix( [&amp;](<a class="code hl_typedef" href="testTriangulatedSurface_8cpp.html#aa7e89e659ae870a9963bb6109a53da62">Face</a> f){ <span class="keywordflow">return</span>(<a class="code hl_variable" href="dgtalCalculus-geodesic_8cpp.html#a4e9d205fb8308b3d07478e48bf63308c">calculus</a>.P(f);} );</div>
</div><!-- fragment --><p>Then, cached operators can be accessed and combined: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> Mf =   cachefaceArea[f] * cacheU[f].transpose()*cacheU[f] + lambda * cacheP[f].transpose() * cacheP[f];</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="index.html">DGtal - Digital Geometry Tools and Algorithms Library.</a></li><li class="navelem"><a href="packageDEC.html">DEC package</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for DGtal by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
