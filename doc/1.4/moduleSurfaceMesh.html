<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Surface mesh data structure for representing manifold or non-manifold polygonal surfaces in R3</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;1.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('moduleSurfaceMesh.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Surface mesh data structure for representing manifold or non-manifold polygonal surfaces in R3</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#SurfMesh_sec1">Creating a surface mesh</a></li>
<li class="level1"><a href="#SurfMesh_sec2">Topological relations within a surface mesh</a></li>
<li class="level1"><a href="#SurfMesh_sec3">A surface mesh is a graph</a></li>
<li class="level1"><a href="#SurfMesh_sec4">Getting manifold, boundary and non-manifold parts</a></li>
<li class="level1"><a href="#SurfMesh_sec5">Geometric positions and normals, and other information associated to cells</a></li>
<li class="level1"><a href="#SurfMesh_sec6">Further geometric services</a></li>
<li class="level1"><a href="#SurfMesh_sec7">Conversion and output to OBJ file format</a></li>
<li class="level1"><a href="#SurfMesh_sec8">Flipping edges</a></li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Jacques-Olivier Lachaud</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1</dd></dl>
<p>Part of <a class="el" href="packageShapes.html">Shapes package</a></p>
<p>This part of the manual describes how to represent and manipulate generic polygonal surfaces embedded in \( \mathbb{R}^3 \). The class <a class="el" href="structDGtal_1_1SurfaceMesh.html">SurfaceMesh</a> proposes an index-based data structure that encodes all topological relations between vertices, edges and faces, even if the mesh presents some non manifold places (like 3 triangles tied along the same edge). Input/output operations to and from OBJ files are provided through classes <a class="el" href="structDGtal_1_1SurfaceMeshReader.html">SurfaceMeshReader</a> and <a class="el" href="structDGtal_1_1SurfaceMeshWriter.html">SurfaceMeshWriter</a>. Creation of classical surface 3D shapes (sphere, torus, Schwarz lantern) with groundtruth geometry is provided in <a class="el" href="structDGtal_1_1SurfaceMeshHelper.html">SurfaceMeshHelper</a>.</p>
<p>The following programs are related to this documentation: </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="testSurfaceMesh_8cpp.html">testSurfaceMesh.cpp</a>, <a class="el" href="exampleSurfaceMesh_8cpp.html" title="An example file for SurfaceMesh in 3D.">exampleSurfaceMesh.cpp</a></dd></dl>
<p>The useful includes are: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/shapes/SurfaceMesh.h&quot;</span>           <span class="comment">// main class</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/shapes/SurfaceMeshHelper.h&quot;</span>     <span class="comment">// creation/conversion</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/io/readers/SurfaceMeshReader.h&quot;</span> <span class="comment">// input from OBJ file</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/io/readers/SurfaceMeshWriter.h&quot;</span> <span class="comment">// output to OBJ file</span></div>
</div><!-- fragment --><h1><a class="anchor" id="SurfMesh_sec1"></a>
Creating a surface mesh</h1>
<p>A surface mesh (class <a class="el" href="structDGtal_1_1SurfaceMesh.html">SurfaceMesh</a>) is a template class parameterized by the types chosen for 3D points and 3D vectors. A common choice is <code><a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a>&lt; double, 3 &gt;</code> for both, or equivalently <code><a class="el" href="namespaceDGtal_1_1Z3i.html#a5f087066515ecd33cefd7bd080ef8114">Z3i::RealPoint</a></code> and <code><a class="el" href="namespaceDGtal_1_1Z3i.html#a5576ca14b13483060ec716f17bf6d81d">Z3i::RealVector</a></code>. Although the topological part of the class does not impose a 3D embedding, the class <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> imposes it since its target is 3D geometry processing. Indeed some geometric operations like computing normals from positions or i/o to OBJ format have meaning only in 3D.</p>
<p>First, write the following typedefs:</p>
<div class="fragment"><div class="line">  <span class="comment">// The following typedefs are useful</span></div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_struct" href="structDGtal_1_1SurfaceMesh.html">SurfaceMesh&lt; RealPoint, RealVector &gt;</a>       <a class="code hl_typedef" href="dgtalCalculus-bunny_8cpp.html#a0da7de0f9d769404c143f3d032eaa496">SurfMesh</a>;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_struct" href="structDGtal_1_1SurfaceMeshHelper.html">SurfaceMeshHelper&lt; RealPoint, RealVector &gt;</a> Helper;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_typedef" href="structDGtal_1_1SurfaceMesh.html#a26bfbda7e780e4104ac3781dfbc785df">SurfMesh::Vertices</a>                         <a class="code hl_typedef" href="fullConvexitySphereGeodesics_8cpp.html#a9b69eb98bda12d4cfd17ccc15a223abc">Vertices</a>;</div>
</div><!-- fragment --><p>Then, there are several ways for creating a surface mesh (see <a class="el" href="exampleSurfaceMesh_8cpp.html">exampleSurfaceMesh.cpp</a> for several examples):</p>
<ul>
<li>by hand with a range of points for each vertex and a range of indices for of each polygonal face (see <a class="el" href="structDGtal_1_1SurfaceMesh.html#a5ef42406f47298de32220d127c91dfa3">SurfaceMesh::SurfaceMesh</a> and <a class="el" href="structDGtal_1_1SurfaceMesh.html#ac37c605467b040d20fe242f941044cba">SurfaceMesh::init</a>).</li>
</ul>
<div class="fragment"><div class="line">  std::vector&lt; RealPoint &gt; positions =</div>
<div class="line">    { { 0, 0, 5 }, { 1, 1, 3 }, { -1, 1, 3 }, { -1, -1, 3 }, { 1, -1, 3 } };</div>
<div class="line">  std::vector&lt; Vertices  &gt; faces =</div>
<div class="line">    { { 0, 1, 2 }, { 0, 2, 3 }, { 0, 3, 4 }, { 0, 4, 1 }, { 4, 3, 2, 1 } };</div>
<div class="line">  <span class="keyword">auto</span> pyramid_mesh = <a class="code hl_typedef" href="dgtalCalculus-bunny_8cpp.html#a0da7de0f9d769404c143f3d032eaa496">SurfMesh</a>( positions.cbegin(), positions.cend(),</div>
<div class="line">                                faces.cbegin(), faces.cend() );</div>
</div><!-- fragment --><ul>
<li>by reading an OBJ (see <a class="el" href="structDGtal_1_1SurfaceMeshReader.html#a609dcf8e4bfb573e2b8c12b8beda388b">SurfaceMeshReader::readOBJ</a>).</li>
</ul>
<div class="fragment"><div class="line">  <a class="code hl_typedef" href="dgtalCalculus-bunny_8cpp.html#a0da7de0f9d769404c143f3d032eaa496">SurfMesh</a>    smesh;</div>
<div class="line">  std::string S = examplesPath + <span class="stringliteral">&quot;samples/spot.obj&quot;</span>;</div>
<div class="line">  std::ifstream input( S.c_str() );</div>
<div class="line">  <span class="keywordtype">bool</span> ok_read  =  <a class="code hl_struct" href="structDGtal_1_1SurfaceMeshReader.html">SurfaceMeshReader&lt; RealPoint, RealVector &gt;::readOBJ</a>( input, smesh );</div>
<div class="line">  input.close();</div>
<div class="line">  <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#a9b36f5ab76b1945c8156cb4dba780bfb">info</a>() &lt;&lt; <span class="stringliteral">&quot;Read &quot;</span> &lt;&lt; ( ok_read ? <span class="stringliteral">&quot;OK&quot;</span> : <span class="stringliteral">&quot;ERROR&quot;</span> )</div>
<div class="line">               &lt;&lt; <span class="stringliteral">&quot; mesh=&quot;</span> &lt;&lt; smesh &lt;&lt; std::endl;</div>
</div><!-- fragment --><ul>
<li>by using classical predefined surfaces (see <a class="el" href="structDGtal_1_1SurfaceMeshHelper.html#aaefdf1b72df3d261c2e08f0315feb4f8">SurfaceMeshHelper::makeSphere</a>, <a class="el" href="structDGtal_1_1SurfaceMeshHelper.html#abf505fb6da1221e624eac901e9a56362">SurfaceMeshHelper::makeTorus</a>, <a class="el" href="structDGtal_1_1SurfaceMeshHelper.html#abfedc0b0759677aab667ce60d6dfa5b8">SurfaceMeshHelper::makeLantern</a>).</li>
</ul>
<div class="fragment"><div class="line">  <span class="keyword">auto</span> torus_mesh = Helper::makeTorus</div>
<div class="line">    ( 2.5, 0.5, <a class="code hl_typedef" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a> { 0.0, 0.0, 0.0 }, 40, 40, 0, Helper::NormalsType::NO_NORMALS );</div>
</div><!-- fragment --><div class="image">
<img src="exampleSurfaceMesh.jpg" alt=""/>
<div class="caption">
Creating surface meshes from OBJ file, by specifying vertex/face information or predefined shapes</div></div>
<h1><a class="anchor" id="SurfMesh_sec2"></a>
Topological relations within a surface mesh</h1>
<p>All topological relations are precomputed as static arrays in <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> class (which is thus not adapted to dynamic topological updates). You may access the number of cells with <a class="el" href="structDGtal_1_1SurfaceMesh.html#ad32cc734fe88ed61b14c03632d2cde31">SurfaceMesh::nbVertices</a>, <a class="el" href="structDGtal_1_1SurfaceMesh.html#aadc9198c62b1e9b19107f97dc2ddf006">SurfaceMesh::nbEdges</a>, <a class="el" href="structDGtal_1_1SurfaceMesh.html#aac6df23e1b3e15f57df733bb6db40a81">SurfaceMesh::nbFaces</a>. Note that edge indices corresponds to pairs of vertices (i,j) with i&lt;j.</p>
<p>You may ask for each vertex <em>v:</em> </p><ul>
<li>its range of incident faces with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a0791135bcf75d2a54e29d86b2f2f1878">SurfaceMesh::incidentFaces</a> (order not significant)</li>
<li>its range of neighbor vertices with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a772e4435f4146a3ae05592747007c362">SurfaceMesh::neighborVertices</a> (order not significant)</li>
</ul>
<p>You may ask for each face <em>f:</em> </p><ul>
<li>its range of incident vertices with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a8f9063bc2954ed10598cfd07576e5a77">SurfaceMesh::incidentVertices</a> (the order is significant: to each consecutive pair of vertices, there is a corresponding edge).</li>
<li>its range of neighbor faces with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a6d6cd2b6345fe3a61b77716a59e75acb">SurfaceMesh::neighborFaces</a> (order not significant)</li>
</ul>
<p>You may create an edge index with <a class="el" href="structDGtal_1_1SurfaceMesh.html#aca1088826624c5caeec89959e81c6fbf">SurfaceMesh::makeEdge</a>. If the two vertices (i,j) do not form an edge, then the returned index is <a class="el" href="structDGtal_1_1SurfaceMesh.html#aadc9198c62b1e9b19107f97dc2ddf006">SurfaceMesh::nbEdges</a>. Note that calling <code>makeEdge(i,j)</code> or <code>makeEdge(j,i)</code> returns always the same index, whether valid or invalid.</p>
<p>You may ask for each edge <em>e:</em> </p><ul>
<li>its two incident vertices with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a8f9063bc2954ed10598cfd07576e5a77">SurfaceMesh::incidentVertices</a>, as pair (i,j) with (i&lt;j).</li>
<li>its range of bordering faces with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a55bbe5d7c0baf3664b3d26329207359b">SurfaceMesh::edgeFaces</a> (they can be incident clockwise or counterclockwise)</li>
<li>its range of left bordering faces with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a8c9935e17bb55bc47a14d59cce2209f3">SurfaceMesh::edgeLeftFaces</a> (a face to its left, being defined ccw, means that the face is some <code>(..., i, j, ... )</code>)</li>
<li>its range of right bordering faces with <a class="el" href="structDGtal_1_1SurfaceMesh.html#aeb6362a8fb23be6a89f003b863ac1ad0">SurfaceMesh::edgeRightFaces</a> (a face to its left, being defined ccw, means that the face is some <code>(..., j, i, ... )</code>)</li>
</ul>
<p>All the preceding methods have global variants returning all incident faces, all incident vertices, etc: <a class="el" href="structDGtal_1_1SurfaceMesh.html#a1d26de65d241cd814ab6428f0db6f2d5">SurfaceMesh::allIncidentFaces</a>, <a class="el" href="structDGtal_1_1SurfaceMesh.html#ac0b250bd805c955a7053fda23f16c9e7">SurfaceMesh::allIncidentVertices</a>, <a class="el" href="structDGtal_1_1SurfaceMesh.html#afbd458a4db55964a5d4b38f638b3c2cd">SurfaceMesh::allNeighborFaces</a>, <a class="el" href="structDGtal_1_1SurfaceMesh.html#abee85e97e7fdbce4e387aa169782cb75">SurfaceMesh::allNeighborVertices</a>, <a class="el" href="structDGtal_1_1SurfaceMesh.html#af3b3828f22f2622e3fa576a38a1a28af">SurfaceMesh::allEdgeFaces</a>, <a class="el" href="structDGtal_1_1SurfaceMesh.html#ab8ee0f6e097a294b5b8843d8345499cb">SurfaceMesh::allEdgeLeftFaces</a>, <a class="el" href="structDGtal_1_1SurfaceMesh.html#ae5ef011b758dee2b46e2020a23c8dc21">SurfaceMesh::allEdgeRightFaces</a>.</p>
<p>Since vertices/edges/faces are indices, visiting them is simply a loop from 0 (included) till <a class="el" href="structDGtal_1_1SurfaceMesh.html#ad32cc734fe88ed61b14c03632d2cde31">SurfaceMesh::nbVertices</a> / <a class="el" href="structDGtal_1_1SurfaceMesh.html#aadc9198c62b1e9b19107f97dc2ddf006">SurfaceMesh::nbEdges</a> / <a class="el" href="structDGtal_1_1SurfaceMesh.html#aac6df23e1b3e15f57df733bb6db40a81">SurfaceMesh::nbFaces</a> (all excluded).</p>
<h1><a class="anchor" id="SurfMesh_sec3"></a>
A surface mesh is a graph</h1>
<p>Class <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> is a model of <a class="el" href="structDGtal_1_1concepts_1_1CUndirectedSimpleGraph.html" title="Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not neces...">concepts::CUndirectedSimpleGraph</a> (see also moduleGraphDefinitions). Hence you can for instance perform a breadth first traversal on its vertices.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/shapes/SurfaceMesh.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/graph/BreadthFirstVisitor.h&quot;</span></div>
<div class="line">...</div>
<div class="line">typedef SurfaceMesh&lt; RealPoint, RealVector &gt; <a class="code hl_typedef" href="dgtalCalculus-bunny_8cpp.html#a0da7de0f9d769404c143f3d032eaa496">SurfMesh</a>;</div>
<div class="line"><a class="code hl_typedef" href="dgtalCalculus-bunny_8cpp.html#a0da7de0f9d769404c143f3d032eaa496">SurfMesh</a> smesh;</div>
<div class="ttc" id="adgtalCalculus-bunny_8cpp_html_a0da7de0f9d769404c143f3d032eaa496"><div class="ttname"><a href="dgtalCalculus-bunny_8cpp.html#a0da7de0f9d769404c143f3d032eaa496">SurfMesh</a></div><div class="ttdeci">SurfaceMesh&lt; RealPoint, RealVector &gt; SurfMesh</div><div class="ttdef"><b>Definition</b> <a href="dgtalCalculus-bunny_8cpp_source.html#l00052">dgtalCalculus-bunny.cpp:52</a></div></div>
</div><!-- fragment --><div class="fragment"><div class="line">  <a class="code hl_class" href="classDGtal_1_1BreadthFirstVisitor.html">BreadthFirstVisitor&lt; SurfMesh &gt;</a> visitor( smesh, 0 );</div>
<div class="line">  std::vector&lt;double&gt;             distances( smesh.<a class="code hl_function" href="structDGtal_1_1SurfaceMesh.html#ad32cc734fe88ed61b14c03632d2cde31">nbVertices</a>() );</div>
<div class="line">  <span class="keywordtype">double</span> biggest_d = 0.0;</div>
<div class="line">  <span class="keywordflow">while</span> ( ! visitor.finished() )</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">auto</span> v = visitor.current().first;  <span class="comment">// current vertex</span></div>
<div class="line">      <span class="keyword">auto</span> d = visitor.current().second; <span class="comment">// current distance</span></div>
<div class="line">      biggest_d      = (double) d;</div>
<div class="line">      distances[ v ] = biggest_d;</div>
<div class="line">      visitor.expand();</div>
<div class="line">    }</div>
</div><!-- fragment --><h1><a class="anchor" id="SurfMesh_sec4"></a>
Getting manifold, boundary and non-manifold parts</h1>
<p><a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> can compute range of edges that have the same topology.</p>
<ul>
<li><a class="el" href="structDGtal_1_1SurfaceMesh.html#ab053beb5757cc26b5c0dd9c6053eeb42">SurfaceMesh::computeManifoldBoundaryEdges</a> returns the edges that lie on the boundary of the mesh, i.e. they have only one incident face.</li>
<li><a class="el" href="structDGtal_1_1SurfaceMesh.html#a2bdf5511bb00776a160aed5f8589af80">SurfaceMesh::computeManifoldInnerEdges</a> returns the edges that lie on the inside of the mesh, with two incident faces, consistently oriented or not.</li>
<li><a class="el" href="structDGtal_1_1SurfaceMesh.html#ab0a56f6242bce2ace7a31ad35b583252">SurfaceMesh::computeManifoldInnerConsistentEdges</a> returns the edges that lie on the inside of the mesh, with consistent local orientation, i.e. they have one left incident face, and one right incident face.</li>
<li><a class="el" href="structDGtal_1_1SurfaceMesh.html#a18dfbbad425584b1a4ba60559097a05d">SurfaceMesh::computeManifoldInnerUnconsistentEdges</a> returns the edges that have two incident faces, but not correctly oriented, i.e. they may have two left incident faces and no right incident face, or two right incident faces and no left incident face.</li>
<li><a class="el" href="structDGtal_1_1SurfaceMesh.html#add89b6762bb7150e760351ca110d28f8">SurfaceMesh::computeNonManifoldEdges</a> returns the edges that are non manifold, i.e. neither boundary or inner edges: they may have more than two incident faces, or two left incident faces for instance.</li>
</ul>
<p>Locating non manifold vertices (like pinched vertices) requires more work and is not implemented.</p>
<h1><a class="anchor" id="SurfMesh_sec5"></a>
Geometric positions and normals, and other information associated to cells</h1>
<p>Vertex positions can be accessed and modified through methods <a class="el" href="structDGtal_1_1SurfaceMesh.html#aa5ae2a11e6928be4cd50896c078bf715">SurfaceMesh::positions</a>, or <a class="el" href="structDGtal_1_1SurfaceMesh.html#acdea18eab52711e7f56a02b06f55532d">SurfaceMesh::position</a> with a given vertex index.</p>
<p>You may associate normal vectors to the mesh as follows:</p><ul>
<li>to vertices with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a2380b33954d4706f4e2d6643be4b89bf">SurfaceMesh::setVertexNormals</a></li>
<li>to faces with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a9c28be28fa07b724ee6604cc88177859">SurfaceMesh::setFaceNormals</a></li>
<li>to faces from vertex positions with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a51bb91e3a8f3296e4e3a5062bc272f91">SurfaceMesh::computeFaceNormalsFromPositions</a></li>
<li>from faces to vertices with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a66173c8fdc013e2b41b60669b268baf4">SurfaceMesh::computeVertexNormalsFromFaceNormals</a> or <a class="el" href="structDGtal_1_1SurfaceMesh.html#a95f5eaf3fcfe06f2644bd2fdf98f527a">SurfaceMesh::computeVertexNormalsFromFaceNormalsWithMaxWeights</a></li>
<li>from vertices to faces with <a class="el" href="structDGtal_1_1SurfaceMesh.html#ad6030c53a9979e2ff9ec4fb0da4a56a8">SurfaceMesh::computeFaceNormalsFromVertexNormals</a></li>
</ul>
<p>Normals are then accessed with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a3b5a938e89cf94403b3b8b5be030ba21">SurfaceMesh::vertexNormals</a> for vertices, <a class="el" href="structDGtal_1_1SurfaceMesh.html#a917039b673fc58dbbfefa63dfc66fa2f">SurfaceMesh::faceNormals</a> for faces, or per element with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a17ee1c96c36568999f269e28c43637c1">SurfaceMesh::vertexNormal</a> and <a class="el" href="structDGtal_1_1SurfaceMesh.html#a18d217ed94c08d4eba35a4510ec22c9c">SurfaceMesh::faceNormal</a>.</p>
<p>More generally, you can transfer (by averaging) vector of values:</p>
<ul>
<li>from faces to vertices with <a class="el" href="structDGtal_1_1SurfaceMesh.html#aa67afb253b01142db81b3b2f316f9c1e">SurfaceMesh::computeVertexValuesFromFaceValues</a> or <a class="el" href="structDGtal_1_1SurfaceMesh.html#a9459015fd28afefe6a2690bdfed24ae0">SurfaceMesh::computeVertexUnitVectorsFromFaceUnitVectors</a> for unit vectors</li>
<li>from vertices to faces with <a class="el" href="structDGtal_1_1SurfaceMesh.html#ad14b4c6c410622ff975b1ca045aa6b81">SurfaceMesh::computeFaceValuesFromVertexValues</a> or <a class="el" href="structDGtal_1_1SurfaceMesh.html#ad7268269cd870e5c67609af0a72a5166">SurfaceMesh::computeFaceUnitVectorsFromVertexUnitVectors</a> for unit vectors</li>
</ul>
<h1><a class="anchor" id="SurfMesh_sec6"></a>
Further geometric services</h1>
<p>The following local geometric services are provided:</p>
<ul>
<li>the area of a face with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a4ecb750380b28e683894b7147e286717">SurfaceMesh::faceArea</a></li>
<li>the centroid of a face with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a319ebe4a9146218ec828a436eabce6c9">SurfaceMesh::faceCentroid</a></li>
<li>the centroid of an edge with <a class="el" href="structDGtal_1_1SurfaceMesh.html#ad47116b56e00f134f45715432660180e">SurfaceMesh::edgeCentroid</a></li>
<li>the average distance between the centroid of face and its vertices with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a468a554c9e453dfd4b7eab5e4d585ed4">SurfaceMesh::localWindow</a></li>
<li>the classical Max's weights for each incident face to a vertex with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a40da91badf55d7dca689038c9e7f2022">SurfaceMesh::getMaxWeights</a> (see <a class="el" href="structDGtal_1_1SurfaceMesh.html#a95f5eaf3fcfe06f2644bd2fdf98f527a">SurfaceMesh::computeVertexNormalsFromFaceNormalsWithMaxWeights</a>)</li>
<li>the vector of weighted faces comprising all the faces included in some ball with <a class="el" href="structDGtal_1_1SurfaceMesh.html#abc25df3bb3a910aeb402817d30a6713c">SurfaceMesh::computeFacesInclusionsInBall</a>, where the weights represent the inclusion ratio of each face in the given ball (from 0, empty intersection, to 1, completely included).</li>
<li>the vectors of weighted cells comprising all the cells included in some ball with <a class="el" href="structDGtal_1_1SurfaceMesh.html#aacf5e524ff895c5dddb7d67feabada10">SurfaceMesh::computeCellsInclusionsInBall</a>, where the weights represent the inclusion ratio (from 0, empty intersection, to 1, completely included).</li>
</ul>
<p>The following global geometric services are provided:</p>
<ul>
<li>the average of the length of edges with <a class="el" href="structDGtal_1_1SurfaceMesh.html#af39993de1b39d4e225742bc79502cafa">SurfaceMesh::averageEdgeLength</a></li>
</ul>
<p>You may also perturbate the mesh positions with uniform or non uniform random noise: with <a class="el" href="structDGtal_1_1SurfaceMesh.html#a48ea9dbdb41f6d76f3a7d386ef7ab6ba">SurfaceMesh::perturbateWithUniformRandomNoise</a> and <a class="el" href="structDGtal_1_1SurfaceMesh.html#a2094a7663c3d875c2966561c888a8f53">SurfaceMesh::perturbateWithAdaptiveUniformRandomNoise</a>;</p>
<h1><a class="anchor" id="SurfMesh_sec7"></a>
Conversion and output to OBJ file format</h1>
<p>You can convert a <a class="el" href="structDGtal_1_1SurfaceMesh.html">SurfaceMesh</a> to a <a class="el" href="classDGtal_1_1Mesh.html">Mesh</a> object simply by calling <a class="el" href="classDGtal_1_1MeshHelpers.html#a94060e366b4dc1388cac915973a5ab3a">MeshHelpers::surfaceMesh2Mesh</a>.</p>
<p>You can also output OBJ file (if available, with vertex normal information) using class <a class="el" href="structDGtal_1_1SurfaceMeshWriter.html#a2d786cc76abdacdbabaa75f9518cbf72">SurfaceMeshWriter::writeOBJ</a>, with some specialization allowing you to color faces. Edge lines and iso-lines can also be output as OBJ in same class.</p>
<p>The snippet below shows how to output the distances computed in <a class="el" href="#SurfMesh_sec3">A surface mesh is a graph</a> as a surface colored per face with three isolines corresponding to relative distances 0.25, 0.5 and 0.75.</p>
<div class="fragment"><div class="line">  <span class="comment">// Displaying faces colored by their distance to vertex 0.</span></div>
<div class="line">  <span class="keyword">auto</span> face_distances = smesh.<a class="code hl_function" href="structDGtal_1_1SurfaceMesh.html#ad14b4c6c410622ff975b1ca045aa6b81">computeFaceValuesFromVertexValues</a>( distances );</div>
<div class="line">  <span class="keyword">auto</span> cmap = <a class="code hl_class" href="classDGtal_1_1GradientColorMap.html">GradientColorMap&lt; double &gt;</a>( 0.0, biggest_d, CMAP_JET );</div>
<div class="line">  std::vector&lt;Color&gt; face_colors( smesh.<a class="code hl_function" href="structDGtal_1_1SurfaceMesh.html#aac6df23e1b3e15f57df733bb6db40a81">nbFaces</a>() );</div>
<div class="line">  <span class="keywordflow">for</span> ( <a class="code hl_typedef" href="structDGtal_1_1SurfaceMesh.html#aa1fa77b6fe00fc9e213be5e71ecf282a">SurfMesh::Face</a> j = 0; j &lt; smesh.<a class="code hl_function" href="structDGtal_1_1SurfaceMesh.html#aac6df23e1b3e15f57df733bb6db40a81">nbFaces</a>(); ++j )</div>
<div class="line">    face_colors[ j ] = cmap( face_distances[ j ] );      </div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_struct" href="structDGtal_1_1SurfaceMeshWriter.html">SurfaceMeshWriter&lt; RealPoint, RealVector &gt;</a> Writer;</div>
<div class="line">  Writer::writeOBJ( <span class="stringliteral">&quot;spot-bft.obj&quot;</span>, smesh, face_colors );</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Displaying three isolines.</span></div>
<div class="line">  Writer::writeIsoLinesOBJ( <span class="stringliteral">&quot;spot-iso-0_25.obj&quot;</span>, smesh,</div>
<div class="line">                            face_distances, distances, distances.back() * 0.25, 0.2 );</div>
<div class="line">  Writer::writeIsoLinesOBJ( <span class="stringliteral">&quot;spot-iso-0_5.obj&quot;</span>,  smesh,</div>
<div class="line">                            face_distances, distances, distances.back() * 0.5,  0.2 );</div>
<div class="line">  Writer::writeIsoLinesOBJ( <span class="stringliteral">&quot;spot-iso-0_75.obj&quot;</span>, smesh,</div>
<div class="line">                            face_distances, distances, distances.back() * 0.75, 0.2 );</div>
</div><!-- fragment --><div class="image">
<img src="spot-bft-isolines.png" alt=""/>
<div class="caption">
SurfaceMesh faces colored according to distance to bluest vertex and three isodistance lines</div></div>
<h1><a class="anchor" id="SurfMesh_sec8"></a>
Flipping edges</h1>
<p>Since 1.4, you may modify a <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> through flips. Only (oriented) edges that are incident to a triangle on the right and a triangle on the left are (topologically) flippable. These two triangles form then a quadrilateral, and the edge is one diagonal of this quadrilateral. Flipping the edge means that the quadrilateral is now split only the other diagonal. Flipping twice the same edge restores the original mesh. Flipping edges has meaning only on orientable parts of a surface.</p>
<p>The following methods are useful for flipping an edge:</p><ul>
<li><a class="el" href="structDGtal_1_1SurfaceMesh.html#af7efd79cbe2aa133b448e361ecf9d338">SurfaceMesh::isFlippable</a> indicates if a given edge is flippable. An edge is (topologically) flippable iff:<ol type="1">
<li>it does not lie on the boundary,</li>
<li>it is bordered by two triangles, one that to its right, one to its left,</li>
<li>the two other vertices of the quad are not already neighbors,</li>
<li>the edge is not bordered by the same two triangles, in opposite orientation.</li>
</ol>
</li>
<li><p class="startli"><a class="el" href="structDGtal_1_1SurfaceMesh.html#ab9f4e831f1077f18678609ff159bdae9">SurfaceMesh::flip</a> performs the flip on a flippable edge <code>e=(i,j)</code>. The flipped edge keeps the same index as the original edge. You may choose whether or not you update locally the face normals.</p>
<pre class="fragment">           l                   l
          / \                 /|\
         /   \               / | \
        /     \             /  |  \
       /   lf  \           /   |   \
      /         \         /    |    \
     i --- e --- j  ==&gt;  i  lf e  rf j    if k &lt; l otherwise rf and lf are swapped
      \         /         \    |    /
       \   rf  /           \   |   /
        \     /             \  |  /
         \   /               \ | /
          \ /                 \|/
           k                   k</pre><dl class="section note"><dt>Note</dt><dd>Almost all information is recomputed locally. Only vertex normals are not updated after a flip, as well as neighbor faces of faces are not recomputed. You may recompute face neighborhoods at the end of a sequence of flips by calling <a class="el" href="structDGtal_1_1SurfaceMesh.html#ae7ecdad2206789f6f0173e337b6eec82" title="Computes neighboring information.">SurfaceMesh::computeNeighbors</a>. You may for instance recompute vertex normals from face normals by a call to <a class="el" href="structDGtal_1_1SurfaceMesh.html#a66173c8fdc013e2b41b60669b268baf4">SurfaceMesh::computeVertexNormalsFromFaceNormals</a>.</dd></dl>
</li>
<li><a class="el" href="structDGtal_1_1SurfaceMesh.html#a7a402887bbcacc77400ac854dfce6716">SurfaceMesh::otherDiagonal</a> returns, given a flippable edge, the two other vertices of the quadrilateral. So in the flip example above, it returns (k,l) if k &lt; l or (l,k) otherwise.</li>
</ul>
<p>The following code builds a Schwarz lantern, and then flips all flippable edges that are longer than their flipped edge.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> PointVector&lt;3,double&gt;                      <a class="code hl_typedef" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a>;</div>
<div class="line"><span class="keyword">typedef</span> PointVector&lt;3,double&gt;                      RealVector;</div>
<div class="line"><span class="keyword">typedef</span> SurfaceMesh&lt; RealPoint, RealVector &gt;       PolygonMesh;</div>
<div class="line"><span class="keyword">typedef</span> SurfaceMeshHelper&lt; RealPoint, RealVector &gt; PolygonMeshHelper;</div>
<div class="line"><span class="keyword">typedef</span> SurfaceMeshWriter&lt; RealPoint, RealVector &gt; PolygonMeshWriter;</div>
<div class="line"><span class="keyword">typedef</span> PolygonMeshHelper::NormalsType             NormalsType;</div>
<div class="line"><span class="keyword">auto</span> meshLantern = PolygonMeshHelper::makeLantern( 3.0, 3.0, <a class="code hl_variable" href="classDGtal_1_1PointVector.html#acd6b03ecf112cf2ae8bae7b644164932">RealPoint::zero</a>,</div>
<div class="line">                                                   10, 10, NormalsType::NO_NORMALS );</div>
<div class="line">{</div>
<div class="line">  std::ofstream output( <span class="stringliteral">&quot;lantern.obj&quot;</span> );</div>
<div class="line">  <span class="keywordtype">bool</span> okw = PolygonMeshWriter::writeOBJ( output, meshLantern );</div>
<div class="line">  output.close();</div>
<div class="line">}</div>
<div class="line"><span class="keyword">auto</span> nb_flipped = 0;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp;   X = meshLantern.positions();</div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keyword">auto</span> e = 0; e &lt; meshLantern.nbEdges(); e++ )</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> ( meshLantern.isFlippable( e ) )</div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">auto</span>   ij    = meshLantern.edgeVertices ( e );</div>
<div class="line">        <span class="keyword">auto</span>   kl    = meshLantern.otherDiagonal( e );</div>
<div class="line">        <span class="keywordtype">double</span> l2_ij = ( X[ ij.first ] - X[ ij.second ] ).squaredNorm();</div>
<div class="line">        <span class="keywordtype">double</span> l2_kl = ( X[ kl.first ] - X[ kl.second ] ).squaredNorm();</div>
<div class="line">        <span class="keywordflow">if</span> ( l2_kl &lt; l2_ij )</div>
<div class="line">          {</div>
<div class="line">            meshLantern.flip( e, <span class="keyword">false</span> );</div>
<div class="line">            nb_flipped++;</div>
<div class="line">          }</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line">{</div>
<div class="line">  std::ofstream output( <span class="stringliteral">&quot;flipped-lantern.obj&quot;</span> );</div>
<div class="line">  <span class="keywordtype">bool</span> okw = PolygonMeshWriter::writeOBJ( output, meshLantern );</div>
<div class="line">  output.close();</div>
<div class="line">}</div>
<div class="ttc" id="aclassDGtal_1_1PointVector_html_acd6b03ecf112cf2ae8bae7b644164932"><div class="ttname"><a href="classDGtal_1_1PointVector.html#acd6b03ecf112cf2ae8bae7b644164932">DGtal::PointVector&lt; 3, double &gt;::zero</a></div><div class="ttdeci">static Self zero</div><div class="ttdef"><b>Definition</b> <a href="PointVector_8h_source.html#l01595">PointVector.h:1595</a></div></div>
<div class="ttc" id="atestTriangulatedSurface_8cpp_html_abb3595c097987c9d2c4f0cc1902df316"><div class="ttname"><a href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a></div><div class="ttdeci">PointVector&lt; 3, double &gt; RealPoint</div><div class="ttdef"><b>Definition</b> <a href="testTriangulatedSurface_8cpp_source.html#l00051">testTriangulatedSurface.cpp:51</a></div></div>
</div><!-- fragment --><table class="doxtable">
<tr>
<td><div class="image">
<img src="lantern.jpg" alt=""/>
<div class="caption">
Schwarz lantern before flip</div></div>
  </td><td><div class="image">
<img src="lantern-flipped.jpg" alt=""/>
<div class="caption">
Schwarz lantern after flip: a nicer cylinder</div></div>
   </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">DGtal - Digital Geometry Tools and Algorithms Library.</a></li><li class="navelem"><a class="el" href="packageShapes.html">Shapes package</a></li>
    <li class="footer">Generated on Mon Jun 10 2024 17:36:19 for DGtal by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
