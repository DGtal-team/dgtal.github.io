<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Digital surface regularization using the Shrouds algorithm</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;1.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('moduleShrouds.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Digital surface regularization using the Shrouds algorithm</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#moduleShrouds_sec1">Introduction</a></li>
<li class="level1"><a href="#moduleShrouds_sec2">Main usage with squared curvature energy</a></li>
<li class="level1"><a href="#moduleShrouds_other">Shrouds regularization with area and snake energy</a></li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Jacques-Olivier Lachaud</dd></dl>
<p>Part of the <a class="el" href="packageGeometry.html">Geometry package</a>.</p>
<p>This part of the manual describes classes and functions related to the regularization of digital surfaces using the "Shrouds" algorithm, by Nielson et al <a class="el" href="citelist.html#CITEREF_nielson2003shrouds">[92]</a>.</p>
<p>On binary 3D images, the "Shrouds" algorithm builds a smooth surface that separates the interior voxels from the exterior voxels. It starts from the (closed) digital surface that separates interior voxels from exterior voxels. The 3D smooth surface reconstruction problem is transformed into a series of 2D smooth contour reconstruction problems, by slicing the 3D volume (and thus the digital surface) with axis-align planes. Each contour is regularized to minimize its squared curvature and the separation property is obtained by forcing each vertex to lie on its unit edge joining an interior voxel to an exterior voxel (i.e. the edge that is dual to the surfel). The 2D problems are intertwined since each vertex is shared by two slices.</p>
<dl class="section note"><dt>Note</dt><dd>This method is limited to closed surface reconstruction, in opposition to the method presented in <a class="el" href="moduleRegularization.html">Digital surface regularization by normal vector alignment</a>.</dd></dl>
<p><b>Disclaimer</b>. This implementation is our interpretation of the work presented in <a class="el" href="citelist.html#CITEREF_nielson2003shrouds">[92]</a>, and tries to follow at best the ideas presented therein. However, a major part of the numerical resolution is not detailed. We have inferred a reasonable way of solving the fourth-order equations but results may differ from the original implementation. For instance, visually on the bunny example of the paper, our results are very close (and look better). This implementation comes thus without any guarantee.</p>
<p>Related example: <a class="el" href="testShroudsRegularization_8cpp.html">geometry/surfaces/testShroudsRegularization.cpp</a></p>
<h1><a class="anchor" id="moduleShrouds_sec1"></a>
Introduction</h1>
<p>Let <em>I</em> be a binary image and <em>S</em> the digital surface that is the boundary of the object in <em>I</em>. Slicing <em>S</em> by a plane aligned orthogonal to an axis <em>k</em> defines a ring of consecutive surfels, that can be seen as a simple contour joining points \( X[s] \) associated to each surfel \( s \in S \). If we define a meaningful adjacency on the digital surface (see <a class="el" href="moduleDigitalSurfaces.html">Digital surfaces</a>), when joining points \( X[\cdot] \) corresponding adjacent surfels within the slice, we build closed 2D contours. Since each surfel in 3D has only two tangent directions, each surfel belongs to exactly two orthogonal contours. During the regularization, the "Shrouds" algorithm principle is to move the point \( X[s] \) associated to each surfel <em>s</em> in a constrained way : it can only move on the unit segment that is orthogonal to the surfel, otherwise said the point is constrained to lie on the edge dual to the primal surfel.</p>
<p>The "Shrouds" algorithm minimizes a global energy that is determined by the positions of each point on its two contours. The user can choose between minimizing the area of the output surface (<a class="el" href="classDGtal_1_1ShroudsRegularization.html#a0d43ce039fb5444d8c401029e04b895ba639aaa22a784d5e5cb03a522267e79c4">ShroudsRegularization::Regularization::AREA</a>), the snake energy of the output surface (<a class="el" href="classDGtal_1_1ShroudsRegularization.html#a0d43ce039fb5444d8c401029e04b895ba6a30da74d0b15b45ec14072c93b6645d">ShroudsRegularization::Regularization::SNAKE</a>) or the squared curvature of the output surface (<a class="el" href="classDGtal_1_1ShroudsRegularization.html#a0d43ce039fb5444d8c401029e04b895ba62914f115993125b3ad1928184b0d872">ShroudsRegularization::Regularization::SQUARED_CURVATURE</a>). The latter one gives the best results.</p>
<p>The snake energy \( E^{snk} \) and the squared curvature energy  \(
E^{\kappa^2} \) are defined per slice on each 2D contour.</p>
<p>For a slice contour \( C=(x(s),y(s)) \) and boundary constraints, we define:</p>
<p class="formulaDsp">
\[ 
E^{snk}(C) = \int_C \alpha (x&#39;(s)^2 + y&#39;(s)^2) + \beta (x&#39;&#39;(s)^2 + y&#39;&#39;(s)^2) ds, 
\]
</p>
<p>and</p>
<p class="formulaDsp">
\[
E^{\kappa^2}(C) = \int_C (x&#39;(s) y&#39;&#39;(s) + x&#39;&#39;(s) y&#39;(s))^2 / (x&#39;(s)^2 + y&#39;(s)^2)^3 ds,
\]
</p>
<dl class="section note"><dt>Note</dt><dd>This process does not optimize the true 3D squared mean curvature of the surface or its 3D elastic and thin plate energy.</dd></dl>
<p>Apart from area energy, energies \( E^{snk}(C) \) and  \(
E^{\kappa^2}(C) \) are not convex and movement constraints on  \( X
\) make things worse. We propose here dedicated finite difference algorithms giving a reasonnable gradient descent for the regularization process, together with randomization at the beginning.</p>
<h1><a class="anchor" id="moduleShrouds_sec2"></a>
Main usage with squared curvature energy</h1>
<p>Starting from an implicit digital surface (with a gridstep set to 0.3 instead of 1 on images):</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1Shortcuts.html">Shortcuts&lt;Z3i::KSpace&gt;</a>         <a class="code hl_typedef" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#ac6834e172d5d8c2b796bc846aa0d643b">SH3</a>;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1SetOfSurfels.html">SH3::ExplicitSurfaceContainer</a>  Container;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_enumeration" href="classDGtal_1_1ShroudsRegularization.html#a0d43ce039fb5444d8c401029e04b895b">ShroudsRegularization&lt; Container &gt;::Regularization</a> RegType;</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">auto</span> params = <a class="code hl_function" href="classDGtal_1_1Shortcuts.html#ac893d3bc87b6dee19a48044627c42df9">SH3::defaultParameters</a>();</div>
<div class="line">  params( <span class="stringliteral">&quot;polynomial&quot;</span>, <span class="stringliteral">&quot;goursat&quot;</span> )( <span class="stringliteral">&quot;gridstep&quot;</span>, 1)(<span class="stringliteral">&quot;verbose&quot;</span>, 0);</div>
<div class="line">  <span class="keyword">auto</span> implicit_shape  = <a class="code hl_function" href="classDGtal_1_1Shortcuts.html#afa5bfec9d0da321962c3a17e39c25926">SH3::makeImplicitShape3D</a>  ( params );</div>
<div class="line">  <span class="keyword">auto</span> digitized_shape = <a class="code hl_function" href="classDGtal_1_1Shortcuts.html#a2e31dfecc5a7dc9116f5bfc7161c136c">SH3::makeDigitizedImplicitShape3D</a>( implicit_shape, params );</div>
<div class="line">  <span class="keyword">auto</span> <a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>               = <a class="code hl_function" href="classDGtal_1_1Shortcuts.html#a25d0be45d2b76a79be6cc83c8e2442b2">SH3::getKSpace</a>( params );</div>
<div class="line">  <span class="keyword">auto</span> <a class="code hl_variable" href="dgtalCalculus-geodesic_8cpp.html#a74206273d94e57c9b5aa280170896031">surface</a>         = <a class="code hl_function" href="classDGtal_1_1Shortcuts.html#a93309902099a369efffe30a7e849673e">SH3::makeDigitalSurface</a>( digitized_shape, <a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, params );</div>
</div><!-- fragment --><p>we obtain the following slice geometry, best seen on the polygonal surface dual to the digital surface:</p>
<div class="image">
<img src="goursat-g0_3-shrouds-init-s.png" alt=""/>
<div class="caption">
Initialization for the Shrouds algorithm (dual surface to goursat digital surface).</div></div>
<p>The regularization class instance can be set up with default parameters using the following syntax:</p>
<div class="fragment"><div class="line">  <span class="keyword">auto</span> idxsurface     = <a class="code hl_function" href="classDGtal_1_1Shortcuts.html#ac8ac0b387df6b9dc10f59da942864d80">SH3::makeIdxDigitalSurface</a>( <a class="code hl_variable" href="dgtalCalculus-geodesic_8cpp.html#a74206273d94e57c9b5aa280170896031">surface</a>, params );</div>
<div class="line">  <a class="code hl_class" href="classDGtal_1_1ShroudsRegularization.html">ShroudsRegularization&lt; Container &gt;</a> shrouds_reg( idxsurface );</div>
<div class="line">  <span class="keyword">auto</span> originalPos    = shrouds_reg.positions();</div>
</div><!-- fragment --><p>You may use <a class="el" href="classDGtal_1_1ShroudsRegularization.html#aa74ddbddd6208fff3d7a7850a4f9f385">ShroudsRegularization::setParams</a> to change some parameters:</p>
<ul>
<li>\( \epsilon \) the bounds for varying the positions of points on dual edge in \( [\epsilon,1-\epsilon] \), where 0 is the center of the bordering inner voxel and 1 is the center of the bordering outer voxel.</li>
<li>\( \alpha \) parameter for Snake first order regularization (~ area).</li>
<li>\( \beta \) parameter for Snake second order regularization (~ curvature).</li>
</ul>
<p>We can now minimize the squared curvature energy as follows:</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span>          loo = 0.0;</div>
<div class="line">  <span class="keywordtype">double</span>           l2 = 0.0;</div>
<div class="line">  <span class="keywordtype">double</span> energyInitK2 = shrouds_reg.energy    ( RegType::SQUARED_CURVATURE );</div>
<div class="line">  std::tie( loo, l2 ) = shrouds_reg.regularize( RegType::SQUARED_CURVATURE,</div>
<div class="line">                                                0.5, 0.0001, 100 );</div>
<div class="line">  <span class="keywordtype">double</span> energyRegK2  = shrouds_reg.energy    ( RegType::SQUARED_CURVATURE );</div>
</div><!-- fragment --><p>The user can specify the number of steps of the gradient descent as well as the randomization. If the <a class="el" href="classDGtal_1_1ShroudsRegularization.html#a4f7079a0badb6c24cc6aca5e893819c9">ShroudsRegularization::regularize</a> method is called another time, the descent starts from the previous results (aka warm restart).</p>
<p>Using the default settings, we obtain the following reconstruction, after respectively 100 and 1000 iterations:</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="goursat-g0_3-shrouds-k2-100-s.png" alt=""/>
<div class="caption">
Optimized surface according to squared curvature (100 iterations).</div></div>
  </td><td><div class="image">
<img src="goursat-g0_3-shrouds-k2-1000-s.png" alt=""/>
<div class="caption">
Optimized surface according to squared curvature (1000 iterations).</div></div>
   </td></tr>
</table>
<p>Clearly, the result after 1000 iterations is more satisfactory. You may output the result for instance as:</p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> regularizedPos = shrouds_reg.positions();</div>
<div class="line">    <span class="keyword">auto</span> polySurf       = <a class="code hl_function" href="classDGtal_1_1Shortcuts.html#aafa01465d7e5b56cadc7dc0ec767033b">SH3::makeDualPolygonalSurface</a>( idxsurface );</div>
<div class="line">    <span class="keyword">auto</span> polySurfPos    = polySurf-&gt;positions();</div>
<div class="line">    <span class="keywordflow">for</span> ( <span class="keywordtype">size_t</span> i = 0; i &lt; regularizedPos.size(); i++ )</div>
<div class="line">      polySurfPos[ i ] = regularizedPos[ i ];</div>
<div class="line">    <a class="code hl_function" href="classDGtal_1_1Shortcuts.html#af32637a785c463811df270bfa43bcd2c">SH3::saveOBJ</a>( polySurf, <span class="stringliteral">&quot;goursat-shrouds-reg-k2.obj&quot;</span> );</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The regularized position are retrieved using the <a class="el" href="classDGtal_1_1ShroudsRegularization.html#a6689733570755d7ad94a8aa8ba4872d5">ShroudsRegularization::positions</a>. The current energy can be retrieved with <a class="el" href="classDGtal_1_1ShroudsRegularization.html#a5273bb5d8a34ffb71fe284713018623c">ShroudsRegularization::energy</a>.</dd></dl>
<h1><a class="anchor" id="moduleShrouds_other"></a>
Shrouds regularization with area and snake energy</h1>
<p>You may optimize according the shape according to area minimization as follows:</p>
<div class="fragment"><div class="line">  shrouds_reg.init();  </div>
<div class="line">  <span class="keywordtype">double</span> energyInitArea= shrouds_reg.energy    ( RegType::AREA );</div>
<div class="line">  std::tie( loo, l2 )  = shrouds_reg.regularize( RegType::AREA,</div>
<div class="line">                                                 0.5, 0.0001, 100 );</div>
<div class="line">  <span class="keywordtype">double</span> energyRegArea = shrouds_reg.energy    ( RegType::AREA );</div>
</div><!-- fragment --><p>and according to snake energy as follows (use <a class="el" href="classDGtal_1_1ShroudsRegularization.html#aa74ddbddd6208fff3d7a7850a4f9f385">ShroudsRegularization::setParams</a> to change \( \alpha,\beta \) parameters):</p>
<div class="fragment"><div class="line">  shrouds_reg.init();  </div>
<div class="line">  <span class="keywordtype">double</span> energyInitSnk= shrouds_reg.energy    ( RegType::SNAKE );</div>
<div class="line">  std::tie( loo, l2 ) = shrouds_reg.regularize( RegType::SNAKE,</div>
<div class="line">                                                0.5, 0.0001, 100 );</div>
<div class="line">  <span class="keywordtype">double</span> energyRegSnk = shrouds_reg.energy    ( RegType::SNAKE );</div>
</div><!-- fragment --><p>We display below the three possible optimizations (after 1000 iterations), which shows that squared curvature energy  \(
E^{\kappa^2}(C) \) produces the best output.</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="goursat-g0_3-shrouds-k2-1000-s.png" alt=""/>
<div class="caption">
Optimized surface according to squared curvature.</div></div>
  </td><td><div class="image">
<img src="goursat-g0_3-shrouds-snake-s.png" alt=""/>
<div class="caption">
Optimized surface according to snake energy.</div></div>
  </td><td><div class="image">
<img src="goursat-g0_3-shrouds-area-s.png" alt=""/>
<div class="caption">
Optimized surface according to area.</div></div>
   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Results are visually very good, notably due to the nice slice / isocontouring effect. However, the output polygonal surface contains many cells with bad geometric properties (very small or elongated faces). </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">DGtal - Digital Geometry Tools and Algorithms Library.</a></li><li class="navelem"><a class="el" href="packageGeometry.html">Geometry package</a></li>
    <li class="footer">Generated on Mon Jun 10 2024 17:36:18 for DGtal by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
