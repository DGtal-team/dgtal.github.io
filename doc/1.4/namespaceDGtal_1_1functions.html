<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: DGtal::functions Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;1.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespaceDGtal_1_1functions.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">DGtal::functions Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>functions</code> namespace gathers all <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> functionsxs.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html">Hull2D</a></td></tr>
<tr class="memdesc:namespaceDGtal_1_1functions_1_1Hull2D"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html" title="Hull2D namespace gathers useful functions to compute and return the convex hull or the alpha-shape of...">Hull2D</a> namespace gathers useful functions to compute and return the convex hull or the alpha-shape of a range of 2D points. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1setops.html">setops</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7b7b25f308f752d0dc5f40996e23f6f7" id="r_a7b7b25f308f752d0dc5f40996e23f6f7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7b7b25f308f752d0dc5f40996e23f6f7"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7b7b25f308f752d0dc5f40996e23f6f7">const_pow</a> (T b, unsigned int e)</td></tr>
<tr class="separator:a7b7b25f308f752d0dc5f40996e23f6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7e762d94422309d0def8e9be9d0253" id="r_aff7e762d94422309d0def8e9be9d0253"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff7e762d94422309d0def8e9be9d0253"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aff7e762d94422309d0def8e9be9d0253">const_middle</a> (T <a class="el" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, unsigned int e)</td></tr>
<tr class="separator:aff7e762d94422309d0def8e9be9d0253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82988f18c989530f73dab774abe12c90" id="r_a82988f18c989530f73dab774abe12c90"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:a82988f18c989530f73dab774abe12c90"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a82988f18c989530f73dab774abe12c90">isEqual</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a82988f18c989530f73dab774abe12c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbef166c5a788624eff4f09e596c09f5" id="r_adbef166c5a788624eff4f09e596c09f5"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:adbef166c5a788624eff4f09e596c09f5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adbef166c5a788624eff4f09e596c09f5">isEqual</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:adbef166c5a788624eff4f09e596c09f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e98eb410830e5ca846260e66bff422" id="r_ac7e98eb410830e5ca846260e66bff422"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:ac7e98eb410830e5ca846260e66bff422"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac7e98eb410830e5ca846260e66bff422">isSubset</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:ac7e98eb410830e5ca846260e66bff422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad171e7dc7973f3fc0ee8363712059124" id="r_ad171e7dc7973f3fc0ee8363712059124"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ad171e7dc7973f3fc0ee8363712059124"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad171e7dc7973f3fc0ee8363712059124">isSubset</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:ad171e7dc7973f3fc0ee8363712059124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8705d6784d95fb11afa99ee677b0897" id="r_aa8705d6784d95fb11afa99ee677b0897"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:aa8705d6784d95fb11afa99ee677b0897"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa8705d6784d95fb11afa99ee677b0897">assignDifference</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:aa8705d6784d95fb11afa99ee677b0897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394caf9bddd53a3bf89865a33b10a2cb" id="r_a394caf9bddd53a3bf89865a33b10a2cb"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a394caf9bddd53a3bf89865a33b10a2cb"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a394caf9bddd53a3bf89865a33b10a2cb">assignDifference</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a394caf9bddd53a3bf89865a33b10a2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5faa4fb283d3dd8b530f1aa46e1303" id="r_adc5faa4fb283d3dd8b530f1aa46e1303"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:adc5faa4fb283d3dd8b530f1aa46e1303"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adc5faa4fb283d3dd8b530f1aa46e1303">makeDifference</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:adc5faa4fb283d3dd8b530f1aa46e1303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba16c21435994b725465e08cb77a9fb" id="r_acba16c21435994b725465e08cb77a9fb"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:acba16c21435994b725465e08cb77a9fb"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acba16c21435994b725465e08cb77a9fb">makeDifference</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:acba16c21435994b725465e08cb77a9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e9511773601750284f81ed46e1abbf" id="r_a68e9511773601750284f81ed46e1abbf"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:a68e9511773601750284f81ed46e1abbf"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a68e9511773601750284f81ed46e1abbf">assignUnion</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a68e9511773601750284f81ed46e1abbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b5ce69f026046126379fac7736f1bc" id="r_a62b5ce69f026046126379fac7736f1bc"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a62b5ce69f026046126379fac7736f1bc"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a62b5ce69f026046126379fac7736f1bc">assignUnion</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a62b5ce69f026046126379fac7736f1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af848d0d5748af67bcb76b3d5e1f616cd" id="r_af848d0d5748af67bcb76b3d5e1f616cd"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:af848d0d5748af67bcb76b3d5e1f616cd"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af848d0d5748af67bcb76b3d5e1f616cd">makeUnion</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:af848d0d5748af67bcb76b3d5e1f616cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af462fb1f5ceade012f0e97831e3d8e64" id="r_af462fb1f5ceade012f0e97831e3d8e64"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:af462fb1f5ceade012f0e97831e3d8e64"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af462fb1f5ceade012f0e97831e3d8e64">makeUnion</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:af462fb1f5ceade012f0e97831e3d8e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddbda63a20b3c113afc5eaeb1ae280c" id="r_a8ddbda63a20b3c113afc5eaeb1ae280c"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:a8ddbda63a20b3c113afc5eaeb1ae280c"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8ddbda63a20b3c113afc5eaeb1ae280c">assignIntersection</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a8ddbda63a20b3c113afc5eaeb1ae280c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce3c7806598929bb44045e20fd127bf" id="r_a4ce3c7806598929bb44045e20fd127bf"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a4ce3c7806598929bb44045e20fd127bf"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4ce3c7806598929bb44045e20fd127bf">assignIntersection</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a4ce3c7806598929bb44045e20fd127bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de7a7bd0c7511d57569c794cff3a113" id="r_a8de7a7bd0c7511d57569c794cff3a113"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:a8de7a7bd0c7511d57569c794cff3a113"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8de7a7bd0c7511d57569c794cff3a113">makeIntersection</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a8de7a7bd0c7511d57569c794cff3a113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d93770c72e70791aa57c47d22c982b9" id="r_a6d93770c72e70791aa57c47d22c982b9"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a6d93770c72e70791aa57c47d22c982b9"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6d93770c72e70791aa57c47d22c982b9">makeIntersection</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a6d93770c72e70791aa57c47d22c982b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d1399432b7339a272a8a272577e7fd" id="r_ac2d1399432b7339a272a8a272577e7fd"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:ac2d1399432b7339a272a8a272577e7fd"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac2d1399432b7339a272a8a272577e7fd">assignSymmetricDifference</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:ac2d1399432b7339a272a8a272577e7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfc36604c7434ba201fcf168586eb68" id="r_afdfc36604c7434ba201fcf168586eb68"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:afdfc36604c7434ba201fcf168586eb68"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afdfc36604c7434ba201fcf168586eb68">assignSymmetricDifference</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:afdfc36604c7434ba201fcf168586eb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f0a6573a95aa152c8b8320baee6884" id="r_a03f0a6573a95aa152c8b8320baee6884"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:a03f0a6573a95aa152c8b8320baee6884"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a03f0a6573a95aa152c8b8320baee6884">makeSymmetricDifference</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a03f0a6573a95aa152c8b8320baee6884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd11e737e0c019de78553ae847a5724" id="r_aacd11e737e0c019de78553ae847a5724"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:aacd11e737e0c019de78553ae847a5724"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aacd11e737e0c019de78553ae847a5724">makeSymmetricDifference</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:aacd11e737e0c019de78553ae847a5724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4fa6a6be77e4813577c8a2b3572299" id="r_a6e4fa6a6be77e4813577c8a2b3572299"><td class="memTemplParams" colspan="2">template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </td></tr>
<tr class="memitem:a6e4fa6a6be77e4813577c8a2b3572299"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6e4fa6a6be77e4813577c8a2b3572299">checkOnePoint</a> (const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;aDSS)</td></tr>
<tr class="separator:a6e4fa6a6be77e4813577c8a2b3572299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b421081da133e4069fe9cbddf33aa54" id="r_a6b421081da133e4069fe9cbddf33aa54"><td class="memTemplParams" colspan="2">template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </td></tr>
<tr class="memitem:a6b421081da133e4069fe9cbddf33aa54"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6b421081da133e4069fe9cbddf33aa54">checkPointsPosition</a> (const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;aDSS)</td></tr>
<tr class="separator:a6b421081da133e4069fe9cbddf33aa54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e697b1094865df340ba6206354f7c37" id="r_a1e697b1094865df340ba6206354f7c37"><td class="memTemplParams" colspan="2">template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </td></tr>
<tr class="memitem:a1e697b1094865df340ba6206354f7c37"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1e697b1094865df340ba6206354f7c37">checkPointsRemainder</a> (const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;aDSS)</td></tr>
<tr class="separator:a1e697b1094865df340ba6206354f7c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612e2adbf3983c441753beb63fd55f86" id="r_a612e2adbf3983c441753beb63fd55f86"><td class="memTemplParams" colspan="2">template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </td></tr>
<tr class="memitem:a612e2adbf3983c441753beb63fd55f86"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a612e2adbf3983c441753beb63fd55f86">checkAll</a> (const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;aDSS)</td></tr>
<tr class="separator:a612e2adbf3983c441753beb63fd55f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c21293d6efa82afb1b20db4d7a794a7" id="r_a2c21293d6efa82afb1b20db4d7a794a7"><td class="memTemplParams" colspan="2">template&lt;typename Position , typename Coordinate , typename <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> , typename OutputIterator , typename PositionFunctor , typename TruncationFunctor1 , typename TruncationFunctor2 &gt; </td></tr>
<tr class="memitem:a2c21293d6efa82afb1b20db4d7a794a7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2c21293d6efa82afb1b20db4d7a794a7">smartCHNextVertex</a> (const Position &amp;positionBound, const Coordinate &amp;remainderBound, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;X, Coordinate &amp;rX, const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;Y, const Coordinate &amp;rY, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;V, Coordinate &amp;rV, OutputIterator ito, const PositionFunctor &amp;pos, const TruncationFunctor1 &amp;f1, const TruncationFunctor2 &amp;f2)</td></tr>
<tr class="memdesc:a2c21293d6efa82afb1b20db4d7a794a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure that computes the next (lower or upper) vertex of the left hull of a DSS.  <br /></td></tr>
<tr class="separator:a2c21293d6efa82afb1b20db4d7a794a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b66e9e7682c0f900bcbeabcac96b7b" id="r_a07b66e9e7682c0f900bcbeabcac96b7b"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> , typename Coordinate , typename Position , typename PositionFunctor , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a07b66e9e7682c0f900bcbeabcac96b7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a07b66e9e7682c0f900bcbeabcac96b7b">smartCH</a> (const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;aFirstPoint, const Coordinate &amp;aRemainderBound, const Position &amp;aPositionBound, const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;aStep, const Coordinate &amp;aRStep, const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;aShift, const Coordinate &amp;aRShift, const PositionFunctor &amp;aPositionFunctor, OutputIterator uIto, OutputIterator lIto)</td></tr>
<tr class="memdesc:a07b66e9e7682c0f900bcbeabcac96b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure that computes the lower and upper left hull of a DSS of first point <em>aFirstPoint</em>, length <em>aPositionBound</em>, contained in a digital straight line described by <em>aRStep</em>, <em>aRShift</em> and <em>aRemainderBound</em>.  <br /></td></tr>
<tr class="separator:a07b66e9e7682c0f900bcbeabcac96b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc99490ec12ae9e68c03c08d473e8692" id="r_adc99490ec12ae9e68c03c08d473e8692"><td class="memTemplParams" colspan="2">template&lt;typename DSL , typename OutputIterator &gt; </td></tr>
<tr class="memitem:adc99490ec12ae9e68c03c08d473e8692"><td class="memTemplItemLeft" align="right" valign="top">DSL::Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adc99490ec12ae9e68c03c08d473e8692">smartCH</a> (const DSL &amp;aDSL, const typename DSL::Point &amp;aFirstPoint, const typename DSL::Position &amp;aLength, OutputIterator uIto, OutputIterator lIto)</td></tr>
<tr class="memdesc:adc99490ec12ae9e68c03c08d473e8692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure that computes the lower and upper left hull of a DSS of first point <em>aFirstPoint</em>, length <em>aLength</em>, contained in a DSL <em>aDSL</em> [Roussillon 2014 : <a class="el" href="citelist.html#CITEREF_RoussillonDGCI2014">[105]</a>].  <br /></td></tr>
<tr class="separator:adc99490ec12ae9e68c03c08d473e8692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184e90763c4747a4b7c71a58e1bf4bfe" id="r_a184e90763c4747a4b7c71a58e1bf4bfe"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> , typename Position , typename OutputIterator , typename TruncationFunctor1 , typename TruncationFunctor2 , typename PositionFunctor &gt; </td></tr>
<tr class="memitem:a184e90763c4747a4b7c71a58e1bf4bfe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a184e90763c4747a4b7c71a58e1bf4bfe">smartCHPreviousVertex</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;X, const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;Y, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;V, const Position &amp;aFirstPosition, const Position &amp;aLastPosition, OutputIterator ito, const PositionFunctor &amp;pos, const TruncationFunctor1 &amp;f1, const TruncationFunctor2 &amp;f2)</td></tr>
<tr class="memdesc:a184e90763c4747a4b7c71a58e1bf4bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure that computes the previous vertex of the left hull of a DSS of main direction vector <em>V</em> , first upper leaning point <em>U</em> and first positive Bezout point <em>L</em>. The computation stops as soon as a computed vertex is located before <em>aLastPosition</em>. <br  />
  <br /></td></tr>
<tr class="separator:a184e90763c4747a4b7c71a58e1bf4bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa754ac3d17216563354db61d905a545c" id="r_aa754ac3d17216563354db61d905a545c"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> , typename Position , typename PositionFunctor , typename OutputIterator &gt; </td></tr>
<tr class="memitem:aa754ac3d17216563354db61d905a545c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa754ac3d17216563354db61d905a545c">reversedSmartCH</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> U, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> L, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> V, const Position &amp;aFirstPosition, const Position &amp;aLastPosition, const PositionFunctor &amp;aPositionFunctor, OutputIterator uIto, OutputIterator lIto)</td></tr>
<tr class="memdesc:aa754ac3d17216563354db61d905a545c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure that computes the lower and upper left hull of the left subsegment of a greater DSS characterized by the first upper leaning point <em>U</em>, the first positive Bezout point <em>L</em> and its direction vector <em>V</em>. Note that the so-called left subsegment is bounded on the one hand by the first point of the DSS located at <em>aFirstPosition</em> and on the other hand by the point located at position <em>aLastPosition</em>.  <br /></td></tr>
<tr class="separator:aa754ac3d17216563354db61d905a545c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d6f1219d53ecefb73b55c386e0d54a" id="r_a42d6f1219d53ecefb73b55c386e0d54a"><td class="memTemplParams" colspan="2">template&lt;typename DSS , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a42d6f1219d53ecefb73b55c386e0d54a"><td class="memTemplItemLeft" align="right" valign="top">DSS::Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a42d6f1219d53ecefb73b55c386e0d54a">reversedSmartCH</a> (const DSS &amp;aDSS, const typename DSS::Position &amp;aPositionBound, OutputIterator uIto, OutputIterator lIto)</td></tr>
<tr class="memdesc:a42d6f1219d53ecefb73b55c386e0d54a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure that computes the lower and upper left hull of the left subsegment of a greater DSS <em>aDSS</em>. Note that the so-called left subsegment is bounded on the one hand by the first point of <em>aDSS</em> and on the other hand by the point located at position <em>aPositionBound</em> [Roussillon 2014 : <a class="el" href="citelist.html#CITEREF_RoussillonDGCI2014">[105]</a>].  <br /></td></tr>
<tr class="separator:a42d6f1219d53ecefb73b55c386e0d54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b68d329aa1461a0847a18e99247885" id="r_a18b68d329aa1461a0847a18e99247885"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a18b68d329aa1461a0847a18e99247885"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a18b68d329aa1461a0847a18e99247885">power</a> (const T &amp;aVal, const unsigned int exponent)</td></tr>
<tr class="separator:a18b68d329aa1461a0847a18e99247885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dff4e7a37ef5122f124d830b4b177a" id="r_a48dff4e7a37ef5122f124d830b4b177a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a48dff4e7a37ef5122f124d830b4b177a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a48dff4e7a37ef5122f124d830b4b177a">roundToUpperPowerOfTwo</a> (const T &amp;n)</td></tr>
<tr class="separator:a48dff4e7a37ef5122f124d830b4b177a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95dcf36f806f7fc15626ca6b1c27d22" id="r_af95dcf36f806f7fc15626ca6b1c27d22"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af95dcf36f806f7fc15626ca6b1c27d22"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af95dcf36f806f7fc15626ca6b1c27d22">abs</a> (const T &amp;a)</td></tr>
<tr class="separator:af95dcf36f806f7fc15626ca6b1c27d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e2160844093488cdd738354027daa1" id="r_ac8e2160844093488cdd738354027daa1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac8e2160844093488cdd738354027daa1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac8e2160844093488cdd738354027daa1">square</a> (T x)</td></tr>
<tr class="separator:ac8e2160844093488cdd738354027daa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4828e0475cb9aa8dceefa94f0ab4d168" id="r_a4828e0475cb9aa8dceefa94f0ab4d168"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4828e0475cb9aa8dceefa94f0ab4d168"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4828e0475cb9aa8dceefa94f0ab4d168">cube</a> (T x)</td></tr>
<tr class="separator:a4828e0475cb9aa8dceefa94f0ab4d168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72edc3d9d652158c3d02a6a11386f249" id="r_a72edc3d9d652158c3d02a6a11386f249"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer , typename CellConstIterator , typename CellMapIteratorPriority &gt; </td></tr>
<tr class="memitem:a72edc3d9d652158c3d02a6a11386f249"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a72edc3d9d652158c3d02a6a11386f249">collapse</a> (<a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;<a class="el" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, CellConstIterator S_itB, CellConstIterator S_itE, const CellMapIteratorPriority &amp;priority, bool hintIsSClosed=false, bool hintIsKClosed=false, bool verbose=false)</td></tr>
<tr class="separator:a72edc3d9d652158c3d02a6a11386f249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8066d9f6db356f21fac91f53ffdde53d" id="r_a8066d9f6db356f21fac91f53ffdde53d"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer , typename BdryCellOutputIterator , typename InnerCellOutputIterator &gt; </td></tr>
<tr class="memitem:a8066d9f6db356f21fac91f53ffdde53d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8066d9f6db356f21fac91f53ffdde53d">filterCellsWithinBounds</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;<a class="el" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, const typename TKSpace::Point &amp;kLow, const typename TKSpace::Point &amp;kUp, BdryCellOutputIterator itBdry, InnerCellOutputIterator itInner)</td></tr>
<tr class="separator:a8066d9f6db356f21fac91f53ffdde53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b5998cbfc23060987babe806313a39" id="r_ab6b5998cbfc23060987babe806313a39"><td class="memTemplParams" colspan="2">template&lt;typename TObject , typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:ab6b5998cbfc23060987babe806313a39"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; TObject &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab6b5998cbfc23060987babe806313a39">objectFromSpels</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;C)</td></tr>
<tr class="separator:ab6b5998cbfc23060987babe806313a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2d27eacf401fb9f784a1569b3ded7c" id="r_a4f2d27eacf401fb9f784a1569b3ded7c"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:a4f2d27eacf401fb9f784a1569b3ded7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDGtal.html#a9b0310c71d3ce78fbc2100f29a979701">NeighborhoodConfiguration</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4f2d27eacf401fb9f784a1569b3ded7c">getSpelNeighborhoodConfigurationOccupancy</a> (const TComplex &amp;input_complex, const typename TComplex::Point &amp;center, const std::unordered_map&lt; typename TComplex::Point, <a class="el" href="namespaceDGtal.html#a9b0310c71d3ce78fbc2100f29a979701">NeighborhoodConfiguration</a> &gt; &amp;mapPointToMask)</td></tr>
<tr class="separator:a4f2d27eacf401fb9f784a1569b3ded7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96aab076fc2c3bd049f041f5867be7a5" id="r_a96aab076fc2c3bd049f041f5867be7a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CountedPtr.html">DGtal::CountedPtr</a>&lt; boost::dynamic_bitset&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96aab076fc2c3bd049f041f5867be7a5">loadTable</a> (const std::string &amp;input_filename, const unsigned int known_size, const bool compressed=true)</td></tr>
<tr class="separator:a96aab076fc2c3bd049f041f5867be7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a55ef824ab5ca8afab45ff04c801693" id="r_a7a55ef824ab5ca8afab45ff04c801693"><td class="memTemplParams" colspan="2">template&lt;unsigned int dimension = 3&gt; </td></tr>
<tr class="memitem:a7a55ef824ab5ca8afab45ff04c801693"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CountedPtr.html">DGtal::CountedPtr</a>&lt; boost::dynamic_bitset&lt;&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7a55ef824ab5ca8afab45ff04c801693">loadTable</a> (const std::string &amp;input_filename, const bool compressed=true)</td></tr>
<tr class="separator:a7a55ef824ab5ca8afab45ff04c801693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d70667078dcd620ce69e2b0ff4d407" id="r_a57d70667078dcd620ce69e2b0ff4d407"><td class="memTemplParams" colspan="2">template&lt;typename TPoint &gt; </td></tr>
<tr class="memitem:a57d70667078dcd620ce69e2b0ff4d407"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CountedPtr.html">DGtal::CountedPtr</a>&lt; std::unordered_map&lt; TPoint, <a class="el" href="namespaceDGtal.html#a9b0310c71d3ce78fbc2100f29a979701">NeighborhoodConfiguration</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57d70667078dcd620ce69e2b0ff4d407">mapZeroPointNeighborhoodToConfigurationMask</a> ()</td></tr>
<tr class="separator:a57d70667078dcd620ce69e2b0ff4d407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924114c3907d5c86e064a513779d24a8" id="r_a924114c3907d5c86e064a513779d24a8"><td class="memTemplParams" colspan="2">template&lt;typename TObject , typename TMap &gt; </td></tr>
<tr class="memitem:a924114c3907d5c86e064a513779d24a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a924114c3907d5c86e064a513779d24a8">generateSimplicityTable</a> (const typename TObject::DigitalTopology &amp;<a class="el" href="dgtalCalculus-geodesic_8cpp.html#a778e38aa889751afffa2dea6b803e67a">dt</a>, TMap &amp;map)</td></tr>
<tr class="separator:a924114c3907d5c86e064a513779d24a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc0eb12f18205fd5335ef3068753109" id="r_a1fc0eb12f18205fd5335ef3068753109"><td class="memTemplParams" colspan="2">template&lt;typename TVoxelComplex , typename TMap &gt; </td></tr>
<tr class="memitem:a1fc0eb12f18205fd5335ef3068753109"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1fc0eb12f18205fd5335ef3068753109">generateVoxelComplexTable</a> (TMap &amp;map, std::function&lt; bool(const TVoxelComplex &amp;, const typename TVoxelComplex::Cell &amp;) &gt; skelFunction)</td></tr>
<tr class="separator:a1fc0eb12f18205fd5335ef3068753109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2a4664af776ca513141edb552a4461" id="r_a8f2a4664af776ca513141edb552a4461"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:a8f2a4664af776ca513141edb552a4461"><td class="memTemplItemLeft" align="right" valign="top">TComplex&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f2a4664af776ca513141edb552a4461">asymetricThinningScheme</a> (TComplex &amp;vc, std::function&lt; std::pair&lt; typename TComplex::Cell, typename TComplex::Data &gt;(const typename TComplex::Clique &amp;) &gt; Select, std::function&lt; bool(const TComplex &amp;, const typename TComplex::Cell &amp;) &gt; Skel, bool verbose=false)</td></tr>
<tr class="separator:a8f2a4664af776ca513141edb552a4461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d491155b4e945e904080855a3bae28" id="r_a46d491155b4e945e904080855a3bae28"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:a46d491155b4e945e904080855a3bae28"><td class="memTemplItemLeft" align="right" valign="top">TComplex&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a46d491155b4e945e904080855a3bae28">persistenceAsymetricThinningScheme</a> (TComplex &amp;vc, std::function&lt; std::pair&lt; typename TComplex::Cell, typename TComplex::Data &gt;(const typename TComplex::Clique &amp;) &gt; Select, std::function&lt; bool(const TComplex &amp;, const typename TComplex::Cell &amp;) &gt; Skel, <a class="el" href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e">uint32_t</a> persistence, bool verbose=false)</td></tr>
<tr class="separator:a46d491155b4e945e904080855a3bae28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38193d6ce6446ca81fb84114d5f9629c" id="r_a38193d6ce6446ca81fb84114d5f9629c"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:a38193d6ce6446ca81fb84114d5f9629c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename TComplex::Cell, typename TComplex::Data &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a38193d6ce6446ca81fb84114d5f9629c">selectFirst</a> (const typename TComplex::Clique &amp;clique)</td></tr>
<tr class="separator:a38193d6ce6446ca81fb84114d5f9629c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5060acdeb2181c1967bcdb413bd5e6" id="r_a2d5060acdeb2181c1967bcdb413bd5e6"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:a2d5060acdeb2181c1967bcdb413bd5e6"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename TComplex::Cell, typename TComplex::Data &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2d5060acdeb2181c1967bcdb413bd5e6">selectRandom</a> (const typename TComplex::Clique &amp;clique)</td></tr>
<tr class="separator:a2d5060acdeb2181c1967bcdb413bd5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ab34965119dc41d5adb081d8ef5262" id="r_ad2ab34965119dc41d5adb081d8ef5262"><td class="memTemplParams" colspan="2">template&lt;typename TComplex , typename TRandomGenerator &gt; </td></tr>
<tr class="memitem:ad2ab34965119dc41d5adb081d8ef5262"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename TComplex::Cell, typename TComplex::Data &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad2ab34965119dc41d5adb081d8ef5262">selectRandom</a> (const typename TComplex::Clique &amp;clique, TRandomGenerator &amp;gen)</td></tr>
<tr class="separator:ad2ab34965119dc41d5adb081d8ef5262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938d429d0ec543c8672a815bdfcf9075" id="r_a938d429d0ec543c8672a815bdfcf9075"><td class="memTemplParams" colspan="2">template&lt;typename TDistanceTransform , typename TComplex &gt; </td></tr>
<tr class="memitem:a938d429d0ec543c8672a815bdfcf9075"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename TComplex::Cell, typename TComplex::Data &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a938d429d0ec543c8672a815bdfcf9075">selectMaxValue</a> (const TDistanceTransform &amp;dist_map, const typename TComplex::Clique &amp;clique)</td></tr>
<tr class="separator:a938d429d0ec543c8672a815bdfcf9075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a335e8f7956c3188e031a8d83a5ea7" id="r_ad1a335e8f7956c3188e031a8d83a5ea7"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:ad1a335e8f7956c3188e031a8d83a5ea7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad1a335e8f7956c3188e031a8d83a5ea7">skelUltimate</a> (const TComplex &amp;vc, const typename TComplex::Cell &amp;cell)</td></tr>
<tr class="separator:ad1a335e8f7956c3188e031a8d83a5ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b08e83670143586a55950e050aa6ad" id="r_a73b08e83670143586a55950e050aa6ad"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:a73b08e83670143586a55950e050aa6ad"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a73b08e83670143586a55950e050aa6ad">skelEnd</a> (const TComplex &amp;vc, const typename TComplex::Cell &amp;cell)</td></tr>
<tr class="separator:a73b08e83670143586a55950e050aa6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8e89624580d0a7c6ecebbb8a3d072d" id="r_a4e8e89624580d0a7c6ecebbb8a3d072d"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:a4e8e89624580d0a7c6ecebbb8a3d072d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4e8e89624580d0a7c6ecebbb8a3d072d">skelSimple</a> (const TComplex &amp;vc, const typename TComplex::Cell &amp;cell)</td></tr>
<tr class="separator:a4e8e89624580d0a7c6ecebbb8a3d072d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147a79d431e108b58dd715c876da90ec" id="r_a147a79d431e108b58dd715c876da90ec"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:a147a79d431e108b58dd715c876da90ec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a147a79d431e108b58dd715c876da90ec">skelIsthmus</a> (const TComplex &amp;vc, const typename TComplex::Cell &amp;cell)</td></tr>
<tr class="separator:a147a79d431e108b58dd715c876da90ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affff269feb515ccbb61fed6df33bd403" id="r_affff269feb515ccbb61fed6df33bd403"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:affff269feb515ccbb61fed6df33bd403"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#affff269feb515ccbb61fed6df33bd403">oneIsthmus</a> (const TComplex &amp;vc, const typename TComplex::Cell &amp;cell)</td></tr>
<tr class="separator:affff269feb515ccbb61fed6df33bd403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86a0dd4add6c1b9f567908893b4a69d" id="r_ad86a0dd4add6c1b9f567908893b4a69d"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:ad86a0dd4add6c1b9f567908893b4a69d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad86a0dd4add6c1b9f567908893b4a69d">twoIsthmus</a> (const TComplex &amp;vc, const typename TComplex::Cell &amp;cell)</td></tr>
<tr class="separator:ad86a0dd4add6c1b9f567908893b4a69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d911a3be8b0751f42bc11e96d3af1b" id="r_a23d911a3be8b0751f42bc11e96d3af1b"><td class="memTemplParams" colspan="2">template&lt;typename TComplex &gt; </td></tr>
<tr class="memitem:a23d911a3be8b0751f42bc11e96d3af1b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a23d911a3be8b0751f42bc11e96d3af1b">skelWithTable</a> (const boost::dynamic_bitset&lt;&gt; &amp;table, const std::unordered_map&lt; typename TComplex::Point, unsigned int &gt; &amp;pointToMaskMap, const TComplex &amp;vc, const typename TComplex::Cell &amp;cell)</td></tr>
<tr class="separator:a23d911a3be8b0751f42bc11e96d3af1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dba32b69179583e300225bf4227a381" id="r_a4dba32b69179583e300225bf4227a381"><td class="memTemplParams" colspan="2">template&lt;typename TObject &gt; </td></tr>
<tr class="memitem:a4dba32b69179583e300225bf4227a381"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4dba32b69179583e300225bf4227a381">isZeroSurface</a> (const TObject &amp;small_obj)</td></tr>
<tr class="separator:a4dba32b69179583e300225bf4227a381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c782738287493c15465124d3516d4ec" id="r_a5c782738287493c15465124d3516d4ec"><td class="memTemplParams" colspan="2">template&lt;typename TObject &gt; </td></tr>
<tr class="memitem:a5c782738287493c15465124d3516d4ec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5c782738287493c15465124d3516d4ec">isOneSurface</a> (const TObject &amp;small_obj)</td></tr>
<tr class="separator:a5c782738287493c15465124d3516d4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafaf8919cafd89499a5a3206f969735b" id="r_aafaf8919cafd89499a5a3206f969735b"><td class="memTemplParams" colspan="2">template&lt;typename TObject &gt; </td></tr>
<tr class="memitem:aafaf8919cafd89499a5a3206f969735b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; TObject &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aafaf8919cafd89499a5a3206f969735b">connectedComponents</a> (const TObject &amp;input_obj, bool verbose)</td></tr>
<tr class="separator:aafaf8919cafd89499a5a3206f969735b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3a164539f931c2f8bbaddb6d44b50a" id="r_abe3a164539f931c2f8bbaddb6d44b50a"><td class="memTemplParams" colspan="2">template&lt;typename TComplex , typename TDistanceTransform  = DistanceTransformation&lt;Z3i::Space, Z3i::DigitalSet, ExactPredicateLpSeparableMetric&lt;Z3i::Space, 3&gt;&gt;&gt; </td></tr>
<tr class="memitem:abe3a164539f931c2f8bbaddb6d44b50a"><td class="memTemplItemLeft" align="right" valign="top">TComplex&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abe3a164539f931c2f8bbaddb6d44b50a">thinningVoxelComplex</a> (TComplex &amp;vc, const std::string &amp;skel_type_str, const std::string &amp;skel_select_type_str, const std::string &amp;tables_folder, const int &amp;persistence=0, const TDistanceTransform *distance_transform=nullptr, const bool profile=false, const bool verbose=false)</td></tr>
<tr class="separator:abe3a164539f931c2f8bbaddb6d44b50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><code>functions</code> namespace gathers all <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> functionsxs. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="af95dcf36f806f7fc15626ca6b1c27d22" name="af95dcf36f806f7fc15626ca6b1c27d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95dcf36f806f7fc15626ca6b1c27d22">&#9670;&#160;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T DGtal::functions::abs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the absolute value of an instance of type T.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of elements to compare (model of <a class="el" href="structboost_1_1LessThanComparable.html" title="Go to http://www.sgi.com/tech/stl/LessThanComparable.html.">boost::LessThanComparable</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the absolute value |a|. </dd></dl>

<p class="definition">Definition at line <a class="el" href="BasicMathFunctions_8h_source.html#l00116">116</a> of file <a class="el" href="BasicMathFunctions_8h_source.html">BasicMathFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  117</span>    {</div>
<div class="line"><span class="lineno">  118</span>      BOOST_CONCEPT_ASSERT((<a class="code hl_struct" href="structboost_1_1LessThanComparable.html">boost::LessThanComparable&lt;T&gt;</a>));</div>
<div class="line"><span class="lineno">  119</span>      <span class="keywordflow">if</span> (a&lt;0) </div>
<div class="line"><span class="lineno">  120</span>        <span class="keywordflow">return</span> -a;</div>
<div class="line"><span class="lineno">  121</span>      <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  122</span>        <span class="keywordflow">return</span> a;</div>
<div class="line"><span class="lineno">  123</span>    }</div>
<div class="ttc" id="astructboost_1_1LessThanComparable_html"><div class="ttname"><a href="structboost_1_1LessThanComparable.html">boost::LessThanComparable</a></div><div class="ttdoc">Go to http://www.sgi.com/tech/stl/LessThanComparable.html.</div><div class="ttdef"><b>Definition</b> <a href="Boost_8dox_source.html#l00048">Boost.dox:48</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa8705d6784d95fb11afa99ee677b0897" name="aa8705d6784d95fb11afa99ee677b0897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8705d6784d95fb11afa99ee677b0897">&#9670;&#160;</a></span>assignDifference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container &amp; DGtal::functions::assignDifference </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set difference operation. Updates the set S1 as S1 - S2. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, <em>S1</em> - <em>S2</em> as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l00896">896</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  897</span>    {</div>
<div class="line"><span class="lineno">  898</span>      BOOST_STATIC_ASSERT( <a class="code hl_struct" href="structDGtal_1_1IsContainer.html">IsContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno">  899</span>      BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno">  900</span>        ( <span class="keywordtype">bool</span>, isAssociative = <a class="code hl_struct" href="structDGtal_1_1IsAssociativeContainer.html">IsAssociativeContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno">  901</span>      BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno">  902</span>        ( <span class="keywordtype">bool</span>, isOrdered = ordered </div>
<div class="line"><span class="lineno">  903</span>          || ( isAssociative &amp;&amp; <a class="code hl_struct" href="structDGtal_1_1IsOrderedAssociativeContainer.html">IsOrderedAssociativeContainer&lt; Container &gt;::value</a> ) );</div>
<div class="line"><span class="lineno">  904</span> </div>
<div class="line"><span class="lineno">  905</span>      <span class="keywordflow">return</span> <a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div>
<div class="line"><span class="lineno">  906</span><a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">        ::assignDifference</a>( S1, S2 );</div>
<div class="line"><span class="lineno">  907</span>    }</div>
<div class="ttc" id="astructDGtal_1_1IsAssociativeContainer_html"><div class="ttname"><a href="structDGtal_1_1IsAssociativeContainer.html">DGtal::IsAssociativeContainer</a></div><div class="ttdef"><b>Definition</b> <a href="ContainerTraits_8h_source.html#l00337">ContainerTraits.h:337</a></div></div>
<div class="ttc" id="astructDGtal_1_1IsContainer_html"><div class="ttname"><a href="structDGtal_1_1IsContainer.html">DGtal::IsContainer</a></div><div class="ttdef"><b>Definition</b> <a href="ContainerTraits_8h_source.html#l00317">ContainerTraits.h:317</a></div></div>
<div class="ttc" id="astructDGtal_1_1IsOrderedAssociativeContainer_html"><div class="ttname"><a href="structDGtal_1_1IsOrderedAssociativeContainer.html">DGtal::IsOrderedAssociativeContainer</a></div><div class="ttdef"><b>Definition</b> <a href="ContainerTraits_8h_source.html#l00347">ContainerTraits.h:347</a></div></div>
<div class="ttc" id="astructDGtal_1_1detail_1_1SetFunctionsImpl_html"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl</a></div><div class="ttdoc">Aim: Specialize set operations (union, intersection, difference, symmetric_difference) according to t...</div><div class="ttdef"><b>Definition</b> <a href="SetFunctions_8h_source.html#l00234">SetFunctions.h:235</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="SetFunctions_8h_source.html#l00946">makeDifference()</a>, and <a class="el" href="SetFunctions_8h_source.html#l01272">DGtal::functions::setops::operator-=()</a>.</p>

</div>
</div>
<a id="a394caf9bddd53a3bf89865a33b10a2cb" name="a394caf9bddd53a3bf89865a33b10a2cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394caf9bddd53a3bf89865a33b10a2cb">&#9670;&#160;</a></span>assignDifference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container &amp; DGtal::functions::assignDifference </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set difference operation. Updates the set S1 as S1 - S2. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, <em>S1</em> - <em>S2</em> as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l00918">918</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  919</span>    {</div>
<div class="line"><span class="lineno">  920</span>      BOOST_STATIC_ASSERT( <a class="code hl_struct" href="structDGtal_1_1IsContainer.html">IsContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno">  921</span>      BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno">  922</span>        ( <span class="keywordtype">bool</span>, isAssociative = <a class="code hl_struct" href="structDGtal_1_1IsAssociativeContainer.html">IsAssociativeContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno">  923</span>      BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno">  924</span>        ( <span class="keywordtype">bool</span>, isOrdered = isAssociative &amp;&amp; <a class="code hl_struct" href="structDGtal_1_1IsOrderedAssociativeContainer.html">IsOrderedAssociativeContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno">  925</span> </div>
<div class="line"><span class="lineno">  926</span>      <span class="keywordflow">return</span> <a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div>
<div class="line"><span class="lineno">  927</span><a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">        ::assignDifference</a>( S1, S2 );</div>
<div class="line"><span class="lineno">  928</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8ddbda63a20b3c113afc5eaeb1ae280c" name="a8ddbda63a20b3c113afc5eaeb1ae280c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ddbda63a20b3c113afc5eaeb1ae280c">&#9670;&#160;</a></span>assignIntersection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container &amp; DGtal::functions::assignIntersection </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set intersection operation. Updates the set <em>S1</em> as \( S1 \cap S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, \( S1 \cap S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l01082">1082</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1083</span>    {</div>
<div class="line"><span class="lineno"> 1084</span>      BOOST_STATIC_ASSERT( <a class="code hl_struct" href="structDGtal_1_1IsContainer.html">IsContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno"> 1085</span>      BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno"> 1086</span>        ( <span class="keywordtype">bool</span>, isAssociative = <a class="code hl_struct" href="structDGtal_1_1IsAssociativeContainer.html">IsAssociativeContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno"> 1087</span>      BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno"> 1088</span>        ( <span class="keywordtype">bool</span>, isOrdered = ordered </div>
<div class="line"><span class="lineno"> 1089</span>          || ( isAssociative &amp;&amp; <a class="code hl_struct" href="structDGtal_1_1IsOrderedAssociativeContainer.html">IsOrderedAssociativeContainer&lt; Container &gt;::value</a> ) );</div>
<div class="line"><span class="lineno"> 1090</span> </div>
<div class="line"><span class="lineno"> 1091</span>      <span class="keywordflow">return</span> <a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div>
<div class="line"><span class="lineno"> 1092</span><a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">        ::assignIntersection</a>( S1, S2 );</div>
<div class="line"><span class="lineno"> 1093</span>    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="SetFunctions_8h_source.html#l01131">makeIntersection()</a>, and <a class="el" href="SetFunctions_8h_source.html#l01346">DGtal::functions::setops::operator&amp;=()</a>.</p>

</div>
</div>
<a id="a4ce3c7806598929bb44045e20fd127bf" name="a4ce3c7806598929bb44045e20fd127bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce3c7806598929bb44045e20fd127bf">&#9670;&#160;</a></span>assignIntersection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container &amp; DGtal::functions::assignIntersection </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set intersection operation. Updates the set <em>S1</em> as \( S1 \cap S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, \( S1 \cap S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l01104">1104</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1105</span>    {</div>
<div class="line"><span class="lineno"> 1106</span>      BOOST_STATIC_ASSERT( <a class="code hl_struct" href="structDGtal_1_1IsContainer.html">IsContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno"> 1107</span>      BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno"> 1108</span>        ( <span class="keywordtype">bool</span>, isAssociative = <a class="code hl_struct" href="structDGtal_1_1IsAssociativeContainer.html">IsAssociativeContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno"> 1109</span>      BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno"> 1110</span>        ( <span class="keywordtype">bool</span>, isOrdered = isAssociative &amp;&amp; <a class="code hl_struct" href="structDGtal_1_1IsOrderedAssociativeContainer.html">IsOrderedAssociativeContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno"> 1111</span> </div>
<div class="line"><span class="lineno"> 1112</span>      <span class="keywordflow">return</span> <a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div>
<div class="line"><span class="lineno"> 1113</span><a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">        ::assignIntersection</a>( S1, S2 );</div>
<div class="line"><span class="lineno"> 1114</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac2d1399432b7339a272a8a272577e7fd" name="ac2d1399432b7339a272a8a272577e7fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d1399432b7339a272a8a272577e7fd">&#9670;&#160;</a></span>assignSymmetricDifference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container &amp; DGtal::functions::assignSymmetricDifference </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set symmetric difference operation. Updates the set <em>S1</em> as \( S1 \Delta S2 \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, \( S1 \Delta S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l01176">1176</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1177</span>    {</div>
<div class="line"><span class="lineno"> 1178</span>      BOOST_STATIC_ASSERT( <a class="code hl_struct" href="structDGtal_1_1IsContainer.html">IsContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno"> 1179</span>      BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno"> 1180</span>        ( <span class="keywordtype">bool</span>, isAssociative = <a class="code hl_struct" href="structDGtal_1_1IsAssociativeContainer.html">IsAssociativeContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno"> 1181</span>      BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno"> 1182</span>        ( <span class="keywordtype">bool</span>, isOrdered = ordered </div>
<div class="line"><span class="lineno"> 1183</span>          || ( isAssociative &amp;&amp; <a class="code hl_struct" href="structDGtal_1_1IsOrderedAssociativeContainer.html">IsOrderedAssociativeContainer&lt; Container &gt;::value</a> ) );</div>
<div class="line"><span class="lineno"> 1184</span> </div>
<div class="line"><span class="lineno"> 1185</span>      <span class="keywordflow">return</span> <a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div>
<div class="line"><span class="lineno"> 1186</span><a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">        ::assignSymmetricDifference</a>( S1, S2 );</div>
<div class="line"><span class="lineno"> 1187</span>    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="SetFunctions_8h_source.html#l01225">makeSymmetricDifference()</a>, and <a class="el" href="SetFunctions_8h_source.html#l01378">DGtal::functions::setops::operator^=()</a>.</p>

</div>
</div>
<a id="afdfc36604c7434ba201fcf168586eb68" name="afdfc36604c7434ba201fcf168586eb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdfc36604c7434ba201fcf168586eb68">&#9670;&#160;</a></span>assignSymmetricDifference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container &amp; DGtal::functions::assignSymmetricDifference </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set symmetric difference operation. Updates the set <em>S1</em> as \( S1 \Delta S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, \( S1 \Delta S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l01198">1198</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1199</span>    {</div>
<div class="line"><span class="lineno"> 1200</span>      BOOST_STATIC_ASSERT( <a class="code hl_struct" href="structDGtal_1_1IsContainer.html">IsContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno"> 1201</span>      BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno"> 1202</span>        ( <span class="keywordtype">bool</span>, isAssociative = <a class="code hl_struct" href="structDGtal_1_1IsAssociativeContainer.html">IsAssociativeContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno"> 1203</span>      BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno"> 1204</span>        ( <span class="keywordtype">bool</span>, isOrdered = isAssociative &amp;&amp; <a class="code hl_struct" href="structDGtal_1_1IsOrderedAssociativeContainer.html">IsOrderedAssociativeContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno"> 1205</span> </div>
<div class="line"><span class="lineno"> 1206</span>      <span class="keywordflow">return</span> <a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div>
<div class="line"><span class="lineno"> 1207</span><a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">        ::assignSymmetricDifference</a>( S1, S2 );</div>
<div class="line"><span class="lineno"> 1208</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a68e9511773601750284f81ed46e1abbf" name="a68e9511773601750284f81ed46e1abbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e9511773601750284f81ed46e1abbf">&#9670;&#160;</a></span>assignUnion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container &amp; DGtal::functions::assignUnion </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set union operation. Updates the set <em>S1</em> as \( S1 \cup S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, \( S1 \cup S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l00990">990</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  991</span>    {</div>
<div class="line"><span class="lineno">  992</span>      BOOST_STATIC_ASSERT( <a class="code hl_struct" href="structDGtal_1_1IsContainer.html">IsContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno">  993</span>      BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno">  994</span>        ( <span class="keywordtype">bool</span>, isAssociative = <a class="code hl_struct" href="structDGtal_1_1IsAssociativeContainer.html">IsAssociativeContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno">  995</span>      BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno">  996</span>        ( <span class="keywordtype">bool</span>, isOrdered = ordered </div>
<div class="line"><span class="lineno">  997</span>          || ( isAssociative &amp;&amp; <a class="code hl_struct" href="structDGtal_1_1IsOrderedAssociativeContainer.html">IsOrderedAssociativeContainer&lt; Container &gt;::value</a> ) );</div>
<div class="line"><span class="lineno">  998</span> </div>
<div class="line"><span class="lineno">  999</span>      <span class="keywordflow">return</span> <a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div>
<div class="line"><span class="lineno"> 1000</span><a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">        ::assignUnion</a>( S1, S2 );</div>
<div class="line"><span class="lineno"> 1001</span>    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="SetFunctions_8h_source.html#l01039">makeUnion()</a>, and <a class="el" href="SetFunctions_8h_source.html#l01317">DGtal::functions::setops::operator|=()</a>.</p>

</div>
</div>
<a id="a62b5ce69f026046126379fac7736f1bc" name="a62b5ce69f026046126379fac7736f1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b5ce69f026046126379fac7736f1bc">&#9670;&#160;</a></span>assignUnion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container &amp; DGtal::functions::assignUnion </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set union operation. Updates the set <em>S1</em> as \( S1 \cup S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, \( S1 \cup S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l01012">1012</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1013</span>    {</div>
<div class="line"><span class="lineno"> 1014</span>      BOOST_STATIC_ASSERT( <a class="code hl_struct" href="structDGtal_1_1IsContainer.html">IsContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno"> 1015</span>      BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno"> 1016</span>        ( <span class="keywordtype">bool</span>, isAssociative = <a class="code hl_struct" href="structDGtal_1_1IsAssociativeContainer.html">IsAssociativeContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno"> 1017</span>      BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno"> 1018</span>        ( <span class="keywordtype">bool</span>, isOrdered = isAssociative &amp;&amp; <a class="code hl_struct" href="structDGtal_1_1IsOrderedAssociativeContainer.html">IsOrderedAssociativeContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno"> 1019</span> </div>
<div class="line"><span class="lineno"> 1020</span>      <span class="keywordflow">return</span> <a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div>
<div class="line"><span class="lineno"> 1021</span><a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">        ::assignUnion</a>( S1, S2 );</div>
<div class="line"><span class="lineno"> 1022</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8f2a4664af776ca513141edb552a4461" name="a8f2a4664af776ca513141edb552a4461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2a4664af776ca513141edb552a4461">&#9670;&#160;</a></span>asymetricThinningScheme()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TComplex DGtal::functions::asymetricThinningScheme </td>
          <td>(</td>
          <td class="paramtype">TComplex &amp;</td>          <td class="paramname"><span class="paramname"><em>vc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; std::pair&lt; typename TComplex::Cell, typename TComplex::Data &gt;(const typename TComplex::Clique &amp;) &gt;</td>          <td class="paramname"><span class="paramname"><em>Select</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const TComplex &amp;, const typename TComplex::Cell &amp;) &gt;</td>          <td class="paramname"><span class="paramname"><em>Skel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="VoxelComplexThinning_8h_source.html#l00092">thinningVoxelComplex()</a>.</p>

</div>
</div>
<a id="a612e2adbf3983c441753beb63fd55f86" name="a612e2adbf3983c441753beb63fd55f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612e2adbf3983c441753beb63fd55f86">&#9670;&#160;</a></span>checkAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::checkAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>aDSS</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether a DSS is valid or not. NB: in logarithmic time (in order to check that a and b are relatively prime) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDSS</td><td>any DSS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if valid, 'false' otherwise. </dd></dl>

</div>
</div>
<a id="a6e4fa6a6be77e4813577c8a2b3572299" name="a6e4fa6a6be77e4813577c8a2b3572299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4fa6a6be77e4813577c8a2b3572299">&#9670;&#160;</a></span>checkOnePoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::checkOnePoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>aDSS</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks the validity of the DSS when it contains only one point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDSS</td><td>any DSS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>the DSS contains only one point </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the DSS is valid, 'false' otherwise. </dd></dl>

</div>
</div>
<a id="a6b421081da133e4069fe9cbddf33aa54" name="a6b421081da133e4069fe9cbddf33aa54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b421081da133e4069fe9cbddf33aa54">&#9670;&#160;</a></span>checkPointsPosition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::checkPointsPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>aDSS</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that the difference between two extremal upper (resp. lower) leaning points is equal to the direction vector (a,b) scaled by an integer. Checks that there is no pattern between end points and extremal leaning points. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDSS</td><td>any DSS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>the DSS contains more than one point, ie a and b are not both null. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if ok, 'false' otherwise. </dd></dl>

</div>
</div>
<a id="a1e697b1094865df340ba6206354f7c37" name="a1e697b1094865df340ba6206354f7c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e697b1094865df340ba6206354f7c37">&#9670;&#160;</a></span>checkPointsRemainder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::checkPointsRemainder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>aDSS</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks the consistency between the parameters and the leaning points: first and last upper leaning points should have a remainder equal to mu while firsta and last lower leaning points should have a remainder equal to mu + omega - 1. Moreover, front and back points should have a remainder lying within the range [mu, mu+omega[. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDSS</td><td>any DSS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>the DSS contains more than one point, ie a and b are not both null. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if this property is fulfilled, 'false' otherwise. </dd></dl>

</div>
</div>
<a id="a72edc3d9d652158c3d02a6a11386f249" name="a72edc3d9d652158c3d02a6a11386f249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72edc3d9d652158c3d02a6a11386f249">&#9670;&#160;</a></span>collapse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer , typename CellConstIterator , typename CellMapIteratorPriority &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5">uint64_t</a> DGtal::functions::collapse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>K</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CellConstIterator</td>          <td class="paramname"><span class="paramname"><em>S_itB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CellConstIterator</td>          <td class="paramname"><span class="paramname"><em>S_itE</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CellMapIteratorPriority &amp;</td>          <td class="paramname"><span class="paramname"><em>priority</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>hintIsSClosed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>hintIsKClosed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collapse a user-specified part of complex <em>K</em>, collapsing cells following priority [priority], in a decreasing sequence until no more collapse is feasible. The range [<em>S_itb</em>,<em>S_itE</em>) provides the starting cells, generally (but not compulsory) maximal cells. The resulting complex is guaranteed to keep the same homotopy type (a kind of topology equivalence).</p>
<dl class="section note"><dt>Note</dt><dd>Cells whose data has been marked as FIXED are not removed.</dd>
<dd>
Only cells that are in the closure of [<em>S_itb</em>,<em>S_itE</em>) may be removed, and only if they are not marked as FIXED.</dd></dl>
<dl class="section user"><dt>Advanced: </dt><dd>If you use a DefaultCellMapIteratorPriority object as <em>priority</em>, then the VALUE part of each cell data defines the priority (the highest value the soonest are these cells collapsed). You may thus fill these cell values before calling this method.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
    <tr><td class="paramname">CellConstIterator</td><td>any forward const iterator on Cell.</td></tr>
    <tr><td class="paramname">CellMapIteratorPriority</td><td>any type defining a method 'bool operator()( const Cell&amp;, const Cell&amp;) const'. Defines the order in which cells are collapsed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>DefaultCellMapIteratorPriority</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">K</td><td>the complex that is collapsed. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">S_itB</td><td>the start of a range of cells which is included in [K]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">S_itE</td><td>the end of a range of cells which is included in [K]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">priority</td><td>the object that assign a priority to each cell. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">hintIsSClosed</td><td>indicates if [<em>S_itb</em>,<em>S_ite</em>) is a closed set (faster in this case). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">hintIsKClosed</td><td>indicates that complex <em>K</em> is closed. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">verbose</td><td>outputs some information during processing when 'true'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of cells removed from complex <em>K</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cubical-complex-collapse_8cpp.html">topology/cubical-complex-collapse.cpp</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="cubical-complex-collapse_8cpp_source.html#l00115">main()</a>, <a class="el" href="cubical-complex-illustrations_8cpp_source.html#l00054">main()</a>, <a class="el" href="testCubicalComplex_8cpp_source.html#l00454">SCENARIO()</a>, and <a class="el" href="testCubicalComplex_8cpp_source.html#l00195">SCENARIO()</a>.</p>

</div>
</div>
<a id="aafaf8919cafd89499a5a3206f969735b" name="aafaf8919cafd89499a5a3206f969735b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafaf8919cafd89499a5a3206f969735b">&#9670;&#160;</a></span>connectedComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TObject &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; TObject &gt; DGtal::functions::connectedComponents </td>
          <td>(</td>
          <td class="paramtype">const TObject &amp;</td>          <td class="paramname"><span class="paramname"><em>input_obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get all connected components of the input object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TObject</td><td><a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> Type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_obj</td><td>input object </td></tr>
    <tr><td class="paramname">verbose</td><td>flag to be verbose at execution</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of TObject containing the different connected components of the object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ObjectBoostGraphInterface_8h_source.html">ObjectBoostGraphInterface.h</a> </dd></dl>

</div>
</div>
<a id="aff7e762d94422309d0def8e9be9d0253" name="aff7e762d94422309d0def8e9be9d0253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff7e762d94422309d0def8e9be9d0253">&#9670;&#160;</a></span>const_middle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T DGtal::functions::const_middle </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>K</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>any model of bounded number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">K</td><td>a non negative number </td></tr>
    <tr><td class="paramname">e</td><td>a non negative integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the middle element in the <code>e</code>-dimensional array of width \( 2K+1 \), computed at compile time.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m1 = <a class="code hl_function" href="#aff7e762d94422309d0def8e9be9d0253">functions::const_middle</a>( 1, 2 ); <span class="comment">// 4, dans le tableau 3x3</span></div>
<div class="line"><span class="keyword">auto</span> m2 = <a class="code hl_function" href="#aff7e762d94422309d0def8e9be9d0253">functions::const_middle</a>( 2, 2 ); <span class="comment">// 12, dans le tableau 5x5</span></div>
<div class="line"><span class="keyword">auto</span> m3 = <a class="code hl_function" href="#aff7e762d94422309d0def8e9be9d0253">functions::const_middle</a>( 1, 3 ); <span class="comment">// 13, dans le tableau 3x3x3</span></div>
<div class="ttc" id="anamespaceDGtal_1_1functions_html_aff7e762d94422309d0def8e9be9d0253"><div class="ttname"><a href="#aff7e762d94422309d0def8e9be9d0253">DGtal::functions::const_middle</a></div><div class="ttdeci">constexpr T const_middle(T K, unsigned int e)</div><div class="ttdef"><b>Definition</b> <a href="ConstExpressions_8h_source.html#l00075">ConstExpressions.h:75</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ConstExpressions_8h_source.html#l00075">75</a> of file <a class="el" href="ConstExpressions_8h_source.html">ConstExpressions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   75</span>                                                    {</div>
<div class="line"><span class="lineno">   76</span>      <span class="keywordflow">return</span> e &lt;= 1</div>
<div class="line"><span class="lineno">   77</span>        ? T( <a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a> )</div>
<div class="line"><span class="lineno">   78</span>        : <a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a> * <a class="code hl_function" href="#a7b7b25f308f752d0dc5f40996e23f6f7">const_pow</a>( 2 * <a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a> + 1, e - 1 ) + <a class="code hl_function" href="#aff7e762d94422309d0def8e9be9d0253">const_middle</a>( <a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, e - 1 );</div>
<div class="line"><span class="lineno">   79</span>    }</div>
<div class="ttc" id="anamespaceDGtal_1_1functions_html_a7b7b25f308f752d0dc5f40996e23f6f7"><div class="ttname"><a href="#a7b7b25f308f752d0dc5f40996e23f6f7">DGtal::functions::const_pow</a></div><div class="ttdeci">constexpr T const_pow(T b, unsigned int e)</div><div class="ttdef"><b>Definition</b> <a href="ConstExpressions_8h_source.html#l00060">ConstExpressions.h:60</a></div></div>
<div class="ttc" id="atestCubicalComplex_8cpp_html_a2b87ed989d2519d025bd5d4fbcbac062"><div class="ttname"><a href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a></div><div class="ttdeci">KSpace K</div><div class="ttdef"><b>Definition</b> <a href="testCubicalComplex_8cpp_source.html#l00062">testCubicalComplex.cpp:62</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="ConstExpressions_8h_source.html#l00075">const_middle()</a>, <a class="el" href="ConstExpressions_8h_source.html#l00060">const_pow()</a>, and <a class="el" href="testCubicalComplex_8cpp_source.html#l00062">K</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstExpressions_8h_source.html#l00075">const_middle()</a>.</p>

</div>
</div>
<a id="a7b7b25f308f752d0dc5f40996e23f6f7" name="a7b7b25f308f752d0dc5f40996e23f6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7b25f308f752d0dc5f40996e23f6f7">&#9670;&#160;</a></span>const_pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T DGtal::functions::const_pow </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>any model of bounded number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>a number </td></tr>
    <tr><td class="paramname">e</td><td>a non negative integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the constant expression \( b^e \), computed at compile time.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> v = <a class="code hl_function" href="#a7b7b25f308f752d0dc5f40996e23f6f7">functions::const_pow</a>( 5, 3 ); <span class="comment">// 5^3</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ConstExpressions_8h_source.html#l00060">60</a> of file <a class="el" href="ConstExpressions_8h_source.html">ConstExpressions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   60</span>                                                {</div>
<div class="line"><span class="lineno">   61</span>      <span class="keywordflow">return</span> e == 0 ? T(1) : b * <a class="code hl_function" href="#a7b7b25f308f752d0dc5f40996e23f6f7">const_pow</a>( b, e - 1 );</div>
<div class="line"><span class="lineno">   62</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="ConstExpressions_8h_source.html#l00060">const_pow()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstExpressions_8h_source.html#l00075">const_middle()</a>, and <a class="el" href="ConstExpressions_8h_source.html#l00060">const_pow()</a>.</p>

</div>
</div>
<a id="a4828e0475cb9aa8dceefa94f0ab4d168" name="a4828e0475cb9aa8dceefa94f0ab4d168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4828e0475cb9aa8dceefa94f0ab4d168">&#9670;&#160;</a></span>cube()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T DGtal::functions::cube </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value x * x * x </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>a type with the multiply operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>any value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value x * x * x </dd></dl>

<p class="definition">Definition at line <a class="el" href="BasicMathFunctions_8h_source.html#l00144">144</a> of file <a class="el" href="BasicMathFunctions_8h_source.html">BasicMathFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  145</span>    { <span class="keywordflow">return</span> x * x * x; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8066d9f6db356f21fac91f53ffdde53d" name="a8066d9f6db356f21fac91f53ffdde53d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8066d9f6db356f21fac91f53ffdde53d">&#9670;&#160;</a></span>filterCellsWithinBounds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer , typename BdryCellOutputIterator , typename InnerCellOutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::filterCellsWithinBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>K</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TKSpace::Point &amp;</td>          <td class="paramname"><span class="paramname"><em>kLow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TKSpace::Point &amp;</td>          <td class="paramname"><span class="paramname"><em>kUp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BdryCellOutputIterator</td>          <td class="paramname"><span class="paramname"><em>itBdry</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerCellOutputIterator</td>          <td class="paramname"><span class="paramname"><em>itInner</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the cells of the given complex <em>K</em> that lies on the boundary or inside the parallelepiped specified by bounds <em>kLow</em> and <em>kUp</em>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
    <tr><td class="paramname">BdryCellOutputIterator</td><td>any output iterator on TCubicalComplex::Cell. </td></tr>
    <tr><td class="paramname">InnerCellOutputIterator</td><td>any output iterator on TCubicalComplex::Cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>any cubical complex.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kLow</td><td>any Khalimsky coordinate representing the lowest possible cell.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kUp</td><td>any Khalimsky coordinate representing the uppermost possible cell.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">itBdry</td><td>An output iterator on Cell that outputs all the cells of <em>K</em> that lie on the boundary of the parallelepiped specified by bounds <em>kLow</em> and <em>kUp</em>.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">itInner</td><td>An output iterator on Cell that outputs all the cells of <em>K</em> that lie in the interior of the parallelepiped specified by bounds <em>kLow</em> and <em>kUp</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Complexity is linear in the number of cells of <em>K</em> (but the constant is also linear in the dimension of <em>K</em>). </dd></dl>

</div>
</div>
<a id="a924114c3907d5c86e064a513779d24a8" name="a924114c3907d5c86e064a513779d24a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924114c3907d5c86e064a513779d24a8">&#9670;&#160;</a></span>generateSimplicityTable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TObject , typename TMap &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::generateSimplicityTable </td>
          <td>(</td>
          <td class="paramtype">const typename TObject::DigitalTopology &amp;</td>          <td class="paramname"><span class="paramname"><em>dt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMap &amp;</td>          <td class="paramname"><span class="paramname"><em>map</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a digital topology <em>dt</em>, generates tables that tells if the central point is simple for the specified configuration. The configuration is determined by a sequence of bits, the first bit for the point in the neighborhood, the second bit for the second point, etc. When set to one, the point is in the neighborhood.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TObject</td><td>the type of object whose simpleness we wish to precompute. Includes the topology. </td></tr>
    <tr><td class="paramname">TMap</td><td>the type used to store the mapping configuration -&gt; bool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>an instance of the digital topology. </td></tr>
    <tr><td class="paramname">map</td><td>(modified) the mapping configuration -&gt; bool. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="NeighborhoodTablesGenerators_8h_source.html#l00071">71</a> of file <a class="el" href="NeighborhoodTablesGenerators_8h_source.html">NeighborhoodTablesGenerators.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   74</span>  {</div>
<div class="line"><span class="lineno">   75</span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> TObject::DigitalSet <a class="code hl_typedef" href="testVoronoiMapComplete_8cpp.html#ac14360761d68859fc57ca37aea0b5c93">DigitalSet</a>;</div>
<div class="line"><span class="lineno">   76</span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> TObject::Point <a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>;</div>
<div class="line"><span class="lineno">   77</span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code hl_typedef" href="classDGtal_1_1DigitalSetByAssociativeContainer.html#a91f48a384b687cefe0354adeaf1be532">DigitalSet::Domain</a> <a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a>;</div>
<div class="line"><span class="lineno">   78</span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code hl_class" href="classDGtal_1_1HyperRectDomain__Iterator.html">Domain::ConstIterator</a> DomainConstIterator;</div>
<div class="line"><span class="lineno">   79</span> </div>
<div class="line"><span class="lineno">   80</span>    <a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> p1 = Point::diagonal( -1 );</div>
<div class="line"><span class="lineno">   81</span>    <a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> p2 = Point::diagonal(  1 );</div>
<div class="line"><span class="lineno">   82</span>    <a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> c = Point::diagonal( 0 );</div>
<div class="line"><span class="lineno">   83</span>    <a class="code hl_class" href="classDGtal_1_1HyperRectDomain.html">Domain</a> <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>( p1, p2 );</div>
<div class="line"><span class="lineno">   84</span>    <a class="code hl_class" href="classDGtal_1_1DigitalSetByAssociativeContainer.html">DigitalSet</a> shapeSet( <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a> );</div>
<div class="line"><span class="lineno">   85</span>    TObject shape( <a class="code hl_variable" href="dgtalCalculus-geodesic_8cpp.html#a778e38aa889751afffa2dea6b803e67a">dt</a>, shapeSet );</div>
<div class="line"><span class="lineno">   86</span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0;</div>
<div class="line"><span class="lineno">   87</span>    <span class="keywordflow">for</span> ( DomainConstIterator it = <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.begin(); it != <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.end(); ++it )</div>
<div class="line"><span class="lineno">   88</span>      <span class="keywordflow">if</span> ( *it != c ) ++k;</div>
<div class="line"><span class="lineno">   89</span>    ASSERT( ( k &lt; 32 )</div>
<div class="line"><span class="lineno">   90</span>        &amp;&amp; <span class="stringliteral">&quot;[generateSimplicityTable] number of configurations is too high.&quot;</span> );</div>
<div class="line"><span class="lineno">   91</span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbCfg = 1 &lt;&lt; k;</div>
<div class="line"><span class="lineno">   92</span>    <span class="keywordflow">for</span> ( <a class="code hl_typedef" href="namespaceDGtal.html#a9b0310c71d3ce78fbc2100f29a979701">NeighborhoodConfiguration</a> cfg = 0; cfg &lt; nbCfg; ++cfg )</div>
<div class="line"><span class="lineno">   93</span>    {</div>
<div class="line"><span class="lineno">   94</span>      <span class="keywordflow">if</span> ( ( cfg % 1000 ) == 0 )</div>
<div class="line"><span class="lineno">   95</span>      {</div>
<div class="line"><span class="lineno">   96</span>        <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#ad8efd553b31277903be115e7aa256f74">progressBar</a>( (<span class="keywordtype">double</span>) cfg, (<span class="keywordtype">double</span>) nbCfg );</div>
<div class="line"><span class="lineno">   97</span>      }</div>
<div class="line"><span class="lineno">   98</span>      shape.pointSet().clear();</div>
<div class="line"><span class="lineno">   99</span>      shape.pointSet().insert( c );</div>
<div class="line"><span class="lineno">  100</span>      <a class="code hl_typedef" href="namespaceDGtal.html#a9b0310c71d3ce78fbc2100f29a979701">NeighborhoodConfiguration</a> mask = 1;</div>
<div class="line"><span class="lineno">  101</span>      <span class="keywordflow">for</span> ( DomainConstIterator it = <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.begin(); it != <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.end(); ++it )</div>
<div class="line"><span class="lineno">  102</span>      {</div>
<div class="line"><span class="lineno">  103</span>        <span class="keywordflow">if</span> ( *it != c )</div>
<div class="line"><span class="lineno">  104</span>        {</div>
<div class="line"><span class="lineno">  105</span>          <span class="keywordflow">if</span> ( cfg &amp; mask ) shape.pointSet().insert( *it );</div>
<div class="line"><span class="lineno">  106</span>          mask &lt;&lt;= 1;</div>
<div class="line"><span class="lineno">  107</span>        }</div>
<div class="line"><span class="lineno">  108</span>      }</div>
<div class="line"><span class="lineno">  109</span>      <span class="keywordtype">bool</span> simple = shape.isSimple( c );</div>
<div class="line"><span class="lineno">  110</span>      map[ cfg ] = simple;</div>
<div class="line"><span class="lineno">  111</span>    }</div>
<div class="line"><span class="lineno">  112</span>  }</div>
<div class="ttc" id="aclassDGtal_1_1DigitalSetByAssociativeContainer_html"><div class="ttname"><a href="classDGtal_1_1DigitalSetByAssociativeContainer.html">DGtal::DigitalSetByAssociativeContainer</a></div><div class="ttdoc">Aim: A wrapper class around a STL associative container for storing sets of digital points within som...</div><div class="ttdef"><b>Definition</b> <a href="DigitalSetByAssociativeContainer_8h_source.html#l00089">DigitalSetByAssociativeContainer.h:90</a></div></div>
<div class="ttc" id="aclassDGtal_1_1DigitalSetByAssociativeContainer_html_a91f48a384b687cefe0354adeaf1be532"><div class="ttname"><a href="classDGtal_1_1DigitalSetByAssociativeContainer.html#a91f48a384b687cefe0354adeaf1be532">DGtal::DigitalSetByAssociativeContainer::Domain</a></div><div class="ttdeci">TDomain Domain</div><div class="ttdoc">Domain type.</div><div class="ttdef"><b>Definition</b> <a href="DigitalSetByAssociativeContainer_8h_source.html#l00094">DigitalSetByAssociativeContainer.h:94</a></div></div>
<div class="ttc" id="aclassDGtal_1_1HyperRectDomain__Iterator_html"><div class="ttname"><a href="classDGtal_1_1HyperRectDomain__Iterator.html">DGtal::HyperRectDomain_Iterator</a></div><div class="ttdoc">Iterator for HyperRectDomain.</div><div class="ttdef"><b>Definition</b> <a href="HyperRectDomain__Iterator_8h_source.html#l00142">HyperRectDomain_Iterator.h:154</a></div></div>
<div class="ttc" id="aclassDGtal_1_1HyperRectDomain_html"><div class="ttname"><a href="classDGtal_1_1HyperRectDomain.html">DGtal::HyperRectDomain&lt; Space &gt;</a></div></div>
<div class="ttc" id="aclassDGtal_1_1Trace_html_ad8efd553b31277903be115e7aa256f74"><div class="ttname"><a href="classDGtal_1_1Trace.html#ad8efd553b31277903be115e7aa256f74">DGtal::Trace::progressBar</a></div><div class="ttdeci">void progressBar(const double currentValue, const double maximalValue)</div></div>
<div class="ttc" id="adgtalCalculus-geodesic_8cpp_html_a778e38aa889751afffa2dea6b803e67a"><div class="ttname"><a href="dgtalCalculus-geodesic_8cpp.html#a778e38aa889751afffa2dea6b803e67a">dt</a></div><div class="ttdeci">float dt</div><div class="ttdef"><b>Definition</b> <a href="dgtalCalculus-geodesic_8cpp_source.html#l00063">dgtalCalculus-geodesic.cpp:63</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a8fc7012708b0416880a5c8b12dfdf9dd"><div class="ttname"><a href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">DGtal::trace</a></div><div class="ttdeci">Trace trace</div><div class="ttdef"><b>Definition</b> <a href="Common_8h_source.html#l00153">Common.h:153</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a9b0310c71d3ce78fbc2100f29a979701"><div class="ttname"><a href="namespaceDGtal.html#a9b0310c71d3ce78fbc2100f29a979701">DGtal::NeighborhoodConfiguration</a></div><div class="ttdeci">uint32_t NeighborhoodConfiguration</div><div class="ttdef"><b>Definition</b> <a href="NeighborhoodConfigurationsHelper_8h_source.html#l00043">NeighborhoodConfigurationsHelper.h:43</a></div></div>
<div class="ttc" id="atestClone2_8cpp_html_a15e9592ccc512dc691b46185e6814758"><div class="ttname"><a href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a></div><div class="ttdeci">MyPointD Point</div><div class="ttdef"><b>Definition</b> <a href="testClone2_8cpp_source.html#l00383">testClone2.cpp:383</a></div></div>
<div class="ttc" id="atestProjection_8cpp_html_a1f1a69f8d8b037b72c2160ed12b3ef51"><div class="ttname"><a href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a></div><div class="ttdeci">Domain domain</div><div class="ttdef"><b>Definition</b> <a href="testProjection_8cpp_source.html#l00088">testProjection.cpp:88</a></div></div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_acd532b318489cd93df57e0b3d136d050"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a></div><div class="ttdeci">HyperRectDomain&lt; Space &gt; Domain</div><div class="ttdef"><b>Definition</b> <a href="testSimpleRandomAccessRangeFromPoint_8cpp_source.html#l00044">testSimpleRandomAccessRangeFromPoint.cpp:44</a></div></div>
<div class="ttc" id="atestVoronoiMapComplete_8cpp_html_ac14360761d68859fc57ca37aea0b5c93"><div class="ttname"><a href="testVoronoiMapComplete_8cpp.html#ac14360761d68859fc57ca37aea0b5c93">DigitalSet</a></div><div class="ttdeci">Z2i::DigitalSet DigitalSet</div><div class="ttdef"><b>Definition</b> <a href="testVoronoiMapComplete_8cpp_source.html#l00040">testVoronoiMapComplete.cpp:40</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="testProjection_8cpp_source.html#l00088">domain</a>, <a class="el" href="dgtalCalculus-geodesic_8cpp_source.html#l00063">dt</a>, <a class="el" href="classDGtal_1_1Trace.html#ad8efd553b31277903be115e7aa256f74">DGtal::Trace::progressBar()</a>, and <a class="el" href="Common_8h_source.html#l00153">DGtal::trace</a>.</p>

<p class="reference">Referenced by <a class="el" href="generateSimplicityTables3D_8cpp_source.html#l00045">main()</a>, and <a class="el" href="generateSimplicityTables2D_8cpp_source.html#l00145">main()</a>.</p>

</div>
</div>
<a id="a1fc0eb12f18205fd5335ef3068753109" name="a1fc0eb12f18205fd5335ef3068753109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc0eb12f18205fd5335ef3068753109">&#9670;&#160;</a></span>generateVoxelComplexTable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TVoxelComplex , typename TMap &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::generateVoxelComplexTable </td>
          <td>(</td>
          <td class="paramtype">TMap &amp;</td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const TVoxelComplex &amp;, const typename TVoxelComplex::Cell &amp;) &gt;</td>          <td class="paramname"><span class="paramname"><em>skelFunction</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a table mapping the number of configuration of a 26 topology voxel neighborhood, and the boolean result of a predicate function applied to the central point for each configuration. The configuration is determined by a sequence of bits, the first bit for the point in the neighborhood, the second bit for the second point, etc. When set to one, the point is in the neighborhood.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TVoxelComplex</td><td>the type of the <a class="el" href="classDGtal_1_1VoxelComplex.html" title="This class represents a voxel complex living in some Khalimsky space. Voxel complexes are derived fro...">VoxelComplex</a> whose property we wish to precompute.</td></tr>
    <tr><td class="paramname">TMap</td><td>the type used to store the mapping configuration -&gt; bool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>(modified) the mapping configuration -&gt; bool. </td></tr>
    <tr><td class="paramname">skelFunction</td><td>a predicate function related to the property we want to check. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="NeighborhoodTablesGenerators_8h_source.html#l00132">132</a> of file <a class="el" href="NeighborhoodTablesGenerators_8h_source.html">NeighborhoodTablesGenerators.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  139</span>    {</div>
<div class="line"><span class="lineno">  140</span>      <span class="keyword">using </span><a class="code hl_class" href="classDGtal_1_1HyperRectDomain.html">Domain</a> = <a class="code hl_typedef" href="namespaceDGtal_1_1Z3i.html#a39a69f8da09f1094df563ca067927c61">DGtal::Z3i::Domain</a>;</div>
<div class="line"><span class="lineno">  141</span>      <span class="keyword">using </span><a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> = <span class="keyword">typename</span> <a class="code hl_typedef" href="classDGtal_1_1HyperRectDomain.html#ad710ac3a2d91d351b55ca6841cb789f5">Domain::Point</a> ;</div>
<div class="line"><span class="lineno">  142</span>      <span class="keyword">using </span><a class="code hl_class" href="classDGtal_1_1DigitalSetByAssociativeContainer.html">DigitalSet</a> = <a class="code hl_class" href="classDGtal_1_1DigitalSetByAssociativeContainer.html">DigitalSetByAssociativeContainer</a>&lt;</div>
<div class="line"><span class="lineno">  143</span>        <a class="code hl_typedef" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a>, std::unordered_set&lt; Point &gt; &gt;;</div>
<div class="line"><span class="lineno">  144</span>      <span class="keyword">using </span>DomainConstIterator = <span class="keyword">typename</span> <a class="code hl_typedef" href="classDGtal_1_1HyperRectDomain.html#ad460a9309eb81ab5391a57f7d2a17055">Domain::ConstIterator</a> ;</div>
<div class="line"><span class="lineno">  145</span>      <span class="keyword">using </span><a class="code hl_class" href="classDGtal_1_1KhalimskySpaceND.html">KSpace</a> = <span class="keyword">typename</span> TVoxelComplex::KSpace;</div>
<div class="line"><span class="lineno">  146</span> </div>
<div class="line"><span class="lineno">  147</span>      <a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> p1 = Point::diagonal( -1 );</div>
<div class="line"><span class="lineno">  148</span>      <a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> p2 = Point::diagonal(  1 );</div>
<div class="line"><span class="lineno">  149</span>      <a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> c = Point::diagonal( 0 );</div>
<div class="line"><span class="lineno">  150</span>      <a class="code hl_class" href="classDGtal_1_1HyperRectDomain.html">Domain</a> <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>( p1, p2 );</div>
<div class="line"><span class="lineno">  151</span>      <a class="code hl_class" href="classDGtal_1_1DigitalSetByAssociativeContainer.html">DigitalSet</a> shapeSet( <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a> );</div>
<div class="line"><span class="lineno">  152</span>      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0;</div>
<div class="line"><span class="lineno">  153</span>      <span class="keywordflow">for</span> ( DomainConstIterator it = <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.begin(); it != <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.end(); ++it )</div>
<div class="line"><span class="lineno">  154</span>        <span class="keywordflow">if</span> ( *it != c ) ++k;</div>
<div class="line"><span class="lineno">  155</span>      ASSERT( ( k &lt; 32 )</div>
<div class="line"><span class="lineno">  156</span>          &amp;&amp; <span class="stringliteral">&quot;[generateVoxelComplexTable] number of configurations is too high.&quot;</span> );</div>
<div class="line"><span class="lineno">  157</span>      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbCfg = 1 &lt;&lt; k;</div>
<div class="line"><span class="lineno">  158</span> </div>
<div class="line"><span class="lineno">  159</span>      <a class="code hl_class" href="classDGtal_1_1KhalimskySpaceND.html">KSpace</a> ks;</div>
<div class="line"><span class="lineno">  160</span>      <span class="comment">// Pad KSpace domain.</span></div>
<div class="line"><span class="lineno">  161</span>      ks.<a class="code hl_function" href="classDGtal_1_1KhalimskySpaceND.html#a15dcbcaae831dd1c36090e6336c177d4">init</a>(<a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.lowerBound() + Point::diagonal( -1 ) ,</div>
<div class="line"><span class="lineno">  162</span>          <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.upperBound() + Point::diagonal( 1 ),</div>
<div class="line"><span class="lineno">  163</span>          <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno">  164</span>      TVoxelComplex vc(ks);</div>
<div class="line"><span class="lineno">  165</span>      vc.construct(shapeSet);</div>
<div class="line"><span class="lineno">  166</span>      <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cfg = 0; cfg &lt; nbCfg; ++cfg ){</div>
<div class="line"><span class="lineno">  167</span>        <span class="keywordflow">if</span> ( ( cfg % 1000 ) == 0 )</div>
<div class="line"><span class="lineno">  168</span>          <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#ad8efd553b31277903be115e7aa256f74">progressBar</a>( (<span class="keywordtype">double</span>) cfg, (<span class="keywordtype">double</span>) nbCfg );</div>
<div class="line"><span class="lineno">  169</span>        vc.clear();</div>
<div class="line"><span class="lineno">  170</span>        vc.insertVoxelPoint(c);</div>
<div class="line"><span class="lineno">  171</span>        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mask = 1;</div>
<div class="line"><span class="lineno">  172</span>        <span class="keywordflow">for</span> ( DomainConstIterator it = <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.begin(); it != <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.end(); ++it ){</div>
<div class="line"><span class="lineno">  173</span>          <span class="keywordflow">if</span> ( *it != c ) {</div>
<div class="line"><span class="lineno">  174</span>            <span class="keywordflow">if</span> ( cfg &amp; mask ) vc.insertVoxelPoint( *it );</div>
<div class="line"><span class="lineno">  175</span>            mask &lt;&lt;= 1;</div>
<div class="line"><span class="lineno">  176</span>          }</div>
<div class="line"><span class="lineno">  177</span>        }</div>
<div class="line"><span class="lineno">  178</span>        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;kcell = vc.space().uSpel(c);</div>
<div class="line"><span class="lineno">  179</span>        <span class="keywordtype">bool</span> predicate_output = skelFunction(vc, kcell);</div>
<div class="line"><span class="lineno">  180</span>        map[ cfg ] = predicate_output;</div>
<div class="line"><span class="lineno">  181</span>      }</div>
<div class="line"><span class="lineno">  182</span>    }</div>
<div class="ttc" id="aclassDGtal_1_1HyperRectDomain_html_ad460a9309eb81ab5391a57f7d2a17055"><div class="ttname"><a href="classDGtal_1_1HyperRectDomain.html#ad460a9309eb81ab5391a57f7d2a17055">DGtal::HyperRectDomain&lt; Space &gt;::ConstIterator</a></div><div class="ttdeci">Iterator ConstIterator</div><div class="ttdef"><b>Definition</b> <a href="HyperRectDomain_8h_source.html#l00125">HyperRectDomain.h:125</a></div></div>
<div class="ttc" id="aclassDGtal_1_1HyperRectDomain_html_ad710ac3a2d91d351b55ca6841cb789f5"><div class="ttname"><a href="classDGtal_1_1HyperRectDomain.html#ad710ac3a2d91d351b55ca6841cb789f5">DGtal::HyperRectDomain&lt; Space &gt;::Point</a></div><div class="ttdeci">Space::Point Point</div><div class="ttdef"><b>Definition</b> <a href="HyperRectDomain_8h_source.html#l00113">HyperRectDomain.h:113</a></div></div>
<div class="ttc" id="aclassDGtal_1_1KhalimskySpaceND_html"><div class="ttname"><a href="classDGtal_1_1KhalimskySpaceND.html">DGtal::KhalimskySpaceND</a></div><div class="ttdoc">Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex,...</div><div class="ttdef"><b>Definition</b> <a href="KhalimskySpaceND_8h_source.html#l00392">KhalimskySpaceND.h:394</a></div></div>
<div class="ttc" id="aclassDGtal_1_1KhalimskySpaceND_html_a15dcbcaae831dd1c36090e6336c177d4"><div class="ttname"><a href="classDGtal_1_1KhalimskySpaceND.html#a15dcbcaae831dd1c36090e6336c177d4">DGtal::KhalimskySpaceND::init</a></div><div class="ttdeci">bool init(const Point &amp;lower, const Point &amp;upper, bool isClosed)</div><div class="ttdoc">Specifies the upper and lower bounds for the maximal cells in this space.</div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z3i_html_a39a69f8da09f1094df563ca067927c61"><div class="ttname"><a href="namespaceDGtal_1_1Z3i.html#a39a69f8da09f1094df563ca067927c61">DGtal::Z3i::Domain</a></div><div class="ttdeci">HyperRectDomain&lt; Space &gt; Domain</div><div class="ttdef"><b>Definition</b> <a href="StdDefs_8h_source.html#l00172">StdDefs.h:172</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="testProjection_8cpp_source.html#l00088">domain</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a15dcbcaae831dd1c36090e6336c177d4">DGtal::KhalimskySpaceND&lt; dim, TInteger &gt;::init()</a>, <a class="el" href="classDGtal_1_1Trace.html#ad8efd553b31277903be115e7aa256f74">DGtal::Trace::progressBar()</a>, and <a class="el" href="Common_8h_source.html#l00153">DGtal::trace</a>.</p>

<p class="reference">Referenced by <a class="el" href="generateVoxelComplexTables_8cpp_source.html#l00061">main()</a>.</p>

</div>
</div>
<a id="a4f2d27eacf401fb9f784a1569b3ded7c" name="a4f2d27eacf401fb9f784a1569b3ded7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2d27eacf401fb9f784a1569b3ded7c">&#9670;&#160;</a></span>getSpelNeighborhoodConfigurationOccupancy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDGtal.html#a9b0310c71d3ce78fbc2100f29a979701">NeighborhoodConfiguration</a> DGtal::functions::getSpelNeighborhoodConfigurationOccupancy </td>
          <td>(</td>
          <td class="paramtype">const TComplex &amp;</td>          <td class="paramname"><span class="paramname"><em>input_complex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TComplex::Point &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; typename TComplex::Point, <a class="el" href="namespaceDGtal.html#a9b0310c71d3ce78fbc2100f29a979701">NeighborhoodConfiguration</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mapPointToMask</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the occupancy configuration of the neighborhood of a point in a cubical complex. The neighborhood size is considered 3^D for dimension D of the point (ie 3x3x3 cube for 3D point).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TComplex</td><td>Complex type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_complex</td><td>input complex. Used to check what points are occupied. </td></tr>
    <tr><td class="paramname">center</td><td>of the neighborhood. It doesn't matter if center belongs or not to <b>input_complex</b>. </td></tr>
    <tr><td class="paramname">mapPointToMask</td><td>map[Point]-&gt;configuration, where Point is inside a DxD cube centered in {0,0,..} in ND.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This doesn't work with KSpace coordinates, these must be converted to digital coordinates before: </dd></dl>
<dl class="section see"><dt>See also</dt><dd>KhalimskySpaceND::uCoords(3,cell) </dd>
<dd>
mapPointToBitMask</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>bit configuration </dd></dl>

</div>
</div>
<a id="a82988f18c989530f73dab774abe12c90" name="a82988f18c989530f73dab774abe12c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82988f18c989530f73dab774abe12c90">&#9670;&#160;</a></span>isEqual() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::isEqual </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equality test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff <em>S1</em> is equal to <em>S2</em> (i.e. <em>S1</em> is a subset of <em>S2</em> and <em>S2</em> is a subset of <em>S1</em>).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l00789">789</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  790</span>      {</div>
<div class="line"><span class="lineno">  791</span>        BOOST_STATIC_ASSERT( <a class="code hl_struct" href="structDGtal_1_1IsContainer.html">IsContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno">  792</span>        BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno">  793</span>          ( <span class="keywordtype">bool</span>, isAssociative = <a class="code hl_struct" href="structDGtal_1_1IsAssociativeContainer.html">IsAssociativeContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno">  794</span>        BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno">  795</span>          ( <span class="keywordtype">bool</span>, isOrdered = ordered </div>
<div class="line"><span class="lineno">  796</span>            || ( isAssociative &amp;&amp; <a class="code hl_struct" href="structDGtal_1_1IsOrderedAssociativeContainer.html">IsOrderedAssociativeContainer&lt; Container &gt;::value</a> ) );</div>
<div class="line"><span class="lineno">  797</span>        </div>
<div class="line"><span class="lineno">  798</span>        <span class="keywordflow">return</span> <a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div>
<div class="line"><span class="lineno">  799</span><a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">          ::isEqual</a>( S1, S2 );</div>
<div class="line"><span class="lineno">  800</span>      }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="CubicalComplexFunctions_8h_source.html#l00293">DGtal::operator!=()</a>, and <a class="el" href="CubicalComplexFunctions_8h_source.html#l00266">DGtal::operator==()</a>.</p>

</div>
</div>
<a id="adbef166c5a788624eff4f09e596c09f5" name="adbef166c5a788624eff4f09e596c09f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbef166c5a788624eff4f09e596c09f5">&#9670;&#160;</a></span>isEqual() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::isEqual </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equality test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff <em>S1</em> is equal to <em>S2</em> (i.e. <em>S1</em> is a subset of <em>S2</em> and <em>S2</em> is a subset of <em>S1</em>).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l00815">815</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  816</span>      {</div>
<div class="line"><span class="lineno">  817</span>        BOOST_STATIC_ASSERT( <a class="code hl_struct" href="structDGtal_1_1IsContainer.html">IsContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno">  818</span>        BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno">  819</span>          ( <span class="keywordtype">bool</span>, isAssociative = <a class="code hl_struct" href="structDGtal_1_1IsAssociativeContainer.html">IsAssociativeContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno">  820</span>        BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno">  821</span>          ( <span class="keywordtype">bool</span>, isOrdered = isAssociative &amp;&amp; <a class="code hl_struct" href="structDGtal_1_1IsOrderedAssociativeContainer.html">IsOrderedAssociativeContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno">  822</span>        </div>
<div class="line"><span class="lineno">  823</span>        <span class="keywordflow">return</span> <a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div>
<div class="line"><span class="lineno">  824</span><a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">          ::isEqual</a>( S1, S2 );</div>
<div class="line"><span class="lineno">  825</span>      }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5c782738287493c15465124d3516d4ec" name="a5c782738287493c15465124d3516d4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c782738287493c15465124d3516d4ec">&#9670;&#160;</a></span>isOneSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TObject &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::isOneSurface </td>
          <td>(</td>
          <td class="paramtype">const TObject &amp;</td>          <td class="paramname"><span class="paramname"><em>small_obj</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if input object is a simple closed curve. <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> must be:</p><ul>
<li>Connected.</li>
<li>Each voxel is a <a class="el" href="#a4dba32b69179583e300225bf4227a381">isZeroSurface</a>.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4dba32b69179583e300225bf4227a381">isZeroSurface</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TObject</td><td><a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> Type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">small_obj</td><td>input object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a id="ac7e98eb410830e5ca846260e66bff422" name="ac7e98eb410830e5ca846260e66bff422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e98eb410830e5ca846260e66bff422">&#9670;&#160;</a></span>isSubset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::isSubset </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inclusion test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff <em>S1</em> is a subset of <em>S2</em>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l00845">845</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  846</span>      {</div>
<div class="line"><span class="lineno">  847</span>        BOOST_STATIC_ASSERT( <a class="code hl_struct" href="structDGtal_1_1IsContainer.html">IsContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno">  848</span>        BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno">  849</span>          ( <span class="keywordtype">bool</span>, isAssociative = <a class="code hl_struct" href="structDGtal_1_1IsAssociativeContainer.html">IsAssociativeContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno">  850</span>        BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno">  851</span>          ( <span class="keywordtype">bool</span>, isOrdered = ordered </div>
<div class="line"><span class="lineno">  852</span>            || ( isAssociative &amp;&amp; <a class="code hl_struct" href="structDGtal_1_1IsOrderedAssociativeContainer.html">IsOrderedAssociativeContainer&lt; Container &gt;::value</a> ) );</div>
<div class="line"><span class="lineno">  853</span>        </div>
<div class="line"><span class="lineno">  854</span>        <span class="keywordflow">return</span> <a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div>
<div class="line"><span class="lineno">  855</span><a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">          ::isSubset</a>( S1, S2 );</div>
<div class="line"><span class="lineno">  856</span>      }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="CubicalComplexFunctions_8h_source.html#l00317">DGtal::operator&lt;=()</a>, and <a class="el" href="CubicalComplexFunctions_8h_source.html#l00340">DGtal::operator&gt;=()</a>.</p>

</div>
</div>
<a id="ad171e7dc7973f3fc0ee8363712059124" name="ad171e7dc7973f3fc0ee8363712059124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad171e7dc7973f3fc0ee8363712059124">&#9670;&#160;</a></span>isSubset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::isSubset </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inclusion test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff <em>S1</em> is a subset of <em>S2</em>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l00869">869</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  870</span>      {</div>
<div class="line"><span class="lineno">  871</span>        BOOST_STATIC_ASSERT( <a class="code hl_struct" href="structDGtal_1_1IsContainer.html">IsContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno">  872</span>        BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno">  873</span>          ( <span class="keywordtype">bool</span>, isAssociative = <a class="code hl_struct" href="structDGtal_1_1IsAssociativeContainer.html">IsAssociativeContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno">  874</span>        BOOST_STATIC_CONSTANT</div>
<div class="line"><span class="lineno">  875</span>          ( <span class="keywordtype">bool</span>, isOrdered = isAssociative &amp;&amp; <a class="code hl_struct" href="structDGtal_1_1IsOrderedAssociativeContainer.html">IsOrderedAssociativeContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno">  876</span>        </div>
<div class="line"><span class="lineno">  877</span>        <span class="keywordflow">return</span> <a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div>
<div class="line"><span class="lineno">  878</span><a class="code hl_struct" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">          ::isSubset</a>( S1, S2 );</div>
<div class="line"><span class="lineno">  879</span>      }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4dba32b69179583e300225bf4227a381" name="a4dba32b69179583e300225bf4227a381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dba32b69179583e300225bf4227a381">&#9670;&#160;</a></span>isZeroSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TObject &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::isZeroSurface </td>
          <td>(</td>
          <td class="paramtype">const TObject &amp;</td>          <td class="paramname"><span class="paramname"><em>small_obj</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the object contains, exclusively, two disconnected voxels.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1Object.html#a4aae59f1144ced95ccf25eb08cf77ea0">Object::computeConnectedness</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TObject</td><td><a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> Type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">small_obj</td><td>input object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a id="a7a55ef824ab5ca8afab45ff04c801693" name="a7a55ef824ab5ca8afab45ff04c801693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a55ef824ab5ca8afab45ff04c801693">&#9670;&#160;</a></span>loadTable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int dimension = 3&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CountedPtr.html">DGtal::CountedPtr</a>&lt; boost::dynamic_bitset&lt;&gt; &gt; DGtal::functions::loadTable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>input_filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>compressed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load existing look up table existing in file_name, precalculated tables can be accessed including the header: "DGtal/topology/tables/NeighborhoodTables.h"</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dimension</td><td>of the space input_filename table refers. 2 or 3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_filename</td><td>plain text containing the bool table. </td></tr>
    <tr><td class="paramname">compressed</td><td>true if table to read has been compressed with zlib.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>smart ptr of map[neighbor_configuration] -&gt; bool</dd></dl>
<dl class="section see"><dt>See also</dt><dd>NeighborhoodConfigurations::loadTable </dd></dl>

</div>
</div>
<a id="a96aab076fc2c3bd049f041f5867be7a5" name="a96aab076fc2c3bd049f041f5867be7a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96aab076fc2c3bd049f041f5867be7a5">&#9670;&#160;</a></span>loadTable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CountedPtr.html">DGtal::CountedPtr</a>&lt; boost::dynamic_bitset&lt;&gt; &gt; DGtal::functions::loadTable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>input_filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int</td>          <td class="paramname"><span class="paramname"><em>known_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>compressed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load existing look up table existing in file_name, precalculated tables can be accessed including the header: "DGtal/topology/tables/NeighborhoodTables.h"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_filename</td><td>plain text containing the bool table. </td></tr>
    <tr><td class="paramname">known_size</td><td>of the bitset, for 2D = 256 (2^8), 3D = 67108864 (2^26) </td></tr>
    <tr><td class="paramname">compressed</td><td>true if table to read has been compressed with zlib.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>smart ptr of map[neighbor_configuration] -&gt; bool</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The tables were calculated using the generateTableXXX examples. Compressed files of the tables are distributed in the source code. At build or install time, the header "DGtal/topology/tables/NeighborhoodTables.h" is generated. It has const strings variables with the file names of the tables. </dd></dl>

<p class="reference">Referenced by <a class="el" href="testNeighborhoodConfigurations_8cpp_source.html#l00301">SCENARIO()</a>, <a class="el" href="testNeighborhoodConfigurations_8cpp_source.html#l00103">SCENARIO()</a>, <a class="el" href="testVoxelComplex_8cpp_source.html#l00313">TEST_CASE_METHOD()</a>, <a class="el" href="testVoxelComplex_8cpp_source.html#l00810">TEST_CASE_METHOD()</a>, <a class="el" href="testVoxelComplex_8cpp_source.html#l01059">TEST_CASE_METHOD()</a>, <a class="el" href="testVoxelComplex_8cpp_source.html#l01004">TEST_CASE_METHOD()</a>, <a class="el" href="testNeighborhoodConfigurations_8cpp_source.html#l00251">TEST_CASE_METHOD()</a>, <a class="el" href="testObject_8cpp_source.html#l00741">testSetTable()</a>, and <a class="el" href="VoxelComplexThinning_8h_source.html#l00092">thinningVoxelComplex()</a>.</p>

</div>
</div>
<a id="adc5faa4fb283d3dd8b530f1aa46e1303" name="adc5faa4fb283d3dd8b530f1aa46e1303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5faa4fb283d3dd8b530f1aa46e1303">&#9670;&#160;</a></span>makeDifference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeDifference </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set difference operation. Returns the difference of <em>S1</em> - <em>S2</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set <em>S1</em> - <em>S2</em>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l00946">946</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  947</span>    {</div>
<div class="line"><span class="lineno">  948</span>      BOOST_STATIC_ASSERT( <a class="code hl_struct" href="structDGtal_1_1IsContainer.html">IsContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno">  949</span>      Container S( S1 );</div>
<div class="line"><span class="lineno">  950</span>      assignDifference&lt;Container, ordered&gt;( S, S2 );</div>
<div class="line"><span class="lineno">  951</span>      <span class="keywordflow">return</span> S;</div>
<div class="line"><span class="lineno">  952</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l00896">assignDifference()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SetFunctions_8h_source.html#l01288">DGtal::functions::setops::operator-()</a>.</p>

</div>
</div>
<a id="acba16c21435994b725465e08cb77a9fb" name="acba16c21435994b725465e08cb77a9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba16c21435994b725465e08cb77a9fb">&#9670;&#160;</a></span>makeDifference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeDifference </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set difference operation. Returns the difference of <em>S1</em> - <em>S2</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set <em>S1</em> - <em>S2</em>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l00965">965</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  966</span>    {</div>
<div class="line"><span class="lineno">  967</span>      BOOST_STATIC_ASSERT( <a class="code hl_struct" href="structDGtal_1_1IsContainer.html">IsContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno">  968</span>      Container S( S1 );</div>
<div class="line"><span class="lineno">  969</span>      <a class="code hl_function" href="#aa8705d6784d95fb11afa99ee677b0897">assignDifference</a>( S, S2 );</div>
<div class="line"><span class="lineno">  970</span>      <span class="keywordflow">return</span> S;</div>
<div class="line"><span class="lineno">  971</span>    }</div>
<div class="ttc" id="anamespaceDGtal_1_1functions_html_aa8705d6784d95fb11afa99ee677b0897"><div class="ttname"><a href="#aa8705d6784d95fb11afa99ee677b0897">DGtal::functions::assignDifference</a></div><div class="ttdeci">Container &amp; assignDifference(Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition</b> <a href="SetFunctions_8h_source.html#l00896">SetFunctions.h:896</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l00896">assignDifference()</a>.</p>

</div>
</div>
<a id="a8de7a7bd0c7511d57569c794cff3a113" name="a8de7a7bd0c7511d57569c794cff3a113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de7a7bd0c7511d57569c794cff3a113">&#9670;&#160;</a></span>makeIntersection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeIntersection </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set intersection operation. Returns the set \( S1 \cap S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set \( S1 \cap S2 \).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l01131">1131</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1132</span>    {</div>
<div class="line"><span class="lineno"> 1133</span>      BOOST_STATIC_ASSERT( <a class="code hl_struct" href="structDGtal_1_1IsContainer.html">IsContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno"> 1134</span>      Container S( S1 );</div>
<div class="line"><span class="lineno"> 1135</span>      assignIntersection&lt;Container, ordered&gt;( S, S2 );</div>
<div class="line"><span class="lineno"> 1136</span>      <span class="keywordflow">return</span> S;</div>
<div class="line"><span class="lineno"> 1137</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l01082">assignIntersection()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SetFunctions_8h_source.html#l01332">DGtal::functions::setops::operator&amp;()</a>.</p>

</div>
</div>
<a id="a6d93770c72e70791aa57c47d22c982b9" name="a6d93770c72e70791aa57c47d22c982b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d93770c72e70791aa57c47d22c982b9">&#9670;&#160;</a></span>makeIntersection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeIntersection </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set intersection operation. Returns the set \( S1 \cap S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set \( S1 \cap S2 \).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l01149">1149</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1150</span>    {</div>
<div class="line"><span class="lineno"> 1151</span>      BOOST_STATIC_ASSERT( <a class="code hl_struct" href="structDGtal_1_1IsContainer.html">IsContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno"> 1152</span>      Container S( S1 );</div>
<div class="line"><span class="lineno"> 1153</span>      <a class="code hl_function" href="#a8ddbda63a20b3c113afc5eaeb1ae280c">assignIntersection</a>( S, S2 );</div>
<div class="line"><span class="lineno"> 1154</span>      <span class="keywordflow">return</span> S;</div>
<div class="line"><span class="lineno"> 1155</span>    }</div>
<div class="ttc" id="anamespaceDGtal_1_1functions_html_a8ddbda63a20b3c113afc5eaeb1ae280c"><div class="ttname"><a href="#a8ddbda63a20b3c113afc5eaeb1ae280c">DGtal::functions::assignIntersection</a></div><div class="ttdeci">Container &amp; assignIntersection(Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition</b> <a href="SetFunctions_8h_source.html#l01082">SetFunctions.h:1082</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l01082">assignIntersection()</a>.</p>

</div>
</div>
<a id="a03f0a6573a95aa152c8b8320baee6884" name="a03f0a6573a95aa152c8b8320baee6884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f0a6573a95aa152c8b8320baee6884">&#9670;&#160;</a></span>makeSymmetricDifference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeSymmetricDifference </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set symmetric difference operation. Returns the set \( S1 \Delta S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set \( S1 \Delta S2 \).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l01225">1225</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1226</span>    {</div>
<div class="line"><span class="lineno"> 1227</span>      BOOST_STATIC_ASSERT( <a class="code hl_struct" href="structDGtal_1_1IsContainer.html">IsContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno"> 1228</span>      Container S( S1 );</div>
<div class="line"><span class="lineno"> 1229</span>      assignSymmetricDifference&lt;Container, ordered&gt;( S, S2 );</div>
<div class="line"><span class="lineno"> 1230</span>      <span class="keywordflow">return</span> S;</div>
<div class="line"><span class="lineno"> 1231</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l01176">assignSymmetricDifference()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SetFunctions_8h_source.html#l01362">DGtal::functions::setops::operator^()</a>.</p>

</div>
</div>
<a id="aacd11e737e0c019de78553ae847a5724" name="aacd11e737e0c019de78553ae847a5724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd11e737e0c019de78553ae847a5724">&#9670;&#160;</a></span>makeSymmetricDifference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeSymmetricDifference </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set symmetric difference operation. Returns the set \( S1 \Delta S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set \( S1 \Delta S2 \).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l01243">1243</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1244</span>    {</div>
<div class="line"><span class="lineno"> 1245</span>      BOOST_STATIC_ASSERT( <a class="code hl_struct" href="structDGtal_1_1IsContainer.html">IsContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno"> 1246</span>      Container S( S1 );</div>
<div class="line"><span class="lineno"> 1247</span>      <a class="code hl_function" href="#ac2d1399432b7339a272a8a272577e7fd">assignSymmetricDifference</a>( S, S2 );</div>
<div class="line"><span class="lineno"> 1248</span>      <span class="keywordflow">return</span> S;</div>
<div class="line"><span class="lineno"> 1249</span>    }</div>
<div class="ttc" id="anamespaceDGtal_1_1functions_html_ac2d1399432b7339a272a8a272577e7fd"><div class="ttname"><a href="#ac2d1399432b7339a272a8a272577e7fd">DGtal::functions::assignSymmetricDifference</a></div><div class="ttdeci">Container &amp; assignSymmetricDifference(Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition</b> <a href="SetFunctions_8h_source.html#l01176">SetFunctions.h:1176</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l01176">assignSymmetricDifference()</a>.</p>

</div>
</div>
<a id="af848d0d5748af67bcb76b3d5e1f616cd" name="af848d0d5748af67bcb76b3d5e1f616cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af848d0d5748af67bcb76b3d5e1f616cd">&#9670;&#160;</a></span>makeUnion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeUnion </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set union operation. Returns the set \( S1 \cup S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set \( S1 \cup S2 \).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l01039">1039</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1040</span>    {</div>
<div class="line"><span class="lineno"> 1041</span>      BOOST_STATIC_ASSERT( <a class="code hl_struct" href="structDGtal_1_1IsContainer.html">IsContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno"> 1042</span>      Container S( S1 );</div>
<div class="line"><span class="lineno"> 1043</span>      assignUnion&lt;Container, ordered&gt;( S, S2 );</div>
<div class="line"><span class="lineno"> 1044</span>      <span class="keywordflow">return</span> S;</div>
<div class="line"><span class="lineno"> 1045</span>    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l00990">assignUnion()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SetFunctions_8h_source.html#l01303">DGtal::functions::setops::operator|()</a>.</p>

</div>
</div>
<a id="af462fb1f5ceade012f0e97831e3d8e64" name="af462fb1f5ceade012f0e97831e3d8e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af462fb1f5ceade012f0e97831e3d8e64">&#9670;&#160;</a></span>makeUnion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeUnion </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>S2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set union operation. Returns the set \( S1 \cup S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set \( S1 \cup S2 \).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SetFunctions_8h_source.html#l01057">1057</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1058</span>    {</div>
<div class="line"><span class="lineno"> 1059</span>      BOOST_STATIC_ASSERT( <a class="code hl_struct" href="structDGtal_1_1IsContainer.html">IsContainer&lt; Container &gt;::value</a> );</div>
<div class="line"><span class="lineno"> 1060</span>      Container S( S1 );</div>
<div class="line"><span class="lineno"> 1061</span>      <a class="code hl_function" href="#a68e9511773601750284f81ed46e1abbf">assignUnion</a>( S, S2 );</div>
<div class="line"><span class="lineno"> 1062</span>      <span class="keywordflow">return</span> S;</div>
<div class="line"><span class="lineno"> 1063</span>    }</div>
<div class="ttc" id="anamespaceDGtal_1_1functions_html_a68e9511773601750284f81ed46e1abbf"><div class="ttname"><a href="#a68e9511773601750284f81ed46e1abbf">DGtal::functions::assignUnion</a></div><div class="ttdeci">Container &amp; assignUnion(Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition</b> <a href="SetFunctions_8h_source.html#l00990">SetFunctions.h:990</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="SetFunctions_8h_source.html#l00990">assignUnion()</a>.</p>

</div>
</div>
<a id="a57d70667078dcd620ce69e2b0ff4d407" name="a57d70667078dcd620ce69e2b0ff4d407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d70667078dcd620ce69e2b0ff4d407">&#9670;&#160;</a></span>mapZeroPointNeighborhoodToConfigurationMask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CountedPtr.html">DGtal::CountedPtr</a>&lt; std::unordered_map&lt; TPoint, <a class="el" href="namespaceDGtal.html#a9b0310c71d3ce78fbc2100f29a979701">NeighborhoodConfiguration</a> &gt; &gt; DGtal::functions::mapZeroPointNeighborhoodToConfigurationMask </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps any point in the neighborhood of point Zero (0,..,0) to its corresponding configuration bit mask. This is a helper to use with tables. The order of the configuration is lexicographic, starting in {-1, -1, ...}. </p><dl class="section note"><dt>Note</dt><dd>the neighborhood is considered to be all points p which ||p-zero|| &lt;= 1</dd></dl>
<p>Example: Point{ -1, -1, -1 } = 1; // corresponding to mask x x 0000 0001 Point{ 0, -1, -1 } = 2; // corresponding to mask x x 0000 0010 Point{ 1, 1, 1 } = 2^26; // x 0010 x x x x x x</p>
<dl class="section note"><dt>Note</dt><dd>NeighborhoodConfiguration is type uint 32 bits, so the max dimension supported is 3.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>HyperRectDomain_Iterator::nextLexicographicOrder </dd>
<dd>
<a class="el" href="testNeighborhoodConfigurations_8cpp.html">testNeighborhoodConfigurations.cpp</a> shows the complete mapping.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TPoint</td><td>type of point to create map and input the desired dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>map[Point]-&gt;configuration smart pointer. </dd></dl>

<p class="reference">Referenced by <a class="el" href="testNeighborhoodConfigurations_8cpp_source.html#l00103">SCENARIO()</a>, <a class="el" href="testNeighborhoodConfigurations_8cpp_source.html#l00232">TEST_CASE()</a>, <a class="el" href="testNeighborhoodConfigurations_8cpp_source.html#l00067">TEST_CASE()</a>, <a class="el" href="testVoxelComplex_8cpp_source.html#l00810">TEST_CASE_METHOD()</a>, <a class="el" href="testVoxelComplex_8cpp_source.html#l01059">TEST_CASE_METHOD()</a>, <a class="el" href="testVoxelComplex_8cpp_source.html#l01004">TEST_CASE_METHOD()</a>, <a class="el" href="testNeighborhoodConfigurations_8cpp_source.html#l00251">TEST_CASE_METHOD()</a>, and <a class="el" href="VoxelComplexThinning_8h_source.html#l00092">thinningVoxelComplex()</a>.</p>

</div>
</div>
<a id="ab6b5998cbfc23060987babe806313a39" name="ab6b5998cbfc23060987babe806313a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b5998cbfc23060987babe806313a39">&#9670;&#160;</a></span>objectFromSpels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TObject , typename TKSpace , typename TCellContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; TObject &gt; DGtal::functions::objectFromSpels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create object from the spels in the complex.</p>
<p>User has to provide a 3D TObject type with its associated DigitalSet and <a class="el" href="classDGtal_1_1DigitalTopology.html" title="Aim: Represents a digital topology as a couple of adjacency relations.">DigitalTopology</a>.</p>
<p>Given a dimension n, spels are the n-cells, equivalently, spels are the grid-points in Z^n.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TObject</td><td>with its associdated DigitalSet and <a class="el" href="classDGtal_1_1DigitalTopology.html" title="Aim: Represents a digital topology as a couple of adjacency relations.">DigitalTopology</a> </td></tr>
    <tr><td class="paramname">TKSpace</td><td>kspace type of the input <a class="el" href="classDGtal_1_1CubicalComplex.html" title="Aim: This class represents an arbitrary cubical complex living in some Khalimsky space....">CubicalComplex</a>. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>cell container type of the input <a class="el" href="classDGtal_1_1CubicalComplex.html" title="Aim: This class represents an arbitrary cubical complex living in some Khalimsky space....">CubicalComplex</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>input <a class="el" href="classDGtal_1_1CubicalComplex.html" title="Aim: This class represents an arbitrary cubical complex living in some Khalimsky space....">CubicalComplex</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unique_ptr of created object with the pointset containing the spels of the complex. </dd></dl>

</div>
</div>
<a id="affff269feb515ccbb61fed6df33bd403" name="affff269feb515ccbb61fed6df33bd403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affff269feb515ccbb61fed6df33bd403">&#9670;&#160;</a></span>oneIsthmus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::oneIsthmus </td>
          <td>(</td>
          <td class="paramtype">const TComplex &amp;</td>          <td class="paramname"><span class="paramname"><em>vc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TComplex::Cell &amp;</td>          <td class="paramname"><span class="paramname"><em>cell</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if input cell is a 1-isthmus. A voxel is a 1-isthmus if, after a thinning, its proper neighborhood is made only by two voxels, ie, it is a 0-Surface <a class="el" href="#a4dba32b69179583e300225bf4227a381">isZeroSurface</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4dba32b69179583e300225bf4227a381">isZeroSurface</a> </dd>
<dd>
<a class="el" href="classDGtal_1_1Object.html#a5dfbef899715f5f0d81e02ad63504892">Object::properNeighborhood</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TComplex</td><td><a class="el" href="classDGtal_1_1VoxelComplex.html" title="This class represents a voxel complex living in some Khalimsky space. Voxel complexes are derived fro...">VoxelComplex</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vc</td><td>input complex. </td></tr>
    <tr><td class="paramname">cell</td><td>apply function on input cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="reference">Referenced by <a class="el" href="generateVoxelComplexTables_8cpp_source.html#l00061">main()</a>.</p>

</div>
</div>
<a id="a46d491155b4e945e904080855a3bae28" name="a46d491155b4e945e904080855a3bae28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d491155b4e945e904080855a3bae28">&#9670;&#160;</a></span>persistenceAsymetricThinningScheme()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TComplex DGtal::functions::persistenceAsymetricThinningScheme </td>
          <td>(</td>
          <td class="paramtype">TComplex &amp;</td>          <td class="paramname"><span class="paramname"><em>vc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; std::pair&lt; typename TComplex::Cell, typename TComplex::Data &gt;(const typename TComplex::Clique &amp;) &gt;</td>          <td class="paramname"><span class="paramname"><em>Select</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const TComplex &amp;, const typename TComplex::Cell &amp;) &gt;</td>          <td class="paramname"><span class="paramname"><em>Skel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e">uint32_t</a></td>          <td class="paramname"><span class="paramname"><em>persistence</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="VoxelComplexThinning_8h_source.html#l00092">thinningVoxelComplex()</a>.</p>

</div>
</div>
<a id="a18b68d329aa1461a0847a18e99247885" name="a18b68d329aa1461a0847a18e99247885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b68d329aa1461a0847a18e99247885">&#9670;&#160;</a></span>power()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T DGtal::functions::power </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>aVal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int</td>          <td class="paramname"><span class="paramname"><em>exponent</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute exponentiation by squaring of a scalar <em>aVal</em> of type <em>T</em> by the exponent <em>exponent</em> (unsigned int). The computation is done in \( O(\log(exponent))\) multiplications. </p><dl class="section note"><dt>Note</dt><dd>This function is better than std::pow on unsigned int exponents and integer value type since it performs exact computations (no cast to float or doubles).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aVal</td><td>the value </td></tr>
    <tr><td class="paramname">exponent</td><td>the exponent </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>scalar value type (must have '*' operator). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>aVal^exponent</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac8e2160844093488cdd738354027daa1">square</a>, <a class="el" href="#a4828e0475cb9aa8dceefa94f0ab4d168">cube</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="BasicMathFunctions_8h_source.html#l00073">73</a> of file <a class="el" href="BasicMathFunctions_8h_source.html">BasicMathFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   74</span>    {</div>
<div class="line"><span class="lineno">   75</span>      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=exponent;</div>
<div class="line"><span class="lineno">   76</span>      T p(aVal);</div>
<div class="line"><span class="lineno">   77</span>      </div>
<div class="line"><span class="lineno">   78</span>      <span class="keywordflow">if</span> (exponent == 0) { <span class="keywordflow">return</span> 1;    }</div>
<div class="line"><span class="lineno">   79</span>      </div>
<div class="line"><span class="lineno">   80</span>      T result = <a class="code hl_struct" href="structDGtal_1_1NumberTraits.html">NumberTraits&lt;T&gt;::ONE</a>;</div>
<div class="line"><span class="lineno">   81</span>      <span class="keywordflow">while</span> (q != 0) </div>
<div class="line"><span class="lineno">   82</span>        {</div>
<div class="line"><span class="lineno">   83</span>          <span class="keywordflow">if</span> (q % 2 == 1) {    <span class="comment">// q is odd</span></div>
<div class="line"><span class="lineno">   84</span>            result *= p;</div>
<div class="line"><span class="lineno">   85</span>            q--;</div>
<div class="line"><span class="lineno">   86</span>          }</div>
<div class="line"><span class="lineno">   87</span>          p *= p;</div>
<div class="line"><span class="lineno">   88</span>          q /= 2;</div>
<div class="line"><span class="lineno">   89</span>        }</div>
<div class="line"><span class="lineno">   90</span>      <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">   91</span>    }</div>
<div class="ttc" id="astructDGtal_1_1NumberTraits_html"><div class="ttname"><a href="structDGtal_1_1NumberTraits.html">DGtal::NumberTraits</a></div><div class="ttdoc">Aim: The traits class for all models of Cinteger.</div><div class="ttdef"><b>Definition</b> <a href="NumberTraits_8h_source.html#l00562">NumberTraits.h:564</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="testBasicMathFunctions_8cpp_source.html#l00046">testBasicMathFunctions()</a>.</p>

</div>
</div>
<a id="a42d6f1219d53ecefb73b55c386e0d54a" name="a42d6f1219d53ecefb73b55c386e0d54a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d6f1219d53ecefb73b55c386e0d54a">&#9670;&#160;</a></span>reversedSmartCH() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DSS , typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DSS::Vector DGtal::functions::reversedSmartCH </td>
          <td>(</td>
          <td class="paramtype">const DSS &amp;</td>          <td class="paramname"><span class="paramname"><em>aDSS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DSS::Position &amp;</td>          <td class="paramname"><span class="paramname"><em>aPositionBound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator</td>          <td class="paramname"><span class="paramname"><em>uIto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator</td>          <td class="paramname"><span class="paramname"><em>lIto</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Procedure that computes the lower and upper left hull of the left subsegment of a greater DSS <em>aDSS</em>. Note that the so-called left subsegment is bounded on the one hand by the first point of <em>aDSS</em> and on the other hand by the point located at position <em>aPositionBound</em> [Roussillon 2014 : <a class="el" href="citelist.html#CITEREF_RoussillonDGCI2014">[105]</a>]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDSS</td><td>bounding DSS </td></tr>
    <tr><td class="paramname">aPositionBound</td><td>position of the last point of the subsegment (should be located after the first point of <em>aDSS</em>). </td></tr>
    <tr><td class="paramname">uIto</td><td>output iterator used to store the vertices of the upper convex hull </td></tr>
    <tr><td class="paramname">lIto</td><td>output iterator used to store the vertices of the lower convex hull</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DSS</td><td>a model of arithmetical DSS </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of output iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last direction vector, ie. the rational slope of minimal denominator </dd></dl>

</div>
</div>
<a id="aa754ac3d17216563354db61d905a545c" name="aa754ac3d17216563354db61d905a545c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa754ac3d17216563354db61d905a545c">&#9670;&#160;</a></span>reversedSmartCH() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> , typename Position , typename PositionFunctor , typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> DGtal::functions::reversedSmartCH </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a></td>          <td class="paramname"><span class="paramname"><em>U</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a></td>          <td class="paramname"><span class="paramname"><em>L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a></td>          <td class="paramname"><span class="paramname"><em>V</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;</td>          <td class="paramname"><span class="paramname"><em>aFirstPosition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;</td>          <td class="paramname"><span class="paramname"><em>aLastPosition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PositionFunctor &amp;</td>          <td class="paramname"><span class="paramname"><em>aPositionFunctor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator</td>          <td class="paramname"><span class="paramname"><em>uIto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator</td>          <td class="paramname"><span class="paramname"><em>lIto</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Procedure that computes the lower and upper left hull of the left subsegment of a greater DSS characterized by the first upper leaning point <em>U</em>, the first positive Bezout point <em>L</em> and its direction vector <em>V</em>. Note that the so-called left subsegment is bounded on the one hand by the first point of the DSS located at <em>aFirstPosition</em> and on the other hand by the point located at position <em>aLastPosition</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>last upper convex hull vertex </td></tr>
    <tr><td class="paramname">L</td><td>last lower convex hull vertex </td></tr>
    <tr><td class="paramname">V</td><td>last valid Bezout vector (main direction vector) </td></tr>
    <tr><td class="paramname">aFirstPosition</td><td>position of the first point of the subsegment </td></tr>
    <tr><td class="paramname">aLastPosition</td><td>position of the last point of the subsegment </td></tr>
    <tr><td class="paramname">aPositionFunctor</td><td>position functor, which returns the position of any given point/vector </td></tr>
    <tr><td class="paramname">uIto</td><td>output iterator used to store the vertices of the upper convex hull </td></tr>
    <tr><td class="paramname">lIto</td><td>output iterator used to store the vertices of the lower convex hull</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a></td><td>a model of 2d point/vector </td></tr>
    <tr><td class="paramname">Position</td><td>a model of integer for the position of the point in the bounding DSS </td></tr>
    <tr><td class="paramname">PositionFunctor</td><td>a model of unary functor that returns the position of a point/vector </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of output iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last direction vector, ie. the rational slope of minimal denominator </dd></dl>

<p class="reference">Referenced by <a class="el" href="testArithmeticalDSSConvexHull_8cpp_source.html#l00499">basicTest2()</a>, and <a class="el" href="testArithmeticalDSSConvexHull_8cpp_source.html#l00629">reversedSmartCHSubsegment()</a>.</p>

</div>
</div>
<a id="a48dff4e7a37ef5122f124d830b4b177a" name="a48dff4e7a37ef5122f124d830b4b177a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48dff4e7a37ef5122f124d830b4b177a">&#9670;&#160;</a></span>roundToUpperPowerOfTwo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T DGtal::functions::roundToUpperPowerOfTwo </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the next higher power of two of the given argument n of type T.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the element T </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an element of type T (casted to unsigned integer). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next higher power of two. </dd></dl>

<p class="definition">Definition at line <a class="el" href="BasicMathFunctions_8h_source.html#l00102">102</a> of file <a class="el" href="BasicMathFunctions_8h_source.html">BasicMathFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  102</span>                                         {</div>
<div class="line"><span class="lineno">  103</span>      <span class="keywordflow">return</span> (T)  1 &lt;&lt; (1+<a class="code hl_function" href="structDGtal_1_1Bits.html#a25b5f464fec0d951d75f1fe10a07f0ea">DGtal::Bits::mostSignificantBit</a>( (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) n-1 ) );</div>
<div class="line"><span class="lineno">  104</span>    }</div>
<div class="ttc" id="astructDGtal_1_1Bits_html_a25b5f464fec0d951d75f1fe10a07f0ea"><div class="ttname"><a href="structDGtal_1_1Bits.html#a25b5f464fec0d951d75f1fe10a07f0ea">DGtal::Bits::mostSignificantBit</a></div><div class="ttdeci">static unsigned int mostSignificantBit(DGtal::uint8_t n)</div><div class="ttdef"><b>Definition</b> <a href="Bits_8h_source.html#l00343">Bits.h:343</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="Bits_8h_source.html#l00343">DGtal::Bits::mostSignificantBit()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Viewer3D_8h_source.html#l01313">DGtal::Viewer3D&lt; TSpace, TKSpace &gt;::GLTextureImage::GLTextureImage()</a>, and <a class="el" href="testBasicMathFunctions_8cpp_source.html#l00046">testBasicMathFunctions()</a>.</p>

</div>
</div>
<a id="a38193d6ce6446ca81fb84114d5f9629c" name="a38193d6ce6446ca81fb84114d5f9629c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38193d6ce6446ca81fb84114d5f9629c">&#9670;&#160;</a></span>selectFirst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename TComplex::Cell, typename TComplex::Data &gt; DGtal::functions::selectFirst </td>
          <td>(</td>
          <td class="paramtype">const typename TComplex::Clique &amp;</td>          <td class="paramname"><span class="paramname"><em>clique</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select first voxel of input clique.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TComplex</td><td>input <a class="el" href="classDGtal_1_1CubicalComplex.html" title="Aim: This class represents an arbitrary cubical complex living in some Khalimsky space....">CubicalComplex</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clique</td><td>from where cell is chosen.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first voxel of clique. </dd></dl>

<p class="reference">Referenced by <a class="el" href="VoxelComplexThinning_8h_source.html#l00092">thinningVoxelComplex()</a>.</p>

</div>
</div>
<a id="a938d429d0ec543c8672a815bdfcf9075" name="a938d429d0ec543c8672a815bdfcf9075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938d429d0ec543c8672a815bdfcf9075">&#9670;&#160;</a></span>selectMaxValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDistanceTransform , typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename TComplex::Cell, typename TComplex::Data &gt; DGtal::functions::selectMaxValue </td>
          <td>(</td>
          <td class="paramtype">const TDistanceTransform &amp;</td>          <td class="paramname"><span class="paramname"><em>dist_map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TComplex::Clique &amp;</td>          <td class="paramname"><span class="paramname"><em>clique</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select cell from clique that has max value looking at the input dist_map. The points in the dist_map and in the clique must refer to the same position.</p>
<p>If you need to have a std::function&lt;bool(const Clique &amp;)&gt; signature (for using it in thinning algorithms), use a lambda: subsitute skelRandom (for example) for: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> selectDistMax =</div>
<div class="line">[&amp;dist_map](<span class="keyword">const</span> Clique &amp; clique){</div>
<div class="line">    <span class="keywordflow">return</span> selectMaxDistance&lt;TDistMap, TComplex&gt;(dist_map, clique);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDistanceTransform</td><td>Container type for the distance map. </td></tr>
    <tr><td class="paramname">TComplex</td><td>input <a class="el" href="classDGtal_1_1CubicalComplex.html" title="Aim: This class represents an arbitrary cubical complex living in some Khalimsky space....">CubicalComplex</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dist_map</td><td>container holding the values. </td></tr>
    <tr><td class="paramname">clique</td><td>from where cell is chosen.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cell from input clique with highest value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DistanceTransformation_8h_source.html">DistanceTransformation.h</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="VoxelComplexThinning_8h_source.html#l00092">thinningVoxelComplex()</a>.</p>

</div>
</div>
<a id="a2d5060acdeb2181c1967bcdb413bd5e6" name="a2d5060acdeb2181c1967bcdb413bd5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5060acdeb2181c1967bcdb413bd5e6">&#9670;&#160;</a></span>selectRandom() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename TComplex::Cell, typename TComplex::Data &gt; DGtal::functions::selectRandom </td>
          <td>(</td>
          <td class="paramtype">const typename TComplex::Clique &amp;</td>          <td class="paramname"><span class="paramname"><em>clique</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select random voxel from input clique.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TComplex</td><td>input <a class="el" href="classDGtal_1_1CubicalComplex.html" title="Aim: This class represents an arbitrary cubical complex living in some Khalimsky space....">CubicalComplex</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clique</td><td>from where cell is chosen.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>random voxel from input clique. </dd></dl>

<p class="reference">Referenced by <a class="el" href="VoxelComplexThinning_8h_source.html#l00092">thinningVoxelComplex()</a>.</p>

</div>
</div>
<a id="ad2ab34965119dc41d5adb081d8ef5262" name="ad2ab34965119dc41d5adb081d8ef5262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ab34965119dc41d5adb081d8ef5262">&#9670;&#160;</a></span>selectRandom() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex , typename TRandomGenerator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename TComplex::Cell, typename TComplex::Data &gt; DGtal::functions::selectRandom </td>
          <td>(</td>
          <td class="paramtype">const typename TComplex::Clique &amp;</td>          <td class="paramname"><span class="paramname"><em>clique</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRandomGenerator &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select random voxel from input clique.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TComplex</td><td><a class="el" href="classDGtal_1_1CubicalComplex.html" title="Aim: This class represents an arbitrary cubical complex living in some Khalimsky space....">CubicalComplex</a> </td></tr>
    <tr><td class="paramname">TRandomGenerator</td><td>RandomGenerator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clique</td><td>from where cell is chosen </td></tr>
    <tr><td class="paramname">gen</td><td>random generator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>random voxel from input clique. </dd></dl>

</div>
</div>
<a id="a73b08e83670143586a55950e050aa6ad" name="a73b08e83670143586a55950e050aa6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b08e83670143586a55950e050aa6ad">&#9670;&#160;</a></span>skelEnd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::skelEnd </td>
          <td>(</td>
          <td class="paramtype">const TComplex &amp;</td>          <td class="paramname"><span class="paramname"><em>vc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TComplex::Cell &amp;</td>          <td class="paramname"><span class="paramname"><em>cell</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if input cell only has one neighbor, using <a class="el" href="classDGtal_1_1Object.html#af7da546db68f0f04420e4c4c6d4d62a0">Object::topology</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TComplex</td><td><a class="el" href="classDGtal_1_1VoxelComplex.html" title="This class represents a voxel complex living in some Khalimsky space. Voxel complexes are derived fro...">VoxelComplex</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vc</td><td>input voxel complex. </td></tr>
    <tr><td class="paramname">cell</td><td>c apply function on this voxel cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if voxel cell only has neighbor. </dd></dl>

<p class="reference">Referenced by <a class="el" href="VoxelComplexThinning_8h_source.html#l00092">thinningVoxelComplex()</a>.</p>

</div>
</div>
<a id="a147a79d431e108b58dd715c876da90ec" name="a147a79d431e108b58dd715c876da90ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147a79d431e108b58dd715c876da90ec">&#9670;&#160;</a></span>skelIsthmus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::skelIsthmus </td>
          <td>(</td>
          <td class="paramtype">const TComplex &amp;</td>          <td class="paramname"><span class="paramname"><em>vc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TComplex::Cell &amp;</td>          <td class="paramname"><span class="paramname"><em>cell</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if input cell is a 1 or 2 Isthmus.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TComplex</td><td><a class="el" href="classDGtal_1_1VoxelComplex.html" title="This class represents a voxel complex living in some Khalimsky space. Voxel complexes are derived fro...">VoxelComplex</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vc</td><td>input complex. </td></tr>
    <tr><td class="paramname">cell</td><td>apply function on input cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>oneIsthmus || twoIsthmus</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#affff269feb515ccbb61fed6df33bd403">oneIsthmus</a> </dd>
<dd>
<a class="el" href="#ad86a0dd4add6c1b9f567908893b4a69d">twoIsthmus</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="generateVoxelComplexTables_8cpp_source.html#l00061">main()</a>.</p>

</div>
</div>
<a id="a4e8e89624580d0a7c6ecebbb8a3d072d" name="a4e8e89624580d0a7c6ecebbb8a3d072d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8e89624580d0a7c6ecebbb8a3d072d">&#9670;&#160;</a></span>skelSimple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::skelSimple </td>
          <td>(</td>
          <td class="paramtype">const TComplex &amp;</td>          <td class="paramname"><span class="paramname"><em>vc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TComplex::Cell &amp;</td>          <td class="paramname"><span class="paramname"><em>cell</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if input cell is simple using <a class="el" href="classDGtal_1_1VoxelComplex.html#ac4bb0bb6a7b8b1c7117f1b5982d658d3">VoxelComplex::isSimple</a> interface to <a class="el" href="classDGtal_1_1Object.html#ae9ea876b5d762b4445e757ba7be42633">Object::isSimple</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1VoxelComplex.html#ac4bb0bb6a7b8b1c7117f1b5982d658d3">VoxelComplex::isSimple</a> </dd>
<dd>
<a class="el" href="classDGtal_1_1Object.html#ae9ea876b5d762b4445e757ba7be42633">Object::isSimple</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TComplex</td><td><a class="el" href="classDGtal_1_1VoxelComplex.html" title="This class represents a voxel complex living in some Khalimsky space. Voxel complexes are derived fro...">VoxelComplex</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vc</td><td>input complex. </td></tr>
    <tr><td class="paramname">cell</td><td>apply function on input cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if voxel is simple. </dd></dl>

</div>
</div>
<a id="ad1a335e8f7956c3188e031a8d83a5ea7" name="ad1a335e8f7956c3188e031a8d83a5ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a335e8f7956c3188e031a8d83a5ea7">&#9670;&#160;</a></span>skelUltimate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::skelUltimate </td>
          <td>(</td>
          <td class="paramtype">const TComplex &amp;</td>          <td class="paramname"><span class="paramname"><em>vc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TComplex::Cell &amp;</td>          <td class="paramname"><span class="paramname"><em>cell</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Always returns false. Used in thinning schemes to calculate an ultimate skeleton. An ultimate skeleton only keeps voxels that don't change the topology.</p>
<dl class="section note"><dt>Note</dt><dd>The number of cells of a thinning using this function is the same as the number of connected components of an object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8f2a4664af776ca513141edb552a4461">asymetricThinningScheme</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TComplex</td><td><a class="el" href="classDGtal_1_1VoxelComplex.html" title="This class represents a voxel complex living in some Khalimsky space. Voxel complexes are derived fro...">VoxelComplex</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vc</td><td>input voxel complex. </td></tr>
    <tr><td class="paramname">cell</td><td>c apply function on this voxel cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>always false. </dd></dl>

<p class="reference">Referenced by <a class="el" href="VoxelComplexThinning_8h_source.html#l00092">thinningVoxelComplex()</a>.</p>

</div>
</div>
<a id="a23d911a3be8b0751f42bc11e96d3af1b" name="a23d911a3be8b0751f42bc11e96d3af1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d911a3be8b0751f42bc11e96d3af1b">&#9670;&#160;</a></span>skelWithTable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::skelWithTable </td>
          <td>(</td>
          <td class="paramtype">const boost::dynamic_bitset&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>table</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; typename TComplex::Point, unsigned int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pointToMaskMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TComplex &amp;</td>          <td class="paramname"><span class="paramname"><em>vc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TComplex::Cell &amp;</td>          <td class="paramname"><span class="paramname"><em>cell</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic predicate to use external tables[configuration]-&gt;bool with skel functions. Can be adapted to any table using lambdas.</p>
<dl class="section see"><dt>See also</dt><dd>LookUpTableFunctions.h </dd>
<dd>
tests/topology/testVoxelComplex.h</dd></dl>
<p>If you need to have a std::function&lt;bool(const Complex &amp; vc, const Cell &amp; c )&gt; signature (for using it in thinning algorithms), use a lambda to capture values: subsitute skelIsthmus (for example) for: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> skelWithTableIsthmus =</div>
<div class="line">[&amp;table, &amp;pointToMaskMap](<span class="keyword">const</span> Complex &amp; vc, <span class="keyword">const</span> <a class="code hl_class" href="structDGtal_1_1KhalimskyCell.html">Cell</a> &amp; cell){</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="#a23d911a3be8b0751f42bc11e96d3af1b">skelWithTable&lt;TComplex&gt;</a>(table, pointToMaskMap, vc, cell);</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceDGtal_1_1functions_html_a23d911a3be8b0751f42bc11e96d3af1b"><div class="ttname"><a href="#a23d911a3be8b0751f42bc11e96d3af1b">DGtal::functions::skelWithTable</a></div><div class="ttdeci">bool skelWithTable(const boost::dynamic_bitset&lt;&gt; &amp;table, const std::unordered_map&lt; typename TComplex::Point, unsigned int &gt; &amp;pointToMaskMap, const TComplex &amp;vc, const typename TComplex::Cell &amp;cell)</div></div>
<div class="ttc" id="astructDGtal_1_1KhalimskyCell_html"><div class="ttname"><a href="structDGtal_1_1KhalimskyCell.html">DGtal::KhalimskyCell&lt; dim, Integer &gt;</a></div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TComplex</td><td>input <a class="el" href="classDGtal_1_1CubicalComplex.html" title="Aim: This class represents an arbitrary cubical complex living in some Khalimsky space....">CubicalComplex</a> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>[configuration]-&gt;bool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>VoxelComplex::loadTable </dd>
<dd>
LookUpTableFunctions.h::loadTable</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointToMaskMap</td><td>map[neighborhood points] to a bit mask. Used to get the neighborhood configuration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1VoxelComplex.html#a88e369a3a09d8eb7dc719199dd56a59e">VoxelComplex::pointToMask</a> </dd>
<dd>
LookUpTableFunctions.h::mapPointToBitMask</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vc</td><td>input complex.</td></tr>
    <tr><td class="paramname">cell</td><td>input cell, center from where the neighborhood [configuration] will be checked. Note that only neighborhood are checked to belong to the complex, not the input cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool from selected table[configuration]. </dd></dl>

<p class="reference">Referenced by <a class="el" href="VoxelComplexThinning_8h_source.html#l00092">thinningVoxelComplex()</a>.</p>

</div>
</div>
<a id="adc99490ec12ae9e68c03c08d473e8692" name="adc99490ec12ae9e68c03c08d473e8692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc99490ec12ae9e68c03c08d473e8692">&#9670;&#160;</a></span>smartCH() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DSL , typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DSL::Vector DGtal::functions::smartCH </td>
          <td>(</td>
          <td class="paramtype">const DSL &amp;</td>          <td class="paramname"><span class="paramname"><em>aDSL</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DSL::Point &amp;</td>          <td class="paramname"><span class="paramname"><em>aFirstPoint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DSL::Position &amp;</td>          <td class="paramname"><span class="paramname"><em>aLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator</td>          <td class="paramname"><span class="paramname"><em>uIto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator</td>          <td class="paramname"><span class="paramname"><em>lIto</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Procedure that computes the lower and upper left hull of a DSS of first point <em>aFirstPoint</em>, length <em>aLength</em>, contained in a DSL <em>aDSL</em> [Roussillon 2014 : <a class="el" href="citelist.html#CITEREF_RoussillonDGCI2014">[105]</a>]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDSL</td><td>bounding DSL </td></tr>
    <tr><td class="paramname">aFirstPoint</td><td>first point of the DSS </td></tr>
    <tr><td class="paramname">aLength</td><td>(strictly positive) length of the DSS </td></tr>
    <tr><td class="paramname">uIto</td><td>output iterator used to store the vertices of the upper convex hull </td></tr>
    <tr><td class="paramname">lIto</td><td>output iterator used to store the vertices of the lower convex hull</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last direction vector, ie. the rational slope of minimal denominator</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DSL</td><td>a model of arithmetical DSL </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of output iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07b66e9e7682c0f900bcbeabcac96b7b" name="a07b66e9e7682c0f900bcbeabcac96b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b66e9e7682c0f900bcbeabcac96b7b">&#9670;&#160;</a></span>smartCH() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> , typename Coordinate , typename Position , typename PositionFunctor , typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> DGtal::functions::smartCH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>aFirstPoint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coordinate &amp;</td>          <td class="paramname"><span class="paramname"><em>aRemainderBound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;</td>          <td class="paramname"><span class="paramname"><em>aPositionBound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>aStep</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coordinate &amp;</td>          <td class="paramname"><span class="paramname"><em>aRStep</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>aShift</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coordinate &amp;</td>          <td class="paramname"><span class="paramname"><em>aRShift</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PositionFunctor &amp;</td>          <td class="paramname"><span class="paramname"><em>aPositionFunctor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator</td>          <td class="paramname"><span class="paramname"><em>uIto</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator</td>          <td class="paramname"><span class="paramname"><em>lIto</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Procedure that computes the lower and upper left hull of a DSS of first point <em>aFirstPoint</em>, length <em>aPositionBound</em>, contained in a digital straight line described by <em>aRStep</em>, <em>aRShift</em> and <em>aRemainderBound</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aFirstPoint</td><td>first point of the DSS </td></tr>
    <tr><td class="paramname">aRemainderBound</td><td>difference between the intercept mu of the bounding DSL and the remainder of the first point. </td></tr>
    <tr><td class="paramname">aPositionBound</td><td>(strictly positive) length of the DSS </td></tr>
    <tr><td class="paramname">aStep</td><td>first step of the DSL </td></tr>
    <tr><td class="paramname">aRStep</td><td>remainder of the first step, ie. parameter \( a \) of the bounding DSL </td></tr>
    <tr><td class="paramname">aShift</td><td>shift vector of the DSL </td></tr>
    <tr><td class="paramname">aRShift</td><td>remainder of the shift vector, ie. parameter \( omega \) of the bounding DSL. </td></tr>
    <tr><td class="paramname">aPositionFunctor</td><td>position functor, which returns the position of any given point/vector </td></tr>
    <tr><td class="paramname">uIto</td><td>output iterator used to store the vertices of the upper convex hull </td></tr>
    <tr><td class="paramname">lIto</td><td>output iterator used to store the vertices of the lower convex hull</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last direction vector, ie. the rational slope of minimal denominator of the DSS</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a></td><td>a model of 2d point/vector </td></tr>
    <tr><td class="paramname">Coordinate</td><td>a model of integer for the coordinates of the point/vector </td></tr>
    <tr><td class="paramname">Position</td><td>a model of integer for locating points in the DSS </td></tr>
    <tr><td class="paramname">PositionFunctor</td><td>a model of unary functor that returns the position of a point/vector </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of output iterator </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="testArithmeticalDSSConvexHull_8cpp_source.html#l00061">basicTest()</a>, <a class="el" href="testArithmeticalDSSConvexHull_8cpp_source.html#l00196">comparisonLeftHull()</a>, and <a class="el" href="testArithmeticalDSSConvexHull_8cpp_source.html#l00318">smartCHSubsegment()</a>.</p>

</div>
</div>
<a id="a2c21293d6efa82afb1b20db4d7a794a7" name="a2c21293d6efa82afb1b20db4d7a794a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c21293d6efa82afb1b20db4d7a794a7">&#9670;&#160;</a></span>smartCHNextVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Position , typename Coordinate , typename <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> , typename OutputIterator , typename PositionFunctor , typename TruncationFunctor1 , typename TruncationFunctor2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::smartCHNextVertex </td>
          <td>(</td>
          <td class="paramtype">const Position &amp;</td>          <td class="paramname"><span class="paramname"><em>positionBound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coordinate &amp;</td>          <td class="paramname"><span class="paramname"><em>remainderBound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coordinate &amp;</td>          <td class="paramname"><span class="paramname"><em>rX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coordinate &amp;</td>          <td class="paramname"><span class="paramname"><em>rY</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>V</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coordinate &amp;</td>          <td class="paramname"><span class="paramname"><em>rV</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator</td>          <td class="paramname"><span class="paramname"><em>ito</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PositionFunctor &amp;</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TruncationFunctor1 &amp;</td>          <td class="paramname"><span class="paramname"><em>f1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TruncationFunctor2 &amp;</td>          <td class="paramname"><span class="paramname"><em>f2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Procedure that computes the next (lower or upper) vertex of the left hull of a DSS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positionBound</td><td>position of the last point of the DSS </td></tr>
    <tr><td class="paramname">remainderBound</td><td>remainder of the lower leaning points contained in the DSS </td></tr>
    <tr><td class="paramname">X</td><td>(returned) last vertex of the considered side </td></tr>
    <tr><td class="paramname">rX</td><td>(returned) remainder of <em>X</em> </td></tr>
    <tr><td class="paramname">Y</td><td>last vertex of the opposite side </td></tr>
    <tr><td class="paramname">rY</td><td>remainder of <em>Y</em> </td></tr>
    <tr><td class="paramname">V</td><td>(returned) last direction vector (unimodular with (<em>X</em> - <em>Y</em>)) </td></tr>
    <tr><td class="paramname">rV</td><td>(returned) remainder of <em>V</em> (not null) </td></tr>
    <tr><td class="paramname">ito</td><td>output iterator used to store the new vertex lying on the same side as <em>X</em> </td></tr>
    <tr><td class="paramname">pos</td><td>position functor, which returns the position of any given point/vector </td></tr>
    <tr><td class="paramname">f1</td><td>first floor function (for the vertex) </td></tr>
    <tr><td class="paramname">f2</td><td>second floor function (for the direction vector)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the last vertex of the left hull has been reached, 'false' otherwise.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Position</td><td>a model of integer for locating points in the DSS </td></tr>
    <tr><td class="paramname"><a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a></td><td>a model of 2d point/vector </td></tr>
    <tr><td class="paramname">Coordinate</td><td>a model of integer for the coordinates of the point/vector </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of output iterator </td></tr>
    <tr><td class="paramname">PositionFunctor</td><td>a model of unary functor that returns the position of a point/vector </td></tr>
    <tr><td class="paramname">TruncationFunctor1</td><td>a model of unary functor that implements an integer division </td></tr>
    <tr><td class="paramname">TruncationFunctor2</td><td>a model of unary functor that implements an integer division </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a184e90763c4747a4b7c71a58e1bf4bfe" name="a184e90763c4747a4b7c71a58e1bf4bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184e90763c4747a4b7c71a58e1bf4bfe">&#9670;&#160;</a></span>smartCHPreviousVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> , typename Position , typename OutputIterator , typename TruncationFunctor1 , typename TruncationFunctor2 , typename PositionFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::smartCHPreviousVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>V</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;</td>          <td class="paramname"><span class="paramname"><em>aFirstPosition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;</td>          <td class="paramname"><span class="paramname"><em>aLastPosition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator</td>          <td class="paramname"><span class="paramname"><em>ito</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PositionFunctor &amp;</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TruncationFunctor1 &amp;</td>          <td class="paramname"><span class="paramname"><em>f1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TruncationFunctor2 &amp;</td>          <td class="paramname"><span class="paramname"><em>f2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Procedure that computes the previous vertex of the left hull of a DSS of main direction vector <em>V</em> , first upper leaning point <em>U</em> and first positive Bezout point <em>L</em>. The computation stops as soon as a computed vertex is located before <em>aLastPosition</em>. <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>(returned) first vertex of the left hull on the considered side </td></tr>
    <tr><td class="paramname">Y</td><td>first vertex of the left hull on the opposite side </td></tr>
    <tr><td class="paramname">V</td><td>(returned) previous direction vector </td></tr>
    <tr><td class="paramname">aFirstPosition</td><td>position of the first point of the subsegment </td></tr>
    <tr><td class="paramname">aLastPosition</td><td>position of the last point of the subsegment </td></tr>
    <tr><td class="paramname">ito</td><td>output iterator used to store the vertices of the left hull lying on the same side as <em>X</em> </td></tr>
    <tr><td class="paramname">pos</td><td>position functor, which returns the position of any given point/vector </td></tr>
    <tr><td class="paramname">f1</td><td>integer divisor for the direction vector update </td></tr>
    <tr><td class="paramname">f2</td><td>integer divisor for the vertex update</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a></td><td>a model of couple of coordinates </td></tr>
    <tr><td class="paramname">Position</td><td>a model of integer for the position of the points </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of output iterator </td></tr>
    <tr><td class="paramname">TruncationFunctor1</td><td>a model of functor for the integer division </td></tr>
    <tr><td class="paramname">TruncationFunctor2</td><td>a model of functor for the integer division </td></tr>
    <tr><td class="paramname">PositionFunctor</td><td>a model of functor returning the position of a point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the last vertex has been reached, 'false' otherwise </dd></dl>

</div>
</div>
<a id="ac8e2160844093488cdd738354027daa1" name="ac8e2160844093488cdd738354027daa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e2160844093488cdd738354027daa1">&#9670;&#160;</a></span>square()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T DGtal::functions::square </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value x * x </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>a type with the multiply operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>any value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value x * x </dd></dl>

<p class="definition">Definition at line <a class="el" href="BasicMathFunctions_8h_source.html#l00133">133</a> of file <a class="el" href="BasicMathFunctions_8h_source.html">BasicMathFunctions.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  134</span>    { <span class="keywordflow">return</span> x * x; }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="Point2ScalarFunctors_8h_source.html#l00097">DGtal::functors::BallConstantPointFunction&lt; TPoint, TScalar &gt;::operator()()</a>, and <a class="el" href="Point2ScalarFunctors_8h_source.html#l00069">DGtal::functors::HatPointFunction&lt; TPoint, TScalar &gt;::operator()()</a>.</p>

</div>
</div>
<a id="abe3a164539f931c2f8bbaddb6d44b50a" name="abe3a164539f931c2f8bbaddb6d44b50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3a164539f931c2f8bbaddb6d44b50a">&#9670;&#160;</a></span>thinningVoxelComplex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex , typename TDistanceTransform  = DistanceTransformation&lt;Z3i::Space, Z3i::DigitalSet, ExactPredicateLpSeparableMetric&lt;Z3i::Space, 3&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TComplex DGtal::functions::thinningVoxelComplex </td>
          <td>(</td>
          <td class="paramtype">TComplex &amp;</td>          <td class="paramname"><span class="paramname"><em>vc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>skel_type_str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>skel_select_type_str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>tables_folder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;</td>          <td class="paramname"><span class="paramname"><em>persistence</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TDistanceTransform *</td>          <td class="paramname"><span class="paramname"><em>distance_transform</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>profile</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VoxelComplexThinning_8h_source.html#l00092">92</a> of file <a class="el" href="VoxelComplexThinning_8h_source.html">VoxelComplexThinning.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  101</span>{</div>
<div class="line"><span class="lineno">  102</span>  <span class="keywordflow">if</span>(verbose) {</div>
<div class="line"><span class="lineno">  103</span>    <span class="keyword">using </span><a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">DGtal::trace</a>;</div>
<div class="line"><span class="lineno">  104</span>    <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a>(<span class="stringliteral">&quot;thin_function parameters:&quot;</span>);</div>
<div class="line"><span class="lineno">  105</span>    <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#a9b36f5ab76b1945c8156cb4dba780bfb">info</a>() &lt;&lt; <span class="stringliteral">&quot;skel_type_str: &quot;</span> &lt;&lt; skel_type_str &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  106</span>    <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#a9b36f5ab76b1945c8156cb4dba780bfb">info</a>() &lt;&lt; <span class="stringliteral">&quot;skel_select_type_str: &quot;</span> &lt;&lt; skel_select_type_str &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  107</span>    <span class="keywordflow">if</span>(distance_transform) {</div>
<div class="line"><span class="lineno">  108</span>      <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#a9b36f5ab76b1945c8156cb4dba780bfb">info</a>() &lt;&lt; <span class="stringliteral">&quot; -- provided distance_transform.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  109</span>    }</div>
<div class="line"><span class="lineno">  110</span>    <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#a9b36f5ab76b1945c8156cb4dba780bfb">info</a>() &lt;&lt; <span class="stringliteral">&quot;persistence: &quot;</span> &lt;&lt; persistence &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  111</span>    <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#a9b36f5ab76b1945c8156cb4dba780bfb">info</a>() &lt;&lt; <span class="stringliteral">&quot;profile: &quot;</span> &lt;&lt; profile &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  112</span>    <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#a9b36f5ab76b1945c8156cb4dba780bfb">info</a>() &lt;&lt; <span class="stringliteral">&quot;verbose: &quot;</span> &lt;&lt; verbose &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  113</span>    <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#a9b36f5ab76b1945c8156cb4dba780bfb">info</a>() &lt;&lt; <span class="stringliteral">&quot;----------&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  114</span>    <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div>
<div class="line"><span class="lineno">  115</span>  }</div>
<div class="line"><span class="lineno">  116</span> </div>
<div class="line"><span class="lineno">  117</span>  <span class="comment">// Validate input skel method and skel_select</span></div>
<div class="line"><span class="lineno">  118</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> skel_type_str_is_valid =</div>
<div class="line"><span class="lineno">  119</span>    skel_type_str == <span class="stringliteral">&quot;ultimate&quot;</span> ||</div>
<div class="line"><span class="lineno">  120</span>    skel_type_str == <span class="stringliteral">&quot;end&quot;</span> ||</div>
<div class="line"><span class="lineno">  121</span>    skel_type_str == <span class="stringliteral">&quot;isthmus&quot;</span> ||</div>
<div class="line"><span class="lineno">  122</span>    skel_type_str == <span class="stringliteral">&quot;1isthmus&quot;</span> ||</div>
<div class="line"><span class="lineno">  123</span>    skel_type_str == <span class="stringliteral">&quot;isthmus1&quot;</span>;</div>
<div class="line"><span class="lineno">  124</span>  <span class="keywordflow">if</span>(!skel_type_str_is_valid) {</div>
<div class="line"><span class="lineno">  125</span>    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;skel_type_str is not valid: \&quot;&quot;</span> + skel_type_str + <span class="stringliteral">&quot;\&quot;&quot;</span>);</div>
<div class="line"><span class="lineno">  126</span>  }</div>
<div class="line"><span class="lineno">  127</span> </div>
<div class="line"><span class="lineno">  128</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> skel_select_type_str_is_valid =</div>
<div class="line"><span class="lineno">  129</span>    skel_select_type_str == <span class="stringliteral">&quot;first&quot;</span> ||</div>
<div class="line"><span class="lineno">  130</span>    skel_select_type_str == <span class="stringliteral">&quot;random&quot;</span> ||</div>
<div class="line"><span class="lineno">  131</span>    skel_select_type_str == <span class="stringliteral">&quot;dmax&quot;</span>;</div>
<div class="line"><span class="lineno">  132</span>  <span class="keywordflow">if</span>(!skel_select_type_str_is_valid) {</div>
<div class="line"><span class="lineno">  133</span>    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;skel_select_type_str is not valid: \&quot;&quot;</span> + skel_select_type_str + <span class="stringliteral">&quot;\&quot;&quot;</span>);</div>
<div class="line"><span class="lineno">  134</span>  }</div>
<div class="line"><span class="lineno">  135</span>  <span class="comment">// // No filesystem to check the tables folder exist. If incorrect, it will fail loading the table.</span></div>
<div class="line"><span class="lineno">  136</span>  <span class="comment">// const fs::path tables_folder_path{tables_folder};</span></div>
<div class="line"><span class="lineno">  137</span>  <span class="comment">// if(!fs::exists(tables_folder_path)) {</span></div>
<div class="line"><span class="lineno">  138</span>  <span class="comment">//   throw std::runtime_error(&quot;tables_folder &quot; + tables_folder_path.string() +</span></div>
<div class="line"><span class="lineno">  139</span>  <span class="comment">//       &quot; doesn&#39;t exist in the filesystem.\n&quot;</span></div>
<div class="line"><span class="lineno">  140</span>  <span class="comment">//       &quot;tables_folder should point to the folder &quot;</span></div>
<div class="line"><span class="lineno">  141</span>  <span class="comment">//       &quot;where DGtal tables are: i.e simplicity_table26_6.zlib&quot;);</span></div>
<div class="line"><span class="lineno">  142</span>  <span class="comment">// }</span></div>
<div class="line"><span class="lineno">  143</span> </div>
<div class="line"><span class="lineno">  144</span>  <span class="comment">// Create a VoxelComplex from the set</span></div>
<div class="line"><span class="lineno">  145</span>  <span class="keyword">using </span><a class="code hl_typedef" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a> = <a class="code hl_typedef" href="namespaceDGtal_1_1Z3i.html#a4c1b0b50dafb838783bc2347a840147d">DGtal::Z3i::KSpace</a>;</div>
<div class="line"><span class="lineno">  146</span>  <span class="keyword">using </span>Complex = TComplex;</div>
<div class="line"><span class="lineno">  147</span>  <span class="keyword">using </span>ComplexCell = <span class="keyword">typename</span> Complex::Cell;</div>
<div class="line"><span class="lineno">  148</span>  <span class="keyword">using </span>ComplexClique = <span class="keyword">typename</span> Complex::Clique;</div>
<div class="line"><span class="lineno">  149</span>  <span class="keyword">using </span><a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> = <a class="code hl_typedef" href="namespaceDGtal_1_1Z3i.html#a8d69892de6b10119a8070bd5d0871bf5">DGtal::Z3i::Point</a>;</div>
<div class="line"><span class="lineno">  150</span> </div>
<div class="line"><span class="lineno">  151</span>  <span class="keywordflow">if</span>(verbose) { <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">DGtal::trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a>(<span class="stringliteral">&quot;load isthmus table&quot;</span>); }</div>
<div class="line"><span class="lineno">  152</span>  boost::dynamic_bitset&lt;&gt; isthmus_table;</div>
<div class="line"><span class="lineno">  153</span>  <span class="keyword">auto</span> &amp;sk = skel_type_str;</div>
<div class="line"><span class="lineno">  154</span>  <span class="keywordflow">if</span>(sk == <span class="stringliteral">&quot;isthmus&quot;</span>) {</div>
<div class="line"><span class="lineno">  155</span>    <span class="keyword">const</span> std::string tableIsthmus = tables_folder + <span class="stringliteral">&quot;/isthmusicity_table26_6.zlib&quot;</span>;</div>
<div class="line"><span class="lineno">  156</span>    isthmus_table = *<a class="code hl_function" href="#a96aab076fc2c3bd049f041f5867be7a5">DGtal::functions::loadTable</a>(tableIsthmus);</div>
<div class="line"><span class="lineno">  157</span>  } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(sk == <span class="stringliteral">&quot;isthmus1&quot;</span> || sk == <span class="stringliteral">&quot;1ishtmus&quot;</span>) {</div>
<div class="line"><span class="lineno">  158</span>    <span class="keyword">const</span> std::string tableOneIsthmus = tables_folder + <span class="stringliteral">&quot;/isthmusicityOne_table26_6.zlib&quot;</span>;</div>
<div class="line"><span class="lineno">  159</span>    isthmus_table = *<a class="code hl_function" href="#a96aab076fc2c3bd049f041f5867be7a5">DGtal::functions::loadTable</a>(tableOneIsthmus);</div>
<div class="line"><span class="lineno">  160</span>  }</div>
<div class="line"><span class="lineno">  161</span>  <span class="keywordflow">if</span>(verbose) { <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">DGtal::trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>(); }</div>
<div class="line"><span class="lineno">  162</span> </div>
<div class="line"><span class="lineno">  163</span> </div>
<div class="line"><span class="lineno">  164</span>  <span class="comment">// SKEL FUNCTION:</span></div>
<div class="line"><span class="lineno">  165</span>  <span class="comment">// Load a look-up-table for the neighborgood of a point</span></div>
<div class="line"><span class="lineno">  166</span>  <span class="keyword">auto</span> pointMap =</div>
<div class="line"><span class="lineno">  167</span>      *<a class="code hl_function" href="#a57d70667078dcd620ce69e2b0ff4d407">DGtal::functions::mapZeroPointNeighborhoodToConfigurationMask&lt;Point&gt;</a>();</div>
<div class="line"><span class="lineno">  168</span>  std::function&lt;bool(<span class="keyword">const</span> Complex&amp;, <span class="keyword">const</span> ComplexCell&amp;)&gt; Skel;</div>
<div class="line"><span class="lineno">  169</span>  <span class="keywordflow">if</span>(sk == <span class="stringliteral">&quot;ultimate&quot;</span>) {</div>
<div class="line"><span class="lineno">  170</span>    Skel = <a class="code hl_function" href="#ad1a335e8f7956c3188e031a8d83a5ea7">DGtal::functions::skelUltimate&lt;Complex&gt;</a>;</div>
<div class="line"><span class="lineno">  171</span>  } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(sk == <span class="stringliteral">&quot;end&quot;</span>) {</div>
<div class="line"><span class="lineno">  172</span>    Skel = <a class="code hl_function" href="#a73b08e83670143586a55950e050aa6ad">DGtal::functions::skelEnd&lt;Complex&gt;</a>;</div>
<div class="line"><span class="lineno">  173</span>  <span class="comment">// else if (sk == &quot;1is&quot;) Skel = oneIsthmus&lt;Complex&gt;;</span></div>
<div class="line"><span class="lineno">  174</span>  <span class="comment">// else if (sk == &quot;is&quot;) Skel = skelIsthmus&lt;Complex&gt;;</span></div>
<div class="line"><span class="lineno">  175</span>  } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(sk == <span class="stringliteral">&quot;isthmus1&quot;</span> || sk == <span class="stringliteral">&quot;1ishtmus&quot;</span>) {</div>
<div class="line"><span class="lineno">  176</span>    Skel = [&amp;isthmus_table, &amp;pointMap](<span class="keyword">const</span> Complex&amp; fc,</div>
<div class="line"><span class="lineno">  177</span>                                       <span class="keyword">const</span> ComplexCell&amp; c) {</div>
<div class="line"><span class="lineno">  178</span>      <span class="keywordflow">return</span> <a class="code hl_function" href="#a23d911a3be8b0751f42bc11e96d3af1b">DGtal::functions::skelWithTable</a>(isthmus_table, pointMap, fc, c);</div>
<div class="line"><span class="lineno">  179</span>    };</div>
<div class="line"><span class="lineno">  180</span>  } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(sk == <span class="stringliteral">&quot;isthmus&quot;</span>) {</div>
<div class="line"><span class="lineno">  181</span>    Skel = [&amp;isthmus_table, &amp;pointMap](<span class="keyword">const</span> Complex&amp; fc,</div>
<div class="line"><span class="lineno">  182</span>                                       <span class="keyword">const</span> ComplexCell&amp; c) {</div>
<div class="line"><span class="lineno">  183</span>      <span class="keywordflow">return</span> <a class="code hl_function" href="#a23d911a3be8b0751f42bc11e96d3af1b">DGtal::functions::skelWithTable</a>(isthmus_table, pointMap, fc, c);</div>
<div class="line"><span class="lineno">  184</span>    };</div>
<div class="line"><span class="lineno">  185</span>  } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  186</span>    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Invalid skel string&quot;</span>);</div>
<div class="line"><span class="lineno">  187</span>  }</div>
<div class="line"><span class="lineno">  188</span> </div>
<div class="line"><span class="lineno">  189</span>  <span class="comment">// SELECT FUNCTION</span></div>
<div class="line"><span class="lineno">  190</span>  std::function&lt;std::pair&lt;typename Complex::Cell, typename Complex::Data&gt;(</div>
<div class="line"><span class="lineno">  191</span>      <span class="keyword">const</span> ComplexClique&amp;)&gt;</div>
<div class="line"><span class="lineno">  192</span>      Select;</div>
<div class="line"><span class="lineno">  193</span> </div>
<div class="line"><span class="lineno">  194</span>  <span class="comment">// profile</span></div>
<div class="line"><span class="lineno">  195</span>  <span class="keyword">auto</span> start = std::chrono::system_clock::now();</div>
<div class="line"><span class="lineno">  196</span> </div>
<div class="line"><span class="lineno">  197</span>  <span class="comment">// If dmax is chosen, but no distance_transform is provided, create one.</span></div>
<div class="line"><span class="lineno">  198</span>  <span class="keyword">using </span>DT = TDistanceTransform;</div>
<div class="line"><span class="lineno">  199</span>  <span class="keyword">using </span>DTDigitalSet = <span class="keyword">typename</span> DT::PointPredicate;</div>
<div class="line"><span class="lineno">  200</span>  <span class="keyword">using </span>DTDigitalSetDomain = <span class="keyword">typename</span> DTDigitalSet::Domain;</div>
<div class="line"><span class="lineno">  201</span>  <span class="keyword">using </span>Metric = <span class="keyword">typename</span> DT::SeparableMetric;</div>
<div class="line"><span class="lineno">  202</span>  Metric l3;</div>
<div class="line"><span class="lineno">  203</span>  <span class="keyword">auto</span> &amp;sel = skel_select_type_str;</div>
<div class="line"><span class="lineno">  204</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> compute_distance_transform = !distance_transform &amp;&amp; sel == <span class="stringliteral">&quot;dmax&quot;</span>;</div>
<div class="line"><span class="lineno">  205</span>  DTDigitalSetDomain vc_domain = compute_distance_transform ?</div>
<div class="line"><span class="lineno">  206</span>    DTDigitalSetDomain(vc.space().lowerBound(), vc.space().upperBound()) :</div>
<div class="line"><span class="lineno">  207</span>    <span class="comment">// dummy domain</span></div>
<div class="line"><span class="lineno">  208</span>    DTDigitalSetDomain(Z3i::<a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>::zero, Z3i::<a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>::<a class="code hl_function" href="namespaceDGtal_1_1dec__helper.html#a08a46835f2b4f1755bcca415b0f7fdf1">diagonal</a>(1));</div>
<div class="line"><span class="lineno">  209</span> </div>
<div class="line"><span class="lineno">  210</span>  DTDigitalSet image_set = DTDigitalSet(vc_domain);</div>
<div class="line"><span class="lineno">  211</span>  <span class="keywordflow">if</span>(compute_distance_transform) {</div>
<div class="line"><span class="lineno">  212</span>    vc.dumpVoxels(image_set);</div>
<div class="line"><span class="lineno">  213</span>  }</div>
<div class="line"><span class="lineno">  214</span>  <span class="comment">// Create the distance map here (computationally expensive if not dummy).</span></div>
<div class="line"><span class="lineno">  215</span>  DT dist_map(vc_domain, image_set, l3);</div>
<div class="line"><span class="lineno">  216</span>  <span class="keywordflow">if</span>(compute_distance_transform) {</div>
<div class="line"><span class="lineno">  217</span>    distance_transform = &amp;dist_map;</div>
<div class="line"><span class="lineno">  218</span>  }</div>
<div class="line"><span class="lineno">  219</span> </div>
<div class="line"><span class="lineno">  220</span>  <span class="keywordflow">if</span>(sel == <span class="stringliteral">&quot;random&quot;</span>) {</div>
<div class="line"><span class="lineno">  221</span>    Select = <a class="code hl_function" href="#a2d5060acdeb2181c1967bcdb413bd5e6">DGtal::functions::selectRandom&lt;Complex&gt;</a>;</div>
<div class="line"><span class="lineno">  222</span>  } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(sel == <span class="stringliteral">&quot;first&quot;</span>) {</div>
<div class="line"><span class="lineno">  223</span>    Select = <a class="code hl_function" href="#a38193d6ce6446ca81fb84114d5f9629c">DGtal::functions::selectFirst&lt;Complex&gt;</a>;</div>
<div class="line"><span class="lineno">  224</span>  } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(sel == <span class="stringliteral">&quot;dmax&quot;</span>) {</div>
<div class="line"><span class="lineno">  225</span>    Select = [&amp;distance_transform](<span class="keyword">const</span> ComplexClique&amp; clique) {</div>
<div class="line"><span class="lineno">  226</span>      <span class="keywordflow">return</span> selectMaxValue&lt;TDistanceTransform, Complex&gt;(*distance_transform, clique);</div>
<div class="line"><span class="lineno">  227</span>      };</div>
<div class="line"><span class="lineno">  228</span>  } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  229</span>    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Invalid skel select type&quot;</span>);</div>
<div class="line"><span class="lineno">  230</span>  }</div>
<div class="line"><span class="lineno">  231</span> </div>
<div class="line"><span class="lineno">  232</span>  <span class="comment">// Perform the thin/skeletonization</span></div>
<div class="line"><span class="lineno">  233</span>  Complex vc_new(vc.space());</div>
<div class="line"><span class="lineno">  234</span>  <span class="keywordflow">if</span>(persistence == 0) {</div>
<div class="line"><span class="lineno">  235</span>    vc_new = <a class="code hl_function" href="#a8f2a4664af776ca513141edb552a4461">DGtal::functions::asymetricThinningScheme&lt;Complex&gt;</a>(vc, Select, Skel, verbose);</div>
<div class="line"><span class="lineno">  236</span>  } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  237</span>    vc_new = <a class="code hl_function" href="#a46d491155b4e945e904080855a3bae28">DGtal::functions::persistenceAsymetricThinningScheme&lt;Complex&gt;</a>(vc, Select, Skel,</div>
<div class="line"><span class="lineno">  238</span>                                                         persistence, verbose);</div>
<div class="line"><span class="lineno">  239</span>  }</div>
<div class="line"><span class="lineno">  240</span> </div>
<div class="line"><span class="lineno">  241</span>  <span class="comment">// profile</span></div>
<div class="line"><span class="lineno">  242</span>  <span class="keyword">auto</span> end = std::chrono::system_clock::now();</div>
<div class="line"><span class="lineno">  243</span>  <span class="keyword">auto</span> elapsed = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(end - start);</div>
<div class="line"><span class="lineno">  244</span>  <span class="keywordflow">if</span>(profile) {</div>
<div class="line"><span class="lineno">  245</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Time elapsed: &quot;</span> &lt;&lt; elapsed.count() &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  246</span>  }</div>
<div class="line"><span class="lineno">  247</span> </div>
<div class="line"><span class="lineno">  248</span>  <span class="keywordflow">return</span> vc_new;</div>
<div class="line"><span class="lineno">  249</span>}</div>
<div class="ttc" id="aclassDGtal_1_1Trace_html_a352b7160bf722e2f0bcbee5d0bad6ef3"><div class="ttname"><a href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">DGtal::Trace::beginBlock</a></div><div class="ttdeci">void beginBlock(const std::string &amp;keyword=&quot;&quot;)</div></div>
<div class="ttc" id="aclassDGtal_1_1Trace_html_a9b36f5ab76b1945c8156cb4dba780bfb"><div class="ttname"><a href="classDGtal_1_1Trace.html#a9b36f5ab76b1945c8156cb4dba780bfb">DGtal::Trace::info</a></div><div class="ttdeci">std::ostream &amp; info()</div></div>
<div class="ttc" id="aclassDGtal_1_1Trace_html_afa3a2874289734884107b1ce68ccb93d"><div class="ttname"><a href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">DGtal::Trace::endBlock</a></div><div class="ttdeci">double endBlock()</div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z3i_html_a4c1b0b50dafb838783bc2347a840147d"><div class="ttname"><a href="namespaceDGtal_1_1Z3i.html#a4c1b0b50dafb838783bc2347a840147d">DGtal::Z3i::KSpace</a></div><div class="ttdeci">KhalimskySpaceND&lt; 3, Integer &gt; KSpace</div><div class="ttdef"><b>Definition</b> <a href="StdDefs_8h_source.html#l00146">StdDefs.h:146</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z3i_html_a8d69892de6b10119a8070bd5d0871bf5"><div class="ttname"><a href="namespaceDGtal_1_1Z3i.html#a8d69892de6b10119a8070bd5d0871bf5">DGtal::Z3i::Point</a></div><div class="ttdeci">Space::Point Point</div><div class="ttdef"><b>Definition</b> <a href="StdDefs_8h_source.html#l00168">StdDefs.h:168</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1dec__helper_html_a08a46835f2b4f1755bcca415b0f7fdf1"><div class="ttname"><a href="namespaceDGtal_1_1dec__helper.html#a08a46835f2b4f1755bcca415b0f7fdf1">DGtal::dec_helper::diagonal</a></div><div class="ttdeci">DGtal::LinearOperator&lt; Calculus, dim, duality, dim, duality &gt; diagonal(const DGtal::KForm&lt; Calculus, dim, duality &gt; &amp;kform)</div><div class="ttdef"><b>Definition</b> <a href="DECHelpers_8h_source.html#l00060">DECHelpers.h:60</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1functions_html_a2d5060acdeb2181c1967bcdb413bd5e6"><div class="ttname"><a href="#a2d5060acdeb2181c1967bcdb413bd5e6">DGtal::functions::selectRandom</a></div><div class="ttdeci">std::pair&lt; typename TComplex::Cell, typename TComplex::Data &gt; selectRandom(const typename TComplex::Clique &amp;clique)</div></div>
<div class="ttc" id="anamespaceDGtal_1_1functions_html_a38193d6ce6446ca81fb84114d5f9629c"><div class="ttname"><a href="#a38193d6ce6446ca81fb84114d5f9629c">DGtal::functions::selectFirst</a></div><div class="ttdeci">std::pair&lt; typename TComplex::Cell, typename TComplex::Data &gt; selectFirst(const typename TComplex::Clique &amp;clique)</div></div>
<div class="ttc" id="anamespaceDGtal_1_1functions_html_a46d491155b4e945e904080855a3bae28"><div class="ttname"><a href="#a46d491155b4e945e904080855a3bae28">DGtal::functions::persistenceAsymetricThinningScheme</a></div><div class="ttdeci">TComplex persistenceAsymetricThinningScheme(TComplex &amp;vc, std::function&lt; std::pair&lt; typename TComplex::Cell, typename TComplex::Data &gt;(const typename TComplex::Clique &amp;) &gt; Select, std::function&lt; bool(const TComplex &amp;, const typename TComplex::Cell &amp;) &gt; Skel, uint32_t persistence, bool verbose=false)</div></div>
<div class="ttc" id="anamespaceDGtal_1_1functions_html_a57d70667078dcd620ce69e2b0ff4d407"><div class="ttname"><a href="#a57d70667078dcd620ce69e2b0ff4d407">DGtal::functions::mapZeroPointNeighborhoodToConfigurationMask</a></div><div class="ttdeci">DGtal::CountedPtr&lt; std::unordered_map&lt; TPoint, NeighborhoodConfiguration &gt; &gt; mapZeroPointNeighborhoodToConfigurationMask()</div></div>
<div class="ttc" id="anamespaceDGtal_1_1functions_html_a73b08e83670143586a55950e050aa6ad"><div class="ttname"><a href="#a73b08e83670143586a55950e050aa6ad">DGtal::functions::skelEnd</a></div><div class="ttdeci">bool skelEnd(const TComplex &amp;vc, const typename TComplex::Cell &amp;cell)</div></div>
<div class="ttc" id="anamespaceDGtal_1_1functions_html_a8f2a4664af776ca513141edb552a4461"><div class="ttname"><a href="#a8f2a4664af776ca513141edb552a4461">DGtal::functions::asymetricThinningScheme</a></div><div class="ttdeci">TComplex asymetricThinningScheme(TComplex &amp;vc, std::function&lt; std::pair&lt; typename TComplex::Cell, typename TComplex::Data &gt;(const typename TComplex::Clique &amp;) &gt; Select, std::function&lt; bool(const TComplex &amp;, const typename TComplex::Cell &amp;) &gt; Skel, bool verbose=false)</div></div>
<div class="ttc" id="anamespaceDGtal_1_1functions_html_a96aab076fc2c3bd049f041f5867be7a5"><div class="ttname"><a href="#a96aab076fc2c3bd049f041f5867be7a5">DGtal::functions::loadTable</a></div><div class="ttdeci">DGtal::CountedPtr&lt; boost::dynamic_bitset&lt;&gt; &gt; loadTable(const std::string &amp;input_filename, const unsigned int known_size, const bool compressed=true)</div></div>
<div class="ttc" id="anamespaceDGtal_1_1functions_html_ad1a335e8f7956c3188e031a8d83a5ea7"><div class="ttname"><a href="#ad1a335e8f7956c3188e031a8d83a5ea7">DGtal::functions::skelUltimate</a></div><div class="ttdeci">bool skelUltimate(const TComplex &amp;vc, const typename TComplex::Cell &amp;cell)</div></div>
<div class="ttc" id="atestArithmeticalDSSComputerOnSurfels_8cpp_html_aebe586e91159919ccf2f565d4407fff7"><div class="ttname"><a href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a></div><div class="ttdeci">Z3i::KSpace KSpace</div><div class="ttdef"><b>Definition</b> <a href="testArithmeticalDSSComputerOnSurfels_8cpp_source.html#l00048">testArithmeticalDSSComputerOnSurfels.cpp:48</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#a8f2a4664af776ca513141edb552a4461">asymetricThinningScheme()</a>, <a class="el" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">DGtal::Trace::beginBlock()</a>, <a class="el" href="classDGtal_1_1PointVector.html#aba9def1d899ca259f6fa532a6eb9a8b5">DGtal::PointVector&lt; dim, Integer &gt;::diagonal()</a>, <a class="el" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">DGtal::Trace::endBlock()</a>, <a class="el" href="classDGtal_1_1Trace.html#a9b36f5ab76b1945c8156cb4dba780bfb">DGtal::Trace::info()</a>, <a class="el" href="#a96aab076fc2c3bd049f041f5867be7a5">loadTable()</a>, <a class="el" href="#a57d70667078dcd620ce69e2b0ff4d407">mapZeroPointNeighborhoodToConfigurationMask()</a>, <a class="el" href="#a46d491155b4e945e904080855a3bae28">persistenceAsymetricThinningScheme()</a>, <a class="el" href="#a38193d6ce6446ca81fb84114d5f9629c">selectFirst()</a>, <a class="el" href="#a938d429d0ec543c8672a815bdfcf9075">selectMaxValue()</a>, <a class="el" href="#a2d5060acdeb2181c1967bcdb413bd5e6">selectRandom()</a>, <a class="el" href="#a73b08e83670143586a55950e050aa6ad">skelEnd()</a>, <a class="el" href="#ad1a335e8f7956c3188e031a8d83a5ea7">skelUltimate()</a>, <a class="el" href="#a23d911a3be8b0751f42bc11e96d3af1b">skelWithTable()</a>, <a class="el" href="Common_8h_source.html#l00153">DGtal::trace</a>, and <a class="el" href="PointVector_8h_source.html#l01595">DGtal::PointVector&lt; dim, Integer &gt;::zero</a>.</p>

</div>
</div>
<a id="ad86a0dd4add6c1b9f567908893b4a69d" name="ad86a0dd4add6c1b9f567908893b4a69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86a0dd4add6c1b9f567908893b4a69d">&#9670;&#160;</a></span>twoIsthmus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::twoIsthmus </td>
          <td>(</td>
          <td class="paramtype">const TComplex &amp;</td>          <td class="paramname"><span class="paramname"><em>vc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TComplex::Cell &amp;</td>          <td class="paramname"><span class="paramname"><em>cell</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if input cell is a 2-isthmus. A voxel is a 2-isthmus if, after a thinning, its proper neighborhood is a 1-Surface <a class="el" href="#a5c782738287493c15465124d3516d4ec">isOneSurface</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5c782738287493c15465124d3516d4ec">isOneSurface</a> </dd>
<dd>
<a class="el" href="classDGtal_1_1Object.html#a5dfbef899715f5f0d81e02ad63504892">Object::properNeighborhood</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TComplex</td><td><a class="el" href="classDGtal_1_1VoxelComplex.html" title="This class represents a voxel complex living in some Khalimsky space. Voxel complexes are derived fro...">VoxelComplex</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vc</td><td>input complex. </td></tr>
    <tr><td class="paramname">cell</td><td>apply function on input cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="reference">Referenced by <a class="el" href="generateVoxelComplexTables_8cpp_source.html#l00061">main()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceDGtal.html">DGtal</a></li><li class="navelem"><a class="el" href="namespaceDGtal_1_1functions.html">functions</a></li>
    <li class="footer">Generated on Mon Jun 10 2024 17:36:27 for DGtal by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
