<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>DGtal: Images</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.9.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Images </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#dgtalImagesAbstract">Overview</a></li>
<li class="level1"><a href="#dgtalImagesDetails">Let us go into details</a><ul><li class="level2"><a href="#dgtalImagesConcepts">Concepts</a></li>
<li class="level2"><a href="#dgtalImagesMainMethods">Main methods</a></li>
<li class="level2"><a href="#dgtalImagesRanges">Ranges of values</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtalImagesModels">Main models</a><ul><li class="level2"><a href="#dgtalImagesModelsVector">ImageContainerBySTLVector</a></li>
<li class="level2"><a href="#dgtalImagesModelsMap">ImageContainerBySTLMap</a></li>
<li class="level2"><a href="#dgtalImagesModelsHashTree">ImageContainerByHashTree</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtalImagesAdapters">Image Adapter classes</a><ul><li class="level2"><a href="#constimage">ConstImageAdapter</a></li>
<li class="level2"><a href="#imageadat">ImageAdapter</a></li>
<li class="level2"><a href="#arrayimageadat">ArrayImageAdapter</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtalImagesFunctions">Useful classes and functions</a><ul><li class="level2"><a href="#SubSampleFct">Subsampling functor</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Authors</dt><dd>Tristan Roussillon, David Coeurjolly, Martial Tola, Roland Denis </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2012/12/05</dd></dl>
<h1><a class="anchor" id="dgtalImagesAbstract"></a>
Overview</h1>
<p>The concept of <em>point</em> functor describe a mapping between the points of a digital space and a set of values. The only method of a point functor is the <code>operator()</code>, which must take a point as input parameter and must return a value.</p>
<p>The concept of <em>constant</em> image is a point functor bounded by a domain. It is thus a refinement of the concept of point functor, describing a mapping between points and values, but having in addition a domain, returned by the <code>domain</code> method, and a range of values (for each point of the domain), returned by the <code>constRange</code> method.</p>
<p>The concept of <em>image</em>, which is a refinement of the concept of constant image, provides extra services to update values. Any model of image must have a method <code>setValue</code> taking a point and a value as input parameters and updating the value associated with the given point with the given value. In addition, they must have a range, returned by the <code>range</code> method, providing output iterators.</p>
<p>Different models of images are available: <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>, <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a>, <a class="el" href="classDGtal_1_1ImageContainerByITKImage.html" title="Aim: implements a model of CImageContainer using a ITK Image. ">ImageContainerByITKImage</a> (a wrapper for ITK images) and &mdash; coming soon &mdash; <a class="el" href="classDGtal_1_1experimental_1_1ImageContainerByHashTree.html" title="Model of CImageContainer implementing the association key<->Value using a hash tree. This class provides a built-in iterator. ">experimental::ImageContainerByHashTree</a>.</p>
<h1><a class="anchor" id="dgtalImagesDetails"></a>
Let us go into details</h1>
<p>In this section, the concepts and the main services to read and write values in images are detailed.</p>
<h2><a class="anchor" id="dgtalImagesConcepts"></a>
Concepts</h2>
<p>Any model of the concept <a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html" title="Aim: Defines a functor on points. ">concepts::CPointFunctor</a> must have two nested types:</p>
<ul>
<li>Point, which specifies the type for a point.</li>
<li>Value, which specifies the type for a value.</li>
</ul>
<p>Moreover, it must have the following method:</p>
<ul>
<li><code>operator()</code>, which takes a point as input parameter and returns a value, like a function.</li>
</ul>
<p>The concept <a class="el" href="structDGtal_1_1concepts_1_1CConstImage.html" title="Aim: Defines the concept describing a read-only image, which is a refinement of CPointFunctor. ">concepts::CConstImage</a> is a refinement of <a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html" title="Aim: Defines a functor on points. ">concepts::CPointFunctor</a>. Its models must have two extra nested types:</p>
<ul>
<li>Domain, a model of <a class="el" href="structDGtal_1_1concepts_1_1CDomain.html" title="Aim: This concept represents a digital domain, i.e. a non mutable subset of points of the given digit...">concepts::CDomain</a></li>
<li>ConstRange, a model of concepts::CConstBidirectionnalRangeFromPoint</li>
</ul>
<p>Obviously, there are two methods that return instances of these two types:</p>
<ul>
<li><code>domain</code>, which returns a constant reference on the image domain</li>
<li><code>constRange</code>, which returns a range providing constant bidirectional iterators on the image values (associated to each point of the image domain)</li>
</ul>
<p>You can see <a class="el" href="moduleSpacePointVectorDomain.html">Digital Spaces, Points, Vectors and Domains</a> for more details about spaces and domains and <a class="el" href="moduleImages.html#dgtalImagesRanges">Ranges of values</a> for more details about ranges in images.</p>
<p>The concept <a class="el" href="structDGtal_1_1concepts_1_1CImage.html" title="Aim: Defines the concept describing a read/write image, having an output iterator. ">concepts::CImage</a> is refinement of <a class="el" href="structDGtal_1_1concepts_1_1CConstImage.html" title="Aim: Defines the concept describing a read-only image, which is a refinement of CPointFunctor. ">concepts::CConstImage</a>. Images, instead of constant ones, provide services to update values. The main way of assigning values to points is the following method:</p>
<ul>
<li><code>setValue</code>, which updates a given value at a given point.</li>
</ul>
<p>Moreover, in addition to the ConstRange, images must have the following inner type:</p>
<ul>
<li>Range, a model of concepts::CConstBidirectionalRangeFromPoint, like ConstRange, and a model of concepts::CBidirectionalRangeWithWritableIteratorFromPoint, which must provide output iterators for incrementally updating a (sub)range of values.</li>
</ul>
<p>Obviously, you can get an instance of this type using the following method:</p>
<ul>
<li><code>range</code>, which returns a range providing both constant bidirectional iterators and output iterators.</li>
</ul>
<p>Lastly, note that the Value type in the (constant) images is expected to be at least a model of concepts::CLabel, ie. to be default-constructible, assignable and equality comparable.</p>
<dl class="section note"><dt>Note</dt><dd>In the snippets of the following subsections, the type of image used is <code><a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values. ">Image</a></code> and its instances are <code>image</code>, <code>image1</code>, <code>image2</code>.</dd></dl>
<h2><a class="anchor" id="dgtalImagesMainMethods"></a>
Main methods</h2>
<p>All models of images have a domain returned by the method <code>domain</code>. This domain is the set of points for which the image is defined and has values. Since a domain is a range, you can straightforwardly use it in order to iterate over the points of an image.</p>
<p>iterate over the points <a class="el" href="classDGtal_1_1Image.html#ace481f886b37a80824817b5f1494df58">Image::Domain</a> d = image.domain(); for (Image::Domain::ConstIterator it = d.begin(), itEnd = d.end(); it != itEnd; ++it) {}</p>
<p>Models of images have also two main methods in order to read or write values at a given point:</p>
<ul>
<li><code>operator()</code> to get the value associated to a given point</li>
<li><code>setValue</code> to assign a value to a given point.</li>
</ul>
<p>process the values <a class="el" href="classDGtal_1_1Image.html#ace481f886b37a80824817b5f1494df58">Image::Domain</a> d = image.domain(); for (Image::Domain::ConstIterator it = d.begin(), itEnd = d.end(); it != itEnd; ++it) { <a class="el" href="classDGtal_1_1Image.html#ad56b43a36c897e64398934c8f7a3b01c">Image::Value</a> v = image( *it ); v += 5; //adding 5 to all values image.setValue( v ); }</p>
<p>Note that this method of iterating over the values of an image is not always the fastest and that is why we also provide ranges.</p>
<h2><a class="anchor" id="dgtalImagesRanges"></a>
Ranges of values</h2>
<p>Constant images provide a constant range of values returned by the <code>constRange</code> method. As every model of concepts::CConstBidirectionalRange, it provides <code>begin</code>, <code>end</code>, <code>rbegin</code> and <code>rend</code> methods returning constant iterators to iterate over the values in the forward or backward direction.</p>
<p>iterate over the values <a class="el" href="classDGtal_1_1Image.html#a0f2c0b68fdedee9231353fc0900e94b6">Image::ConstRange</a> r = image.constRange(); for (<a class="el" href="classDGtal_1_1SimpleRandomAccessConstRangeFromPoint.html#a8795e5e07c00b939bb6ace6589b73713">Image::ConstRange::ConstIterator</a> it = r.begin(), itEnd = r.end(); it != itEnd; ++it) {}</p>
<p>However, this range is also a model of concepts::CConstBidirectionalRangeFromPoint, which is a refinement of concepts::CConstBidirectionalRange. That is why it also has overloaded versions of the <code>begin</code> and <code>rbegin</code> methods taking a point as input argument. This provides a way of iterating on sub-ranges defined from points.</p>
<p>iterator on the origin (0, ... , 0) <a class="el" href="classDGtal_1_1SimpleRandomAccessConstRangeFromPoint.html#a8795e5e07c00b939bb6ace6589b73713">Image::ConstRange::ConstIterator</a> it = r.begin( Image::Point::diagonal(0) )</p>
<p>Note that if the point does not belong to the domain, the returned iterators (resp. reverse iterators) must be equal to the <code>end</code> (resp. <code>rend</code>) methods. </p><pre class="fragment">ASSERT( image.constRange().begin( image.domain().end() ) == image.constRange().end() )
</pre><p>Images provide in addition to a constant range, a richer range returned by the <code>range</code> method. This range is not only a model of concepts::CBidirectionalRangeFromPoint, but also a model of concepts::CBidirectionalRangeWithWritableIteratorFromPoint. That is why, it must have two methods: <code>outputIterator</code> and <code>routputIterator</code> returning output iterators. Moreover, it must have overloaded versions of these methods taking a point as input argument. Thus, these output iterators are useful in order to incrementaly fill (a part of) an image. For instance, you can fill an image from the values of another one (assumed to have the same domain) as follows: </p><pre class="fragment">Image::Range r1 = image1.range(); 
Image::ConstRange r2 = image2.constRange(); 
std::copy( r2.begin(), r2.end(), r1.outputIterator() ); 
</pre><h1><a class="anchor" id="dgtalImagesModels"></a>
Main models</h1>
<p>Different models of images are available: <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>, <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a>, and &mdash; coming soon &mdash; <a class="el" href="classDGtal_1_1experimental_1_1ImageContainerByHashTree.html" title="Model of CImageContainer implementing the association key<->Value using a hash tree. This class provides a built-in iterator. ">experimental::ImageContainerByHashTree</a>, experimental::ImageContainerByITKImage, a wrapper for ITK images.</p>
<h2><a class="anchor" id="dgtalImagesModelsVector"></a>
ImageContainerBySTLVector</h2>
<p><a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a> is a model of <a class="el" href="structDGtal_1_1concepts_1_1CImage.html" title="Aim: Defines the concept describing a read/write image, having an output iterator. ">concepts::CImage</a> that inherits the STL vector class. The hyper-rectangular domain, which the only model of domain accepted, is linearized so that each point is mapped, from its coordinates, into an index and each index is mapped into a unique value, as in any one-dimensional array.</p>
<p>Let \( n \) be the domain size (the number of points). At construction all the needed space is allocated and filled with a default value (0) in \( O(n) \) space and time. After that, you can access to the value associated to any point at any time. Each access for reading (<code>operator()</code>) or writing ('setValue`) values is in \( O(1) \).</p>
<p>The (constant) range of this class only used the built-in iterators of the underlying STL vector. It is therefore a fast way of iterating over the values of the image.</p>
<h2><a class="anchor" id="dgtalImagesModelsMap"></a>
ImageContainerBySTLMap</h2>
<p><a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> is a model of <a class="el" href="structDGtal_1_1concepts_1_1CImage.html" title="Aim: Defines the concept describing a read/write image, having an output iterator. ">concepts::CImage</a> that inherits the STL map class. The domain can be any set of points. Values are stored and associated to points in pairs point-value. The set of points stored in this way may be any domain subset. A default value (user-defined) is automatically associated to each point of the domain that does not belong the subset for which values are known. Once constructed (in \( O(1) \)), the image is valid and every point of the image domain has a value, which can be read and overwritten.</p>
<p>The pairs point-value are stored in a red-black tree, where the points are used as keys, so that each access for reading (<code>operator()</code>) or writing (<code>setValue</code>) values is in \( O(log m) \), where \( m \) is the cardinal of the subset for which values are known (less or equal to the domain size \( n \)).</p>
<p>The (constant) range of this class adapts the domain iterators in order to deal with values instead of points. The <code>operator*</code> of the iterators provided by the range calls the <code>operator()</code> and use the <code>setValue</code> method of the class.</p>
<h2><a class="anchor" id="dgtalImagesModelsHashTree"></a>
ImageContainerByHashTree</h2>
<p><a class="el" href="classDGtal_1_1experimental_1_1ImageContainerByHashTree.html" title="Model of CImageContainer implementing the association key<->Value using a hash tree. This class provides a built-in iterator. ">experimental::ImageContainerByHashTree</a> is an experimental image container implementing a pointerless nD-tree structure. In dimension 2 and 3, this structure is similar to quadtree and octree repsectively in which hierarchical links between a node and its children is given by prefix of a binary representation of the node coordinates using <a class="el" href="classDGtal_1_1Morton.html" title="Aim: Implements the binary Morton code construction in nD. ">Morton</a> keys. Finally, data values are stored in the structure in a hash table whose hash function is a suffix on the <a class="el" href="classDGtal_1_1Morton.html" title="Aim: Implements the binary Morton code construction in nD. ">Morton</a> key code.</p>
<p>Such container is well adapted for high resolution sparse images.</p>
<p>For more details, please refer to <a class="el" href="citelist.html#CITEREF_Lewiner2009a">[41]</a></p>
<h1><a class="anchor" id="dgtalImagesAdapters"></a>
Image Adapter classes</h1>
<p><a class="el" href="classDGtal_1_1ImageAdapter.html" title="Aim: implements an image adapter with a given domain (i.e. a subdomain) and 3 functors : g for domain...">ImageAdapter</a>, <a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a> are perfect swiss-nifes to transform and adapt images (change their domain definition, change their value types, ...). These classses are parametrized by several types and functor in order to adapt the behavior of image getters/setters (<em>operator()</em> and <em>setValue</em> methods). These adapted behaviors are computed on-the-fly when calling these methods.</p>
<p><a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a> requires several types and functors to create a "read-only" adapted image (operator(), constRange(), ...)</p>
<p><a class="el" href="classDGtal_1_1ImageAdapter.html" title="Aim: implements an image adapter with a given domain (i.e. a subdomain) and 3 functors : g for domain...">ImageAdapter</a> requires a supplementary functor and allows write access to the image (<em>setValue</em> methods, range(), ... )</p>
<dl class="section note"><dt>Note</dt><dd>Functors used to convert domains or values may be complex. Keep in mind that each time operator() or setValue() methods are called, such functors are evaluated (with potential side-effects depending on the functors).</dd></dl>
<p>In addition, ArrayImageAdapter allows to convert any iterable storage (like a C-style array or some <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a> image models), to a <a class="el" href="structDGtal_1_1concepts_1_1CImage.html" title="Aim: Defines the concept describing a read/write image, having an output iterator. ">concepts::CImage</a> (or <a class="el" href="structDGtal_1_1concepts_1_1CConstImage.html" title="Aim: Defines the concept describing a read-only image, which is a refinement of CPointFunctor. ">concepts::CConstImage</a>) model with the possibility to restrict his visibility to a sub-domain of the definition domain.</p>
<h2><a class="anchor" id="constimage"></a>
ConstImageAdapter</h2>
<p><a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a> is a small class that adapts any (constant or not) image into a constant one, which provides a virtual view (so read-only) of the true values contained in the adapted image. The class is parametrized by several template arguments: <em>TImageContainer:</em> the type of image to adapt. <em>TNewDomain:</em> the type of the new domain. <em>TFunctorD:</em> type of functor used to convert image domain points to new domain points <em>TNewValue:</em> type of the new image value type. <em>TFucntorV:</em> functor to convert values.</p>
<p>The values associated to access the point values are adapted with a functor <em>g</em> and a functor <em>f</em> given at construction so that operator() calls <em>f</em>(img(g(aPoint))), instead of calling directly img.operator() of the underlying image <em>img</em>.</p>
<p>Functor g (and/or functor f) can be a default functor, i.e. a simple functor that just returns its argument.</p>
<p>In order to illustrate the next <a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a> usage samples, we are going a) to use these includes:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/io/colormaps/HueShadeColorMap.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/io/colormaps/GrayscaleColorMap.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/images/ImageContainerBySTLVector.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/images/ConstImageAdapter.h&quot;</span></div>
</div><!-- fragment --><p> b) then define these types and variables:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> HueShadeColorMap&lt;unsigned char&gt; HueShade;     <span class="comment">// a simple HueShadeColorMap varying on &#39;unsigned char&#39; values</span></div>
<div class="line">  <span class="keyword">typedef</span> HueShadeColorMap&lt;double&gt; HueShadeDouble;      <span class="comment">// a simple HueShadeColorMap varying on &#39;double&#39; values</span></div>
<div class="line">  <span class="keyword">typedef</span> GrayscaleColorMap&lt;unsigned char&gt; Gray;        <span class="comment">// a simple GrayscaleColorMap varying on &#39;unsigned char&#39; values</span></div>
<div class="line">  </div>
<div class="line">  functors::Identity df;                                    <span class="comment">// a simple functor that just returns its argument</span></div>
</div><!-- fragment --><p> c) then define a simple 16x16 (1,1) to (16,16) image (of 'unsigned char' type):</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ImageContainerBySTLVector&lt;Domain, unsigned char&gt; Image;</div>
<div class="line">  Domain domain(Point(1,1), Point(16,16));</div>
<div class="line">  Image image(domain);</div>
</div><!-- fragment --><p> filled with 0 to 255 values like that:</p>
<div class="fragment"><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> i = 0;</div>
<div class="line">  <span class="keywordflow">for</span> (<a class="code" href="classDGtal_1_1ImageContainerBySTLVector.html#a7cd7b0da52697b0d0f1f5f65781d8a52">Image::Iterator</a> it = image.begin(); it != image.end(); ++it)</div>
<div class="line">      *it = i++;</div>
</div><!-- fragment --><p> which looks like that with a simple <a class="el" href="classDGtal_1_1HueShadeColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">HueShadeColorMap</a> varying from 0 to 255 and with (1,1) the first bottom-left point:</p>
<div class="image">
<img src="image.png" alt="image.png"/>
<div class="caption">
(1) simple 16x16 image: (1,1) to (16,16) drawn with a simple HueShadeColorMap varying from 0 to 255.</div></div>
 <p>Here is now the construction of a simple image adapter that use a subdomain of the initial image domain to access the first bottom-left 8x8 image:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ConstImageAdapter&lt;Image, Domain, functors::Identity, Image::Value, functors::Identity &gt; ConstImageAdapterForSubImage;</div>
<div class="line">  Domain subDomain(Point(1,1), Point(8,8));</div>
<div class="line">  ConstImageAdapterForSubImage subImage(image, subDomain, df, df);</div>
</div><!-- fragment --><p> and here is the result: </p><div class="image">
<img src="subImage.png" alt="subImage.png"/>
<div class="caption">
(2) first bottom-left 8x8 image: (1,1) to (8,8) adapted from image (1) with a subdomain.</div></div>
 <p>Here is then the construction of an image adapter that use a specific domain: here, only one pixel on two in x and y coordinates, created like that:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal_1_1Z2i.html#a371252c324e496cf8650757c1a2b4eb0">DigitalSet</a> set(domain);</div>
<div class="line">  <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y=0; y &lt; 17; y++)</div>
<div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=0; x &lt; 17; x++)</div>
<div class="line">        <span class="keywordflow">if</span> ((x%2) &amp;&amp; (y%2))</div>
<div class="line">          set.insertNew(Point(x,y));</div>
<div class="line">        </div>
<div class="line">  DigitalSetDomain&lt;DigitalSet&gt; specificDomain(set);</div>
</div><!-- fragment --><p> from the initial image domain.</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ConstImageAdapter&lt;Image, DigitalSetDomain&lt;DigitalSet&gt;, functors::Identity, <a class="code" href="classDGtal_1_1Image.html#ad56b43a36c897e64398934c8f7a3b01c">Image::Value</a>, functors::Identity &gt; ConstImageAdapterForSpecificImage;</div>
<div class="line">  ConstImageAdapterForSpecificImage specificImage(image, specificDomain, df, df);</div>
</div><!-- fragment --><p> Here is the result:</p>
<div class="image">
<img src="specificImage.png" alt="specificImage.png"/>
<div class="caption">
(3) 16x16 image: (1,1) to (16,16) adapted from image (1) with a specific domain.</div></div>
 <p>Here is now the construction of an image adapter that is a thresholded view of the initial scalar image:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ConstImageAdapter&lt;Image, Domain, functors::Identity, bool, DGtal::functors::Thresholder&lt;Image::Value&gt; &gt; ConstImageAdapterForThresholderImage;</div>
<div class="line">  <a class="code" href="classDGtal_1_1functors_1_1Thresholder.html">DGtal::functors::Thresholder&lt;Image::Value&gt;</a> t(127);</div>
<div class="line">  ConstImageAdapterForThresholderImage thresholderImage(image, domain, df, t);</div>
</div><!-- fragment --><p> and here is the result with a simple <a class="el" href="classDGtal_1_1GrayscaleColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into gray l...">GrayscaleColorMap</a> varying from 0 to 1:</p>
<div class="image">
<img src="thresholderImage.png" alt="thresholderImage.png"/>
<div class="caption">
(4) 16x16 image: (1,1) to (16,16) adapted from image (1) with a thresholder set to 127.</div></div>
 <p>Here is finally the construction of an image adapter that use a functor to change 'unsigned char' values to 'double' values using a log scale functor defined like that:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Scalar&gt;</div>
<div class="line"><span class="keyword">struct </span>LogScaleFunctor {</div>
<div class="line"></div>
<div class="line">  LogScaleFunctor() {};</div>
<div class="line">  <span class="keywordtype">double</span> operator()(<span class="keyword">const</span> Scalar &amp;a)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> std::log( 1 + NumberTraits&lt;Scalar&gt;::castToDouble(a) );</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">};</div>
</div><!-- fragment --><p> defined from the initial image:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ConstImageAdapter&lt;Image, Domain, functors::Identity, double, LogScaleFunctor&lt;Image::Value&gt; &gt; ConstImageAdapterForLogScale;</div>
<div class="line">  LogScaleFunctor&lt;Image::Value&gt; logScale;</div>
<div class="line">  ConstImageAdapterForLogScale logImage(image, domain, df, logScale);</div>
</div><!-- fragment --><p> and here is the result with a simple <a class="el" href="classDGtal_1_1HueShadeColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">HueShadeColorMap</a> varying from 0. to logScale(255):</p>
<div class="image">
<img src="logImage.png" alt="logImage.png"/>
<div class="caption">
(5) 16x16 image: (1,1) to (16,16) adapted from image (1) with a log scale functor.</div></div>
 <h2><a class="anchor" id="imageadat"></a>
ImageAdapter</h2>
<p><a class="el" href="classDGtal_1_1ImageAdapter.html" title="Aim: implements an image adapter with a given domain (i.e. a subdomain) and 3 functors : g for domain...">ImageAdapter</a> is a small class that adapts an image (like <a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a>) but provides a virtual access (reading and writing) of the true values contained in the adapted image. It uses a given Domain (i.e. a subdomain) but work directly (for reading and writing processes) thanks to an alias (i.e. a pointer) on the original <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values. ">Image</a> given in argument.</p>
<p>This class requires an additional templare paremter: <em>TFunctoVm1:</em> functor to convert adapted image values to the original image values.</p>
<p>The values associated to accessing the point values are adapted with a functor g and a functor f given at construction so that operator() calls f(img(g(aPoint))), instead of calling directly operator() of the underlying image img.</p>
<p>The values associated to writing the points are adapted with a functor <em>g</em> and a functor \( f^{-1}\) given at construction so that setValue() is <em>img.setValue</em>(g(aPoint), f-1(aValue)).</p>
<p>The use is the same that for <a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a>.</p>
<h2><a class="anchor" id="arrayimageadat"></a>
ArrayImageAdapter</h2>
<p>The ArrayImageAdapter class is less generic than <a class="el" href="classDGtal_1_1ImageAdapter.html" title="Aim: implements an image adapter with a given domain (i.e. a subdomain) and 3 functors : g for domain...">ImageAdapter</a> but is able to adapt any storage that have a random-access iterator to a <a class="el" href="structDGtal_1_1concepts_1_1CImage.html" title="Aim: Defines the concept describing a read/write image, having an output iterator. ">concepts::CImage</a> model. It is thus usable on C-style array but also on STL container like <code>std::vector</code> (and therefore on <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>) and on another ArrayImageAdapter instances.</p>
<p>In addition, this class allows to restrict the visibility to a sub-domain of the definition domain and provides a read-write random-access iterator (depending on the mutability of the storage's iterator) with fast access to the underlying point (no need to iterate over the domain).</p>
<p>A common usage of this last feature is for padded raw data.</p>
<p>In order to illustrate the following ArrayImageAdapter usages, we need some common includes: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;new&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;DGtal/io/colormaps/HueShadeColorMap.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;DGtal/images/ImageContainerBySTLVector.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;DGtal/images/ArrayImageAdapter.h&gt;</span></div>
</div><!-- fragment --><p>and the next definitions: </p><div class="fragment"><div class="line">  <span class="keyword">using</span> Value = double; <span class="comment">// value type  of the image</span></div>
<div class="line">  <span class="keyword">using</span> HueShadeDouble = HueShadeColorMap&lt;Value&gt;;   <span class="comment">// a simple HueShadeColorMap varying on &#39;double&#39; values</span></div>
</div><!-- fragment --><p> From a C-style array, we can create an image that spans the full definition domain: </p><div class="fragment"><div class="line">  <span class="keyword">const</span> Domain domain(Point(1,1), Point(16,16));</div>
<div class="line">  Value* data = <span class="keyword">new</span> Value[ domain.size() ];</div>
<div class="line">  ArrayImageAdapter&lt; Value*, Domain &gt; image( data, domain );</div>
</div><!-- fragment --><p>and fill it using common iterator syntax: </p><div class="fragment"><div class="line">  Value i = 0;</div>
<div class="line">  <span class="keywordflow">for</span> ( <span class="keyword">auto</span> &amp; value : image )</div>
<div class="line">    value = i++;</div>
</div><!-- fragment --><p>that gives us the following result: </p><div class="image">
<img src="ArrayImageAdapter_image.png" alt="ArrayImageAdapter_image.png"/>
<div class="caption">
(6) simple 16x16 image: (1,1) to (16,16) drawn with a simple HueShadeColorMap varying from 0 to 255.</div></div>
<p>We can now create a read-only view of the same image on a sub-domain: </p><div class="fragment"><div class="line">  Domain subDomain(Point(1,1), Point(8,8));</div>
<div class="line">  ArrayImageAdapter&lt; Value const*, Domain &gt; constSubImage( data, domain, subDomain );</div>
</div><!-- fragment --><p>that gives us: </p><div class="image">
<img src="ArrayImageAdapter_subImage.png" alt="ArrayImageAdapter_subImage.png"/>
<div class="caption">
(7) first bottom-left 8x8 image: (1,1) to (8,8) adapted from image (1) with a subdomain.</div></div>
<p>If we want to modify the image through this adapter, we must create a read-write instance using the following syntax: </p><div class="fragment"><div class="line">  ArrayImageAdapter&lt; Value*, Domain &gt; subImage( data, domain, subDomain );</div>
</div><!-- fragment --><p>or the alternate method using the helpers: </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> subImage = <a class="code" href="namespaceDGtal.html#a4d7cc85d6072793cb8f15694be4d0d44">makeArrayImageAdapterFromIterator</a>( data, domain, subDomain );</div>
</div><!-- fragment --><p>and we can then modify it using the common syntax with a domain iterator: </p><div class="fragment"><div class="line">  <span class="keywordflow">for</span> ( <span class="keyword">auto</span> point : subImage.domain() )</div>
<div class="line">    {</div>
<div class="line">      Value coord = (point - Point(4,4)).norm();</div>
<div class="line">      subImage.setValue( point, 25*(cos(coord)+1) );</div>
<div class="line">    }</div>
</div><!-- fragment --> <div class="image">
<img src="ArrayImageAdapter_subImage_modifByDomain.png" alt="ArrayImageAdapter_subImage_modifByDomain.png"/>
<div class="caption">
(8) modifying the first bottom-left 8x8 image through the sub-domain view with a domain iterator.</div></div>
<p>Alternatively, there is a computationally faster syntax (no need to linearize the point) using the method <code>getPoint</code> featured by the ArrayImageAdapter iterators (see <a class="el" href="classDGtal_1_1ArrayImageIterator.html" title="Aim: Random access iterator over an image given his definition domain and viewable domain...">ArrayImageIterator</a>): </p><div class="fragment"><div class="line">  <span class="keywordflow">for</span> ( <span class="keyword">auto</span> it = subImage.begin(), it_end = subImage.end(); it != it_end; ++it )</div>
<div class="line">    {</div>
<div class="line">      Value coord = (it.getPoint() - Point(4,4)).norm();</div>
<div class="line">      *it = 25*(sin(coord)+1);</div>
<div class="line">    }</div>
</div><!-- fragment --> <div class="image">
<img src="ArrayImageAdapter_subImage_modifByImage.png" alt="ArrayImageAdapter_subImage_modifByImage.png"/>
<div class="caption">
(9) modifying the first bottom-left 8x8 image through the sub-domain view with an image iterator.</div></div>
<p>It is also possible to use ArrayImageAdater on any image model that provides a random-access iterator, like <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>: </p><div class="fragment"><div class="line">  ImageContainerBySTLVector&lt;Domain, Value&gt; anIterableImage(domain);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; value : anIterableImage)</div>
<div class="line">    value = 0;</div>
</div><!-- fragment --><p>and adapt it using: </p><div class="fragment"><div class="line">  {</div>
<div class="line">  ArrayImageAdapter&lt; ImageContainerBySTLVector&lt;Domain,Value&gt;::Iterator, Domain &gt; subImageSTL( anIterableImage.begin(), domain, subDomain );</div>
<div class="line">  }</div>
</div><!-- fragment --><p>or, thanks to the helpers: </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> subImageSTL = <a class="code" href="namespaceDGtal.html#a5d8f2b0c05fa81f94692c1c48bb44c6b">makeArrayImageAdapterFromImage</a>( anIterableImage, subDomain );</div>
</div><!-- fragment --><p> From there, we can use all the previous features or, for example, use available STL algorithms: </p><div class="fragment"><div class="line">  std::copy( subImage.cbegin(), subImage.cend(), subImageSTL.begin() );</div>
</div><!-- fragment --> <div class="image">
<img src="ArrayImageAdapter_subImage_copyToImageSTL.png" alt="ArrayImageAdapter_subImage_copyToImageSTL.png"/>
<div class="caption">
(10) modifying the first bottom-left 8x8 image of a ImageContainerBySTLVector through the sub-domain view.</div></div>
<h1><a class="anchor" id="dgtalImagesFunctions"></a>
Useful classes and functions</h1>
<p>In addition to the image containers and the image adapters described in the previous sections, there are also image proxys:</p>
<p><a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values. ">Image</a> is a light proxy on image containers based on a COW pointer. It can be constructed, copied, assigned, deleted without any special care.</p>
<p>Moreover, in <a class="el" href="ImageHelper_8h_source.html">ImageHelper.h</a>, many useful functions are provided.</p>
<ol type="1">
<li>Conversely, others convert images into digital sets with value comparators: setFromPointsRangeAndPredicate, setFromPointsRangeAndFunctor, setFromImage.</li>
<li>Some of them convert digital sets into images, imageFromRangeAndValue assigns a given value in an image to each point of a given range.</li>
<li>Some functions are available to fastly fill images from point functors or other images: imageFromFunctor and imageFromImage.</li>
<li>Lastly, some functor like the Projector from BasicPointFunctors can be useful to manipulate domain points and permits to extract N-1 images from ND images (see example <a class="el" href="extract2DImagesFrom3D_8cpp_source.html">extract2DImagesFrom3D.cpp</a>).</li>
</ol>
<h2><a class="anchor" id="SubSampleFct"></a>
Subsampling functor</h2>
<p>In association with <a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a> or <a class="el" href="classDGtal_1_1ImageAdapter.html" title="Aim: implements an image adapter with a given domain (i.e. a subdomain) and 3 functors : g for domain...">ImageAdapter</a> you can apply image subsampling using a domain subsampler (BasicDomainSubSampler from the BasicPointFunctors class). The example <a class="el" href="imageBasicSubsampling_8cpp_source.html">imageBasicSubsampling.cpp</a> illustrates such a simple image subsampling (in 2D and 3D).</p>
<p>To apply the subsampling, you first have to import the headers associated with the <a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a> and to the BasicDomainSubSampler:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/kernel/BasicPointFunctors.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/images/ConstImageAdapter.h&quot;</span></div>
</div><!-- fragment --><p>Then you can define some image types including the <a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a>:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ImageContainerBySTLVector &lt; Z2i::Domain, unsigned char&gt; Image2D;</div>
<div class="line">  <span class="keyword">typedef</span> ConstImageAdapter&lt;Image2D,  Image2D::Domain, </div>
<div class="line">                            functors::BasicDomainSubSampler&lt;Image2D::Domain&gt;,  </div>
<div class="line">                            Image2D::Value,</div>
<div class="line">                            functors::Identity &gt; ConstImageAdapterForSubSampling;</div>
<div class="line"></div>
</div><!-- fragment --><p> A subsampling functor can be constructed from a given grid size and a shift vector:</p>
<div class="fragment"><div class="line">    <a class="code" href="classDGtal_1_1functors_1_1BasicDomainSubSampler.html">DGtal::functors::BasicDomainSubSampler&lt;Image2D::Domain&gt;</a> subSampler2D(image2D.domain(), aGridSize2D, <a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(0 ,0));</div>
</div><!-- fragment --><p> Afterwards the <a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a> can be defined as follows:</p>
<div class="fragment"><div class="line">    Image2D::Domain subSampledDomain2D  = subSampler2D.getSubSampledDomain();</div>
<div class="line">    ConstImageAdapterForSubSampling subsampledImage2D (image2D, subSampledDomain2D, subSampler2D, df);</div>
</div><!-- fragment --><p> The resulting image can be exported with the <a class="el" href="structDGtal_1_1GenericWriter.html" title="Aim: Provide a mechanism to save image (2D or 3D) into file with the best saver loader according to a...">GenericWriter</a> class:</p>
<div class="fragment"><div class="line">    <a class="code" href="structDGtal_1_1GenericWriter.html#ae9f11d212f4136c678a4a5b3b8b6c111">GenericWriter&lt;ConstImageAdapterForSubSampling&gt;::exportFile</a>(outputname.str(), subsampledImage2D );</div>
</div><!-- fragment --><p>You will obtain such a result (with also the result on 3D images): </p><div class="image">
<img src="imageBasicSubsamplingExample.png" alt="imageBasicSubsamplingExample.png"/>
<div class="caption">
Illustration of the resulting subsampling given by the imageBasicSubsampling.cpp example</div></div>
<p>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 24 2016 14:01:37 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
