<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>DGtal: Analysis of one-dimensional discrete structures</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.9.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Analysis of one-dimensional discrete structures </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#geometryIntro">One-dimensional discrete structures</a><ul><li class="level2"><a href="#geometryBasicConcepts">Iterators/Circulators and Ranges.</a></li>
<li class="level2"><a href="#geometryGridCurve">GridCurve and FreemanChain.</a></li>
</ul>
</li>
<li class="level1"><a href="#geometrySegments">Segments and on-line detection of segments.</a></li>
<li class="level1"><a href="#geometrySegmentsExtraction">Segments Extraction.</a><ul><li class="level2"><a href="#geometryGreedyDecomposition">Greedy segmentation</a></li>
<li class="level2"><a href="#geometryUniqueDecomposition">Saturated segmentation.</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Authors</dt><dd>Tristan Roussillon</dd></dl>
<dl class="section date"><dt>Date</dt><dd>2011/08/31</dd></dl>
<p>This part of the manual describes how to extract patterns from one-dimensional discrete structures (basically digital curves).</p>
<h1><a class="anchor" id="geometryIntro"></a>
One-dimensional discrete structures</h1>
<p>The goal is to provide tools that help in analysing any one-dimensional discrete structures in a generic framework. These structures are assumed to be constant, not mutable. This is a (not exhaustive) list of such structures used in digital geometry:</p>
<ul>
<li>digital curves<ul>
<li>2d, 3d, nd</li>
<li>4-connected, 8-connected, disconnected</li>
<li>interpixels, pixels</li>
<li>open, closed</li>
</ul>
</li>
<li>chaincodes</li>
</ul>
<h2><a class="anchor" id="geometryBasicConcepts"></a>
Iterators/Circulators and Ranges.</h2>
<p>Since these structures are one-dimensional and discrete, they can be viewed as a locally ordered set of elements, like a string of pearls. Two notions are thus important: the one of <em>element</em> and the one of <em>local order</em>, which means that all the elements (except maybe at the ends) have a previous and next element. The concept of <em>iterator</em> is heavily used in our framework because it encompasses these two notions at the same time: like a pointer, it provides a way of moving along the structure (operator++, operator--) and provides a way of getting the elements (operator*).</p>
<p>In the following, iterators are assumed to be constant (because the structures are assumed to be constant) and to be at least bidirectionnal (ie. they are either bidirectionnal iterators or random access iterators). You can read the STL documentation about iterators: <a href="http://www.sgi.com/tech/stl/Iterators.html">http://www.sgi.com/tech/stl/Iterators.html</a> to learn more about the different kind of iterators.</p>
<p>The notion of <em>reachability</em> is very important. An iterator j is reachable from an iterator i if and only if i can be made equal to j with finitely many applications of the operator++. If j is reachable from i, one can iterate over the <em>range</em> of elements bounded by i and j, from the one pointed to by i and up to but not including the one pointed to by j. Such a range is valid and is denoted by [i,j).</p>
<p>Let i and j be two iterators that point to two elements of a same structure. For open (or linear) structures, [i,j) is not always a valid range (ie. j is not always reachable from i) because if j has not been reached and if i points to the last element, one application of the operator++ makes i to be equal to the <em>past-the-end</em> value, ie. an iterator value that points past the last element (just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element of the array). If i turns out to be equal to the past-the-end value, then j cannot be reached from i. If an iterator denoted by begin points to the first element of a given structure and an iterator denoted by end is the past-the-end value, iterating over the range [begin,end) is a way of iterating over all the elements of the underlying structure. If the underlying structure is empty, it only has a past-the-end value. As a consequence, a range [i, i) denotes an empty range. A range of a linear structure is illustrated below (normal values are depicted with a small straight segment, whereas the past-the-end value is depicted with a cross). In this example, [i,j) is not a valid range because j cannot be reached from i and the whole range may be denoted by [begin,end).</p>
<div class="image">
<img src="linearRange.png" alt="linearRange.png"/>
<div class="caption">
Linear range</div></div>
 <p>However, for closed (or circular) structures, [i,j) should always be a valid range (ie. j should always be reachable from i) and there should be no past-the-end value. As a consequence, iterating over all the elements or dealing with empty ranges is different. The chosen solution is the same as the one used in <a href="http://www.cgal.org/Manual/3.3/doc_html/cgal_manual/Circulator/Chapter_main.html">CGAL</a>. Circular iterators (or <em>circulators</em> for short) are used instead of classic iterators. They behave like classic iterators but they have a specific state in the empty range case. As long as i != j, the range [i,j) behaves like a classic iterator range and could be used in STL algorithms. The range [i,i) is used to iterate over all the elements in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a> algorithms (each element is visited only once). Such a range is however considered as empty in STL algorithms. A range of a circular structure is illustrated below. In this example, [i,j) is a valid range.</p>
<div class="image">
<img src="circularRange.png" alt="circularRange.png"/>
<div class="caption">
Circular range</div></div>
 <p>Either an iterator or a circulator may have a reverse counterpart, ie. an adaptor that enables a backward scanning. The operator++ of the adaptor calls the operator-- of the underlying (circular)iterator and conversely. You can use the STL reverse iterator for that: <a href="http://www.sgi.com/tech/stl/ReverseIterator.html">http://www.sgi.com/tech/stl/ReverseIterator.html</a></p>
<h2><a class="anchor" id="geometryGridCurve"></a>
GridCurve and FreemanChain.</h2>
<p>Two objects are provided in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a> to deal with digital curves: <a class="el" href="classDGtal_1_1GridCurve.html" title="Aim: describes, in a cellular space of dimension n, a closed or open sequence of signed d-cells (or d...">GridCurve</a> and <a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a>.</p>
<p><a class="el" href="classDGtal_1_1GridCurve.html" title="Aim: describes, in a cellular space of dimension n, a closed or open sequence of signed d-cells (or d...">GridCurve</a> describes, in a cellular space of dimension n, a closed or open sequence of signed d-cells (or d-scells), d being either equal to 1 or (n-1).</p>
<p>For instance, the topological boundary of a simply connected digital set is a closed sequence of 1-scells in 2d.</p>
<p>It stores a list of d-scells, but provides many ranges to iterate over different kinds of elements:</p>
<ul>
<li>SCellsRange to iterate over the d-scells</li>
<li>PointsRange to iterate over the digital coordinates of the 0-scells that are directly incident to the d-scells</li>
<li>MidPointsRange to iterate over the real coordinates of the d-scells</li>
<li>ArrowsRange to iterate over the arrows coding the 1-scells. Note that an arrow is a pair point-vector: the point codes the digital coordinates of the 1-scell, the vector gives the topology and sign of the 1-scell.</li>
<li>InnerPointsRange to iterate over the digital coordinates of the n-scells that are <em>directly</em> incident to the (n-1)-scells.</li>
<li>OuterPointsRange to iterate over the digital coordinates of the n-scells that are <em>indirectly</em> incident to the (n-1)-scells.</li>
<li>IncidentPointsRange to iterate over the pairs of inner and outer points (defined as above)</li>
<li>CodesRange to iterate over the codes {0,1,2,3} of the 1-scells (only available if n = 2)</li>
</ul>
<p>You can get an access to these eight ranges through the following methods:</p>
<ul>
<li>getSCellsRange()</li>
<li>getPointsRange()</li>
<li>getMidPointsRange()</li>
<li>getArrowsRange()</li>
<li>getInnerPointsRange()</li>
<li>getOuterPointsRange()</li>
<li>getIncidentPointsRange()</li>
<li>getCodesRange()</li>
</ul>
<p>The different ranges for a grid curve whose chain code is 0001112223333 are depicted below.</p>
<div class="image">
<img src="1cellsRange.png" alt="1cellsRange.png"/>
<div class="caption">
Range of 1-cells</div></div>
  <div class="image">
<img src="PointsRange.png" alt="PointsRange.png"/>
<div class="caption">
Points of integer coordinates associated to 0-cells</div></div>
  <div class="image">
<img src="MidPointsRange.png" alt="MidPointsRange.png"/>
<div class="caption">
Points of half-integer coordinates accociated to 1-cells</div></div>
  <div class="image">
<img src="InnerPointsRange.png" alt="InnerPointsRange.png"/>
<div class="caption">
Points of integer coordinates associated to the 2-cells directly incident to the 1-cells</div></div>
  <div class="image">
<img src="OuterPointsRange.png" alt="OuterPointsRange.png"/>
<div class="caption">
Points of integer coordinates associated to the 2-cells indirectly incident to the 1-cells</div></div>
  <div class="image">
<img src="IncidentPointsRange.png" alt="IncidentPointsRange.png"/>
<div class="caption">
Points of integer coordinates associated to the 2-cells incident to the 1-cells</div></div>
 <p><a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a> is a 2-dimensional and 4-connected digital curve stored as a string of codes {0,1,2,3} as follows:</p>
<ul>
<li>0 for a horizontal step to the right</li>
<li>1 for a vertical step to the up</li>
<li>2 for a horizontal step to the left</li>
<li>3 for a vertical step to the bottom</li>
</ul>
<p>As <a class="el" href="classDGtal_1_1GridCurve.html" title="Aim: describes, in a cellular space of dimension n, a closed or open sequence of signed d-cells (or d...">GridCurve</a>, it provides a CodesRange.</p>
<p>Each range has the following inner types:</p>
<ul>
<li>ConstIterator</li>
<li>ConstReverseIterator</li>
<li>ConstCirculator</li>
<li>ConstReverseCirculator</li>
</ul>
<p>And each range provides these (circular)iterator services:</p>
<ul>
<li>begin() : begin ConstIterator</li>
<li>end() : end ConstIterator</li>
<li>rbegin() : begin ConstReverseIterator</li>
<li>rend() : end ConstReverseIterator</li>
<li>c() : ConstCirculator</li>
<li>rc() : ConstReverseCirculator</li>
</ul>
<p>You can use these services to iterate over the elements of a given range as follows:</p>
<div class="fragment"><div class="line">    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;\t iterate over the range&quot;</span> &lt;&lt; endl;</div>
<div class="line">    Range::ConstIterator it = r.begin(); </div>
<div class="line">    Range::ConstIterator itEnd = r.end(); </div>
<div class="line">    <span class="keywordflow">for</span> ( ; it != itEnd; ++it)</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; *it;</div>
<div class="line">    }</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; endl;</div>
<div class="line">    </div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;\t iterate over the range in the reverse way&quot;</span> &lt;&lt; endl;</div>
<div class="line">    <a class="code" href="classDGtal_1_1SimpleRandomAccessRangeFromPoint.html#aeaa678cba54eb073acd6a15adc2ea4a9">Range::ConstReverseIterator</a> rit = r.rbegin(); </div>
<div class="line">    <a class="code" href="classDGtal_1_1SimpleRandomAccessRangeFromPoint.html#aeaa678cba54eb073acd6a15adc2ea4a9">Range::ConstReverseIterator</a> ritEnd = r.rend(); </div>
<div class="line">    <span class="keywordflow">for</span> ( ; rit != ritEnd; ++rit) </div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; *rit;</div>
<div class="line">    }</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; endl;</div>
<div class="line">      </div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;\t iterate over the range in a circular way&quot;</span> &lt;&lt; endl;</div>
<div class="line">    <a class="code" href="classDGtal_1_1Circulator.html">Range::ConstCirculator</a> c = r.c();</div>
<div class="line">    <span class="comment">//set the starting element wherever you want... </span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; 20; ++i) ++c; </div>
<div class="line">    <span class="comment">//... and circulate</span></div>
<div class="line">    <a class="code" href="classDGtal_1_1Circulator.html">Range::ConstCirculator</a> cend( c );</div>
<div class="line">    <span class="keywordflow">do</span> </div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; *c;</div>
<div class="line">      c++;</div>
<div class="line">    } <span class="keywordflow">while</span> (c!=cend);</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Since <a class="el" href="classDGtal_1_1GridCurve.html" title="Aim: describes, in a cellular space of dimension n, a closed or open sequence of signed d-cells (or d...">GridCurve</a> and <a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a> have both a method isClosed(), you can decide to use a classic iterator or a circulator at running time as follows:</p>
<div class="fragment"><div class="line"><span class="comment">//c is a grid curve, r is an instance of Range</span></div>
<div class="line"><span class="comment">//doSomething is a template function where </span></div>
<div class="line"><span class="comment">//the range r is processed through (circular)iterators</span></div>
<div class="line"><span class="keywordflow">if</span> ( c.isClosed() )</div>
<div class="line">  doSomething( r.c(), r.c() ); </div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  doSomething( r.begin(), r.end() ); </div>
</div><!-- fragment --><h1><a class="anchor" id="geometrySegments"></a>
Segments and on-line detection of segments.</h1>
<p>In this section, we focus on parts of one-dimensional structures, called <em>segment</em>. More precisely, a segment is a valid and not empty range.</p>
<p>The concept <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment, ie. a valid and not empty range. ">CSegment</a> refines <a class="el" href="structboost_1_1DefaultConstructible.html" title="Go to http://www.boost.org/doc/html/DefaultConstructible.html. ">boost::DefaultConstructible</a>, <a class="el" href="structboost_1_1CopyConstructible.html" title="Go to http://www.boost.org/doc/html/CopyConstructible.html. ">boost::CopyConstructible</a>, <a class="el" href="structboost_1_1Assignable.html" title="Go to http://www.boost.org/doc/html/Assignable.html. ">boost::Assignable</a>, <a class="el" href="structboost_1_1EqualityComparable.html" title="Go to http://www.boost.org/doc/html/EqualityComparable.html. ">boost::EqualityComparable</a>, and the one of constant range. It thus have the following inner types:</p>
<ul>
<li>ConstIterator : a model of bidirectional iterator</li>
</ul>
<p>and the following methods:</p>
<ul>
<li>begin() : begin iterator</li>
<li>end() : end iterator</li>
</ul>
<p>Note that since a segment is a not empty range, we have the following invariant: begin() != end().</p>
<p>A class of segments \( \Sigma_P \) is a set of segments such that for each segment of the set, a given predicate P is true: \( \forall s \in \Sigma_P \), P(s) = true.</p>
<p>Segment computers are segments that can</p><ol type="1">
<li>construct instances of their own type (or derived type)</li>
<li>check whether a predicate (possibly not explicit) is true or not</li>
</ol>
<p><a class="el" href="structDGtal_1_1CSegmentFactory.html" title="Aim: Defines the concept describing a segment ie. a valid and not empty subrange, which can construct...">CSegmentFactory</a> is a refinement of <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment, ie. a valid and not empty range. ">CSegment</a> and should define in addition the following nested types:</p>
<ul>
<li>Self (its own type)</li>
<li>Reverse (like Self but based on reverse iterators)</li>
</ul>
<p>Reverse is a type that behaves like Self but based on std::reverse_iterator&lt;ConstIterator&gt; instead of ConstIterator. Moreover, in order to build an instance of Self (resp. Reverse) from a segment computer, the following methods should be defined:</p>
<ul>
<li>Self getSelf() : returns an instance of Self</li>
<li>Reverse getReverse() : returns an instance of Reverse</li>
</ul>
<p>The returned objects may not be full copies of this, may not have the same internal state as this, but must be constructed from the same input parameters so that they can detect segments of the same class.</p>
<p>These methods are useful in segmentation algorithms when new segment computers must be created. An independant factory is not required since a segment computer is a factory for instances of its own type.</p>
<p>A segment computer is not a single concept, but actually several concepts that form a hierarchy. The five concepts that are used in segmentation algorithms are <a class="el" href="structDGtal_1_1CIncrementalSegmentComputer.html" title="Aim: Defines the concept describing an incremental segment computer, ie. a model of CSegmentFactory t...">CIncrementalSegmentComputer</a>, <a class="el" href="structDGtal_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer. Like any model of CIncrementalSegment...">CForwardSegmentComputer</a>, <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a>, <a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html" title="Aim: Defines the concept describing a dynamic segment computer, ie. a model of CSegment that can exte...">CDynamicSegmentComputer</a> and <a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie...">CDynamicBidirectionalSegmentComputer</a>.</p>
<div align="center">
<img src="dot_inline_dotgraph_6.png" alt="dot_inline_dotgraph_6.png" border="0" usemap="#dot_inline_dotgraph_6.map"/>
<map name="dot_inline_dotgraph_6.map" id="dot_inline_dotgraph_6.map"><area shape="poly" id="node2" href="structDGtal_1_1CSegment.html" title="CSegment" alt="" coords="554,52 550,44 538,38 519,32 496,29 471,27 445,29 422,32 404,38 392,44 388,52 392,60 404,66 422,72 445,75 471,77 496,75 519,72 538,66 550,60"/>
<area shape="poly" id="node3" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="CBidirectionalSegmentComputer" alt="" coords="483,447 472,439 439,432 389,427 325,423 255,422 184,423 121,427 70,432 38,439 27,447 38,454 70,461 121,466 184,470 255,471 325,470 389,466 439,461 472,454"/>
<area shape="poly" id="node5" href="structDGtal_1_1CForwardSegmentComputer.html" title="CForwardSegmentComputer" alt="" coords="671,348 662,340 633,334 589,328 533,325 471,323 409,325 353,328 308,334 280,340 270,348 280,356 308,362 353,368 409,371 471,373 533,371 589,368 633,362 662,356"/>
<area shape="poly" id="node4" href="structDGtal_1_1CIncrementalSegmentComputer.html" title="CIncrementalSegmentComputer" alt="" coords="696,249 685,242 653,235 603,230 540,226 471,225 401,226 338,230 288,235 256,242 245,249 256,257 288,264 338,269 401,273 471,274 540,273 603,269 653,264 685,257"/>
<area shape="poly" id="node6" href="structDGtal_1_1CSegmentFactory.html" title="CSegmentFactory" alt="" coords="601,151 594,143 576,136 547,131 511,127 471,126 430,127 394,131 365,136 347,143 341,151 347,158 365,165 394,170 430,174 471,175 511,174 547,170 576,165 594,158"/>
<area shape="poly" id="node7" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html" title="CDynamicBidirectionalSegmentComputer" alt="" coords="754,545 740,538 700,531 637,526 557,522 469,521 381,522 302,526 239,531 199,538 185,545 199,553 239,560 302,565 381,569 469,570 557,569 637,565 700,560 740,553"/>
<area shape="poly" id="node8" href="structDGtal_1_1CDynamicSegmentComputer.html" title="CDynamicSegmentComputer" alt="" coords="913,447 903,439 874,432 829,427 772,423 709,422 646,423 590,427 545,432 516,439 506,447 516,454 545,461 590,466 646,470 709,471 772,470 829,466 874,461 903,454"/>
</map>
</div>
<p>Incremental segment computers provides a way of <em>incrementally</em> detecting a segment belonging to a known class, ie. checking if P is true.</p>
<p>Note that the incremental constraint implies a constraint on P: for each iterator it from begin() to end(), P must be true for the range [begin(), it), so that a incremental segment computer can be initialized at a starting element and then can be extended forward to the neighbor elements while P remains true.</p>
<p><a class="el" href="structDGtal_1_1CIncrementalSegmentComputer.html" title="Aim: Defines the concept describing an incremental segment computer, ie. a model of CSegmentFactory t...">CIncrementalSegmentComputer</a> is a refinement of <a class="el" href="structDGtal_1_1CSegmentFactory.html" title="Aim: Defines the concept describing a segment ie. a valid and not empty subrange, which can construct...">CSegmentFactory</a> and should provide in addition the following methods:</p>
<ul>
<li>void init ( const Iterator&amp; it ) : set the segment to the element pointed to by it.</li>
<li>bool extendFront () : return 'true' and extend the segment to the element pointed to by end() if it is possible, return 'false' and does not extend the segment otherwise.</li>
<li>bool isExtendableFront () : return 'true' if the segment can be extended to the element pointed to by end() and 'false' otherwise (no extension is performed).</li>
</ul>
<p>Detecting a segment in a range looks like this:</p>
<div class="fragment"><div class="line"><span class="comment">//s is a segment computer</span></div>
<div class="line"><span class="comment">//[begin,end) is a range</span></div>
<div class="line">            s.init( begin );</div>
<div class="line"><span class="keywordflow">while</span> ( (s.end() != end) &amp;&amp; (s.extendFront()) ) {} </div>
</div><!-- fragment --><p>If the underlying structure is closed, infinite loops are avoided as follows:</p>
<div class="fragment"><div class="line"><span class="comment">//s is a segment computer</span></div>
<div class="line"><span class="comment">//c is a circulator</span></div>
<div class="line">            s.init( c );</div>
<div class="line"><span class="keywordflow">while</span> ( (s.end() != s.begin()) &amp;&amp; (s.extendFront()) ) {} </div>
</div><!-- fragment --><p>Like any model of <a class="el" href="structDGtal_1_1CIncrementalSegmentComputer.html" title="Aim: Defines the concept describing an incremental segment computer, ie. a model of CSegmentFactory t...">CIncrementalSegmentComputer</a>, a model of <a class="el" href="structDGtal_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer. Like any model of CIncrementalSegment...">CForwardSegmentComputer</a> can control its own extension so that P remains true. However, contrary to models of <a class="el" href="structDGtal_1_1CIncrementalSegmentComputer.html" title="Aim: Defines the concept describing an incremental segment computer, ie. a model of CSegmentFactory t...">CIncrementalSegmentComputer</a>, it garantees that for each iterator it from begin() to end(), P must be true for the range [it, end()). This last constraint, together with the previous contraint on the range [begin(), it), implies that P is true for any subrange. This property is necessary to be able to incrementally check whether a segment is maximal (not included in a greater segment) or not.</p>
<p>As the name suggests, forward segment computers can only extend themselves in the forward direction, but this direction is relative to the direction of the underlying iterators (the direction given by operator++ for instances of Self, but the direction given by operator-- for instances of Reverse). They cannot extend themselves in two directions at the same time around an element contrary to bidirectional segment computers.</p>
<p>Any model of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a>, which is a refinement of <a class="el" href="structDGtal_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer. Like any model of CIncrementalSegment...">CForwardSegmentComputer</a>, should define the following methods:</p>
<ul>
<li>bool extendBack () : return 'true' and extend the segment to the element pointed to by &ndash;begin() if it is possible, return 'false' and does not extend the segment otherwise.</li>
<li>bool isExtendableBack () : return 'true' if the segment can be extended to the element pointed to by &ndash;begin() and 'false' otherwise (no extension is performed).</li>
</ul>
<p><a class="el" href="classDGtal_1_1StabbingLineComputer.html" title="Aim: On-line recognition of a digital straight segment (DSS) defined as a sequence of connected grid ...">StabbingLineComputer</a> and <a class="el" href="classDGtal_1_1StabbingCircleComputer.html" title="Aim: On-line recognition of a digital circular arcs (DCA) defined as a sequence of connected grid edg...">StabbingCircleComputer</a> are both models of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a>.</p>
<p>The concept <a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html" title="Aim: Defines the concept describing a dynamic segment computer, ie. a model of CSegment that can exte...">CDynamicSegmentComputer</a> is another refinement of <a class="el" href="structDGtal_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer. Like any model of CIncrementalSegment...">CForwardSegmentComputer</a>. Any model of this concept should define the following method:</p>
<ul>
<li>bool retractBack () : return 'true' and move the beginning of the segment to ++begin() if ++begin() != end(), return 'false' otherwise.</li>
</ul>
<p>Finally, the concept <a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie...">CDynamicBidirectionalSegmentComputer</a> is a refinement of both <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a> and <a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html" title="Aim: Defines the concept describing a dynamic segment computer, ie. a model of CSegment that can exte...">CDynamicSegmentComputer</a> and should define this extra method:</p>
<ul>
<li>bool retractFront () : return 'true' and move the end of the segment to &ndash;end() if begin() != &ndash;end(), return 'false' otherwise.</li>
</ul>
<p>A model of <a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie...">CDynamicBidirectionalSegmentComputer</a> is <a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html" title="Aim: This class is a wrapper around ArithmeticalDSS that is devoted to the dynamic recognition of dig...">ArithmeticalDSSComputer</a>, devoted to the dynamic recognition of DSSs, defined as a sequence of connected points \( (x,y) \) such that \( \mu \leq ax - by &lt; \mu + \omega \) (see Debled and Reveilles, 1995).</p>
<p>Here is a short example of how to use this class in the 4-connected case:</p>
<div class="fragment"></div><!-- fragment --><p> Here is a short example of how to use this class in the 8-connected case:</p>
<div class="fragment"></div><!-- fragment --><p> These snippets are drawn from ArithmeticalDSSComputer.cpp.</p>
<p>The resulting DSSs of the two previous pieces of code are drawing below:</p>
<div class="image">
<img src="DSS8.png" alt="DSS8.png"/>
<div class="caption">
8-connected DSS drawn with the paving mode</div></div>
 <div class="image">
<img src="DSS4.png" alt="DSS4.png"/>
<div class="caption">
4-connected DSS drawn with the grid mode</div></div>
 <p>See dgtal_dgtalboard for the drawing mechanism.</p>
<p>As seen above, the code can be different if an iterator or a circulator is used as the nested ConstIterator type. Moreover, some tasks can be made faster for a given kind of segment computer than for another kind of segment computer. That's why many generic functions are provided in SegmentComputerUtils.h:</p>
<ul>
<li>maximalExtension, oppositeEndMaximalExtension, maximalSymmetricExtension,</li>
<li>maximalRetraction, oppositeEndMaximalRetraction,</li>
<li>longestSegment,</li>
<li>firstMaximalSegment, lastMaximalSegment, mostCenteredMaximalSegment,</li>
<li>previousMaximalSegment, nextMaximalSegment,</li>
</ul>
<p>These functions are used in the segmentation algorithms introduced below.</p>
<h1><a class="anchor" id="geometrySegmentsExtraction"></a>
Segments Extraction.</h1>
<p>A given range contains a finite set of segments verifying a given predicate P. A <em>segmentation&lt;</em> is a subset of the whole set of segments, such that:</p>
<p>i. each element of the range belongs to a segment of the subset and</p>
<p>ii. no segment contains another segment of the subset.</p>
<p>Due to (ii), the segments of a segmentation can be ordered without ambiguity (according to the position of their first element for instance).</p>
<p>Segmentation algorithms should verify the concept CSegmentation. A CSegmentation model should define the following nested type:</p>
<ul>
<li>SegmentComputerIterator: a model of the concept CSegmentComputerIterator</li>
</ul>
<p>It should also define a constructor taking as input parameters:</p>
<ul>
<li>begin/end iterators of the range to be segmented.</li>
<li>an instance of a model of CSegmentComputer.</li>
</ul>
<p>Note that a model of CSegmentComputerIterator should define the following methods :</p>
<ul>
<li>default and copy constructors</li>
<li>dereference operator: return an instance of a model of CSegmentComputer.</li>
<li>intersectPrevious(), intersectNext(): return 'true' if the current segment intersects, respectively, the previous and the next one (when they exist), 'false' otherwise.</li>
</ul>
<h2><a class="anchor" id="geometryGreedyDecomposition"></a>
Greedy segmentation</h2>
<p>The first and simplest segmentation is the greedy one: from a starting element, extend a segment while it is possible, get the last element of the resulting segment and iterate. This segmentation algorithm is implemented in the class  <a class="el" href="classDGtal_1_1GreedySegmentation.html" title="Aim: Computes the greedy segmentation of a range given by a pair of ConstIterators. The last element of a given segment is the first one one of the next segment. ">GreedySegmentation</a>. </p><pre class="fragment"> In the short example below, a digital curve stored in a STL vector
 is decomposed into 8-connected DSSs whose parameters are sent to 
 the standard output.
</pre> <div class="fragment"><div class="line"><span class="comment">//types definition</span></div>
<div class="line"><span class="keyword">typedef</span> PointVector&lt;2,int&gt; Point;</div>
<div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Range;</div>
<div class="line"><span class="keyword">typedef</span> Range::const_iterator ConstIterator;</div>
<div class="line"><span class="keyword">typedef</span> ArithmeticalDSSComputer&lt;ConstIterator,int,8&gt; SegmentComputer;</div>
<div class="line">      <span class="keyword">typedef</span> GreedySegmentation&lt;SegmentComputer&gt; Segmentation;</div>
<div class="line"></div>
<div class="line">      <span class="comment">//input points</span></div>
<div class="line">      Range curve;</div>
<div class="line">      curve.push_back(Point(1,1));</div>
<div class="line">      curve.push_back(Point(2,1));</div>
<div class="line">      curve.push_back(Point(3,2));</div>
<div class="line">      curve.push_back(Point(4,2));</div>
<div class="line">      curve.push_back(Point(5,2));</div>
<div class="line">      curve.push_back(Point(6,2));</div>
<div class="line">      curve.push_back(Point(7,2));</div>
<div class="line">      curve.push_back(Point(8,1));</div>
<div class="line">      curve.push_back(Point(9,1));</div>
<div class="line"></div>
<div class="line"><span class="comment">//Segmentation</span></div>
<div class="line">      SegmentComputer recognitionAlgorithm;</div>
<div class="line">Segmentation theSegmentation(curve.<a class="code" href="classDGtal_1_1SimpleRandomAccessRangeFromPoint.html#a3f3127761d5c822c16368719929eb07e">begin</a>(), curve.<a class="code" href="classDGtal_1_1SimpleRandomAccessRangeFromPoint.html#aeff6def66f4bbd73d61afb27e3f23035">end</a>(), recognitionAlgorithm);</div>
<div class="line">                               </div>
<div class="line">Segmentation::SegmentComputerIterator i = theSegmentation.<a class="code" href="classDGtal_1_1SimpleRandomAccessRangeFromPoint.html#a3f3127761d5c822c16368719929eb07e">begin</a>();</div>
<div class="line">Segmentation::SegmentComputerIterator end = theSegmentation.end();</div>
<div class="line"><span class="keywordflow">for</span> ( ; i != end; ++i) {</div>
<div class="line">              SegmentComputer current(*i);</div>
<div class="line">              <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; current &lt;&lt; std::endl;   <span class="comment">//standard output</span></div>
<div class="line">} </div>
</div><!-- fragment --><p>If you want to get the DSSs segmentation of the digital curve when it is scanned in the reverse way, you can use the reverse iterator of the STL vector: </p><div class="fragment"><div class="line">...</div>
<div class="line">        <span class="keyword">typedef</span> Range::const_reverse_iterator ConstReverseIterator;</div>
<div class="line">...</div>
<div class="line">  Segmentation theSegmentation(curve.<a class="code" href="classDGtal_1_1SimpleRandomAccessRangeFromPoint.html#ad73efeb4270b6af18c1ca1c19b170a47">rbegin</a>(), curve.<a class="code" href="classDGtal_1_1SimpleRandomAccessRangeFromPoint.html#ad7356fa905011a1ac92a8cfa87ad1eb3">rend</a>(), recognitionAlgorithm);</div>
<div class="line">...</div>
</div><!-- fragment --><p>The resulting segmentations are shown in the figures below:</p>
<div class="image">
<img src="left_right.png" alt="left_right.png"/>
<div class="caption">
segmented from left to right</div></div>
 <div class="image">
<img src="right_left.png" alt="right_left.png"/>
<div class="caption">
segmented from right to left</div></div>
 <pre class="fragment"> If you want to get the DSSs segmentation of a part of the 
 digital curve (not the whole digital curve), you can give 
 the range to process as a pair of iterators when calling 
 the setSubRange() method as follow: 
</pre> <div class="fragment"><div class="line">theSegmentation.setSubRange(beginIt, endIt);</div>
</div><!-- fragment --><p>Obviously, [beginIt, endIt) has to be a valid range included in the wider range [curve.begin(), curve.end()).</p>
<p>Moreover, a part of a digital curve may be processed either as an independant (open) digital curve or as a part whose segmentation at the ends depends of the underlying digital curve. That's why 3 processing modes are available:</p><ul>
<li>"Truncate" (default), the extension of the last segment (and the segmentation) stops just before endIt.</li>
<li>"Truncate+1", the last segment is extended to endIt too if it is possible, provided that endIt != curve.end().</li>
<li>"DoNotTruncate", the last segment is extended as far as possible, provided that curve.end() is not reached.</li>
</ul>
<p>In order to set a mode (before getting a SegmentComputerIterator), use the setMode() method as follow: </p><div class="fragment"><div class="line">theSegmentation.setMode(<span class="stringliteral">&quot;DoNotTruncate&quot;</span>);</div>
</div><!-- fragment --><p> Note that the default mode will be used for any unknown modes.</p>
<p>The complexity of the greedy segmentation algorithm relies on the complexity of the extendFront() method of the segment computer. If it runs in (possibly amortized) constant time, then the complexity of the segmentation is linear in the length of the range.</p>
<h2><a class="anchor" id="geometryUniqueDecomposition"></a>
Saturated segmentation.</h2>
<p>A unique and richer segmentation, called saturated segmentation, is the whole set of <em>maximal segments</em> (a maximal segment is a segment that cannot be contained in a greater segment). This segmentation algorithm is implemented in the class <a class="el" href="classDGtal_1_1SaturatedSegmentation.html">SaturatedSegmentation</a>.</p>
<p>In the previous segmentation code, instead of the line: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> GreedySegmentation&lt;SegmentComputer&gt; Segmentation;</div>
</div><!-- fragment --><p> it is enough to write the following line: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> SaturatedSegmentation&lt;SegmentComputer&gt; Segmentation;</div>
</div><!-- fragment --><p>to get the following figure: </p><div class="image">
<img src="maxseg.png" alt="maxseg.png"/>
<div class="caption">
maximal segments</div></div>
 <p>See  <a class="el" href="convex-and-concave-parts_8cpp_source.html">convex-and-concave-parts.cpp</a> for an example of how to use maximal DSSs to decompose a digital curve into convex and concave parts.</p>
<p>If you want to get the saturated segmentation of a part of the digital curve (not the whole digital curve), you can give the range to process as a pair of iterators when calling the setSubRange() method as follow: </p><div class="fragment"><div class="line">theSegmentation.setSubRange(beginIt, endIt);</div>
</div><!-- fragment --><p>Obviously, [beginIt, endIt) has to be a valid range included in the wider range [curve.begin(), curve.end()).</p>
<p>Moreover, the segmentation at the ends depends of the underlying digital curve. Among the whole set of maximal segments that pass through the first (resp. last) element of the range, one maximal segment must be chosen as the first (resp. last) retrieved maximal segments. Several processing modes are therefore available:</p><ul>
<li>"First",</li>
<li>"MostCentered" (default),</li>
<li>"Last",</li>
</ul>
<p>The mode i indicates that the segmentation begins with the i-th maximal segment passing through the first element and ends with the i maximal segment passing through the last element.</p>
<p>In order to set a mode (before getting a SegmentComputerIterator), use the setMode() method as follow: </p><div class="fragment"><div class="line">theSegmentation.setMode(<span class="stringliteral">&quot;First&quot;</span>);</div>
</div><!-- fragment --><p> Note that the default mode will be used for any unknown modes.</p>
<p>The complexity of the saturated segmentation algorithm relies on the complexity of the functions available for computing maximal segments (firstMaximalSegment, lastMaximalSegment, mostCenteredMaximalSegment, previousMaximalSegment and nextMaximalSegment), which are specialized according to the type of segment computer (forward, bidirectional and dynamic).</p>
<p>Let \( l \) be the length of the range and \( n \) the number of maximal segments. Let \( L_i \) be the length of the i-th maximal segments. During the segmentation, the current segment is extended:</p>
<ul>
<li>at most \( 2.\Sigma_{1 \leq i \leq n} L_i \) times in the forward case.</li>
<li>exactly \( \Sigma_{1 \leq i \leq n} L_i \) times in the bidirectional case.</li>
<li>\( l \) times in the dynamic case. (But in this case, the current segment is also retracted \( l \) times).</li>
</ul>
<p>Moreover, note that \( \Sigma_{1 \leq i \leq n} L_i \) may be equal to \( O(l) \) (for instance for DSSs). </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 24 2016 14:01:37 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
