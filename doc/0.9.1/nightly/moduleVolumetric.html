<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>DGtal: nD Volumetric Analysis using Separable Processes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.9.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">nD Volumetric Analysis using Separable Processes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#introVol">Introduction</a></li>
<li class="level1"><a href="#voronoiSect">Digital Voronoi Diagram Computation</a></li>
<li class="level1"><a href="#DTsec">Distance Transformation</a></li>
<li class="level1"><a href="#RDTSec">Digital Power Map and Reverse Distance Transformation</a></li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>David Coeurjolly</dd></dl>
<p>This part of the manual describes the <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a> volumetric module. We focus here on separable process based volumetric analysis such as distance transformation, reverse distance transformation and medial axis extraction.</p>
<h1><a class="anchor" id="introVol"></a>
Introduction</h1>
<p>For decades, distance transformation (DT) and geometrical skeleton extraction have been classic tools for shape analysis <a class="el" href="citelist.html#CITEREF_Rosenfeld1966">[54]</a> <a class="el" href="citelist.html#CITEREF_Rosenfeld1968">[55]</a> . The DT of a shape consists in labelling object grid points with the distance to the closest background pixel. From the DT values, we thus have information on the shape geometry. Beside its applications in shape description, DT has been used in many situations such as shape analysis, shape matching, shape-based interpolation, motion planning, image registration, or differential measurement estimation.</p>
<p>In the literature, many techniques have been proposed to compute the DT given a metric with a trade-off between algorithmic performances and the <em>accuracy</em> of the metric compared to the Euclidean one. Hence, many papers have considered distances based on chamfer masks <a class="el" href="citelist.html#CITEREF_Rosenfeld1966">[54]</a> <a class="el" href="citelist.html#CITEREF_Rosenfeld1968">[55]</a> <a class="el" href="citelist.html#CITEREF_Borgefors1986CVGIP">[9]</a> , or sequences of chamfer distances; the vector displacement based Euclidean distance <a class="el" href="citelist.html#CITEREF_Danielsson1980">[22]</a> <a class="el" href="citelist.html#CITEREF_Ragnemalm1993">[52]</a> the Voronoi diagram based Euclidean distance <a class="el" href="citelist.html#CITEREF_Breu1995">[10]</a> <a class="el" href="citelist.html#CITEREF_Maurer2003PAMI">[43]</a> or the square of the Euclidean distance <a class="el" href="citelist.html#CITEREF_Saito1994-DT">[60]</a> <a class="el" href="citelist.html#CITEREF_Hirata1996">[33]</a> . From a computational point of view, several of these methods lead to time optimal algorithms to compute the error-free Euclidean Distance Transformation (EDT) for <em>n-</em> dimensional binary images: the extension of these algorithms is straightforward since they use separable techniques to compute the DT; <em>n</em> one-dimensional operations -one per direction of the coordinate axis- are performed.</p>
<p>In <a class="el" href="citelist.html#CITEREF_dcoeurjo_pami_RDMA">[15]</a>, it has been demonstrated that a similar decomposition can be used to compute both the reverse distance transformation and a discrete medial axis of the binary shape.</p>
<p>In fact, the separable decomposition and the associated algorithmic tools can be used on a wider class of metrics (see <a class="el" href="citelist.html#CITEREF_Hirata1996">[33]</a> or <a class="el" href="citelist.html#CITEREF_Maurer2003PAMI">[43]</a>). For instance, all weighted \(l_p\) metrics defined in \(R^n\) by </p><p class="formulaDsp">
\[ d_{L_p} (u,v) = \left ( \sum_{i=0}^n w_i|u_i-v_i |^p \right )^{\frac{1}{p}}\]
</p>
<p> can be considered.</p>
<p>In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a>, we have chosen to implement such volumetric tools such that the underlying metric could be specified independently.</p>
<p>For a complete discussion of metric concepts in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a>, please refer to <a class="el" href="moduleMetrics.html">Metric Spaces, Digital Metric Spaces and Related Concepts</a>.</p>
<h1><a class="anchor" id="voronoiSect"></a>
Digital Voronoi Diagram Computation</h1>
<p>The generic distance transformation is based on a prior Voronoi map consturction. Indeed, if we compute the Voronoi diagram of background points, the distance transformation at an object point is exactly its distance to the site associated with the Voronoi cell it belongs to.</p>
<p>The core of the implementation is based on a separable approach: For example, in dimension 2, partial digital Voronoi maps of dimension one are first computed in each row independently. Then such partial Voronoi maps are updated using independent processes along the columns, leading to a valid Voronoi map of dimension 2. In an algorithmic point of view, the 1D processes used for both columns and rows are exactly the same. In higher dimensions, the other dimensions are processed similarly.</p>
<dl class="section note"><dt>Note</dt><dd>We say digital Voronoi map instead of Voronoi diagram since the output of the result is the intersection between the Voronoi diagram of exterior points with \( \mathbb{Z}^d \). Furthermore, along Voronoi faces (<em>e.i</em>. when two sites are equidistant), only one sites is considered when intersection with \( \mathbb{Z}^d \).</dd></dl>
<p>In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a>, the class <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction. ">VoronoiMap</a> implements such digital Vornoi map extraction. Such class is parametrized by the following types:</p><ul>
<li>a type representing the underlying digital space (model of CSpace);</li>
<li>a type representing the object \( X \) as a point predicate (model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a>) ;</li>
<li>a type representing the underlying metric (model of CSeparableMetric, see below)</li>
<li>and an optional image container to store the resulting Voronoi map (by default, the type is <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>&lt;HyperRectDomain&lt;TSpace&gt;,typename TSpace::Vector&gt;).</li>
</ul>
<p>The <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction. ">VoronoiMap</a> constructor is parametrized by</p><ul>
<li>an instance of Domain (the Domain type associated with the image container);</li>
<li>an instance of the PointPredicate ;</li>
<li>and an instance of the separable metric.</li>
</ul>
<p>The <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction. ">VoronoiMap</a> will be computed on the specified and will use the point predicate to decide if a point of such domain is in the object or note.</p>
<dl class="section warning"><dt>Warning</dt><dd>The point predicate must be valid for each point in the specified domain. Basically, the domain can a sub-domain of the point predicate definition domain.</dd></dl>
<p>Once the <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction. ">VoronoiMap</a> object is created, the voronoi map is computed and the class itself is a model of CConstImage. In other words, you can access to the <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction. ">VoronoiMap</a> value at a point <em>p</em> and iterate of values using image ranges (see <a class="el" href="moduleImages.html">Images</a>). For example</p>
<div class="fragment"><div class="line">VoronoiMap&lt;....&gt; myVoronoiMap( .... ); <span class="comment">//object construction</span></div>
<div class="line">VoronoiMap&lt;....&gt;::Point p(12,34);</div>
<div class="line"></div>
<div class="line">VoronoiMap&lt;....&gt;::Value vectorToClosestSiteAtP = myVoronoiMap( p );</div>
<div class="line"><span class="keywordflow">for</span>(<a class="code" href="classDGtal_1_1HyperRectDomain.html#ad460a9309eb81ab5391a57f7d2a17055">VoronoiMap&lt;....&gt;::Domain::ConstIterator</a> it  = myVoronoiMap.domain().begin() , itend = myVoronoiMap.domain().end();</div>
<div class="line">it != itend ; ++it)</div>
<div class="line">     <span class="comment">//do something on myVoronoiMap(it)</span></div>
</div><!-- fragment --><p>Since we are constructing a <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction. ">VoronoiMap</a>, the value type of the map is a vector (pointing to the closest site) of type <a class="el" href="classDGtal_1_1SpaceND.html#ae194f4dfc28465ea14b437c066e69604" title="Vectors in DGtal::SpaceND. ">Space::Vector</a> (if Space was the underlying digital space type used when specifying <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction. ">VoronoiMap</a> template parameters).</p>
<p>Let us illustrate the construction in dimension 2 (see <a class="el" href="voronoimap2D_8cpp_source.html">voronoimap2D.cpp</a>). Other examples can be found in <a class="el" href="distancetransform2D_8cpp_source.html">distancetransform2D.cpp</a> and <a class="el" href="distancetransform3D_8cpp_source.html">distancetransform3D.cpp</a>.</p>
<p>First of all, we need couple of includes:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/kernel/BasicPointPredicates.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/images/SimpleThresholdForegroundPredicate.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/volumes/distance/ExactPredicateLpSeparableMetric.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/volumes/distance/VoronoiMap.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/volumes/distance/DistanceTransformation.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/io/colormaps/HueShadeColorMap.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/io/boards/Board2D.h&quot;</span></div>
</div><!-- fragment --><p> We will discuss later about the metric definition but let us consider a classical Euclidean \( l_2 \) metric:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ExactPredicateLpSeparableMetric&lt;Z2i::Space, 2&gt; L2Metric;</div>
<div class="line">  L2Metric l2;</div>
</div><!-- fragment --><p> We now consider an object in a [0,0]x[16,16] domain with three background points. To construct such point predicate, we first define a set containing the three points, then we consider the point predicate defined on this set (which returns true at a point if the point is inside the set) and we consider the negation of such predicate in order to return true for object points. Here you have the construction:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a> lower(0,0);</div>
<div class="line">  <a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a> upper(16,16);</div>
<div class="line">  <a class="code" href="namespaceDGtal_1_1Z2i.html#aca523bebdae58eb19385aaefffff8bc5">Z2i::Domain</a> domain(lower,upper);</div>
<div class="line"></div>
<div class="line">  <a class="code" href="namespaceDGtal_1_1Z2i.html#a371252c324e496cf8650757c1a2b4eb0">Z2i::DigitalSet</a> set(domain);</div>
<div class="line">  set.insertNew(<a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(2,3));</div>
<div class="line">  set.insertNew(<a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(7,15));</div>
<div class="line">  set.insertNew(<a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(12,5));</div>
<div class="line">  Board2D board;</div>
<div class="line"></div>
<div class="line">  board&lt;&lt; domain &lt;&lt; set;</div>
<div class="line">  board.saveSVG(<span class="stringliteral">&quot;voronoimap-inputset.svg&quot;</span>);</div>
</div><!-- fragment --><p> and the resulting set:</p>
<div class="image">
<img src="voronoimap-inputset.png" alt="voronoimap-inputset.png"/>
<div class="caption">
Input set.</div></div>
<p>The voronoi map is simply given by:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> VoronoiMap&lt;Z2i::Space, NotPredicate, L2Metric &gt; Voronoi2D;</div>
<div class="line">  Voronoi2D voronoimap(domain,notSetPred,l2);</div>
</div><!-- fragment --><p> At each point of the object, we thus have a vector to the closest background point. We can display this information as follows:</p>
<div class="fragment"><div class="line">  board.clear();</div>
<div class="line">  board &lt;&lt; domain;</div>
<div class="line">  <span class="keywordflow">for</span>(Voronoi2D::Domain::ConstIterator it = voronoimap.domain().begin(),</div>
<div class="line">      itend = voronoimap.domain().end(); it != itend; ++it)</div>
<div class="line">  {</div>
<div class="line">    Voronoi2D::Value site = voronoimap( *it );   <span class="comment">//closest site to (*it)</span></div>
<div class="line">    <span class="keywordflow">if</span> (site != (*it))</div>
<div class="line">      <a class="code" href="structDGtal_1_1Display2DFactory.html#a22bc78a987ac67e708111902eae1c698">Display2DFactory::draw</a>( board,   site - (*it), (*it)); <span class="comment">//Draw an arrow</span></div>
<div class="line">  }</div>
<div class="line">  board.saveSVG(<span class="stringliteral">&quot;voronoimap-voro.svg&quot;</span>);</div>
</div><!-- fragment --><p> To obtain:</p>
<div class="image">
<img src="voronoimap-voro.png" alt="voronoimap-voro.png"/>
<div class="caption">
Voronoi map.</div></div>
 Changing the board output, we can see the Voronoi cells accordingly:</p>
<div class="fragment"><div class="line">  board.clear();</div>
<div class="line">  <span class="keywordflow">for</span>(Voronoi2D::Domain::ConstIterator it = voronoimap.domain().begin(),</div>
<div class="line">      itend = voronoimap.domain().end(); it != itend; ++it)</div>
<div class="line">  {</div>
<div class="line">    Voronoi2D::Value site = voronoimap( *it );   <span class="comment">//closest site to (*it)</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c = (site[1]*13 + site[0] * 7) % 256; <span class="comment">//basic hashfunction</span></div>
<div class="line">    board &lt;&lt; CustomStyle( (*it).className(), <span class="keyword">new</span> CustomColors(Color(c,c,c),Color(c,c,c)))</div>
<div class="line">      &lt;&lt; (*it);</div>
<div class="line">  }</div>
<div class="line">  board.saveSVG(<span class="stringliteral">&quot;voronoimap-cells.svg&quot;</span>);</div>
</div><!-- fragment --><p> To get:</p>
<div class="image">
<img src="voronoimap-cells.png" alt="voronoimap-cells.png"/>
<div class="caption">
Voronoi map cells.</div></div>
 We could easily change the metric (here to the \( l_8 \)) and get a new Voronoi map: </p><div class="fragment"><div class="line">  <span class="keyword">typedef</span> ExactPredicateLpSeparableMetric&lt;Z2i::Space, 8&gt; L8Metric;</div>
<div class="line">  L8Metric l8;</div>
<div class="line">  <span class="keyword">typedef</span> VoronoiMap&lt;Z2i::Space, NotPredicate, L8Metric &gt; Voronoi2D_l8;</div>
<div class="line">  Voronoi2D_l8 voronoimap_l8(domain,notSetPred,l8);</div>
<div class="line">  board.clear();</div>
<div class="line">  board &lt;&lt; domain;</div>
<div class="line">  <span class="keywordflow">for</span>(Voronoi2D_l8::Domain::ConstIterator it = voronoimap_l8.domain().begin(),</div>
<div class="line">      itend = voronoimap_l8.domain().end(); it != itend; ++it)</div>
<div class="line">  {</div>
<div class="line">    Voronoi2D::Value site = voronoimap_l8( *it );   <span class="comment">//closest site to (*it)</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c = (site[1]*13 + site[0] * 7) % 256; <span class="comment">//basic hashfunction</span></div>
<div class="line">    board &lt;&lt; CustomStyle( (*it).className(), <span class="keyword">new</span> CustomColors(Color(c,c,c),Color(c,c,c)))</div>
<div class="line">          &lt;&lt; (*it);</div>
<div class="line">  }</div>
<div class="line">  board.saveSVG(<span class="stringliteral">&quot;voronoimap-vorol8.svg&quot;</span>);</div>
</div><!-- fragment --> <div class="image">
<img src="voronoimap-vorol8.png" alt="voronoimap-vorol8.png"/>
<div class="caption">
Voronoi map for the l_8 metric.</div></div>
 <h1><a class="anchor" id="DTsec"></a>
Distance Transformation</h1>
<p>As discussed earlier, the distance transformation is given by computing distances once the Voronoi map is obtained. In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a>, the class <a class="el" href="classDGtal_1_1DistanceTransformation.html" title="Aim: Implementation of the linear in time distance transformation for separable metrics. ">DistanceTransformation</a> simply adapts the <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction. ">VoronoiMap</a> class in order to override output image getters to return the distance for the given metric to the closest site instead of the vector.</p>
<p>As a consequence, the <a class="el" href="classDGtal_1_1DistanceTransformation.html" title="Aim: Implementation of the linear in time distance transformation for separable metrics. ">DistanceTransformation</a> class simply inherits from the <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction. ">VoronoiMap</a> class and overrides methods required by the CConstImage concept. Note that the DistanceTransfomation::Value type is double. If you want to get the underlying vector instead of the distance to perform exact computations, you can use the <a class="el" href="classDGtal_1_1DistanceTransformation.html#a262cfa7c9c2520fe448aaf00c551ef05">DistanceTransformation::getVoronoiVector</a> method.</p>
<p>In the following example, we consider the previous small image and use a colormap to display distance values for the \( l_2 \) mertic:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> DistanceTransformation&lt;Z2i::Space, NotPredicate, L2Metric &gt; DT;</div>
<div class="line">  DT dt(domain,notSetPred,l2);</div>
<div class="line">  board.clear();</div>
<div class="line">  board &lt;&lt; domain;</div>
<div class="line"></div>
<div class="line">  <span class="comment">//Fast max computation on the range value</span></div>
<div class="line">  DT::Value maxDT=0.0;</div>
<div class="line">  <span class="keywordflow">for</span>(DT::ConstRange::ConstIterator it = dt.constRange().begin(), itend = dt.constRange().end();</div>
<div class="line">      it != itend ; ++it)</div>
<div class="line">    <span class="keywordflow">if</span> ((*it)&gt;maxDT) maxDT = (*it);</div>
<div class="line"></div>
<div class="line">  <span class="comment">//Colormap</span></div>
<div class="line">  HueShadeColorMap&lt;DT::Value,1&gt; hueMap(0.0,maxDT);</div>
<div class="line"></div>
<div class="line">  <span class="comment">//Drawing</span></div>
<div class="line">  <span class="keywordflow">for</span>(DT::Domain::ConstIterator it = dt.domain().begin(),</div>
<div class="line">      itend = dt.domain().end(); it != itend; ++it)</div>
<div class="line">  {</div>
<div class="line">    DT::Value dist = dt( *it );   <span class="comment">//distance to closest site to (*it)</span></div>
<div class="line">    board &lt;&lt; CustomStyle( (*it).className(), <span class="keyword">new</span> CustomColors( hueMap(dist), hueMap(dist)))</div>
<div class="line">          &lt;&lt; (*it);</div>
<div class="line">  }</div>
<div class="line">  board.saveSVG(<span class="stringliteral">&quot;voronoimap-dt.svg&quot;</span>);</div>
</div><!-- fragment --> <div class="image">
<img src="voronoimap-dt.png" alt="voronoimap-dt.png"/>
<div class="caption">
Distance transformation for the l_2 metric.</div></div>
<h1><a class="anchor" id="RDTSec"></a>
Digital Power Map and Reverse Distance Transformation</h1>
<p>Similarly to Voronoi diagram and digital Voronoi maps, digital Power maps are defined as the intersection between the integer grid and a power diagram. Given a set of weighed points, power diagram can be seen as Voronoi diagram where the metric is modified with additive weights. For example, considering the \( l_2\) metric, the power distance between a point \(p\) and a weighted point \((q,w)\) is defined by </p><p class="formulaDsp">
\[ pow(p,q) = \| p - q\|_2^2 - w \]
</p>
<p>Hence, similarly to Voronoi diagram, the power diagram is a decomposition of the space ino cells from weighed sites where each cell (maybe empty) is associated with a site and each point in the cell has got minimal power distance to the cell site (compared to its power distance to all other sites) <a class="el" href="citelist.html#CITEREF_Aurenhammer1987">[5]</a> .</p>
<p>Separable algorithms similar to VoronoiMap/DistanceTransformation can be designed to compute respectively <a class="el" href="classDGtal_1_1PowerMap.html" title="Aim: Implementation of the linear in time Power map construction. ">PowerMap</a> and <a class="el" href="classDGtal_1_1ReverseDistanceTransformation.html" title="Aim: Implementation of the linear in time reverse distance transformation for separable metrics...">ReverseDistanceTransformation</a>. The only difference is that the input of <a class="el" href="classDGtal_1_1PowerMap.html" title="Aim: Implementation of the linear in time Power map construction. ">PowerMap</a> is a weighted set of points instead of a point predicate.</p>
<dl class="section note"><dt>Note</dt><dd>for \(l_p\) metrics, the power distance is defined by \( pow(p,q) = \| p - q\|_p^p - w \). Hence, both the distance and the weight value type capacity must be able to represent d-sums of power p numbers (if d is the dimension of the space).</dd></dl>
<p>Hence such class is parametrized by the following types:</p><ul>
<li>a type representing the mapping between points and weights (WeightImage, model of CImage);</li>
<li>a type representing the underlying power metric (model of CSeparablePowerMetric, see below)</li>
<li>and an optional image container to store the resulting Power map (by default, the type is <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>).</li>
</ul>
<p>The <a class="el" href="classDGtal_1_1PowerMap.html" title="Aim: Implementation of the linear in time Power map construction. ">PowerMap</a> constructor is parametrized by</p><ul>
<li>an instance of Domain (the Domain type associated with the image container);</li>
<li>an instance of <a class="el" href="classDGtal_1_1PowerMap.html#a96d646a0a331d6d6c3c2075bf4fa1a44" title="Copy of the distance image types. ">PowerMap::WeightImage</a>;</li>
<li>and an instance of the power separable metric.</li>
</ul>
<p>Similarly to <a class="el" href="classDGtal_1_1DistanceTransformation.html" title="Aim: Implementation of the linear in time distance transformation for separable metrics. ">DistanceTransformation</a>, <a class="el" href="classDGtal_1_1ReverseDistanceTransformation.html" title="Aim: Implementation of the linear in time reverse distance transformation for separable metrics...">ReverseDistanceTransformation</a> remaps the <a class="el" href="classDGtal_1_1PowerMap.html" title="Aim: Implementation of the linear in time Power map construction. ">PowerMap</a> vectors to map the power metric to the closest weighted site.</p>
<p>As a consequence, for the Euclidean \( l_2 \) metric, if we consider a set of balls \( B_i(p_i,r_i) \) and if we create an WeightImage whose domain contains points \(\{ p_i \}\) and with values \( r_i^2\), negative (strictly) values of the <a class="el" href="classDGtal_1_1ReverseDistanceTransformation.html" title="Aim: Implementation of the linear in time reverse distance transformation for separable metrics...">ReverseDistanceTransformation</a> will correspond to digital points belonging to the union \( \bigcup \{B_i\}\) (see <a class="el" href="citelist.html#CITEREF_dcoeurjo_pami_RDMA">[15]</a>).</p>
<p><a class="el" href="classDGtal_1_1ReverseDistanceTransformation.html" title="Aim: Implementation of the linear in time reverse distance transformation for separable metrics...">ReverseDistanceTransformation</a> can thus be used to reconstructed a binary shape from a given Medial Axis or any set of balls. Another consequence is that given a binary shape, the pipeline </p><p class="formulaDsp">
\[ Shape \rightarrow DT \rightarrow ReverseDT \rightarrow \text{ strictly negative values }\]
</p>
<p> for the same metric/power metric, returns the input binary shape.</p>
<dl class="section note"><dt>Note</dt><dd>Power separable metrics are formalized in CPowerMetric and CSeparablePowerMetric concepts whose main concept is ExactLpPowerSeparableMetric, see <a class="el" href="moduleMetrics.html">Metric Spaces, Digital Metric Spaces and Related Concepts</a> </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 24 2016 14:01:37 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
