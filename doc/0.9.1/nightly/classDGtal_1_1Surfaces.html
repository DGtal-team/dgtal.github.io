<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>DGtal: DGtal::Surfaces&lt; TKSpace &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.9.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceDGtal.html">DGtal</a></li><li class="navelem"><a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">DGtal::Surfaces&lt; TKSpace &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Surfaces_8h_source.html">topology/helpers/Surfaces.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae254510c81f339dbb5bd4b33ed9f5f3e"><td class="memItemLeft" align="right" valign="top">typedef TKSpace&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a></td></tr>
<tr class="separator:ae254510c81f339dbb5bd4b33ed9f5f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91dd49aa1b8c90ceaf595448ce30ebb3"><td class="memItemLeft" align="right" valign="top">typedef KSpace::Integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a91dd49aa1b8c90ceaf595448ce30ebb3">Integer</a></td></tr>
<tr class="separator:a91dd49aa1b8c90ceaf595448ce30ebb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58accd9ff51d3cb85f7f4d7e7ed80c5"><td class="memItemLeft" align="right" valign="top">typedef KSpace::Point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a></td></tr>
<tr class="separator:ab58accd9ff51d3cb85f7f4d7e7ed80c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e02ccfe37b82b2d278d066161f4d1d2"><td class="memItemLeft" align="right" valign="top">typedef KSpace::Cell&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a></td></tr>
<tr class="separator:a6e02ccfe37b82b2d278d066161f4d1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eaebd043923d70cecb81470431be557"><td class="memItemLeft" align="right" valign="top">typedef KSpace::SCell&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a></td></tr>
<tr class="separator:a5eaebd043923d70cecb81470431be557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3655c1310aed70fc5fcedaef454d21"><td class="memItemLeft" align="right" valign="top">typedef KSpace::DirIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#aea3655c1310aed70fc5fcedaef454d21">DirIterator</a></td></tr>
<tr class="separator:aea3655c1310aed70fc5fcedaef454d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4a40685150ee27be46185eed33b49582"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a4a40685150ee27be46185eed33b49582">~Surfaces</a> ()</td></tr>
<tr class="separator:a4a40685150ee27be46185eed33b49582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80771c760a6b1ae094343a2e8011dad3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a80771c760a6b1ae094343a2e8011dad3">selfDisplay</a> (std::ostream &amp;out) const </td></tr>
<tr class="separator:a80771c760a6b1ae094343a2e8011dad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d3b1bb0ae25b25a2f02b32096c8ea4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a93d3b1bb0ae25b25a2f02b32096c8ea4">isValid</a> () const </td></tr>
<tr class="separator:a93d3b1bb0ae25b25a2f02b32096c8ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a48e3a0e7c4728f6a6f23ec6f468a41b8"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:a48e3a0e7c4728f6a6f23ec6f468a41b8"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a48e3a0e7c4728f6a6f23ec6f468a41b8">findABel</a> (const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const PointPredicate &amp;pp, unsigned int nbtries=1000)  throw (DGtal::InputException)</td></tr>
<tr class="separator:a48e3a0e7c4728f6a6f23ec6f468a41b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6487aa0c9c948674ca917be7b79a8166"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:a6487aa0c9c948674ca917be7b79a8166"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a6487aa0c9c948674ca917be7b79a8166">findABel</a> (const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const PointPredicate &amp;pp, <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> x1, <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> x2)</td></tr>
<tr class="separator:a6487aa0c9c948674ca917be7b79a8166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274dbb659f269382154035ae61d7e7b3"><td class="memTemplParams" colspan="2">template&lt;typename SCellSet , typename PointPredicate &gt; </td></tr>
<tr class="memitem:a274dbb659f269382154035ae61d7e7b3"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a274dbb659f269382154035ae61d7e7b3">trackBoundary</a> (SCellSet &amp;surface, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="separator:a274dbb659f269382154035ae61d7e7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3cf3c5f54d0b556630f9dde154968d"><td class="memTemplParams" colspan="2">template&lt;typename SCellSet , typename PointPredicate &gt; </td></tr>
<tr class="memitem:a1d3cf3c5f54d0b556630f9dde154968d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a1d3cf3c5f54d0b556630f9dde154968d">trackClosedBoundary</a> (SCellSet &amp;surface, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="separator:a1d3cf3c5f54d0b556630f9dde154968d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7859e9bffcd18681960cdb5bb94a6f"><td class="memTemplParams" colspan="2">template&lt;typename SCellSet , typename SurfelPredicate &gt; </td></tr>
<tr class="memitem:a4a7859e9bffcd18681960cdb5bb94a6f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a4a7859e9bffcd18681960cdb5bb94a6f">trackSurface</a> (SCellSet &amp;surface, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const SurfelPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="separator:a4a7859e9bffcd18681960cdb5bb94a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd46bf2fb99f542112308e03bd45124c"><td class="memTemplParams" colspan="2">template&lt;typename SCellSet , typename SurfelPredicate &gt; </td></tr>
<tr class="memitem:abd46bf2fb99f542112308e03bd45124c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#abd46bf2fb99f542112308e03bd45124c">trackClosedSurface</a> (SCellSet &amp;surface, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const SurfelPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="separator:abd46bf2fb99f542112308e03bd45124c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02a8a022a501740afd3e1f78382c162"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:aa02a8a022a501740afd3e1f78382c162"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#aa02a8a022a501740afd3e1f78382c162">track2DBoundary</a> (std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;aSCellContour2D, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="separator:aa02a8a022a501740afd3e1f78382c162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc745dd716a5328b0f278e3b3cd0d6ee"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:acc745dd716a5328b0f278e3b3cd0d6ee"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#acc745dd716a5328b0f278e3b3cd0d6ee">track2DSliceBoundary</a> (std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;aSCellContour2D, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> &amp;trackDir, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="separator:acc745dd716a5328b0f278e3b3cd0d6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8cf97c743219fb3f3b8ff8c12c456e"><td class="memTemplParams" colspan="2">template&lt;typename SurfelPredicate &gt; </td></tr>
<tr class="memitem:adf8cf97c743219fb3f3b8ff8c12c456e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#adf8cf97c743219fb3f3b8ff8c12c456e">track2DSurface</a> (std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;aSCellContour, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const SurfelPredicate &amp;sp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="separator:adf8cf97c743219fb3f3b8ff8c12c456e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad182fbc789703070d6e22b95cfb093b"><td class="memTemplParams" colspan="2">template&lt;typename SurfelPredicate &gt; </td></tr>
<tr class="memitem:aad182fbc789703070d6e22b95cfb093b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#aad182fbc789703070d6e22b95cfb093b">track2DSliceSurface</a> (std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;aSCellContour, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> &amp;trackDir, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const SurfelPredicate &amp;sp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="separator:aad182fbc789703070d6e22b95cfb093b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02299fbe8123cd8dfdcf7d42371bc50c"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:a02299fbe8123cd8dfdcf7d42371bc50c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a02299fbe8123cd8dfdcf7d42371bc50c">track2DBoundaryPoints</a> (std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &gt; &amp;aVectorOfPoints, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="separator:a02299fbe8123cd8dfdcf7d42371bc50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a497078cf752746aa035abecaa8b6d6"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:a6a497078cf752746aa035abecaa8b6d6"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a6a497078cf752746aa035abecaa8b6d6">extractAllPointContours4C</a> (std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &gt; &gt; &amp;aVectPointContour2D, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; 2 &gt; &amp;aSAdj)</td></tr>
<tr class="separator:a6a497078cf752746aa035abecaa8b6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2537ecb6e1f330239490f67c85ae73fd"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:a2537ecb6e1f330239490f67c85ae73fd"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a2537ecb6e1f330239490f67c85ae73fd">extractAll2DSCellContours</a> (std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &gt; &amp;aVectSCellContour2D, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;aSurfelAdj, const PointPredicate &amp;pp)</td></tr>
<tr class="separator:a2537ecb6e1f330239490f67c85ae73fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b214170d160153376c4ecf3497de3f"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:a19b214170d160153376c4ecf3497de3f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a19b214170d160153376c4ecf3497de3f">extractAllConnectedSCell</a> (std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &gt; &amp;aVectConnectedSCell, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;aSurfelAdj, const PointPredicate &amp;pp, bool forceOrientCellExterior=false)</td></tr>
<tr class="separator:a19b214170d160153376c4ecf3497de3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eda7d188df09dfdee18747064a8044d"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:a9eda7d188df09dfdee18747064a8044d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a9eda7d188df09dfdee18747064a8044d">orientSCellExterior</a> (std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;aVectOfSCell, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const PointPredicate &amp;pp)</td></tr>
<tr class="separator:a9eda7d188df09dfdee18747064a8044d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4c49a163650eaaff8759504d7891f7"><td class="memTemplParams" colspan="2">template&lt;typename CellSet , typename PointPredicate &gt; </td></tr>
<tr class="memitem:a7c4c49a163650eaaff8759504d7891f7"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a7c4c49a163650eaaff8759504d7891f7">uMakeBoundary</a> (CellSet &amp;aBoundary, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aLowerBound, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aUpperBound)</td></tr>
<tr class="separator:a7c4c49a163650eaaff8759504d7891f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61619b3dbd948aea387202369bddd6f"><td class="memTemplParams" colspan="2">template&lt;typename SCellSet , typename PointPredicate &gt; </td></tr>
<tr class="memitem:af61619b3dbd948aea387202369bddd6f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#af61619b3dbd948aea387202369bddd6f">sMakeBoundary</a> (SCellSet &amp;aBoundary, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aLowerBound, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aUpperBound)</td></tr>
<tr class="separator:af61619b3dbd948aea387202369bddd6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc15d59768c239dd1a4ac318b4584f12"><td class="memTemplParams" colspan="2">template&lt;typename OutputIterator , typename PointPredicate &gt; </td></tr>
<tr class="memitem:abc15d59768c239dd1a4ac318b4584f12"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#abc15d59768c239dd1a4ac318b4584f12">uWriteBoundary</a> (OutputIterator &amp;out_it, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aLowerBound, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aUpperBound)</td></tr>
<tr class="separator:abc15d59768c239dd1a4ac318b4584f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ea5c95390b2a9d3eec8fcdefef07fc"><td class="memTemplParams" colspan="2">template&lt;typename OutputIterator , typename PointPredicate &gt; </td></tr>
<tr class="memitem:aa4ea5c95390b2a9d3eec8fcdefef07fc"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#aa4ea5c95390b2a9d3eec8fcdefef07fc">sWriteBoundary</a> (OutputIterator &amp;out_it, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aLowerBound, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aUpperBound)</td></tr>
<tr class="separator:aa4ea5c95390b2a9d3eec8fcdefef07fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93005c492ca555daa7252278fe58116b"><td class="memTemplParams" colspan="2">template&lt;typename TSurfelPredicate , typename TImageContainer &gt; </td></tr>
<tr class="memitem:a93005c492ca555daa7252278fe58116b"><td class="memTemplItemLeft" align="right" valign="top">unsigned static int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a93005c492ca555daa7252278fe58116b">uFillInterior</a> (const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const TSurfelPredicate &amp;aSurfPred, TImageContainer &amp;anImage, const typename TImageContainer::Value &amp;aValue, bool empty_is_inside=false, bool incrementMode=true)</td></tr>
<tr class="separator:a93005c492ca555daa7252278fe58116b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeec413320a80c0e5ce74c1b1100cd4e"><td class="memTemplParams" colspan="2">template&lt;typename SurfelPredicate , typename TImageContainer &gt; </td></tr>
<tr class="memitem:aeeec413320a80c0e5ce74c1b1100cd4e"><td class="memTemplItemLeft" align="right" valign="top">unsigned static int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#aeeec413320a80c0e5ce74c1b1100cd4e">uFillExterior</a> (const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const SurfelPredicate &amp;aSurfPred, TImageContainer &amp;anImage, const typename TImageContainer::Value &amp;aValue, bool empty_is_outside=true, bool incrementMode=true)</td></tr>
<tr class="separator:aeeec413320a80c0e5ce74c1b1100cd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af256c2b3c2af32a9b20e011748382e1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#af256c2b3c2af32a9b20e011748382e1b">Surfaces</a> ()</td></tr>
<tr class="separator:af256c2b3c2af32a9b20e011748382e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a8cab7368470487cee8c10921739f5f23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a8cab7368470487cee8c10921739f5f23">Surfaces</a> (const <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> &amp;other)</td></tr>
<tr class="separator:a8cab7368470487cee8c10921739f5f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d72cf1ccdf33632636c890e5816d1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a31d72cf1ccdf33632636c890e5816d1d">operator=</a> (const <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> &amp;other)</td></tr>
<tr class="separator:a31d72cf1ccdf33632636c890e5816d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TKSpace&gt;<br />
class DGtal::Surfaces&lt; TKSpace &gt;</h3>

<p>Aim: A utility class for constructing surfaces (i.e. set of (n-1)-cells). </p>
<p>Description of template class '<a class="el" href="classDGtal_1_1Surfaces.html" title="Aim: A utility class for constructing surfaces (i.e. set of (n-1)-cells). ">Surfaces</a>' </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the type of cellular grid space (e.g. a <a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex...">KhalimskySpaceND</a>).</td></tr>
  </table>
  </dd>
</dl>
<p>Note that many methods requires a surfel adjacency so as to know how connected surfels are linked (first by the interior or first by the exterior). Secondly, many methods are parameterized by a PointPredicate which describes the shape as a characteristic function. This is to be more generic than a simple DigitalSet. With this approach, shapes can be defined implicitly.</p>
<p>Essentially a backport from <a href="https://gforge.liris.cnrs.fr/projects/imagene">ImaGene</a>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="examples_2tutorial-examples_2polyhedralizer_8cpp-example.html#_a12">examples/tutorial-examples/polyhedralizer.cpp</a>, <a class="el" href="geometry_2curves_2exampleGridCurve2d_8cpp-example.html#_a9">geometry/curves/exampleGridCurve2d.cpp</a>, <a class="el" href="geometry_2curves_2exampleGridCurve3d-2_8cpp-example.html#_a11">geometry/curves/exampleGridCurve3d-2.cpp</a>, <a class="el" href="geometry_2surfaces_2dvcm-3d_8cpp-example.html#_a18">geometry/surfaces/dvcm-3d.cpp</a>, <a class="el" href="geometry_2volumes_2distance_2exampleFMM3D_8cpp-example.html#_a15">geometry/volumes/distance/exampleFMM3D.cpp</a>, <a class="el" href="graph_2volDistanceTraversal_8cpp-example.html#_a12">graph/volDistanceTraversal.cpp</a>, <a class="el" href="topology_23dKSSurfaceExtraction_8cpp-example.html#_a6">topology/3dKSSurfaceExtraction.cpp</a>, <a class="el" href="topology_2ctopo-2-3d_8cpp-example.html#_a12">topology/ctopo-2-3d.cpp</a>, <a class="el" href="topology_2ctopo-2_8cpp-example.html#_a10">topology/ctopo-2.cpp</a>, <a class="el" href="topology_2ctopo-fillContours_8cpp-example.html#_a15">topology/ctopo-fillContours.cpp</a>, <a class="el" href="topology_2trackImplicitPolynomialSurfaceToOFF_8cpp-example.html#_a18">topology/trackImplicitPolynomialSurfaceToOFF.cpp</a>, <a class="el" href="topology_2volScanBoundary_8cpp-example.html#_a8">topology/volScanBoundary.cpp</a>, <a class="el" href="topology_2volToOFF_8cpp-example.html#_a11">topology/volToOFF.cpp</a>, and <a class="el" href="topology_2volTrackBoundary_8cpp-example.html#_a9">topology/volTrackBoundary.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00078">78</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a6e02ccfe37b82b2d278d066161f4d1d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KSpace::Cell <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00085">85</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<a class="anchor" id="aea3655c1310aed70fc5fcedaef454d21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KSpace::DirIterator <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#aea3655c1310aed70fc5fcedaef454d21">DirIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00087">87</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<a class="anchor" id="a91dd49aa1b8c90ceaf595448ce30ebb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KSpace::Integer <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a91dd49aa1b8c90ceaf595448ce30ebb3">Integer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00083">83</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae254510c81f339dbb5bd4b33ed9f5f3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TKSpace <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00082">82</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab58accd9ff51d3cb85f7f4d7e7ed80c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KSpace::Point <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00084">84</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5eaebd043923d70cecb81470431be557"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KSpace::SCell <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00086">86</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4a40685150ee27be46185eed33b49582"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::~<a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<a class="anchor" id="af256c2b3c2af32a9b20e011748382e1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. Forbidden by default (protected to avoid g++ warnings). </p>

</div>
</div>
<a class="anchor" id="a8cab7368470487cee8c10921739f5f23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a>&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the object to clone. Forbidden by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2537ecb6e1f330239490f67c85ae73fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::extractAll2DSCellContours </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>aVectSCellContour2D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSurfelAdj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract all contours as a vector containing the set of contours composed of SCell. Each contour is represented by a vector of signed surfels whose elements represents a boundary component of a digital shape defined by the predicate [pp]. The algorithms tracks surfels along the boundary of the shape.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aVectSCellContour2D</td><td>(modified) a vector of contour represented by a vector of cells (which are all surfels), containing the ordered list of the boundary component of [spelset].</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space.</td></tr>
    <tr><td class="paramname">aSurfelAdj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a>, for instance a SetPredicate for a digital set representing a shape. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19b214170d160153376c4ecf3497de3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::extractAllConnectedSCell </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>aVectConnectedSCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSurfelAdj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceOrientCellExterior</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract all surfel elements associated to each connected components of the given DigitalSet. The connected surfel set are given as result in a vector containing all components. The orientation of the resulting SCell indicates the exterior orientation according the positive axis.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aVectConnectedSCell</td><td>(modified) a vector containing for each connected components a vector of the sequence of connected SCells.</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space.</td></tr>
    <tr><td class="paramname">aSurfelAdj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a>, for instance a SetPredicate for a digital set representing a shape.</td></tr>
    <tr><td class="paramname">forceOrientCellExterior</td><td>if 'true', used to change the default cell orientation in order to get the direction of shape exterior (default =false). This is used only for displaying cells with <a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a>. This mechanism should evolve shortly. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a497078cf752746aa035abecaa8b6d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::extractAllPointContours4C </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>aVectPointContour2D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSAdj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that extracts all the boundaries of a 2D shape (specified by a predicate on point) in a 2D KSpace. The boundaries are returned as a vector of vector of points.</p>
<p>Extract all 4-connected contours as a vector containing the sequence of contour Points. Each contour is represented by a vector of points defined by the sequence of pointels extracted from the boundary surfels. Calls extractAll2DSCellContours.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aVectPointContour2D</td><td>(modified) a vector of contour represented by a vector of cells (which are all surfels), containing the ordered list of the boundary component of [pp].</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a>, for instance a SetPredicate for a digital set representing a shape.</td></tr>
    <tr><td class="paramname">aSAdj</td><td>the surfel adjacency chosen for the tracking. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial-examples_2freemanChainFromImage_8cpp-example.html#a10">tutorial-examples/freemanChainFromImage.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a48e3a0e7c4728f6a6f23ec6f468a41b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::findABel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nbtries</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="classDGtal_1_1InputException.html">DGtal::InputException</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find a bel in some digital set by random tries then dichotomy.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">K</td><td>any cellular grid space.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a>, for instance a SetPredicate for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">nbtries</td><td>the maximum number of random tries (default 1000).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a signed surfel separating a digital point in [dset] from a face adjacent digital point outside [dset] or throws an <a class="el" href="classDGtal_1_1InputException.html">InputException</a> if none was found after [nbtries] iterations. </dd></dl>

</div>
</div>
<a class="anchor" id="a6487aa0c9c948674ca917be7b79a8166"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::findABel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a>&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a>&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find a bel in some digital set given two hints (one point inside, one point outside).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>we must have pp( x1 ) != pp( x2 ), i.e. one point should satisfy the predicate while the other not.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">K</td><td>any cellular grid space.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a>, for instance a SetPredicate for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">x1</td><td>a point within the bounds of K and such that pp( x1 ) != pp( x2 ).</td></tr>
    <tr><td class="paramname">x2</td><td>a point within the bounds of K and such that pp( x1 ) != pp( x2 ).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a signed surfel separating a digital point in [dset] from a face adjacent digital point outside [dset]. </dd></dl>

</div>
</div>
<a class="anchor" id="a93d3b1bb0ae25b25a2f02b32096c8ea4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks the validity/consistency of the object. </p><dl class="section return"><dt>Returns</dt><dd>'true' if the object is valid, 'false' otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a31d72cf1ccdf33632636c890e5816d1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a>&amp; <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a>&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the object to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference on 'this'. Forbidden by default. </dd></dl>

</div>
</div>
<a class="anchor" id="a9eda7d188df09dfdee18747064a8044d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::orientSCellExterior </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aVectOfSCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Orient the SCell positively in the direction of the exterior of the DigitalSet aShape. It simply check if the direct incident Cell in the first upper dimension (obtain with sDirectIncident) belongs to the DigitalSet or not.</p>
<p>This method is used to change the default cell orientation in order to get the direction of shape exterior (default =false). This is used only for displaying cells with <a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a>. This mechanism should evolve shortly.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aVectOfSCell</td><td>(modified) a vector containing the SCell to be oriented positively in the direction of the exterior.</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a>, for instance a SetPredicate for a digital set representing a shape. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80771c760a6b1ae094343a2e8011dad3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::selfDisplay </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes/Displays the object on an output stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af61619b3dbd948aea387202369bddd6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename SCellSet , typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::sMakeBoundary </td>
          <td>(</td>
          <td class="paramtype">SCellSet &amp;&#160;</td>
          <td class="paramname"><em>aBoundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aLowerBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aUpperBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a set of signed surfels whose elements represents all the boundary components of a digital shape described by the predicate [pp].</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SCellSet</td><td>a model of a set of SCell (e.g., std::set&lt;SCell&gt;). </td></tr>
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aBoundary</td><td>(modified) a set of cells (which are all surfels), the boundary component of [aSpelSet].</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space. </td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a>, for instance a SetPredicate for a digital set representing a shape.</td></tr>
    <tr><td class="paramname">aLowerBound</td><td>and </td></tr>
    <tr><td class="paramname">aUpperBound</td><td>points giving the bounds of the extracted boundary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4ea5c95390b2a9d3eec8fcdefef07fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename OutputIterator , typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::sWriteBoundary </td>
          <td>(</td>
          <td class="paramtype">OutputIterator &amp;&#160;</td>
          <td class="paramname"><em>out_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aLowerBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aUpperBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes on the output iterator <em>out_it</em> the signed surfels whose elements represents all the boundary elements of a digital shape described by the predicate [pp].</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputIterator</td><td>any output iterator (like std::back_insert_iterator&lt; std::vector&lt;SCell&gt; &gt;).</td></tr>
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_it</td><td>any output iterator for writing the signed cells.</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a>, for instance a SetPredicate for a digital set representing a shape.</td></tr>
    <tr><td class="paramname">aLowerBound</td><td>and </td></tr>
    <tr><td class="paramname">aUpperBound</td><td>points giving the bounds of the extracted boundary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa02a8a022a501740afd3e1f78382c162"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::track2DBoundary </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSCellContour2D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that extracts the boundary of a 2D shape (specified by a predicate on point) in a 2D KSpace. The boundary is returned as a vector of surfels. The surfels are guaranteed to be in the direct orientation ordering.</p>
<p>Creates a vector of signed surfels whose elements represents a 2D boundary component of a digital shape described by a PointPredicate. The algorithm tracks surfels along the boundary of the shape by starting from the given [start_surfel]. It only tracks the boundary of a 2D shape.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aSCellContour2D</td><td>(modified) a vector of cells (which are all surfels), containing the ordered list of the boundary component of [spelset] which touches [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space of dimension 2.</td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a>, for instance a SetPredicate for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be between an element of [shape] and an element not in [shape]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02299fbe8123cd8dfdcf7d42371bc50c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::track2DBoundaryPoints </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aVectorOfPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that extracts the boundary of a 2D shape (specified by a predicate on point) in a 2D KSpace. The boundary is returned as a vector of points.</p>
<p>This method uses random tries to find a first linel separating an interior pixel from an exterior one. It then follows direct orientations to extract the 4-connected set of points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aVectorOfPoints</td><td>(returns) the sequence of points of the boundary component of the digitized shape containing [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space of dimension 2.</td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a>, for instance a SetPredicate for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be between an element of [shape] and an element not in [shape]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc745dd716a5328b0f278e3b3cd0d6ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::track2DSliceBoundary </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSCellContour2D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> &amp;&#160;</td>
          <td class="paramname"><em>trackDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that extracts a 2D slice of the boundary of a nD shape (specified by a predicate on point) in a nD KSpace. The boundary is returned as a vector of surfels. The surfels are guaranteed to be in the direct orientation ordering.</p>
<p>Creates a vector of signed surfels whose elements represents a 2D boundary component of a digital shape described by a PointPredicate. The algorithms tracks surfels along the boundary of the shape by starting from the given [start_surfel], along the direction specified by [trackDir]. More precisely, it is the boundary of the slice of the shape along directions [trackDir] and the orthogonal direction of [start_surfel].</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aSCellContour2D</td><td>(modified) a vector of cells (which are all surfels), containing the ordered list of the boundary component of [spelset] which touches [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space (dimension is arbitrary).</td></tr>
    <tr><td class="paramname">trackDir</td><td>the initial track direction at [start_surfel], should be different from the orthogonal direction of [start_surfel].</td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a>, for instance a SetPredicate for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be between an element of [shape] and an element not in [shape]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad182fbc789703070d6e22b95cfb093b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename SurfelPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::track2DSliceSurface </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSCellContour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> &amp;&#160;</td>
          <td class="paramname"><em>trackDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SurfelPredicate &amp;&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that extracts a 2D slice of a n-1 digital surface (specified by a predicate on surfel) in a nD KSpace. The boundary is returned as a vector of surfels. The surfels (of dimension n-1) are guaranteed to be in the direct orientation ordering.</p>
<p>Creates a vector of signed surfels whose elements represents a component of a slice of digital surface described by a SurfelPredicate. The algorithm tracks surfels along the surface by starting from the given <em>start_surfel</em> and by moving along the directions <em>trackDir</em> and the orthogonal direction to <em>start_surfel</em>. All surfels are returned so as to follow the direct orientation. If the surface is open, the first surfel is at one extremity (the indirect extremity) while the last surfel is at the other extremity. Otherwise, the first surfel is <em>start_surfel</em>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SurfelPredicate</td><td>a model of CSurfelPredicate, meaning a functor taking a Surfel (SCell) and returning 'true' whenever the surfel belongs to the digital surface. Models include FrontierPredicate and BoundaryPredicate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aSCellContour</td><td>(modified) a vector of cells (which are all surfels), containing the ordered list of surfels that forms the connected component of the digital surface slice containing surfel <em>start_surfel</em> and the direction <em>trackDir</em>.</td></tr>
    <tr><td class="paramname">K</td><td>any space (dimension is arbitrary).</td></tr>
    <tr><td class="paramname">trackDir</td><td>the initial track direction at [start_surfel], should be different from the orthogonal direction of [start_surfel].</td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">sp</td><td>an instance of a model of CSurfelPredicate, for instance a FrontierPredicate or a BoundaryPredicate.</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel such that sp(start_surfel) is true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf8cf97c743219fb3f3b8ff8c12c456e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename SurfelPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::track2DSurface </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSCellContour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SurfelPredicate &amp;&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that extracts a 1d-contour (specified by a predicate on surfel) in a 2D KSpace. The boundary is returned as a vector of surfels. The surfels are guaranteed to be in the direct orientation ordering.</p>
<p>Creates a vector of signed surfels whose elements represents a component of a digital surface described by a SurfelPredicate. The algorithm tracks surfels along the surface by starting from the given <em>start_surfel</em>. All surfels are returned so as to follow the direct orientation. If the surface is open, the first surfel is at one extremity (the indirect extremity) while the last surfel is at the other extremity. Otherwise, the first surfel is <em>start_surfel</em>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SurfelPredicate</td><td>a model of CSurfelPredicate, meaning a functor taking a Surfel (SCell) and returning 'true' whenever the surfel belongs to the digital surface. Models include FrontierPredicate and BoundaryPredicate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aSCellContour</td><td>(modified) a vector of cells (which are all surfels), containing the ordered list of surfels that forms the connected component containing surfel [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space of dimension 2.</td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">sp</td><td>an instance of a model of CSurfelPredicate, for instance a FrontierPredicate or a BoundaryPredicate.</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel such that sp(start_surfel) is true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a274dbb659f269382154035ae61d7e7b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename SCellSet , typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::trackBoundary </td>
          <td>(</td>
          <td class="paramtype">SCellSet &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that extracts the boundary of a nD digital shape (specified by a predicate on point), closed or open, in a nD KSpace. The boundary is returned as a set of surfels.</p>
<p>Creates a set of signed surfels whose elements represents a boundary component of a digital shape described by a PointPredicate. The algorithms tracks surfels along the boundary of the shape.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SCellSet</td><td>a model of a set of SCell (e.g., std::set&lt;SCell&gt;).</td></tr>
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>(modified) a set of cells (which are all surfels), the boundary component of [spelset] which touches [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space. </td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a>, for instance a SetPredicate for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be between an element of [shape] and an element not in [shape]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d3cf3c5f54d0b556630f9dde154968d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename SCellSet , typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::trackClosedBoundary </td>
          <td>(</td>
          <td class="paramtype">SCellSet &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that extracts the <b>closed</b> boundary of a nD digital shape (specified by a predicate on point), in a nD KSpace. The boundary is returned as a set of surfels.</p>
<p>Creates a set of signed surfels whose elements represents a boundary component of a digital shape described by a PointPredicate. The algorithms tracks surfels along the boundary of the shape. It follows only direct orientations, so that it is faster than trackBoundary but requires the object to be fully inside the space. Follows the idea of Artzy, Frieder and Herman algorithm [Artzy:1981-cgip], but in nD.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SCellSet</td><td>a model of a set of SCell (e.g., std::set&lt;SCell&gt;).</td></tr>
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>(modified) a set of cells (which are all surfels), the boundary component of [spelset] which touches [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space. </td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a>, for instance a SetPredicate for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be between an element of [shape] and an element not in [shape]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd46bf2fb99f542112308e03bd45124c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename SCellSet , typename SurfelPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::trackClosedSurface </td>
          <td>(</td>
          <td class="paramtype">SCellSet &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SurfelPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that extracts a <b>closed</b> n-1 digital surface (specified by a predicate on surfel) in a nD KSpace. The surface is returned as a set of surfels.</p>
<p>Creates a set of signed surfels whose elements represents a boundary component of a digital surface described by a SurfelPredicate. The algorithms tracks surfels along the surface. This is an optimized version of trackSurface, which is valid only when the tracked surface is closed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SCellSet</td><td>a model of a set of SCell (e.g., std::set&lt;SCell&gt;).</td></tr>
    <tr><td class="paramname">SurfelPredicate</td><td>a model of CSurfelPredicate describing whether a surfel belongs or not to the surface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>(modified) a set of cells (which are all surfels), the boundary component of [spelset] which touches [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space. </td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of CSurfelPredicate.</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be part of the surface, ie. 'sp(start_surfel)==true'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a7859e9bffcd18681960cdb5bb94a6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename SCellSet , typename SurfelPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::trackSurface </td>
          <td>(</td>
          <td class="paramtype">SCellSet &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SurfelPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function that extracts a n-1 digital surface (specified by a predicate on surfel), closed or open, in a nD KSpace. The surface is returned as a set of surfels.</p>
<p>Creates a set of signed surfels whose elements represents a boundary component of a digital surface described by a SurfelPredicate. The algorithms tracks surfels along the surface.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SCellSet</td><td>a model of a set of SCell (e.g., std::set&lt;SCell&gt;).</td></tr>
    <tr><td class="paramname">SurfelPredicate</td><td>a model of CSurfelPredicate describing whether a surfel belongs or not to the surface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>(modified) a set of cells (which are all surfels), the boundary component of [spelset] which touches [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space. </td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of CSurfelPredicate.</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be part of the surface, ie. 'sp(start_surfel)==true'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeeec413320a80c0e5ce74c1b1100cd4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename SurfelPredicate , typename TImageContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned static int <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::uFillExterior </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SurfelPredicate &amp;&#160;</td>
          <td class="paramname"><em>aSurfPred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TImageContainer &amp;&#160;</td>
          <td class="paramname"><em>anImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TImageContainer::Value &amp;&#160;</td>
          <td class="paramname"><em>aValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>empty_is_outside</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>incrementMode</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a boundary surface [aSurfPred] in [aKSpace] (given as SurfelPredicate), fills its exterior in a given image [anImage] by a specific value [aValue] (considered as increment if [incrementMode] is set to true). The technique is to fill line by line and tests the intersection with the surface. Note that the set of the surfel of the boundary has to be a closed surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aKSpace</td><td>the digital space. </td></tr>
    <tr><td class="paramname">aSurfPred</td><td>the digital Jordan surface. </td></tr>
    <tr><td class="paramname">anImage</td><td>the image to be filled. </td></tr>
    <tr><td class="paramname">aValue</td><td>the value to fill the image. </td></tr>
    <tr><td class="paramname">empty_is_outside</td><td>when 'true', an empty line is considered exterior, otherwise interior. </td></tr>
    <tr><td class="paramname">incrementMode</td><td>if set to 'true' the image value is incremented by [aValue] instead to be set to [aValue] (default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of cells filled in the image. </dd></dl>

</div>
</div>
<a class="anchor" id="a93005c492ca555daa7252278fe58116b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename TSurfelPredicate , typename TImageContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned static int <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::uFillInterior </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TSurfelPredicate &amp;&#160;</td>
          <td class="paramname"><em>aSurfPred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TImageContainer &amp;&#160;</td>
          <td class="paramname"><em>anImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TImageContainer::Value &amp;&#160;</td>
          <td class="paramname"><em>aValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>empty_is_inside</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>incrementMode</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a boundary surface [aSurfPred] in [aKSpace] (given as SurfelPredicate), fills its interior in a given image [anImage] by a specific value [aValue] (considered as increment if [incrementMode] is set to true). The technique is to fill line by line and tests the intersection with the surface. Note that the set of the surfel of the boundary has to be a closed surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aKSpace</td><td>the digital space. </td></tr>
    <tr><td class="paramname">aSurfPred</td><td>the digital Jordan surface. </td></tr>
    <tr><td class="paramname">anImage</td><td>the image to be filled. </td></tr>
    <tr><td class="paramname">aValue</td><td>the value to fill the image. </td></tr>
    <tr><td class="paramname">empty_is_inside</td><td>when 'true', an empty line is considered interior, otherwise exterior (set by default to false). </td></tr>
    <tr><td class="paramname">incrementMode</td><td>if set to 'true' the image value is incremented by [aValue] instead to be set to [aValue] (default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of cells filled in the image. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c4c49a163650eaaff8759504d7891f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename CellSet , typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::uMakeBoundary </td>
          <td>(</td>
          <td class="paramtype">CellSet &amp;&#160;</td>
          <td class="paramname"><em>aBoundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aLowerBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aUpperBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a set of unsigned surfels whose elements represents all the boundary components of a digital shape described by the predicate [pp].</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CellSet</td><td>a model of a set of Cell (e.g., std::set&lt;Cell&gt;). </td></tr>
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aBoundary</td><td>(modified) a set of cells (which are all surfels), the boundary component of [aSpelSet].</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space. </td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a>, for instance a SetPredicate for a digital set representing a shape.</td></tr>
    <tr><td class="paramname">aLowerBound</td><td>and </td></tr>
    <tr><td class="paramname">aUpperBound</td><td>points giving the bounds of the extracted boundary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc15d59768c239dd1a4ac318b4584f12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
<div class="memtemplate">
template&lt;typename OutputIterator , typename PointPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::uWriteBoundary </td>
          <td>(</td>
          <td class="paramtype">OutputIterator &amp;&#160;</td>
          <td class="paramname"><em>out_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aLowerBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aUpperBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes on the output iterator <em>out_it</em> the unsigned surfels whose elements represents all the boundary elements of a digital shape described by the predicate [pp].</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputIterator</td><td>any output iterator (like std::back_insert_iterator&lt; std::vector&lt;Cell&gt; &gt;).</td></tr>
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_it</td><td>any output iterator for writing the cells.</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a>, for instance a SetPredicate for a digital set representing a shape.</td></tr>
    <tr><td class="paramname">aLowerBound</td><td>and </td></tr>
    <tr><td class="paramname">aUpperBound</td><td>points giving the bounds of the extracted boundary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Surfaces_8h_source.html">Surfaces.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 24 2016 14:01:45 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
