<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>DGtal: Parameter passing, cloning and referencing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.9.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Parameter passing, cloning and referencing </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#moduleCloneAndReference_sec1">Categories of parameter passing</a><ul><li class="level2"><a href="#moduleCloneAndReference_sec11">Parameter passing in C++</a></li>
<li class="level2"><a href="#moduleCloneAndReference_sec12">Alternative definition for parameter passing</a></li>
</ul>
</li>
<li class="level1"><a href="#moduleCloneAndReference_sec2">Parameter passing with Clone, Alias and ConstAlias</a><ul><li class="level2"><a href="#moduleCloneAndReference_sec21">Disambiguating parameter passing</a></li>
<li class="level2"><a href="#moduleCloneAndReference_sec22">User passing an argument to a Clone parameter</a></li>
<li class="level2"><a href="#moduleCloneAndReference_sec23">User passing an argument to an Alias parameter</a></li>
<li class="level2"><a href="#moduleCloneAndReference_sec24">User passing an argument to a ConstAlias parameter</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation:</dt><dd>Jacques-Olivier Lachaud</dd></dl>
<p>Part of the <a class="el" href="packageBase.html">Base package</a>.</p>
<p>This module gathers classes to make easier and more readable parameter passing by expliciting its type in the signature of functions and methods. The main classes are <a class="el" href="classDGtal_1_1Clone.html">Clone</a>, <a class="el" href="classDGtal_1_1Alias.html">Alias</a> and <a class="el" href="classDGtal_1_1ConstAlias.html">ConstAlias</a>. They can be used in conjunction with smart pointer classes <a class="el" href="classDGtal_1_1CountedPtr.html">CountedPtr</a>, <a class="el" href="classDGtal_1_1CowPtr.html">CowPtr</a>, <a class="el" href="classDGtal_1_1CountedPtrOrPtr.html">CountedPtrOrPtr</a>, <a class="el" href="classDGtal_1_1CountedConstPtrOrConstPtr.html">CountedConstPtrOrConstPtr</a>. These classes do not add a significant slowdown (between 0 and 10%) in elementary cases, while they can save 50% of time in some cases (with lazy duplication and move).</p>
<p>Related tests are <a class="el" href="testCloneAndAliases_8cpp_source.html">testCloneAndAliases.cpp</a>, <a class="el" href="testClone2_8cpp_source.html">testClone2.cpp</a>.</p>
<h1><a class="anchor" id="moduleCloneAndReference_sec1"></a>
Categories of parameter passing</h1>
<p>In the following, the <b>programmer</b> is the one that has written the function/method <code>f</code> being called, while the <b>user</b> is the one that has written the code that calls <code>f</code>.</p>
<h2><a class="anchor" id="moduleCloneAndReference_sec11"></a>
Parameter passing in C++</h2>
<p>From a C++ point of view, you may pass an object of type <code>T</code> as parameter to <code>f</code> through the following mechanism:</p>
<ul>
<li>by <b>value</b> with <code>f</code>(<code>T</code> <code>t</code> ). It is <em>mostly</em> used when passing native types (like <code>int</code>, <code>bool</code>, etc), small objects like iterators, as <b>input</b>. It indicates to the user that its argument is <b>duplicated</b> (at least once) and <b>not</b> <b>modified</b>. The user may also give a <b>right-<b>value</b> object</b> as parameter, though <b>without</b> <b>move</b> possibility.</li>
<li>by <b>const</b> <b>reference</b> with <code>f</code>(<code>const</code> <code>T&amp;</code> <code>t</code> ). This form is <em>generally</em> used as an <b>alternative</b> to <b>passing-by-value</b>, to pass bigger objects as <b>input</b>. It may <em>sometimes</em> indicate to the user that the argument is <b>const</b> <b>referenced</b> in <code>f</code> for further uses, especially when <code>f</code> is a constructor/method of another object. It is <b>unclear</b> whether the <b> lifetime of the argument should exceed the lifetime of <code>f</code> </b>. This fact is clarified generally by the documentation.</li>
<li>by <b>const</b> <b>pointer</b> with <code>f</code>(<code>const</code> <code>T*</code> <code>ptrT</code> ). This form is <em>sometimes</em> used as an alternative to passing-by-value, to pass bigger objects as <b>input</b> while authorizing an invalid object (null pointer). Although this form is more C-like, it may be used in some C++ situation (like creating or destroying relations between objects). It may <em>sometimes</em> indicate to the user that the argument is <b>const</b> <b>pointed</b> in <code>f</code> for further uses, especially when <code>f</code> is a constructor/method of another object. It is <b>unclear</b> whether the <b> lifetime of the argument should exceed the lifetime of <code>f</code> </b>. This fact is clarified generally by the documentation.</li>
<li>by <b>reference</b> with <code>f</code>(<code>T&amp;</code> <code>t</code> ). It is <em>generally</em> used for <b>modifying</b> an object (<b>input-output</b> or <b>output</b>). It may <em>sometimes</em> indicate to the user that the argument is <b>referenced</b> in <code>f</code> for further uses and modifications, especially when <code>f</code> is a constructor/method of an object. It is <b>unclear</b> whether the <b> lifetime of the argument should exceed the lifetime of <code>f</code> </b>. This fact is clarified generally by the documentation.</li>
<li>by <b>pointer</b> with <code>f</code>( <code>T*</code> <code>ptrT</code> ). This form is <em>sometimes</em> used as an alternative to passing-by-reference for <b>modifying</b> an object (<b>input-output</b> or <b>output</b>). Although this form is more C-like, it may be used also for specifying <b>acquisition</b> of the object (which should then have been dynamically allocated). It may <em>sometimes</em> indicate to the user that the argument is <b>pointed</b> in <code>f</code> for further uses and modifications, especially when <code>f</code> is a constructor/method of an object. It is <b>unclear</b> whether the <b> lifetime of the argument should exceed the lifetime of <code>f</code> </b>. This fact is clarified generally by the documentation.</li>
</ul>
<p>The preceding discussion shows that standard parameter passing is <em>ambiguous</em> by nature, since each parameter passing method has several meanings. The user is forced to checked carefully the documentation (at best) or the full code to see how parameters are used.</p>
<h2><a class="anchor" id="moduleCloneAndReference_sec12"></a>
Alternative definition for parameter passing</h2>
<p>The <b>programmer</b> should explicit its <em>intent</em> to the user in an unambiguous way directly in the signature of <code>f</code>. We propose the following taxonomy:</p>
<ol type="1">
<li><b>input</b> parameters<ol type="a">
<li><b>immediate</b> <b>use</b>. The <em>argument</em> is used immediately in <code>f</code>, it is <em>not</em> <em>pointed</em> nor <em>referenced</em> for <em>further</em> <em>use</em>, and its lifetime is whatever.</li>
<li><b>immediate</b> <b>cloning</b>. The <em>argument</em> is cloned in <code>f</code> for <em>further</em> <b>secure</b> <em>use</em> or <em>modifications</em>, and hence its lifetime is whatever.</li>
<li><b>long-term</b> <b>const</b> <b>aliasing</b>. The <em>argument</em> is aliased in <code>f</code> for <em>further</em> <em>use</em>. The user is warned that he must adapt the lifetime of the argument consequently (generally the lifetime of the other object). The user knows that its argument will not be modified.</li>
<li><b>object</b> <b>transfer</b> or <b>pointer</b> <b>acquisition</b>. The <em>argument</em> was dynamically allocated and you wish to transfer its ownership to another object through call of <code>f</code>. This is a <b>cloning</b> for the <em>programmer</em> induced by a specific call by the <em>user</em> with a pointer.</li>
</ol>
</li>
<li><b>input-output</b> and <b>output</b> parameters<ol type="a">
<li><b>immediate</b> <b>use</b>. The <em>argument</em> is used immediately in <code>f</code>, it is <em>not</em> <em>pointed</em> or <em>referenced</em> for <em>further</em> <em>use</em>, and its lifetime is whatever. The argument is <em>modified</em> by <code>f</code>.</li>
<li><b>long-term</b> <b>aliasing</b> (or <b>sharing</b>). The <em>argument</em> is aliased in <code>f</code> for <em>further</em> <em>use</em> and <em>modifications</em>. The user is warned that he must adapt the lifetime of the argument consequently (generally the lifetime of the other object). The user knows that its argument is shared by another object.</li>
</ol>
</li>
</ol>
<h1><a class="anchor" id="moduleCloneAndReference_sec2"></a>
Parameter passing with Clone, Alias and ConstAlias</h1>
<p>Classes <a class="el" href="classDGtal_1_1Clone.html" title="Aim: This class encapsulates its parameter class to indicate that the given parameter is required to ...">Clone</a>, <a class="el" href="classDGtal_1_1Alias.html" title="Aim: This class encapsulates its parameter class so that to indicate to the user that the object/poin...">Alias</a>, and <a class="el" href="classDGtal_1_1ConstAlias.html" title="Aim: This class encapsulates its parameter class so that to indicate to the user that the object/poin...">ConstAlias</a> are defined in order to accept several arguments from the <em>user</em>. Symmetrically, they may be automatically converted into several types for the <em>programmer</em>. Not all combinations are allowed, but several optimizations are made, most notably by avoiding duplication if possible, by performing lazy duplication, or by moving objects. Furthermore, even for long-term aliasing, the <em>user</em> may choose at compile time between either an unsecure or secure aliasing method, depending on its application.</p>
<p>Therefore, those three classes are useful both from an efficiency and pragmatic point of view.</p>
<h2><a class="anchor" id="moduleCloneAndReference_sec21"></a>
Disambiguating parameter passing</h2>
<p>We propose the following ways to pass parameters without ambiguity:</p>
<table class="doxtable">
<tr>
<th>input parameter </th><th>immediate use </th><th>immediate cloning / object transfer </th><th>long-term const-aliasing  </th></tr>
<tr>
<td>basic types, small object </td><td><code>f( T t )</code> </td><td><code>f( <a class="el" href="classDGtal_1_1Clone.html" title="Aim: This class encapsulates its parameter class to indicate that the given parameter is required to ...">Clone</a>&lt;T&gt; t )</code> </td><td><code>f( <a class="el" href="classDGtal_1_1ConstAlias.html" title="Aim: This class encapsulates its parameter class so that to indicate to the user that the object/poin...">ConstAlias</a>&lt;T&gt; t )</code> </td></tr>
<tr>
<td>bigger objects </td><td><code>f( const T&amp; t )</code> </td><td><code>f( <a class="el" href="classDGtal_1_1Clone.html" title="Aim: This class encapsulates its parameter class to indicate that the given parameter is required to ...">Clone</a>&lt;T&gt; t )</code> </td><td><code>f( <a class="el" href="classDGtal_1_1ConstAlias.html" title="Aim: This class encapsulates its parameter class so that to indicate to the user that the object/poin...">ConstAlias</a>&lt;T&gt; t )</code> </td></tr>
<tr>
<td>User must be careful of argument lifetime</td><td>no </td><td>no </td><td>yes </td></tr>
</table>
<table class="doxtable">
<tr>
<th>input-output / output parameter</th><th>immediate use </th><th>long-term aliasing / sharing  </th></tr>
<tr>
<td>any type/object </td><td><code>f( T&amp; t )</code> </td><td><code>f( <a class="el" href="classDGtal_1_1Alias.html" title="Aim: This class encapsulates its parameter class so that to indicate to the user that the object/poin...">Alias</a>&lt;T&gt; t )</code> </td></tr>
<tr>
<td>User must be careful of argument lifetime</td><td>no </td><td>yes </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Parameter passing by <b>pointer</b> may be used in place of references in the first column, altough this is not encouraged. Indeed, you have to think about your parameter passing by pointer to determine whether it is truely an immediate use or an implicit <code>Clone&lt;T*&gt;</code>. You may use a parameter passing by <b>pointer</b> in the following cases:<ul>
<li>you wish to alias / const-alias an object that may be <em>null</em> (0) in some cases, like in an optional object association. In this case, you should use a <b>pointer</b> member.</li>
<li>you are manipulating arrays: pointers relate to cells of your array and are in fact <em>iterators</em> passed by value. Perhaps consider a typedef to remove ambiguity.</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="moduleCloneAndReference_sec22"></a>
User passing an argument to a Clone parameter</h2>
<p>A parameter <code>( <a class="el" href="classDGtal_1_1Clone.html" title="Aim: This class encapsulates its parameter class to indicate that the given parameter is required to ...">Clone</a>&lt;T&gt; cT )</code> accepts several types of arguments constructed from <code>T</code>. The true behavior of <code><a class="el" href="classDGtal_1_1Clone.html" title="Aim: This class encapsulates its parameter class to indicate that the given parameter is required to ...">Clone</a></code> depends also on the way the <em>programmer</em> uses the object <code>cT</code> in the function/method. The object <code>cT</code> may be used to initialize 3 different types of object (often a data member): <code>T</code>, <code>T*</code>, CowPtr&lt;T&gt;. The following table sums up the different conversions <em>Argument</em> toward <em>member</em>.</p>
<table class="doxtable">
<tr>
<th>Argument type: </th><th><code>const</code> <code>T&amp;</code> </th><th><code>T*</code> </th><th><code>CountedPtr&lt;T&gt;</code> </th><th><code>CowPtr&lt;T&gt;</code> </th><th><code>T&amp;&amp;</code> (c++11)  </th></tr>
<tr>
<td>To:<code>T</code> </td><td>Dupl. O(N) </td><td>Acq. Dupl. O(N)</td><td>Dupl. O(N) </td><td>Dupl. O(N) </td><td>Move. O(1) </td></tr>
<tr>
<td>To:<code>T*</code> </td><td>Dupl. O(N) </td><td>Acq. O(1) </td><td>Dupl. O(N) </td><td>Dupl. O(N) </td><td>Move. O(1) </td></tr>
<tr>
<td>To:CowPtr&lt;T&gt; </td><td>Dupl. O(N) </td><td>Acq. O(1) </td><td>Lazy. O(1)/O(N)</td><td>Lazy. O(1)/O(N)</td><td>Move. O(1) </td></tr>
</table>
<p>where O(N) stands for the time to duplicate an instance of <code>T</code>, and with the following abbreviations:</p><ul>
<li><b>Dupl</b>. <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> is duplicated.</li>
<li><b>Lazy</b>. <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> is lazily duplicated, meaning only when the user writes on it (which may be never).</li>
<li><b>Acq</b>. Dynamically allocated pointer is acquired. User should take care himself of deletion only if storing the parameter with a pointer.</li>
<li><b>Move</b>. The object is moved into the new object. This is generally much faster than copy. This is true for instance for all classical STL containers. You can also write a specific <code>move</code> constructor for your class.</li>
</ul>
<p>It is clear that worst case is duplication while sometimes <a class="el" href="classDGtal_1_1Clone.html">Clone</a> is constant time (while guaranteeing object invariance and life-time).</p>
<dl class="section note"><dt>Note</dt><dd>A conversion to <code>T*</code> means pointer acquisition. Hence the programmer should take care of deletion of the object. Otherwise, deletion is automatic for <code>T</code> or <code>CowPtr&lt;T&gt;</code> member. Furthermore, a conversion to a <code>T*</code> requires the use of the address operator (<code>operator&amp;</code>) by the <em>developer</em>. If argument is <code><a class="el" href="classDGtal_1_1Clone.html" title="Aim: This class encapsulates its parameter class to indicate that the given parameter is required to ...">Clone</a>&lt;T&gt; a</code>, and member name is <code>b</code>:</dd></dl>
<table class="doxtable">
<tr>
<th>member type:</th><th><code>T</code> </th><th><code>T*</code> </th><th><code>CowPtr&lt;T&gt;</code>  </th></tr>
<tr>
<td>member deletion:</td><td>automatic </td><td><b>manual</b> </td><td>automatic </td></tr>
<tr>
<td>conversion:</td><td>automatic: <code>b(a)</code> </td><td>address: <code>b(&amp;a)</code></td><td>automatic: <code>b(a)</code> </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>When choosing a <code><a class="el" href="classDGtal_1_1Clone.html" title="Aim: This class encapsulates its parameter class to indicate that the given parameter is required to ...">Clone</a>&lt;T&gt;</code> parameter, the <em>programmer</em> should really consider using a <code><a class="el" href="classDGtal_1_1CowPtr.html" title="Aim: Copy on write shared pointer. ">CowPtr</a>&lt;T&gt;</code> member to store it, since it is the most versatile and optimizable variant. The only advantage of the two others storing methods (<code>T</code> and <code>T*</code>) is that there is one less indirection.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>BigFatA { ... };</div><div class="line"></div><div class="line"><span class="keyword">struct </span>B {</div><div class="line">  <span class="comment">// versatile constructor. Accepts 5 different versions.</span></div><div class="line">  B( Clone&lt;BigFatA&gt; a ) : myOwnFat( a ) {}  </div><div class="line">  <span class="keywordtype">void</span> f() { myOwnFat-&gt;do(); }</div><div class="line">  CowPtr&lt;BigFatA&gt; myOwnFat;</div><div class="line">};</div><div class="line"></div><div class="line">BigFatA a1;</div><div class="line">B b1( a1 ); <span class="comment">// cloned</span></div><div class="line">B b2( <span class="keyword">new</span> BigFatA( <span class="stringliteral">&quot;I am the one &quot;</span> ) ); <span class="comment">// acquired </span></div><div class="line">CountedPtr&lt;BigFatA&gt; counted_ptr = <span class="keyword">new</span> BigFatA( <span class="stringliteral">&quot;I am the other one&quot;</span> ); </div><div class="line">B b3( counted_ptr ); <span class="comment">// O(1) since lazy duplication (waiting for a write).</span></div><div class="line">B b4( BigFatA( <span class="stringliteral">&quot;Moving one&quot;</span> ) ); <span class="comment">// this one is created directly in b4 (with c++11).</span></div></div><!-- fragment --><p>This version acquires the given argument. Note the use of the address operator <code>operator&amp;</code> and the <code>delete</code> in the destructor.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>BigFatA { ... };</div><div class="line"></div><div class="line"><span class="keyword">struct </span>B {</div><div class="line">  <span class="comment">// versatile constructor. Accepts 5 different versions.</span></div><div class="line">  B( Clone&lt;BigFatA&gt; a ) : myAcquiredFat( &amp;a ) {} <span class="comment">// note the address operator</span></div><div class="line">  ~B() { <span class="keyword">delete</span> myAcquiredFat; }                 <span class="comment">// required because of pointer acquisition</span></div><div class="line">  <span class="keywordtype">void</span> f() { myOwnFat-&gt;do(); }</div><div class="line">  BigFatA* myAcquiredFat;</div><div class="line">};</div><div class="line"></div><div class="line">BigFatA a1;</div><div class="line">B b1( a1 ); <span class="comment">// cloned</span></div><div class="line">B b2( <span class="keyword">new</span> BigFatA( <span class="stringliteral">&quot;I am the one &quot;</span> ) ); <span class="comment">// acquired </span></div><div class="line">CountedPtr&lt;BigFatA&gt; counted_ptr = <span class="keyword">new</span> BigFatA( <span class="stringliteral">&quot;I am the other one&quot;</span> ); </div><div class="line">B b3( counted_ptr ); <span class="comment">// duplicated</span></div><div class="line">B b4( BigFatA( <span class="stringliteral">&quot;Moving one&quot;</span> ) ); <span class="comment">// this one is created directly in b4 (with c++11).</span></div></div><!-- fragment --><h2><a class="anchor" id="moduleCloneAndReference_sec23"></a>
User passing an argument to an Alias parameter</h2>
<p>A parameter <code>( <a class="el" href="classDGtal_1_1Alias.html" title="Aim: This class encapsulates its parameter class so that to indicate to the user that the object/poin...">Alias</a>&lt;T&gt; cT )</code> accepts several types of arguments constructed from <code>T</code>. The true behavior of <code><a class="el" href="classDGtal_1_1Alias.html" title="Aim: This class encapsulates its parameter class so that to indicate to the user that the object/poin...">Alias</a></code> depends also on the way the <em>programmer</em> uses the object <code>cT</code> in the function/method. The object <code>cT</code> may be used to initialize 3 different types of object (often a data member): <code>T&amp;</code>, <code>T*</code>, <code>CountedPtrOrPtr&lt;T&gt;</code>. The following table sums up the different conversions <em>Argument</em> toward <em>member</em>.</p>
<table class="doxtable">
<tr>
<th>Argument type </th><th><code>T&amp;</code> </th><th><code>T*</code> </th><th><code>CountedPtr&lt;T&gt;</code> </th><th><code>CountedPtrOrPtr&lt;T&gt;</code>  </th></tr>
<tr>
<td>To: <code>T&amp;</code> </td><td>Shared. O(1) </td><td>Shared. O(1) </td><td></td><td></td></tr>
<tr>
<td>To: <code>T*</code> </td><td>Shared. O(1) </td><td>Shared. O(1) </td><td></td><td></td></tr>
<tr>
<td>To: CountedPtrOrPtr&lt;T&gt;</td><td>Shared. O(1)</td><td>Shared. O(1)</td><td>Shared. O(1), <b>secure</b> </td><td>Shared. O(1), <b>secure</b> </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>When choosing an <code><a class="el" href="classDGtal_1_1Alias.html" title="Aim: This class encapsulates its parameter class so that to indicate to the user that the object/poin...">Alias</a>&lt;T&gt;</code> parameter, the <em>programmer</em> should really consider using a <code><a class="el" href="classDGtal_1_1CountedPtrOrPtr.html" title="Aim: Smart or simple pointer on T. It can be a smart pointer based on reference counts or a simple po...">CountedPtrOrPtr</a>&lt;T&gt;</code> member to store it, since it is the most secure-able variant. The only advantage of the two others storing methods (<code>T&amp;</code> and <code>T*</code>) is that there is one less boolean test and indirection.</dd>
<dd>
A conversion to a <code>T*</code> requires the use of the address operator (<code>operator&amp;</code>) by the <em>developer</em>. If argument is <code><a class="el" href="classDGtal_1_1Alias.html" title="Aim: This class encapsulates its parameter class so that to indicate to the user that the object/poin...">Alias</a>&lt;T&gt; a</code>, and member name is <code>b</code>:</dd></dl>
<table class="doxtable">
<tr>
<th>member type:</th><th><code>T&amp;</code> </th><th><code>T*</code> </th><th><code>CountedPtrOrPtr&lt;T&gt;</code>  </th></tr>
<tr>
<td>conversion:</td><td>automatic: <code>b(a)</code> </td><td>address: <code>b(&amp;a)</code></td><td>automatic: <code>b(a)</code> </td></tr>
</table>
<dl class="section user"><dt>Advanced:</dt><dd>As one can see, if the <em>programmer</em> has chosen a <code><a class="el" href="classDGtal_1_1CountedPtrOrPtr.html" title="Aim: Smart or simple pointer on T. It can be a smart pointer based on reference counts or a simple po...">CountedPtrOrPtr</a>&lt;T&gt;</code> for storing the alias, the <em>user</em> can choose between a <b>secure</b> <b>long-term</b> <b>aliasing</b> (with a <code><a class="el" href="classDGtal_1_1CountedPtr.html" title="Aim: Smart pointer based on reference counts. ">CountedPtr</a>&lt;T&gt;</code> or <code><a class="el" href="classDGtal_1_1CountedPtrOrPtr.html" title="Aim: Smart or simple pointer on T. It can be a smart pointer based on reference counts or a simple po...">CountedPtrOrPtr</a>&lt;T&gt;</code> argument) or <b>non</b> <b>secure</b> <b>long-term</b> <b>aliasing</b> (with a <code>T&amp;</code> or <code>T*</code> argument).</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>BigFatA { ... };</div><div class="line"></div><div class="line"><span class="keyword">struct </span>B {</div><div class="line">  <span class="comment">// versatile constructor. Accepts 4 different versions.</span></div><div class="line">  B( Alias&lt;BigFatA&gt; a ) : mySharedFat( a ) {}</div><div class="line">  <span class="keywordtype">void</span> f() { mySharedFat-&gt;do(); }</div><div class="line">  CountedPtrOrPtr&lt;BigFatA&gt; mySharedFat;</div><div class="line">};</div><div class="line"></div><div class="line">BigFatA a1;</div><div class="line">B b1( a1 ); <span class="comment">// aliased (unsecure)</span></div><div class="line">BigFatA adr = <span class="keyword">new</span> BigFatA( <span class="stringliteral">&quot;I am the one &quot;</span> )</div><div class="line">B b2( adr ); <span class="comment">// aliased</span></div><div class="line">CountedPtr&lt;BigFatA&gt; counted_ptr = new BigFatA( &quot;I am the other one&quot; ); </div><div class="line">B b3( counted_ptr ); <span class="comment">// secure aliased</span></div><div class="line">delete counted_ptr; <span class="comment">// b3 is still fine.</span></div><div class="line">delete adr;</div></div><!-- fragment --><h2><a class="anchor" id="moduleCloneAndReference_sec24"></a>
User passing an argument to a ConstAlias parameter</h2>
<p>A parameter <code>( <a class="el" href="classDGtal_1_1ConstAlias.html" title="Aim: This class encapsulates its parameter class so that to indicate to the user that the object/poin...">ConstAlias</a>&lt;T&gt; cT )</code> accepts several types of arguments constructed from <code>T</code>. The true behavior of <code><a class="el" href="classDGtal_1_1ConstAlias.html" title="Aim: This class encapsulates its parameter class so that to indicate to the user that the object/poin...">ConstAlias</a></code> depends also on the way the <em>programmer</em> uses the object <code>cT</code> in the function/method. The object <code>cT</code> may be used to initialize 3 different types of object (often a data member): <code>T&amp;</code>, <code>T*</code>, <code>CowPtr&lt;T&gt;</code>. The following table sums up the different conversions <em>Argument</em> toward <em>member</em>.</p>
<table class="doxtable">
<tr>
<th>Argument </th><th><code>const</code> <code>T&amp;</code> </th><th><code>const</code> <code>T*</code> </th><th><code>CountedPtr&lt;T&gt;</code> </th><th><code>CountedPtrOrPtr&lt;T&gt;</code> </th><th><code>CountedConstPtrOrConstPtr&lt;T&gt;</code>  </th></tr>
<tr>
<td>To: <code>const</code> T&amp; </td><td>Shared. O(1) </td><td>Shared. O(1) </td><td></td><td></td><td></td></tr>
<tr>
<td>To: <code>const</code> T* </td><td>Shared. O(1) </td><td>Shared. O(1) </td><td></td><td></td><td></td></tr>
<tr>
<td>To: CountedConstPtrOrConstPtr&lt;T&gt;</td><td>Shared. O(1)</td><td>Shared. O(1)</td><td>Shared. O(1), <b>secure</b> </td><td>Shared. O(1), <b>secure</b> </td><td>Shared. O(1), <b>secure</b> </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>When choosing a <code><a class="el" href="classDGtal_1_1ConstAlias.html" title="Aim: This class encapsulates its parameter class so that to indicate to the user that the object/poin...">ConstAlias</a>&lt;T&gt;</code> parameter, the <em>programmer</em> should really consider using a <code><a class="el" href="classDGtal_1_1CountedConstPtrOrConstPtr.html" title="Aim: Smart or simple const pointer on T. It can be a smart pointer based on reference counts or a sim...">CountedConstPtrOrConstPtr</a>&lt;T&gt;</code> member to store it, since it is the most secure-able variant. The only advantage of the two others storing methods (<code>const</code> <code>T&amp;</code> and <code>const</code> <code>T*</code>) is that there is one less boolean test and indirection.</dd>
<dd>
A conversion to a <code>const T*</code> requires the use of the address operator (<code>operator&amp;</code>) by the <em>developer</em>. If argument is <code><a class="el" href="classDGtal_1_1ConstAlias.html" title="Aim: This class encapsulates its parameter class so that to indicate to the user that the object/poin...">ConstAlias</a>&lt;T&gt; a</code>, and member name is <code>b</code>:</dd></dl>
<table class="doxtable">
<tr>
<th>member type:</th><th><code>const</code> <code>T&amp;</code> </th><th><code>const</code> <code>T*</code> </th><th><code>CountedConstPtrOrConstPtr&lt;T&gt;</code>  </th></tr>
<tr>
<td>conversion:</td><td>automatic: <code>b(a)</code> </td><td>address: <code>b(&amp;a)</code></td><td>automatic: <code>b(a)</code> </td></tr>
</table>
<dl class="section user"><dt>Advanced:</dt><dd>As one can see, if the <em>programmer</em> has chosen a <code><a class="el" href="classDGtal_1_1CountedConstPtrOrConstPtr.html" title="Aim: Smart or simple const pointer on T. It can be a smart pointer based on reference counts or a sim...">CountedConstPtrOrConstPtr</a>&lt;T&gt;</code> for storing the const alias, the <em>user</em> can choose between a <b>secure</b> <b>long-term</b> <b>const-aliasing</b> (with a <code><a class="el" href="classDGtal_1_1CountedPtr.html" title="Aim: Smart pointer based on reference counts. ">CountedPtr</a>&lt;T&gt;</code> or <code><a class="el" href="classDGtal_1_1CountedPtrOrPtr.html" title="Aim: Smart or simple pointer on T. It can be a smart pointer based on reference counts or a simple po...">CountedPtrOrPtr</a>&lt;T&gt;</code> or <code><a class="el" href="classDGtal_1_1CountedConstPtrOrConstPtr.html" title="Aim: Smart or simple const pointer on T. It can be a smart pointer based on reference counts or a sim...">CountedConstPtrOrConstPtr</a>&lt;T&gt;</code> argument) or <b>non</b> <b>secure</b> <b>long-term</b> <b>const-aliasing</b> (with a <code>T&amp;</code> or <code>T*</code> argument).</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>BigFatA { ... };</div><div class="line"></div><div class="line"><span class="keyword">struct </span>B {</div><div class="line">  <span class="comment">// versatile constructor. Accepts 5 different versions.</span></div><div class="line">  B( ConstAlias&lt;BigFatA&gt; a ) : myConstSharedFat( a ) {}</div><div class="line">  <span class="keywordtype">void</span> f()<span class="keyword"> const </span>{ myConstSharedFat-&gt;do(); } <span class="comment">// const method</span></div><div class="line">  CountedConstPtrOrConstPtr&lt;BigFatA&gt; myConstSharedFat;</div><div class="line">};</div><div class="line"></div><div class="line">BigFatA a1;</div><div class="line">B b1( a1 ); <span class="comment">// const-aliased (unsecure)</span></div><div class="line">BigFatA adr = <span class="keyword">new</span> BigFatA( <span class="stringliteral">&quot;I am the one &quot;</span> )</div><div class="line">B b2( adr ); <span class="comment">// aliased</span></div><div class="line">CountedPtr&lt;BigFatA&gt; counted_ptr = new BigFatA( &quot;I am the other one&quot; ); </div><div class="line">B b3( counted_ptr ); <span class="comment">// secure aliased</span></div><div class="line">delete counted_ptr; <span class="comment">// b3 is still fine.</span></div><div class="line">delete adr;</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 22 2016 21:11:40 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
