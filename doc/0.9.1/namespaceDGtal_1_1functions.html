<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>DGtal: DGtal::functions Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.9.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceDGtal.html">DGtal</a></li><li class="navelem"><a class="el" href="namespaceDGtal_1_1functions.html">functions</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DGtal::functions Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceDGtal_1_1functions_1_1Hull2D"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html">Hull2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceDGtal_1_1functions_1_1setops"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions_1_1setops.html">setops</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a82988f18c989530f73dab774abe12c90"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:a82988f18c989530f73dab774abe12c90"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a82988f18c989530f73dab774abe12c90">isEqual</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a82988f18c989530f73dab774abe12c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbef166c5a788624eff4f09e596c09f5"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:adbef166c5a788624eff4f09e596c09f5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#adbef166c5a788624eff4f09e596c09f5">isEqual</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:adbef166c5a788624eff4f09e596c09f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e98eb410830e5ca846260e66bff422"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:ac7e98eb410830e5ca846260e66bff422"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#ac7e98eb410830e5ca846260e66bff422">isSubset</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:ac7e98eb410830e5ca846260e66bff422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad171e7dc7973f3fc0ee8363712059124"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ad171e7dc7973f3fc0ee8363712059124"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#ad171e7dc7973f3fc0ee8363712059124">isSubset</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:ad171e7dc7973f3fc0ee8363712059124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97099c06241a42dce86a53230b665d7"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:ac97099c06241a42dce86a53230b665d7"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#ac97099c06241a42dce86a53230b665d7">assignDifference</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:ac97099c06241a42dce86a53230b665d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b91c6c5fb3c893dd709f4e90e9eff93"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a0b91c6c5fb3c893dd709f4e90e9eff93"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a0b91c6c5fb3c893dd709f4e90e9eff93">assignDifference</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a0b91c6c5fb3c893dd709f4e90e9eff93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5faa4fb283d3dd8b530f1aa46e1303"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:adc5faa4fb283d3dd8b530f1aa46e1303"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#adc5faa4fb283d3dd8b530f1aa46e1303">makeDifference</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:adc5faa4fb283d3dd8b530f1aa46e1303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba16c21435994b725465e08cb77a9fb"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:acba16c21435994b725465e08cb77a9fb"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#acba16c21435994b725465e08cb77a9fb">makeDifference</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:acba16c21435994b725465e08cb77a9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58ca694e397fb84d77c53aba2134887"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:ac58ca694e397fb84d77c53aba2134887"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#ac58ca694e397fb84d77c53aba2134887">assignUnion</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:ac58ca694e397fb84d77c53aba2134887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4932db4b89711ecfc43c950766c8a3c2"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a4932db4b89711ecfc43c950766c8a3c2"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a4932db4b89711ecfc43c950766c8a3c2">assignUnion</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a4932db4b89711ecfc43c950766c8a3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af848d0d5748af67bcb76b3d5e1f616cd"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:af848d0d5748af67bcb76b3d5e1f616cd"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#af848d0d5748af67bcb76b3d5e1f616cd">makeUnion</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:af848d0d5748af67bcb76b3d5e1f616cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af462fb1f5ceade012f0e97831e3d8e64"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:af462fb1f5ceade012f0e97831e3d8e64"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#af462fb1f5ceade012f0e97831e3d8e64">makeUnion</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:af462fb1f5ceade012f0e97831e3d8e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3360043e7032e9a8eaf2ef0fde60afd"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:af3360043e7032e9a8eaf2ef0fde60afd"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#af3360043e7032e9a8eaf2ef0fde60afd">assignIntersection</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:af3360043e7032e9a8eaf2ef0fde60afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03568b922cfd14ec380c2b297af70dff"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a03568b922cfd14ec380c2b297af70dff"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a03568b922cfd14ec380c2b297af70dff">assignIntersection</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a03568b922cfd14ec380c2b297af70dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de7a7bd0c7511d57569c794cff3a113"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:a8de7a7bd0c7511d57569c794cff3a113"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a8de7a7bd0c7511d57569c794cff3a113">makeIntersection</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a8de7a7bd0c7511d57569c794cff3a113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d93770c72e70791aa57c47d22c982b9"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a6d93770c72e70791aa57c47d22c982b9"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a6d93770c72e70791aa57c47d22c982b9">makeIntersection</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a6d93770c72e70791aa57c47d22c982b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65694ad895f3f4cb42c54213fce7295a"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:a65694ad895f3f4cb42c54213fce7295a"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a65694ad895f3f4cb42c54213fce7295a">assignSymmetricDifference</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a65694ad895f3f4cb42c54213fce7295a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e5c37c5f1aaade38460038220ce4fd"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a20e5c37c5f1aaade38460038220ce4fd"><td class="memTemplItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a20e5c37c5f1aaade38460038220ce4fd">assignSymmetricDifference</a> (Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a20e5c37c5f1aaade38460038220ce4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f0a6573a95aa152c8b8320baee6884"><td class="memTemplParams" colspan="2">template&lt;typename Container , bool ordered&gt; </td></tr>
<tr class="memitem:a03f0a6573a95aa152c8b8320baee6884"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a03f0a6573a95aa152c8b8320baee6884">makeSymmetricDifference</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:a03f0a6573a95aa152c8b8320baee6884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd11e737e0c019de78553ae847a5724"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:aacd11e737e0c019de78553ae847a5724"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#aacd11e737e0c019de78553ae847a5724">makeSymmetricDifference</a> (const Container &amp;S1, const Container &amp;S2)</td></tr>
<tr class="separator:aacd11e737e0c019de78553ae847a5724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4fa6a6be77e4813577c8a2b3572299"><td class="memTemplParams" colspan="2">template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </td></tr>
<tr class="memitem:a6e4fa6a6be77e4813577c8a2b3572299"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a6e4fa6a6be77e4813577c8a2b3572299">checkOnePoint</a> (const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;aDSS)</td></tr>
<tr class="separator:a6e4fa6a6be77e4813577c8a2b3572299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b421081da133e4069fe9cbddf33aa54"><td class="memTemplParams" colspan="2">template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </td></tr>
<tr class="memitem:a6b421081da133e4069fe9cbddf33aa54"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a6b421081da133e4069fe9cbddf33aa54">checkPointsPosition</a> (const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;aDSS)</td></tr>
<tr class="separator:a6b421081da133e4069fe9cbddf33aa54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e697b1094865df340ba6206354f7c37"><td class="memTemplParams" colspan="2">template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </td></tr>
<tr class="memitem:a1e697b1094865df340ba6206354f7c37"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a1e697b1094865df340ba6206354f7c37">checkPointsRemainder</a> (const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;aDSS)</td></tr>
<tr class="separator:a1e697b1094865df340ba6206354f7c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612e2adbf3983c441753beb63fd55f86"><td class="memTemplParams" colspan="2">template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </td></tr>
<tr class="memitem:a612e2adbf3983c441753beb63fd55f86"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a612e2adbf3983c441753beb63fd55f86">checkAll</a> (const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;aDSS)</td></tr>
<tr class="separator:a612e2adbf3983c441753beb63fd55f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c21293d6efa82afb1b20db4d7a794a7"><td class="memTemplParams" colspan="2">template&lt;typename Position , typename Coordinate , typename PointVector , typename OutputIterator , typename PositionFunctor , typename TruncationFunctor1 , typename TruncationFunctor2 &gt; </td></tr>
<tr class="memitem:a2c21293d6efa82afb1b20db4d7a794a7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a2c21293d6efa82afb1b20db4d7a794a7">smartCHNextVertex</a> (const Position &amp;positionBound, const Coordinate &amp;remainderBound, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;X, Coordinate &amp;rX, const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;Y, const Coordinate &amp;rY, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;V, Coordinate &amp;rV, OutputIterator ito, const PositionFunctor &amp;pos, const TruncationFunctor1 &amp;f1, const TruncationFunctor2 &amp;f2)</td></tr>
<tr class="separator:a2c21293d6efa82afb1b20db4d7a794a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b66e9e7682c0f900bcbeabcac96b7b"><td class="memTemplParams" colspan="2">template&lt;typename PointVector , typename Coordinate , typename Position , typename PositionFunctor , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a07b66e9e7682c0f900bcbeabcac96b7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a07b66e9e7682c0f900bcbeabcac96b7b">smartCH</a> (const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;aFirstPoint, const Coordinate &amp;aRemainderBound, const Position &amp;aPositionBound, const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;aStep, const Coordinate &amp;aRStep, const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;aShift, const Coordinate &amp;aRShift, const PositionFunctor &amp;aPositionFunctor, OutputIterator uIto, OutputIterator lIto)</td></tr>
<tr class="separator:a07b66e9e7682c0f900bcbeabcac96b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc99490ec12ae9e68c03c08d473e8692"><td class="memTemplParams" colspan="2">template&lt;typename DSL , typename OutputIterator &gt; </td></tr>
<tr class="memitem:adc99490ec12ae9e68c03c08d473e8692"><td class="memTemplItemLeft" align="right" valign="top">DSL::Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#adc99490ec12ae9e68c03c08d473e8692">smartCH</a> (const DSL &amp;aDSL, const typename DSL::Point &amp;aFirstPoint, const typename DSL::Position &amp;aLength, OutputIterator uIto, OutputIterator lIto)</td></tr>
<tr class="separator:adc99490ec12ae9e68c03c08d473e8692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184e90763c4747a4b7c71a58e1bf4bfe"><td class="memTemplParams" colspan="2">template&lt;typename PointVector , typename Position , typename OutputIterator , typename TruncationFunctor1 , typename TruncationFunctor2 , typename PositionFunctor &gt; </td></tr>
<tr class="memitem:a184e90763c4747a4b7c71a58e1bf4bfe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a184e90763c4747a4b7c71a58e1bf4bfe">smartCHPreviousVertex</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;X, const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;Y, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;V, const Position &amp;aFirstPosition, const Position &amp;aLastPosition, OutputIterator ito, const PositionFunctor &amp;pos, const TruncationFunctor1 &amp;f1, const TruncationFunctor2 &amp;f2)</td></tr>
<tr class="separator:a184e90763c4747a4b7c71a58e1bf4bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa754ac3d17216563354db61d905a545c"><td class="memTemplParams" colspan="2">template&lt;typename PointVector , typename Position , typename PositionFunctor , typename OutputIterator &gt; </td></tr>
<tr class="memitem:aa754ac3d17216563354db61d905a545c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#aa754ac3d17216563354db61d905a545c">reversedSmartCH</a> (<a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> U, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> L, <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> V, const Position &amp;aFirstPosition, const Position &amp;aLastPosition, const PositionFunctor &amp;aPositionFunctor, OutputIterator uIto, OutputIterator lIto)</td></tr>
<tr class="separator:aa754ac3d17216563354db61d905a545c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d6f1219d53ecefb73b55c386e0d54a"><td class="memTemplParams" colspan="2">template&lt;typename DSS , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a42d6f1219d53ecefb73b55c386e0d54a"><td class="memTemplItemLeft" align="right" valign="top">DSS::Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a42d6f1219d53ecefb73b55c386e0d54a">reversedSmartCH</a> (const DSS &amp;aDSS, const typename DSS::Position &amp;aPositionBound, OutputIterator uIto, OutputIterator lIto)</td></tr>
<tr class="separator:a42d6f1219d53ecefb73b55c386e0d54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b68d329aa1461a0847a18e99247885"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a18b68d329aa1461a0847a18e99247885"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a18b68d329aa1461a0847a18e99247885">power</a> (const T &amp;aVal, const unsigned int exponent)</td></tr>
<tr class="separator:a18b68d329aa1461a0847a18e99247885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dff4e7a37ef5122f124d830b4b177a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a48dff4e7a37ef5122f124d830b4b177a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a48dff4e7a37ef5122f124d830b4b177a">roundToUpperPowerOfTwo</a> (const T &amp;n)</td></tr>
<tr class="separator:a48dff4e7a37ef5122f124d830b4b177a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95dcf36f806f7fc15626ca6b1c27d22"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af95dcf36f806f7fc15626ca6b1c27d22"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#af95dcf36f806f7fc15626ca6b1c27d22">abs</a> (const T &amp;a)</td></tr>
<tr class="separator:af95dcf36f806f7fc15626ca6b1c27d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e2160844093488cdd738354027daa1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac8e2160844093488cdd738354027daa1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#ac8e2160844093488cdd738354027daa1">square</a> (T x)</td></tr>
<tr class="separator:ac8e2160844093488cdd738354027daa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4828e0475cb9aa8dceefa94f0ab4d168"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4828e0475cb9aa8dceefa94f0ab4d168"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a4828e0475cb9aa8dceefa94f0ab4d168">cube</a> (T x)</td></tr>
<tr class="separator:a4828e0475cb9aa8dceefa94f0ab4d168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad734479156a9b698609b8712d66a44f6"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:ad734479156a9b698609b8712d66a44f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#ad734479156a9b698609b8712d66a44f6">operator|=</a> (<a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:ad734479156a9b698609b8712d66a44f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6b49b5903838abae2b567991bd53c9"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:aab6b49b5903838abae2b567991bd53c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#aab6b49b5903838abae2b567991bd53c9">operator&amp;=</a> (<a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:aab6b49b5903838abae2b567991bd53c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2dc598f6424e1a8d919c4f8ec1d6234"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:ac2dc598f6424e1a8d919c4f8ec1d6234"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#ac2dc598f6424e1a8d919c4f8ec1d6234">operator^=</a> (<a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:ac2dc598f6424e1a8d919c4f8ec1d6234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84b034580c878cf0e6793c13af5d6dc"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:ae84b034580c878cf0e6793c13af5d6dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#ae84b034580c878cf0e6793c13af5d6dc">operator-=</a> (<a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:ae84b034580c878cf0e6793c13af5d6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae447f1a3e814a5bb11a9aeaec99d8b0f"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:ae447f1a3e814a5bb11a9aeaec99d8b0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#ae447f1a3e814a5bb11a9aeaec99d8b0f">operator|</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:ae447f1a3e814a5bb11a9aeaec99d8b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc70acf08a32615d9b6dc8bf46b21bcd"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:adc70acf08a32615d9b6dc8bf46b21bcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#adc70acf08a32615d9b6dc8bf46b21bcd">operator&amp;</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:adc70acf08a32615d9b6dc8bf46b21bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafb4dd5d75d73c6b2558bda06ff7ba2"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:aaafb4dd5d75d73c6b2558bda06ff7ba2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#aaafb4dd5d75d73c6b2558bda06ff7ba2">operator^</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:aaafb4dd5d75d73c6b2558bda06ff7ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2192cfe9f2c9b5d3b3ae1e11e74696d5"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:a2192cfe9f2c9b5d3b3ae1e11e74696d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a2192cfe9f2c9b5d3b3ae1e11e74696d5">operator-</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:a2192cfe9f2c9b5d3b3ae1e11e74696d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168a5ac6b1b9969a8aec0f82fd637e89"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:a168a5ac6b1b9969a8aec0f82fd637e89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a168a5ac6b1b9969a8aec0f82fd637e89">operator~</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:a168a5ac6b1b9969a8aec0f82fd637e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66f96d40ea286f17345ce9dc6c16769"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:aa66f96d40ea286f17345ce9dc6c16769"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#aa66f96d40ea286f17345ce9dc6c16769">operator*</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:aa66f96d40ea286f17345ce9dc6c16769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c93bd91d630dec05aeaa56370213a6"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:a56c93bd91d630dec05aeaa56370213a6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a56c93bd91d630dec05aeaa56370213a6">operator==</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:a56c93bd91d630dec05aeaa56370213a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93277b98c78598b1057e678c1066848d"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:a93277b98c78598b1057e678c1066848d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a93277b98c78598b1057e678c1066848d">operator!=</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:a93277b98c78598b1057e678c1066848d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab33aff5419600defbb447146e533c0"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:aeab33aff5419600defbb447146e533c0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#aeab33aff5419600defbb447146e533c0">operator&lt;=</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:aeab33aff5419600defbb447146e533c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbd4654807b58176f0a7aa25edc9173"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer &gt; </td></tr>
<tr class="memitem:a8dbd4654807b58176f0a7aa25edc9173"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a8dbd4654807b58176f0a7aa25edc9173">operator&gt;=</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;, const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;)</td></tr>
<tr class="separator:a8dbd4654807b58176f0a7aa25edc9173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72edc3d9d652158c3d02a6a11386f249"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer , typename CellConstIterator , typename CellMapIteratorPriority &gt; </td></tr>
<tr class="memitem:a72edc3d9d652158c3d02a6a11386f249"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a72edc3d9d652158c3d02a6a11386f249">collapse</a> (<a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;K, CellConstIterator S_itB, CellConstIterator S_itE, const CellMapIteratorPriority &amp;priority, bool hintIsSClosed=false, bool hintIsKClosed=false, bool verbose=false)</td></tr>
<tr class="separator:a72edc3d9d652158c3d02a6a11386f249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8066d9f6db356f21fac91f53ffdde53d"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TCellContainer , typename BdryCellOutputIterator , typename InnerCellOutputIterator &gt; </td></tr>
<tr class="memitem:a8066d9f6db356f21fac91f53ffdde53d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functions.html#a8066d9f6db356f21fac91f53ffdde53d">filterCellsWithinBounds</a> (const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;K, const typename TKSpace::Point &amp;kLow, const typename TKSpace::Point &amp;kUp, BdryCellOutputIterator itBdry, InnerCellOutputIterator itInner)</td></tr>
<tr class="separator:a8066d9f6db356f21fac91f53ffdde53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><code>functions</code> namespace gathers all <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a> functionsxs. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af95dcf36f806f7fc15626ca6b1c27d22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T DGtal::functions::abs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the absolute value of an instance of type T.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of elements to compare (model of <a class="el" href="structboost_1_1LessThanComparable.html" title="Go to http://www.boost.org/doc/html/LessThanComparable.html. ">boost::LessThanComparable</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the absolute value |a|. </dd></dl>

<p>Definition at line <a class="el" href="BasicMathFunctions_8h_source.html#l00116">116</a> of file <a class="el" href="BasicMathFunctions_8h_source.html">BasicMathFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    {</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;      BOOST_CONCEPT_ASSERT((<a class="code" href="structboost_1_1LessThanComparable.html">boost::LessThanComparable&lt;T&gt;</a>));</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;      <span class="keywordflow">if</span> (a&lt;0) </div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        <span class="keywordflow">return</span> -a;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        <span class="keywordflow">return</span> a;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    }</div><div class="ttc" id="structboost_1_1LessThanComparable_html"><div class="ttname"><a href="structboost_1_1LessThanComparable.html">boost::LessThanComparable</a></div><div class="ttdoc">Go to http://www.boost.org/doc/html/LessThanComparable.html. </div><div class="ttdef"><b>Definition:</b> <a href="Boost_8dox_source.html#l00048">Boost.dox:48</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac97099c06241a42dce86a53230b665d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container&amp; DGtal::functions::assignDifference </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set difference operation. Updates the set S1 as S1 - S2. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, <em>S1</em> - <em>S2</em> as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SetFunctions_8h_source.html#l00896">896</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>

<p>References <a class="el" href="SetFunctions_8h_source.html#l00896">assignDifference()</a>.</p>

<p>Referenced by <a class="el" href="SetFunctions_8h_source.html#l00896">assignDifference()</a>, <a class="el" href="SetFunctions_8h_source.html#l00965">makeDifference()</a>, and <a class="el" href="SetFunctions_8h_source.html#l01272">DGtal::functions::setops::operator-=()</a>.</p>
<div class="fragment"><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;    {</div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;        ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;        ( <span class="keywordtype">bool</span>, isOrdered = ordered </div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;          || ( isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value ) );</div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">        ::assignDifference</a>( S1, S2 );</div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;    }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl</a></div><div class="ttdoc">Aim: Specialize set operations (union, intersection, difference, symmetric_difference) according to t...</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00234">SetFunctions.h:234</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0b91c6c5fb3c893dd709f4e90e9eff93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container&amp; DGtal::functions::assignDifference </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set difference operation. Updates the set S1 as S1 - S2. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, <em>S1</em> - <em>S2</em> as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SetFunctions_8h_source.html#l00918">918</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>

<p>References <a class="el" href="SetFunctions_8h_source.html#l00896">assignDifference()</a>.</p>
<div class="fragment"><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;    {</div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;        ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;        ( <span class="keywordtype">bool</span>, isOrdered = isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">        ::assignDifference</a>( S1, S2 );</div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;    }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl</a></div><div class="ttdoc">Aim: Specialize set operations (union, intersection, difference, symmetric_difference) according to t...</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00234">SetFunctions.h:234</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af3360043e7032e9a8eaf2ef0fde60afd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container&amp; DGtal::functions::assignIntersection </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set intersection operation. Updates the set <em>S1</em> as \( S1 \cap S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, \( S1 \cap S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SetFunctions_8h_source.html#l01082">1082</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>

<p>References <a class="el" href="SetFunctions_8h_source.html#l01082">assignIntersection()</a>.</p>

<p>Referenced by <a class="el" href="SetFunctions_8h_source.html#l01082">assignIntersection()</a>, <a class="el" href="SetFunctions_8h_source.html#l01149">makeIntersection()</a>, and <a class="el" href="SetFunctions_8h_source.html#l01346">DGtal::functions::setops::operator&amp;=()</a>.</p>
<div class="fragment"><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;    {</div><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;        ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;        ( <span class="keywordtype">bool</span>, isOrdered = ordered </div><div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;          || ( isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value ) );</div><div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;</div><div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">        ::assignIntersection</a>( S1, S2 );</div><div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;    }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl</a></div><div class="ttdoc">Aim: Specialize set operations (union, intersection, difference, symmetric_difference) according to t...</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00234">SetFunctions.h:234</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a03568b922cfd14ec380c2b297af70dff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container&amp; DGtal::functions::assignIntersection </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set intersection operation. Updates the set <em>S1</em> as \( S1 \cap S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, \( S1 \cap S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SetFunctions_8h_source.html#l01104">1104</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>

<p>References <a class="el" href="SetFunctions_8h_source.html#l01082">assignIntersection()</a>.</p>
<div class="fragment"><div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;    {</div><div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;        ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;        ( <span class="keywordtype">bool</span>, isOrdered = isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;</div><div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">        ::assignIntersection</a>( S1, S2 );</div><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;    }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl</a></div><div class="ttdoc">Aim: Specialize set operations (union, intersection, difference, symmetric_difference) according to t...</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00234">SetFunctions.h:234</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a65694ad895f3f4cb42c54213fce7295a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container&amp; DGtal::functions::assignSymmetricDifference </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set symmetric difference operation. Updates the set <em>S1</em> as \( S1 \Delta S2 \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, \( S1 \Delta S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SetFunctions_8h_source.html#l01176">1176</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>

<p>References <a class="el" href="SetFunctions_8h_source.html#l01176">assignSymmetricDifference()</a>.</p>

<p>Referenced by <a class="el" href="SetFunctions_8h_source.html#l01176">assignSymmetricDifference()</a>, <a class="el" href="SetFunctions_8h_source.html#l01243">makeSymmetricDifference()</a>, and <a class="el" href="SetFunctions_8h_source.html#l01378">DGtal::functions::setops::operator^=()</a>.</p>
<div class="fragment"><div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;    {</div><div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;        ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;        ( <span class="keywordtype">bool</span>, isOrdered = ordered </div><div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;          || ( isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value ) );</div><div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;</div><div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">        ::assignSymmetricDifference</a>( S1, S2 );</div><div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;    }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl</a></div><div class="ttdoc">Aim: Specialize set operations (union, intersection, difference, symmetric_difference) according to t...</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00234">SetFunctions.h:234</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a20e5c37c5f1aaade38460038220ce4fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container&amp; DGtal::functions::assignSymmetricDifference </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set symmetric difference operation. Updates the set <em>S1</em> as \( S1 \Delta S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, \( S1 \Delta S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SetFunctions_8h_source.html#l01198">1198</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>

<p>References <a class="el" href="SetFunctions_8h_source.html#l01176">assignSymmetricDifference()</a>.</p>
<div class="fragment"><div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;    {</div><div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;        ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;        ( <span class="keywordtype">bool</span>, isOrdered = isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;</div><div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">        ::assignSymmetricDifference</a>( S1, S2 );</div><div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;    }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl</a></div><div class="ttdoc">Aim: Specialize set operations (union, intersection, difference, symmetric_difference) according to t...</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00234">SetFunctions.h:234</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac58ca694e397fb84d77c53aba2134887"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container&amp; DGtal::functions::assignUnion </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set union operation. Updates the set <em>S1</em> as \( S1 \cup S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, \( S1 \cup S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SetFunctions_8h_source.html#l00990">990</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>

<p>References <a class="el" href="SetFunctions_8h_source.html#l00990">assignUnion()</a>.</p>

<p>Referenced by <a class="el" href="SetFunctions_8h_source.html#l00990">assignUnion()</a>, <a class="el" href="SetFunctions_8h_source.html#l01057">makeUnion()</a>, and <a class="el" href="SetFunctions_8h_source.html#l01317">DGtal::functions::setops::operator|=()</a>.</p>
<div class="fragment"><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;    {</div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;        ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;        ( <span class="keywordtype">bool</span>, isOrdered = ordered </div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;          || ( isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value ) );</div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">        ::assignUnion</a>( S1, S2 );</div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;    }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl</a></div><div class="ttdoc">Aim: Specialize set operations (union, intersection, difference, symmetric_difference) according to t...</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00234">SetFunctions.h:234</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4932db4b89711ecfc43c950766c8a3c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container&amp; DGtal::functions::assignUnion </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set union operation. Updates the set <em>S1</em> as \( S1 \cup S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input set, \( S1 \cup S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SetFunctions_8h_source.html#l01012">1012</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>

<p>References <a class="el" href="SetFunctions_8h_source.html#l00990">assignUnion()</a>.</p>
<div class="fragment"><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;    {</div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;        ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;      BOOST_STATIC_CONSTANT</div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;        ( <span class="keywordtype">bool</span>, isOrdered = isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;</div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">        ::assignUnion</a>( S1, S2 );</div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;    }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl</a></div><div class="ttdoc">Aim: Specialize set operations (union, intersection, difference, symmetric_difference) according to t...</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00234">SetFunctions.h:234</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a612e2adbf3983c441753beb63fd55f86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::checkAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;&#160;</td>
          <td class="paramname"><em>aDSS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether a DSS is valid or not. NB: in logarithmic time (in order to check that a and b are relatively prime) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDSS</td><td>any DSS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if valid, 'false' otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a6e4fa6a6be77e4813577c8a2b3572299"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::checkOnePoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;&#160;</td>
          <td class="paramname"><em>aDSS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks the validity of the DSS when it contains only one point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDSS</td><td>any DSS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>the DSS contains only one point </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the DSS is valid, 'false' otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b421081da133e4069fe9cbddf33aa54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::checkPointsPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;&#160;</td>
          <td class="paramname"><em>aDSS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that the difference between two extremal upper (resp. lower) leaning points is equal to the direction vector (a,b) scaled by an integer. Checks that there is no pattern between end points and extremal leaning points. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDSS</td><td>any DSS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>the DSS contains more than one point, ie a and b are not both null. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if ok, 'false' otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e697b1094865df340ba6206354f7c37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCoordinate , typename TInteger , unsigned short adjacency&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::checkPointsRemainder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TCoordinate, TInteger, adjacency &gt; &amp;&#160;</td>
          <td class="paramname"><em>aDSS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks the consistency between the parameters and the leaning points: first and last upper leaning points should have a remainder equal to mu while firsta and last lower leaning points should have a remainder equal to mu + omega - 1. Moreover, front and back points should have a remainder lying within the range [mu, mu+omega[. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDSS</td><td>any DSS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>the DSS contains more than one point, ie a and b are not both null. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if this property is fulfilled, 'false' otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a72edc3d9d652158c3d02a6a11386f249"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer , typename CellConstIterator , typename CellMapIteratorPriority &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5">uint64_t</a> DGtal::functions::collapse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CellConstIterator&#160;</td>
          <td class="paramname"><em>S_itB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CellConstIterator&#160;</td>
          <td class="paramname"><em>S_itE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CellMapIteratorPriority &amp;&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hintIsSClosed</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hintIsKClosed</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collapse a user-specified part of complex <em>K</em>, collapsing cells following priority [priority], in a decreasing sequence until no more collapse is feasible. The range [<em>S_itb</em>,<em>S_itE</em>) provides the starting cells, generally (but not compulsory) maximal cells. The resulting complex is guaranteed to keep the same homotopy type (a kind of topology equivalence).</p>
<dl class="section note"><dt>Note</dt><dd>Cells whose data has been marked as FIXED are not removed.</dd>
<dd>
Only cells that are in the closure of [<em>S_itb</em>,<em>S_itE</em>) may be removed, and only if they are not marked as FIXED.</dd></dl>
<dl class="section user"><dt>Advanced:</dt><dd>If you use a DefaultCellMapIteratorPriority object as <em>priority</em>, then the VALUE part of each cell data defines the priority (the highest value the soonest are these cells collapsed). You may thus fill these cell values before calling this method.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
    <tr><td class="paramname">CellConstIterator</td><td>any forward const iterator on Cell.</td></tr>
    <tr><td class="paramname">CellMapIteratorPriority</td><td>any type defining a method 'bool operator()( const Cell&amp;, const Cell&amp;) const'. Defines the order in which cells are collapsed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>DefaultCellMapIteratorPriority</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">K</td><td>the complex that is collapsed. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">S_itB</td><td>the start of a range of cells which is included in [K]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">S_itE</td><td>the end of a range of cells which is included in [K]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">priority</td><td>the object that assign a priority to each cell. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">hintIsSClosed</td><td>indicates if [<em>S_itb</em>,<em>S_ite</em>) is a closed set (faster in this case). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">hintIsKClosed</td><td>indicates that complex <em>K</em> is closed. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">verbose</td><td>outputs some information during processing when 'true'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of cells removed from complex <em>K</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cubical-complex-collapse_8cpp_source.html">topology/cubical-complex-collapse.cpp</a> </dd></dl>

<p>Referenced by <a class="el" href="CubicalComplexFunctions_8h_source.html#l00341">operator&gt;=()</a>.</p>

</div>
</div>
<a class="anchor" id="a4828e0475cb9aa8dceefa94f0ab4d168"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T DGtal::functions::cube </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value x * x * x </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>a type with the multiply operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>any value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value x * x * x </dd></dl>

<p>Definition at line <a class="el" href="BasicMathFunctions_8h_source.html#l00144">144</a> of file <a class="el" href="BasicMathFunctions_8h_source.html">BasicMathFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    { <span class="keywordflow">return</span> x * x * x; }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8066d9f6db356f21fac91f53ffdde53d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer , typename BdryCellOutputIterator , typename InnerCellOutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DGtal::functions::filterCellsWithinBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TKSpace::Point &amp;&#160;</td>
          <td class="paramname"><em>kLow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TKSpace::Point &amp;&#160;</td>
          <td class="paramname"><em>kUp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BdryCellOutputIterator&#160;</td>
          <td class="paramname"><em>itBdry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerCellOutputIterator&#160;</td>
          <td class="paramname"><em>itInner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the cells of the given complex <em>K</em> that lies on the boundary or inside the parallelepiped specified by bounds <em>kLow</em> and <em>kUp</em>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
    <tr><td class="paramname">BdryCellOutputIterator</td><td>any output iterator on TCubicalComplex::Cell. </td></tr>
    <tr><td class="paramname">InnerCellOutputIterator</td><td>any output iterator on TCubicalComplex::Cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>any cubical complex.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kLow</td><td>any Khalimsky coordinate representing the lowest possible cell.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kUp</td><td>any Khalimsky coordinate representing the uppermost possible cell.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">itBdry</td><td>An output iterator on Cell that outputs all the cells of <em>K</em> that lie on the boundary of the parallelepiped specified by bounds <em>kLow</em> and <em>kUp</em>.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">itInner</td><td>An output iterator on Cell that outputs all the cells of <em>K</em> that lie in the interior of the parallelepiped specified by bounds <em>kLow</em> and <em>kUp</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Complexity is linear in the number of cells of <em>K</em> (but the constant is also linear in the dimension of <em>K</em>). </dd></dl>

<p>Referenced by <a class="el" href="CubicalComplexFunctions_8h_source.html#l00341">operator&gt;=()</a>.</p>

</div>
</div>
<a class="anchor" id="a82988f18c989530f73dab774abe12c90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::isEqual </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equality test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff <em>S1</em> is equal to <em>S2</em> (i.e. <em>S1</em> is a subset of <em>S2</em> and <em>S2</em> is a subset of <em>S1</em>).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SetFunctions_8h_source.html#l00789">789</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>

<p>References <a class="el" href="SetFunctions_8h_source.html#l00789">isEqual()</a>.</p>

<p>Referenced by <a class="el" href="SetFunctions_8h_source.html#l00789">isEqual()</a>, <a class="el" href="CubicalComplexFunctions_8h_source.html#l00294">operator!=()</a>, and <a class="el" href="CubicalComplexFunctions_8h_source.html#l00267">operator==()</a>.</p>
<div class="fragment"><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;      {</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;        BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;        BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;          ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;        BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;          ( <span class="keywordtype">bool</span>, isOrdered = ordered </div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;            || ( isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value ) );</div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;        </div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">          ::isEqual</a>( S1, S2 );</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;      }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl</a></div><div class="ttdoc">Aim: Specialize set operations (union, intersection, difference, symmetric_difference) according to t...</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00234">SetFunctions.h:234</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adbef166c5a788624eff4f09e596c09f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::isEqual </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equality test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff <em>S1</em> is equal to <em>S2</em> (i.e. <em>S1</em> is a subset of <em>S2</em> and <em>S2</em> is a subset of <em>S1</em>).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SetFunctions_8h_source.html#l00815">815</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>

<p>References <a class="el" href="SetFunctions_8h_source.html#l00789">isEqual()</a>.</p>
<div class="fragment"><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;      {</div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;        BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;        BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;          ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;        BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;          ( <span class="keywordtype">bool</span>, isOrdered = isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;        </div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">          ::isEqual</a>( S1, S2 );</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;      }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl</a></div><div class="ttdoc">Aim: Specialize set operations (union, intersection, difference, symmetric_difference) according to t...</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00234">SetFunctions.h:234</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac7e98eb410830e5ca846260e66bff422"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::isSubset </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inclusion test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff <em>S1</em> is a subset of <em>S2</em>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SetFunctions_8h_source.html#l00845">845</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>

<p>References <a class="el" href="SetFunctions_8h_source.html#l00845">isSubset()</a>.</p>

<p>Referenced by <a class="el" href="SetFunctions_8h_source.html#l00845">isSubset()</a>, <a class="el" href="CubicalComplexFunctions_8h_source.html#l00318">operator&lt;=()</a>, and <a class="el" href="CubicalComplexFunctions_8h_source.html#l00341">operator&gt;=()</a>.</p>
<div class="fragment"><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;      {</div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;        BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;        BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;          ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;        BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;          ( <span class="keywordtype">bool</span>, isOrdered = ordered </div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;            || ( isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value ) );</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;        </div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">          ::isSubset</a>( S1, S2 );</div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;      }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl</a></div><div class="ttdoc">Aim: Specialize set operations (union, intersection, difference, symmetric_difference) according to t...</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00234">SetFunctions.h:234</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad171e7dc7973f3fc0ee8363712059124"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::isSubset </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inclusion test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff <em>S1</em> is a subset of <em>S2</em>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SetFunctions_8h_source.html#l00869">869</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>

<p>References <a class="el" href="SetFunctions_8h_source.html#l00845">isSubset()</a>.</p>
<div class="fragment"><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;      {</div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;        BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;        BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;          ( <span class="keywordtype">bool</span>, isAssociative = IsAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;        BOOST_STATIC_CONSTANT</div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;          ( <span class="keywordtype">bool</span>, isOrdered = isAssociative &amp;&amp; IsOrderedAssociativeContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;        </div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl&lt; Container, isAssociative, isOrdered &gt;</a></div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;<a class="code" href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">          ::isSubset</a>( S1, S2 );</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;      }</div><div class="ttc" id="structDGtal_1_1detail_1_1SetFunctionsImpl_html"><div class="ttname"><a href="structDGtal_1_1detail_1_1SetFunctionsImpl.html">DGtal::detail::SetFunctionsImpl</a></div><div class="ttdoc">Aim: Specialize set operations (union, intersection, difference, symmetric_difference) according to t...</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00234">SetFunctions.h:234</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adc5faa4fb283d3dd8b530f1aa46e1303"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeDifference </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set difference operation. Returns the difference of <em>S1</em> - <em>S2</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set <em>S1</em> - <em>S2</em>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SetFunctions_8h_source.html#l00946">946</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>

<p>References <a class="el" href="SetFunctions_8h_source.html#l00946">makeDifference()</a>.</p>

<p>Referenced by <a class="el" href="SetFunctions_8h_source.html#l00946">makeDifference()</a>, and <a class="el" href="SetFunctions_8h_source.html#l01288">DGtal::functions::setops::operator-()</a>.</p>
<div class="fragment"><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;    {</div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;      Container S( S1 );</div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;      assignDifference&lt;Container, ordered&gt;( S, S2 );</div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;      <span class="keywordflow">return</span> S;</div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acba16c21435994b725465e08cb77a9fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeDifference </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set difference operation. Returns the difference of <em>S1</em> - <em>S2</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set <em>S1</em> - <em>S2</em>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SetFunctions_8h_source.html#l00965">965</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>

<p>References <a class="el" href="SetFunctions_8h_source.html#l00896">assignDifference()</a>, and <a class="el" href="SetFunctions_8h_source.html#l00946">makeDifference()</a>.</p>
<div class="fragment"><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;    {</div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;      Container S( S1 );</div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;      <a class="code" href="namespaceDGtal_1_1functions.html#ac97099c06241a42dce86a53230b665d7">assignDifference</a>( S, S2 );</div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;      <span class="keywordflow">return</span> S;</div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;    }</div><div class="ttc" id="namespaceDGtal_1_1functions_html_ac97099c06241a42dce86a53230b665d7"><div class="ttname"><a href="namespaceDGtal_1_1functions.html#ac97099c06241a42dce86a53230b665d7">DGtal::functions::assignDifference</a></div><div class="ttdeci">Container &amp; assignDifference(Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00896">SetFunctions.h:896</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8de7a7bd0c7511d57569c794cff3a113"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeIntersection </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set intersection operation. Returns the set \( S1 \cap S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set \( S1 \cap S2 \).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SetFunctions_8h_source.html#l01131">1131</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>

<p>References <a class="el" href="SetFunctions_8h_source.html#l01131">makeIntersection()</a>.</p>

<p>Referenced by <a class="el" href="SetFunctions_8h_source.html#l01131">makeIntersection()</a>, and <a class="el" href="SetFunctions_8h_source.html#l01332">DGtal::functions::setops::operator&amp;()</a>.</p>
<div class="fragment"><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;    {</div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;      Container S( S1 );</div><div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;      assignIntersection&lt;Container, ordered&gt;( S, S2 );</div><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;      <span class="keywordflow">return</span> S;</div><div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6d93770c72e70791aa57c47d22c982b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeIntersection </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set intersection operation. Returns the set \( S1 \cap S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set \( S1 \cap S2 \).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SetFunctions_8h_source.html#l01149">1149</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>

<p>References <a class="el" href="SetFunctions_8h_source.html#l01082">assignIntersection()</a>, and <a class="el" href="SetFunctions_8h_source.html#l01131">makeIntersection()</a>.</p>
<div class="fragment"><div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;    {</div><div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;      Container S( S1 );</div><div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;      <a class="code" href="namespaceDGtal_1_1functions.html#af3360043e7032e9a8eaf2ef0fde60afd">assignIntersection</a>( S, S2 );</div><div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;      <span class="keywordflow">return</span> S;</div><div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;    }</div><div class="ttc" id="namespaceDGtal_1_1functions_html_af3360043e7032e9a8eaf2ef0fde60afd"><div class="ttname"><a href="namespaceDGtal_1_1functions.html#af3360043e7032e9a8eaf2ef0fde60afd">DGtal::functions::assignIntersection</a></div><div class="ttdeci">Container &amp; assignIntersection(Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l01082">SetFunctions.h:1082</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a03f0a6573a95aa152c8b8320baee6884"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeSymmetricDifference </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set symmetric difference operation. Returns the set \( S1 \Delta S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set \( S1 \Delta S2 \).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SetFunctions_8h_source.html#l01225">1225</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>

<p>References <a class="el" href="SetFunctions_8h_source.html#l01225">makeSymmetricDifference()</a>.</p>

<p>Referenced by <a class="el" href="SetFunctions_8h_source.html#l01225">makeSymmetricDifference()</a>, and <a class="el" href="SetFunctions_8h_source.html#l01362">DGtal::functions::setops::operator^()</a>.</p>
<div class="fragment"><div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;    {</div><div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;      Container S( S1 );</div><div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;      assignSymmetricDifference&lt;Container, ordered&gt;( S, S2 );</div><div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;      <span class="keywordflow">return</span> S;</div><div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aacd11e737e0c019de78553ae847a5724"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeSymmetricDifference </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set symmetric difference operation. Returns the set \( S1 \Delta S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set \( S1 \Delta S2 \).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SetFunctions_8h_source.html#l01243">1243</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>

<p>References <a class="el" href="SetFunctions_8h_source.html#l01176">assignSymmetricDifference()</a>, and <a class="el" href="SetFunctions_8h_source.html#l01225">makeSymmetricDifference()</a>.</p>
<div class="fragment"><div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;    {</div><div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;      Container S( S1 );</div><div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;      <a class="code" href="namespaceDGtal_1_1functions.html#a65694ad895f3f4cb42c54213fce7295a">assignSymmetricDifference</a>( S, S2 );</div><div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;      <span class="keywordflow">return</span> S;</div><div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;    }</div><div class="ttc" id="namespaceDGtal_1_1functions_html_a65694ad895f3f4cb42c54213fce7295a"><div class="ttname"><a href="namespaceDGtal_1_1functions.html#a65694ad895f3f4cb42c54213fce7295a">DGtal::functions::assignSymmetricDifference</a></div><div class="ttdeci">Container &amp; assignSymmetricDifference(Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l01176">SetFunctions.h:1176</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af848d0d5748af67bcb76b3d5e1f616cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , bool ordered&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeUnion </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set union operation. Returns the set \( S1 \cup S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set \( S1 \cup S2 \).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc).</td></tr>
    <tr><td class="paramname">ordered</td><td>when 'true', the user indicates that values are ordered (e.g. a sorted vector), otherwise, depending on the container type, the compiler may still determine that values are ordered. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SetFunctions_8h_source.html#l01039">1039</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>

<p>References <a class="el" href="SetFunctions_8h_source.html#l01039">makeUnion()</a>.</p>

<p>Referenced by <a class="el" href="SetFunctions_8h_source.html#l01039">makeUnion()</a>, and <a class="el" href="SetFunctions_8h_source.html#l01303">DGtal::functions::setops::operator|()</a>.</p>
<div class="fragment"><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;    {</div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;      Container S( S1 );</div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;      assignUnion&lt;Container, ordered&gt;( S, S2 );</div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;      <span class="keywordflow">return</span> S;</div><div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af462fb1f5ceade012f0e97831e3d8e64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container DGtal::functions::makeUnion </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set union operation. Returns the set \( S1 \cup S2 \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set \( S1 \cup S2 \).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>any type of container (even a sequence, a set, an unordered_set, a map, etc). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SetFunctions_8h_source.html#l01057">1057</a> of file <a class="el" href="SetFunctions_8h_source.html">SetFunctions.h</a>.</p>

<p>References <a class="el" href="SetFunctions_8h_source.html#l00990">assignUnion()</a>, and <a class="el" href="SetFunctions_8h_source.html#l01039">makeUnion()</a>.</p>
<div class="fragment"><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;    {</div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;      BOOST_STATIC_ASSERT( IsContainer&lt; Container &gt;::value );</div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;      Container S( S1 );</div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;      <a class="code" href="namespaceDGtal_1_1functions.html#ac58ca694e397fb84d77c53aba2134887">assignUnion</a>( S, S2 );</div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;      <span class="keywordflow">return</span> S;</div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;    }</div><div class="ttc" id="namespaceDGtal_1_1functions_html_ac58ca694e397fb84d77c53aba2134887"><div class="ttname"><a href="namespaceDGtal_1_1functions.html#ac58ca694e397fb84d77c53aba2134887">DGtal::functions::assignUnion</a></div><div class="ttdeci">Container &amp; assignUnion(Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00990">SetFunctions.h:990</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a93277b98c78598b1057e678c1066848d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Difference test.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input cubical complex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff <em>S1</em> is not equal to <em>S2</em> (i.e. either <em>S1</em> is not a subcomplex of <em>S2</em> or <em>S2</em> is not a subcomplex of <em>S1</em>). </dd></dl>

<p>Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00294">294</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>

<p>References <a class="el" href="CubicalComplex_8h_source.html#l00216">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::dimension</a>, <a class="el" href="SetFunctions_8h_source.html#l00789">isEqual()</a>, <a class="el" href="CubicalComplex_8h_source.html#l01253">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>, and <a class="el" href="classDGtal_1_1CubicalComplex.html#a5f1b0344086dc77ed816ab4386493bb7">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::space()</a>.</p>
<div class="fragment"><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    {</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;      <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="classDGtal_1_1CubicalComplex.html">CC</a>;</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;      ASSERT( &amp;(S1.space()) == &amp;(S2.space()) );</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;      <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= <a class="code" href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">CC::dimension</a>; ++i )</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;        <span class="keywordflow">if</span> ( ! <a class="code" href="namespaceDGtal_1_1functions.html#a82988f18c989530f73dab774abe12c90">isEqual</a>( S1.myCells[ i ], S2.myCells[ i ] ) )</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;          <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    }</div><div class="ttc" id="classDGtal_1_1CubicalComplex_html"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html">DGtal::CubicalComplex</a></div><div class="ttdoc">Aim: This class represents an arbitrary cubical complex living in some Khalimsky space. Cubical complexes are sets of cells of different dimensions related together with incidence relations. Two cells in a cubical complex are incident if and only if they are incident in the surrounding Khalimsky space. In other words, cubical complexes are defined here as subsets of Khalimsky spaces. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00084">CubicalComplex.h:84</a></div></div>
<div class="ttc" id="namespaceDGtal_1_1functions_html_a82988f18c989530f73dab774abe12c90"><div class="ttname"><a href="namespaceDGtal_1_1functions.html#a82988f18c989530f73dab774abe12c90">DGtal::functions::isEqual</a></div><div class="ttdeci">bool isEqual(const Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00789">SetFunctions.h:789</a></div></div>
<div class="ttc" id="classDGtal_1_1CubicalComplex_html_ac4a7b9f7a80e6bd5415cd0792b5f5797"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">DGtal::CubicalComplex::dimension</a></div><div class="ttdeci">static const Dimension dimension</div><div class="ttdoc">The dimension of the embedding space. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00216">CubicalComplex.h:216</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adc70acf08a32615d9b6dc8bf46b21bcd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; DGtal::functions::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cubical Complex intersection operation. Returns the cubical complex \( S1 \cap S2 \). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input cubical complex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the cubical complex \( S1 \cap S2 \). </dd></dl>

<p>Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00181">181</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>

<p>References <a class="el" href="CubicalComplex_8h_source.html#l00216">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::dimension</a>, and <a class="el" href="CubicalComplex_8h_source.html#l01253">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>.</p>
<div class="fragment"><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    {</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;      <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="classDGtal_1_1CubicalComplex.html">CC</a>;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;      CC S( S1 );</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;      <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= <a class="code" href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">CC::dimension</a>; ++i )</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;        setops::operator&amp;=( S.myCells[ i ], S2.myCells[ i ] );</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;      <span class="keywordflow">return</span> S;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    }</div><div class="ttc" id="classDGtal_1_1CubicalComplex_html"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html">DGtal::CubicalComplex</a></div><div class="ttdoc">Aim: This class represents an arbitrary cubical complex living in some Khalimsky space. Cubical complexes are sets of cells of different dimensions related together with incidence relations. Two cells in a cubical complex are incident if and only if they are incident in the surrounding Khalimsky space. In other words, cubical complexes are defined here as subsets of Khalimsky spaces. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00084">CubicalComplex.h:84</a></div></div>
<div class="ttc" id="classDGtal_1_1CubicalComplex_html_ac4a7b9f7a80e6bd5415cd0792b5f5797"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">DGtal::CubicalComplex::dimension</a></div><div class="ttdeci">static const Dimension dimension</div><div class="ttdoc">The dimension of the embedding space. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00216">CubicalComplex.h:216</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aab6b49b5903838abae2b567991bd53c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp; DGtal::functions::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cubical Complex intersection operation. Updates the cubical complex <em>S1</em> as \( S1 \cap S2 \). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input cubical complex, \( S1 \cap S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the modified cubical complex S1. </dd></dl>

<p>Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00202">202</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>

<p>References <a class="el" href="CubicalComplex_8h_source.html#l00216">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::dimension</a>, and <a class="el" href="CubicalComplex_8h_source.html#l01253">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>.</p>
<div class="fragment"><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    {</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;      <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="classDGtal_1_1CubicalComplex.html">CC</a>;</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;      <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= <a class="code" href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">CC::dimension</a>; ++i )</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        setops::operator&amp;=( S1.myCells[ i ], S2.myCells[ i ] );</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;      <span class="keywordflow">return</span> S1;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    }</div><div class="ttc" id="classDGtal_1_1CubicalComplex_html"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html">DGtal::CubicalComplex</a></div><div class="ttdoc">Aim: This class represents an arbitrary cubical complex living in some Khalimsky space. Cubical complexes are sets of cells of different dimensions related together with incidence relations. Two cells in a cubical complex are incident if and only if they are incident in the surrounding Khalimsky space. In other words, cubical complexes are defined here as subsets of Khalimsky spaces. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00084">CubicalComplex.h:84</a></div></div>
<div class="ttc" id="classDGtal_1_1CubicalComplex_html_ac4a7b9f7a80e6bd5415cd0792b5f5797"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">DGtal::CubicalComplex::dimension</a></div><div class="ttdeci">static const Dimension dimension</div><div class="ttdoc">The dimension of the embedding space. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00216">CubicalComplex.h:216</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa66f96d40ea286f17345ce9dc6c16769"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; DGtal::functions::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cubical Complex open operation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input cubical complex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new cubical complex that is the opening of S1. </dd></dl>

<p>Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00079">79</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>

<p>References <a class="el" href="classDGtal_1_1CubicalComplex.html#aaf566fbbd9e2e68c631b7ff826770eb5">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::open()</a>.</p>
<div class="fragment"><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    {</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;      CubicalComplex&lt; TKSpace, TCellContainer &gt; S( S1 );</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;      S.open();</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;      <span class="keywordflow">return</span> S;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2192cfe9f2c9b5d3b3ae1e11e74696d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; DGtal::functions::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cubical Complex difference operation. Returns the difference of <em>S1</em> - <em>S2</em>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input cubical complex </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the cubical complex <em>S1</em> - <em>S2</em>. </dd></dl>

<p>Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00119">119</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>

<p>References <a class="el" href="CubicalComplex_8h_source.html#l00216">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::dimension</a>, and <a class="el" href="CubicalComplex_8h_source.html#l01253">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>.</p>
<div class="fragment"><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    {</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;      <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="classDGtal_1_1CubicalComplex.html">CC</a>;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;      CC S( S1 );</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;      <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= <a class="code" href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">CC::dimension</a>; ++i )</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        setops::operator-=( S.myCells[ i ],S2.myCells[ i ] );</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;      <span class="keywordflow">return</span> S;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    }</div><div class="ttc" id="classDGtal_1_1CubicalComplex_html"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html">DGtal::CubicalComplex</a></div><div class="ttdoc">Aim: This class represents an arbitrary cubical complex living in some Khalimsky space. Cubical complexes are sets of cells of different dimensions related together with incidence relations. Two cells in a cubical complex are incident if and only if they are incident in the surrounding Khalimsky space. In other words, cubical complexes are defined here as subsets of Khalimsky spaces. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00084">CubicalComplex.h:84</a></div></div>
<div class="ttc" id="classDGtal_1_1CubicalComplex_html_ac4a7b9f7a80e6bd5415cd0792b5f5797"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">DGtal::CubicalComplex::dimension</a></div><div class="ttdeci">static const Dimension dimension</div><div class="ttdoc">The dimension of the embedding space. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00216">CubicalComplex.h:216</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae84b034580c878cf0e6793c13af5d6dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp; DGtal::functions::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cubical Complex difference operation. Updates the cubical complex S1 as S1 - S2. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input cubical complex, <em>S1</em> - <em>S2</em> as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the modified cubical complex S1. </dd></dl>

<p>Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00098">98</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>

<p>References <a class="el" href="CubicalComplex_8h_source.html#l00216">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::dimension</a>, and <a class="el" href="CubicalComplex_8h_source.html#l01253">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>.</p>
<div class="fragment"><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    {</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;      <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="classDGtal_1_1CubicalComplex.html">CC</a>;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;      <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= <a class="code" href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">CC::dimension</a>; ++i )</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        setops::operator-=( S1.myCells[ i ],S2.myCells[ i ] );</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;      <span class="keywordflow">return</span> S1;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    }</div><div class="ttc" id="classDGtal_1_1CubicalComplex_html"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html">DGtal::CubicalComplex</a></div><div class="ttdoc">Aim: This class represents an arbitrary cubical complex living in some Khalimsky space. Cubical complexes are sets of cells of different dimensions related together with incidence relations. Two cells in a cubical complex are incident if and only if they are incident in the surrounding Khalimsky space. In other words, cubical complexes are defined here as subsets of Khalimsky spaces. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00084">CubicalComplex.h:84</a></div></div>
<div class="ttc" id="classDGtal_1_1CubicalComplex_html_ac4a7b9f7a80e6bd5415cd0792b5f5797"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">DGtal::CubicalComplex::dimension</a></div><div class="ttdeci">static const Dimension dimension</div><div class="ttdoc">The dimension of the embedding space. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00216">CubicalComplex.h:216</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aeab33aff5419600defbb447146e533c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inclusion test (subset of).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input cubical complex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff <em>S1</em> is a subcomplex of <em>S2</em>. </dd></dl>

<p>Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00318">318</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>

<p>References <a class="el" href="CubicalComplex_8h_source.html#l00216">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::dimension</a>, and <a class="el" href="SetFunctions_8h_source.html#l00845">isSubset()</a>.</p>
<div class="fragment"><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    {</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;      <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="classDGtal_1_1CubicalComplex.html">CC</a>;</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;      ASSERT( &amp;(S1.space()) == &amp;(S2.space()) );</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;      <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= <a class="code" href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">CC::dimension</a>; ++i )</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        <span class="keywordflow">if</span> ( ! <a class="code" href="namespaceDGtal_1_1functions.html#ac7e98eb410830e5ca846260e66bff422">isSubset</a>( S1.myCells[ i ], S2.myCells[ i ] ) )</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;          <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    }</div><div class="ttc" id="classDGtal_1_1CubicalComplex_html"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html">DGtal::CubicalComplex</a></div><div class="ttdoc">Aim: This class represents an arbitrary cubical complex living in some Khalimsky space. Cubical complexes are sets of cells of different dimensions related together with incidence relations. Two cells in a cubical complex are incident if and only if they are incident in the surrounding Khalimsky space. In other words, cubical complexes are defined here as subsets of Khalimsky spaces. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00084">CubicalComplex.h:84</a></div></div>
<div class="ttc" id="namespaceDGtal_1_1functions_html_ac7e98eb410830e5ca846260e66bff422"><div class="ttname"><a href="namespaceDGtal_1_1functions.html#ac7e98eb410830e5ca846260e66bff422">DGtal::functions::isSubset</a></div><div class="ttdeci">bool isSubset(const Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00845">SetFunctions.h:845</a></div></div>
<div class="ttc" id="classDGtal_1_1CubicalComplex_html_ac4a7b9f7a80e6bd5415cd0792b5f5797"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">DGtal::CubicalComplex::dimension</a></div><div class="ttdeci">static const Dimension dimension</div><div class="ttdoc">The dimension of the embedding space. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00216">CubicalComplex.h:216</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a56c93bd91d630dec05aeaa56370213a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equality test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input cubical complex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff <em>S1</em> is equal to <em>S2</em> (i.e. <em>S1</em> is a subcomplex of <em>S2</em> and <em>S2</em> is a subcomplex of <em>S1</em>). </dd></dl>

<p>Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00267">267</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>

<p>References <a class="el" href="CubicalComplex_8h_source.html#l00216">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::dimension</a>, <a class="el" href="SetFunctions_8h_source.html#l00789">isEqual()</a>, <a class="el" href="CubicalComplex_8h_source.html#l01253">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>, and <a class="el" href="classDGtal_1_1CubicalComplex.html#a5f1b0344086dc77ed816ab4386493bb7">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::space()</a>.</p>
<div class="fragment"><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    {</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;      <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="classDGtal_1_1CubicalComplex.html">CC</a>;</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;      ASSERT( &amp;(S1.space()) == &amp;(S2.space()) );</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;      <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= <a class="code" href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">CC::dimension</a>; ++i )</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;        <span class="keywordflow">if</span> ( ! <a class="code" href="namespaceDGtal_1_1functions.html#a82988f18c989530f73dab774abe12c90">isEqual</a>( S1.myCells[ i ], S2.myCells[ i ] ) )</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;          <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;    }</div><div class="ttc" id="classDGtal_1_1CubicalComplex_html"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html">DGtal::CubicalComplex</a></div><div class="ttdoc">Aim: This class represents an arbitrary cubical complex living in some Khalimsky space. Cubical complexes are sets of cells of different dimensions related together with incidence relations. Two cells in a cubical complex are incident if and only if they are incident in the surrounding Khalimsky space. In other words, cubical complexes are defined here as subsets of Khalimsky spaces. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00084">CubicalComplex.h:84</a></div></div>
<div class="ttc" id="namespaceDGtal_1_1functions_html_a82988f18c989530f73dab774abe12c90"><div class="ttname"><a href="namespaceDGtal_1_1functions.html#a82988f18c989530f73dab774abe12c90">DGtal::functions::isEqual</a></div><div class="ttdeci">bool isEqual(const Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00789">SetFunctions.h:789</a></div></div>
<div class="ttc" id="classDGtal_1_1CubicalComplex_html_ac4a7b9f7a80e6bd5415cd0792b5f5797"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">DGtal::CubicalComplex::dimension</a></div><div class="ttdeci">static const Dimension dimension</div><div class="ttdoc">The dimension of the embedding space. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00216">CubicalComplex.h:216</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8dbd4654807b58176f0a7aa25edc9173"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inclusion test (supset of).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input cubical complex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff <em>S2</em> is a subcomplex of <em>S1</em>. </dd></dl>

<p>Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00341">341</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>

<p>References <a class="el" href="namespaceDGtal_1_1functions.html#a72edc3d9d652158c3d02a6a11386f249">collapse()</a>, <a class="el" href="CubicalComplex_8h_source.html#l00216">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::dimension</a>, <a class="el" href="namespaceDGtal_1_1functions.html#a8066d9f6db356f21fac91f53ffdde53d">filterCellsWithinBounds()</a>, <a class="el" href="SetFunctions_8h_source.html#l00845">isSubset()</a>, <a class="el" href="CubicalComplex_8h_source.html#l01253">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>, and <a class="el" href="classDGtal_1_1CubicalComplex.html#a5f1b0344086dc77ed816ab4386493bb7">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::space()</a>.</p>
<div class="fragment"><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    {</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;      <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="classDGtal_1_1CubicalComplex.html">CC</a>;</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;      ASSERT( &amp;(S1.space()) == &amp;(S2.space()) );</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;      <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= <a class="code" href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">CC::dimension</a>; ++i )</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;        <span class="keywordflow">if</span> ( ! <a class="code" href="namespaceDGtal_1_1functions.html#ac7e98eb410830e5ca846260e66bff422">isSubset</a>( S2.myCells[ i ], S1.myCells[ i ] ) )</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;          <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    }</div><div class="ttc" id="classDGtal_1_1CubicalComplex_html"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html">DGtal::CubicalComplex</a></div><div class="ttdoc">Aim: This class represents an arbitrary cubical complex living in some Khalimsky space. Cubical complexes are sets of cells of different dimensions related together with incidence relations. Two cells in a cubical complex are incident if and only if they are incident in the surrounding Khalimsky space. In other words, cubical complexes are defined here as subsets of Khalimsky spaces. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00084">CubicalComplex.h:84</a></div></div>
<div class="ttc" id="namespaceDGtal_1_1functions_html_ac7e98eb410830e5ca846260e66bff422"><div class="ttname"><a href="namespaceDGtal_1_1functions.html#ac7e98eb410830e5ca846260e66bff422">DGtal::functions::isSubset</a></div><div class="ttdeci">bool isSubset(const Container &amp;S1, const Container &amp;S2)</div><div class="ttdef"><b>Definition:</b> <a href="SetFunctions_8h_source.html#l00845">SetFunctions.h:845</a></div></div>
<div class="ttc" id="classDGtal_1_1CubicalComplex_html_ac4a7b9f7a80e6bd5415cd0792b5f5797"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">DGtal::CubicalComplex::dimension</a></div><div class="ttdeci">static const Dimension dimension</div><div class="ttdoc">The dimension of the embedding space. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00216">CubicalComplex.h:216</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aaafb4dd5d75d73c6b2558bda06ff7ba2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; DGtal::functions::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cubical Complex symmetric difference operation. Returns the cubical complex \( S1 \Delta S2 \).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input cubical complex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the cubical complex \( S1 \Delta S2 \). </dd></dl>

<p>Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00223">223</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>

<p>References <a class="el" href="CubicalComplex_8h_source.html#l00216">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::dimension</a>, and <a class="el" href="CubicalComplex_8h_source.html#l01253">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>.</p>
<div class="fragment"><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    {</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;      <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="classDGtal_1_1CubicalComplex.html">CC</a>;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;      CC S( S1 );</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;      <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= <a class="code" href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">CC::dimension</a>; ++i )</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;        setops::operator^=( S.myCells[ i ], S2.myCells[ i ] );</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;      <span class="keywordflow">return</span> S;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    }</div><div class="ttc" id="classDGtal_1_1CubicalComplex_html"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html">DGtal::CubicalComplex</a></div><div class="ttdoc">Aim: This class represents an arbitrary cubical complex living in some Khalimsky space. Cubical complexes are sets of cells of different dimensions related together with incidence relations. Two cells in a cubical complex are incident if and only if they are incident in the surrounding Khalimsky space. In other words, cubical complexes are defined here as subsets of Khalimsky spaces. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00084">CubicalComplex.h:84</a></div></div>
<div class="ttc" id="classDGtal_1_1CubicalComplex_html_ac4a7b9f7a80e6bd5415cd0792b5f5797"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">DGtal::CubicalComplex::dimension</a></div><div class="ttdeci">static const Dimension dimension</div><div class="ttdoc">The dimension of the embedding space. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00216">CubicalComplex.h:216</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac2dc598f6424e1a8d919c4f8ec1d6234"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp; DGtal::functions::operator^= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cubical Complex symmetric difference operation. Updates the cubical complex <em>S1</em> as \( S1 \Delta S2 \).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input cubical complex, \( S1 \Delta S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the modified cubical complex S1. </dd></dl>

<p>Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00246">246</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>

<p>References <a class="el" href="CubicalComplex_8h_source.html#l00216">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::dimension</a>, and <a class="el" href="CubicalComplex_8h_source.html#l01253">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>.</p>
<div class="fragment"><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    {</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;      <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="classDGtal_1_1CubicalComplex.html">CC</a>;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;      <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= <a class="code" href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">CC::dimension</a>; ++i )</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        setops::operator^=( S1.myCells[ i ], S2.myCells[ i ] );</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;      <span class="keywordflow">return</span> S1;</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    }</div><div class="ttc" id="classDGtal_1_1CubicalComplex_html"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html">DGtal::CubicalComplex</a></div><div class="ttdoc">Aim: This class represents an arbitrary cubical complex living in some Khalimsky space. Cubical complexes are sets of cells of different dimensions related together with incidence relations. Two cells in a cubical complex are incident if and only if they are incident in the surrounding Khalimsky space. In other words, cubical complexes are defined here as subsets of Khalimsky spaces. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00084">CubicalComplex.h:84</a></div></div>
<div class="ttc" id="classDGtal_1_1CubicalComplex_html_ac4a7b9f7a80e6bd5415cd0792b5f5797"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">DGtal::CubicalComplex::dimension</a></div><div class="ttdeci">static const Dimension dimension</div><div class="ttdoc">The dimension of the embedding space. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00216">CubicalComplex.h:216</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae447f1a3e814a5bb11a9aeaec99d8b0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; DGtal::functions::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cubical Complex union operation. Returns the cubical complex \( S1 \cup S2 \). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input cubical complex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the cubical complex \( S1 \cup S2 \). </dd></dl>

<p>Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00140">140</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>

<p>References <a class="el" href="CubicalComplex_8h_source.html#l00216">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::dimension</a>, and <a class="el" href="CubicalComplex_8h_source.html#l01253">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>.</p>
<div class="fragment"><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    {</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;      <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="classDGtal_1_1CubicalComplex.html">CC</a>;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;      CC S( S1 );</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;      <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= <a class="code" href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">CC::dimension</a>; ++i )</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        setops::operator|=( S.myCells[ i ],S2.myCells[ i ] );</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;      <span class="keywordflow">return</span> S;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    }</div><div class="ttc" id="classDGtal_1_1CubicalComplex_html"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html">DGtal::CubicalComplex</a></div><div class="ttdoc">Aim: This class represents an arbitrary cubical complex living in some Khalimsky space. Cubical complexes are sets of cells of different dimensions related together with incidence relations. Two cells in a cubical complex are incident if and only if they are incident in the surrounding Khalimsky space. In other words, cubical complexes are defined here as subsets of Khalimsky spaces. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00084">CubicalComplex.h:84</a></div></div>
<div class="ttc" id="classDGtal_1_1CubicalComplex_html_ac4a7b9f7a80e6bd5415cd0792b5f5797"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">DGtal::CubicalComplex::dimension</a></div><div class="ttdeci">static const Dimension dimension</div><div class="ttdoc">The dimension of the embedding space. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00216">CubicalComplex.h:216</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad734479156a9b698609b8712d66a44f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp; DGtal::functions::operator|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cubical Complex union operation. Updates the cubical complex <em>S1</em> as \( S1 \cup S2 \). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S1</td><td>an input cubical complex, \( S1 \cup S2 \) as output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>another input cubical complex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the modified cubical complex S1. </dd></dl>

<p>Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00161">161</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>

<p>References <a class="el" href="CubicalComplex_8h_source.html#l00216">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::dimension</a>, and <a class="el" href="CubicalComplex_8h_source.html#l01253">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::myCells</a>.</p>
<div class="fragment"><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    {</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;      <span class="keyword">typedef</span> CubicalComplex&lt; TKSpace, TCellContainer &gt; <a class="code" href="classDGtal_1_1CubicalComplex.html">CC</a>;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;      <span class="keywordflow">for</span> ( Dimension i = 0; i &lt;= <a class="code" href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">CC::dimension</a>; ++i )</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        setops::operator|=( S1.myCells[ i ], S2.myCells[ i ] );</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;      <span class="keywordflow">return</span> S1;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    }</div><div class="ttc" id="classDGtal_1_1CubicalComplex_html"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html">DGtal::CubicalComplex</a></div><div class="ttdoc">Aim: This class represents an arbitrary cubical complex living in some Khalimsky space. Cubical complexes are sets of cells of different dimensions related together with incidence relations. Two cells in a cubical complex are incident if and only if they are incident in the surrounding Khalimsky space. In other words, cubical complexes are defined here as subsets of Khalimsky spaces. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00084">CubicalComplex.h:84</a></div></div>
<div class="ttc" id="classDGtal_1_1CubicalComplex_html_ac4a7b9f7a80e6bd5415cd0792b5f5797"><div class="ttname"><a href="classDGtal_1_1CubicalComplex.html#ac4a7b9f7a80e6bd5415cd0792b5f5797">DGtal::CubicalComplex::dimension</a></div><div class="ttdeci">static const Dimension dimension</div><div class="ttdoc">The dimension of the embedding space. </div><div class="ttdef"><b>Definition:</b> <a href="CubicalComplex_8h_source.html#l00216">CubicalComplex.h:216</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a168a5ac6b1b9969a8aec0f82fd637e89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TCellContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; DGtal::functions::operator~ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CubicalComplex.html">CubicalComplex</a>&lt; TKSpace, TCellContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cubical Complex close operation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKSpace</td><td>the digital space in which lives the cubical complex. </td></tr>
    <tr><td class="paramname">TCellContainer</td><td>the associative container used to store cells within the cubical complex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>an input cubical complex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new cubical complex that is the closing of S1. </dd></dl>

<p>Definition at line <a class="el" href="CubicalComplexFunctions_8h_source.html#l00062">62</a> of file <a class="el" href="CubicalComplexFunctions_8h_source.html">CubicalComplexFunctions.h</a>.</p>

<p>References <a class="el" href="classDGtal_1_1CubicalComplex.html#aaeda923879c69e02aa85ba6622698d97">DGtal::CubicalComplex&lt; TKSpace, TCellContainer &gt;::close()</a>.</p>
<div class="fragment"><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    {</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;      CubicalComplex&lt; TKSpace, TCellContainer &gt; S( S1 );</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;      S.close();</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;      <span class="keywordflow">return</span> S;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a18b68d329aa1461a0847a18e99247885"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T DGtal::functions::power </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>aVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute exponentiation by squaring of a scalar <em>aVal</em> of type <em>T</em> by the exponent <em>exponent</em> (unsigned int). The computation is done in \( O(\log(exponent))\) multiplications. </p><dl class="section note"><dt>Note</dt><dd>This function is better than std::pow on unsigned int exponents and integer value type since it performs exact computations (no cast to float or doubles).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aVal</td><td>the value </td></tr>
    <tr><td class="paramname">exponent</td><td>the exponent </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>scalar value type (must have '*' operator). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>aVal^exponent</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceDGtal_1_1functions.html#ac8e2160844093488cdd738354027daa1">square</a>, <a class="el" href="namespaceDGtal_1_1functions.html#a4828e0475cb9aa8dceefa94f0ab4d168">cube</a> </dd></dl>

<p>Definition at line <a class="el" href="BasicMathFunctions_8h_source.html#l00073">73</a> of file <a class="el" href="BasicMathFunctions_8h_source.html">BasicMathFunctions.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    {</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=exponent;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;      T p(aVal);</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;      </div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;      <span class="keywordflow">if</span> (exponent == 0) { <span class="keywordflow">return</span> 1;    }</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;      </div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;      T result = NumberTraits&lt;T&gt;::ONE;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;      <span class="keywordflow">while</span> (q != 0) </div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        {</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;          <span class="keywordflow">if</span> (q % 2 == 1) {    <span class="comment">// q is odd</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;            result *= p;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;            q--;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;          }</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;          p *= p;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;          q /= 2;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        }</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;      <span class="keywordflow">return</span> result;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa754ac3d17216563354db61d905a545c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointVector , typename Position , typename PositionFunctor , typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> DGtal::functions::reversedSmartCH </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>aFirstPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>aLastPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PositionFunctor &amp;&#160;</td>
          <td class="paramname"><em>aPositionFunctor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>uIto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>lIto</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Procedure that computes the lower and upper left hull of the left subsegment of a greater DSS characterized by the first upper leaning point <em>U</em>, the first positive Bezout point <em>L</em> and its direction vector <em>V</em>. Note that the so-called left subsegment is bounded on the one hand by the first point of the DSS located at <em>aFirstPosition</em> and on the other hand by the point located at position <em>aLastPosition</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>last upper convex hull vertex </td></tr>
    <tr><td class="paramname">L</td><td>last lower convex hull vertex </td></tr>
    <tr><td class="paramname">V</td><td>last valid Bezout vector (main direction vector) </td></tr>
    <tr><td class="paramname">aFirstPosition</td><td>position of the first point of the subsegment </td></tr>
    <tr><td class="paramname">aLastPosition</td><td>position of the last point of the subsegment </td></tr>
    <tr><td class="paramname">aPositionFunctor</td><td>position functor, which returns the position of any given point/vector </td></tr>
    <tr><td class="paramname">uIto</td><td>output iterator used to store the vertices of the upper convex hull </td></tr>
    <tr><td class="paramname">lIto</td><td>output iterator used to store the vertices of the lower convex hull</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes. ">PointVector</a></td><td>a model of 2d point/vector </td></tr>
    <tr><td class="paramname">Position</td><td>a model of integer for the position of the point in the bounding DSS </td></tr>
    <tr><td class="paramname">PositionFunctor</td><td>a model of unary functor that returns the position of a point/vector </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of output iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last direction vector, ie. the rational slope of minimal denominator </dd></dl>

</div>
</div>
<a class="anchor" id="a42d6f1219d53ecefb73b55c386e0d54a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DSS , typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DSS::Vector DGtal::functions::reversedSmartCH </td>
          <td>(</td>
          <td class="paramtype">const DSS &amp;&#160;</td>
          <td class="paramname"><em>aDSS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DSS::Position &amp;&#160;</td>
          <td class="paramname"><em>aPositionBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>uIto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>lIto</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Procedure that computes the lower and upper left hull of the left subsegment of a greater DSS <em>aDSS</em>. Note that the so-called left subsegment is bounded on the one hand by the first point of <em>aDSS</em> and on the other hand by the point located at position <em>aPositionBound</em> [Roussillon 2014 : <a class="el" href="citelist.html#CITEREF_RoussillonDGCI2014">[57]</a>]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDSS</td><td>bounding DSS </td></tr>
    <tr><td class="paramname">aPositionBound</td><td>position of the last point of the subsegment (should be located after the first point of <em>aDSS</em>). </td></tr>
    <tr><td class="paramname">uIto</td><td>output iterator used to store the vertices of the upper convex hull </td></tr>
    <tr><td class="paramname">lIto</td><td>output iterator used to store the vertices of the lower convex hull</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DSS</td><td>a model of arithmetical DSS </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of output iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last direction vector, ie. the rational slope of minimal denominator </dd></dl>

</div>
</div>
<a class="anchor" id="a48dff4e7a37ef5122f124d830b4b177a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T DGtal::functions::roundToUpperPowerOfTwo </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the next higher power of two of the given argument n of type T.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the element T </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an element of type T (casted to unsigned integer). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next higher power of two. </dd></dl>

<p>Definition at line <a class="el" href="BasicMathFunctions_8h_source.html#l00102">102</a> of file <a class="el" href="BasicMathFunctions_8h_source.html">BasicMathFunctions.h</a>.</p>

<p>References <a class="el" href="Bits_8h_source.html#l00343">DGtal::Bits::mostSignificantBit()</a>.</p>

<p>Referenced by <a class="el" href="Viewer3D_8h_source.html#l01034">DGtal::Viewer3D&lt; Space, KSpace &gt;::GLTextureImage::GLTextureImage()</a>.</p>
<div class="fragment"><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;                                         {</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;      <span class="keywordflow">return</span> (T)  1 &lt;&lt; (1+<a class="code" href="structDGtal_1_1Bits.html#a25b5f464fec0d951d75f1fe10a07f0ea">DGtal::Bits::mostSignificantBit</a>( (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) n-1 ) );</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    }</div><div class="ttc" id="structDGtal_1_1Bits_html_a25b5f464fec0d951d75f1fe10a07f0ea"><div class="ttname"><a href="structDGtal_1_1Bits.html#a25b5f464fec0d951d75f1fe10a07f0ea">DGtal::Bits::mostSignificantBit</a></div><div class="ttdeci">static unsigned int mostSignificantBit(DGtal::uint8_t n)</div><div class="ttdef"><b>Definition:</b> <a href="Bits_8h_source.html#l00343">Bits.h:343</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a07b66e9e7682c0f900bcbeabcac96b7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointVector , typename Coordinate , typename Position , typename PositionFunctor , typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> DGtal::functions::smartCH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;&#160;</td>
          <td class="paramname"><em>aFirstPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coordinate &amp;&#160;</td>
          <td class="paramname"><em>aRemainderBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>aPositionBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;&#160;</td>
          <td class="paramname"><em>aStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coordinate &amp;&#160;</td>
          <td class="paramname"><em>aRStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;&#160;</td>
          <td class="paramname"><em>aShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coordinate &amp;&#160;</td>
          <td class="paramname"><em>aRShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PositionFunctor &amp;&#160;</td>
          <td class="paramname"><em>aPositionFunctor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>uIto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>lIto</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Procedure that computes the lower and upper left hull of a DSS of first point <em>aFirstPoint</em>, length <em>aPositionBound</em>, contained in a digital straight line described by <em>aRStep</em>, <em>aRShift</em> and <em>aRemainderBound</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aFirstPoint</td><td>first point of the DSS </td></tr>
    <tr><td class="paramname">aRemainderBound</td><td>difference between the intercept mu of the bounding DSL and the remainder of the first point. </td></tr>
    <tr><td class="paramname">aPositionBound</td><td>(strictly positive) length of the DSS </td></tr>
    <tr><td class="paramname">aStep</td><td>first step of the DSL </td></tr>
    <tr><td class="paramname">aRStep</td><td>remainder of the first step, ie. parameter \( a \) of the bounding DSL </td></tr>
    <tr><td class="paramname">aShift</td><td>shift vector of the DSL </td></tr>
    <tr><td class="paramname">aRShift</td><td>remainder of the shift vector, ie. parameter \( omega \) of the bounding DSL. </td></tr>
    <tr><td class="paramname">aPositionFunctor</td><td>position functor, which returns the position of any given point/vector </td></tr>
    <tr><td class="paramname">uIto</td><td>output iterator used to store the vertices of the upper convex hull </td></tr>
    <tr><td class="paramname">lIto</td><td>output iterator used to store the vertices of the lower convex hull</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last direction vector, ie. the rational slope of minimal denominator of the DSS</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes. ">PointVector</a></td><td>a model of 2d point/vector </td></tr>
    <tr><td class="paramname">Coordinate</td><td>a model of integer for the coordinates of the point/vector </td></tr>
    <tr><td class="paramname">Position</td><td>a model of integer for locating points in the DSS </td></tr>
    <tr><td class="paramname">PositionFunctor</td><td>a model of unary functor that returns the position of a point/vector </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of output iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc99490ec12ae9e68c03c08d473e8692"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DSL , typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DSL::Vector DGtal::functions::smartCH </td>
          <td>(</td>
          <td class="paramtype">const DSL &amp;&#160;</td>
          <td class="paramname"><em>aDSL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DSL::Point &amp;&#160;</td>
          <td class="paramname"><em>aFirstPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DSL::Position &amp;&#160;</td>
          <td class="paramname"><em>aLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>uIto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>lIto</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Procedure that computes the lower and upper left hull of a DSS of first point <em>aFirstPoint</em>, length <em>aLength</em>, contained in a DSL <em>aDSL</em> [Roussillon 2014 : <a class="el" href="citelist.html#CITEREF_RoussillonDGCI2014">[57]</a>]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDSL</td><td>bounding DSL </td></tr>
    <tr><td class="paramname">aFirstPoint</td><td>first point of the DSS </td></tr>
    <tr><td class="paramname">aLength</td><td>(strictly positive) length of the DSS </td></tr>
    <tr><td class="paramname">uIto</td><td>output iterator used to store the vertices of the upper convex hull </td></tr>
    <tr><td class="paramname">lIto</td><td>output iterator used to store the vertices of the lower convex hull</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last direction vector, ie. the rational slope of minimal denominator</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DSL</td><td>a model of arithmetical DSL </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of output iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c21293d6efa82afb1b20db4d7a794a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Position , typename Coordinate , typename PointVector , typename OutputIterator , typename PositionFunctor , typename TruncationFunctor1 , typename TruncationFunctor2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::smartCHNextVertex </td>
          <td>(</td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>positionBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coordinate &amp;&#160;</td>
          <td class="paramname"><em>remainderBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coordinate &amp;&#160;</td>
          <td class="paramname"><em>rX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coordinate &amp;&#160;</td>
          <td class="paramname"><em>rY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coordinate &amp;&#160;</td>
          <td class="paramname"><em>rV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>ito</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PositionFunctor &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TruncationFunctor1 &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TruncationFunctor2 &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Procedure that computes the next (lower or upper) vertex of the left hull of a DSS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positionBound</td><td>position of the last point of the DSS </td></tr>
    <tr><td class="paramname">remainderBound</td><td>remainder of the lower leaning points contained in the DSS </td></tr>
    <tr><td class="paramname">X</td><td>(returned) last vertex of the considered side </td></tr>
    <tr><td class="paramname">rX</td><td>(returned) remainder of <em>X</em> </td></tr>
    <tr><td class="paramname">Y</td><td>last vertex of the opposite side </td></tr>
    <tr><td class="paramname">rY</td><td>remainder of <em>Y</em> </td></tr>
    <tr><td class="paramname">V</td><td>(returned) last direction vector (unimodular with (<em>X</em> - <em>Y</em>)) </td></tr>
    <tr><td class="paramname">rV</td><td>(returned) remainder of <em>V</em> (not null) </td></tr>
    <tr><td class="paramname">ito</td><td>output iterator used to store the new vertex lying on the same side as <em>X</em> </td></tr>
    <tr><td class="paramname">pos</td><td>position functor, which returns the position of any given point/vector </td></tr>
    <tr><td class="paramname">f1</td><td>first floor function (for the vertex) </td></tr>
    <tr><td class="paramname">f2</td><td>second floor function (for the direction vector)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the last vertex of the left hull has been reached, 'false' otherwise.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Position</td><td>a model of integer for locating points in the DSS </td></tr>
    <tr><td class="paramname"><a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes. ">PointVector</a></td><td>a model of 2d point/vector </td></tr>
    <tr><td class="paramname">Coordinate</td><td>a model of integer for the coordinates of the point/vector </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of output iterator </td></tr>
    <tr><td class="paramname">PositionFunctor</td><td>a model of unary functor that returns the position of a point/vector </td></tr>
    <tr><td class="paramname">TruncationFunctor1</td><td>a model of unary functor that implements an integer division </td></tr>
    <tr><td class="paramname">TruncationFunctor2</td><td>a model of unary functor that implements an integer division </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a184e90763c4747a4b7c71a58e1bf4bfe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointVector , typename Position , typename OutputIterator , typename TruncationFunctor1 , typename TruncationFunctor2 , typename PositionFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DGtal::functions::smartCHPreviousVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>aFirstPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Position &amp;&#160;</td>
          <td class="paramname"><em>aLastPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>ito</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PositionFunctor &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TruncationFunctor1 &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TruncationFunctor2 &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Procedure that computes the previous vertex of the left hull of a DSS of main direction vector <em>V</em> , first upper leaning point <em>U</em> and first positive Bezout point <em>L</em>. The computation stops as soon as a computed vertex is located before <em>aLastPosition</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>(returned) first vertex of the left hull on the considered side </td></tr>
    <tr><td class="paramname">Y</td><td>first vertex of the left hull on the opposite side </td></tr>
    <tr><td class="paramname">V</td><td>(returned) previous direction vector </td></tr>
    <tr><td class="paramname">aFirstPosition</td><td>position of the first point of the subsegment </td></tr>
    <tr><td class="paramname">aLastPosition</td><td>position of the last point of the subsegment </td></tr>
    <tr><td class="paramname">ito</td><td>output iterator used to store the vertices of the left hull lying on the same side as <em>X</em> </td></tr>
    <tr><td class="paramname">pos</td><td>position functor, which returns the position of any given point/vector </td></tr>
    <tr><td class="paramname">f1</td><td>integer divisor for the direction vector update </td></tr>
    <tr><td class="paramname">f2</td><td>integer divisor for the vertex update</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes. ">PointVector</a></td><td>a model of couple of coordinates </td></tr>
    <tr><td class="paramname">Position</td><td>a model of integer for the position of the points </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>a model of output iterator </td></tr>
    <tr><td class="paramname">TruncationFunctor1</td><td>a model of functor for the integer division </td></tr>
    <tr><td class="paramname">TruncationFunctor2</td><td>a model of functor for the integer division </td></tr>
    <tr><td class="paramname">PositionFunctor</td><td>a model of functor returning the position of a point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if the last vertex has been reached, 'false' otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ac8e2160844093488cdd738354027daa1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T DGtal::functions::square </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value x * x </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>a type with the multiply operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>any value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value x * x </dd></dl>

<p>Definition at line <a class="el" href="BasicMathFunctions_8h_source.html#l00133">133</a> of file <a class="el" href="BasicMathFunctions_8h_source.html">BasicMathFunctions.h</a>.</p>

<p>Referenced by <a class="el" href="Point2ScalarFunctors_8h_source.html#l00069">DGtal::functors::HatPointFunction&lt; TPoint, TScalar &gt;::operator()()</a>, and <a class="el" href="Point2ScalarFunctors_8h_source.html#l00097">DGtal::functors::BallConstantPointFunction&lt; TPoint, TScalar &gt;::operator()()</a>.</p>
<div class="fragment"><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    { <span class="keywordflow">return</span> x * x; }</div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 22 2016 21:12:02 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
