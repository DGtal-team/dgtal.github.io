<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>DGtal: Tutorial: making a polyhedron from a digital object</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial: making a polyhedron from a digital object </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tutoPolyhedralisation_sec1">Set up your project</a></li>
<li class="level1"><a href="#tutoPolyhedralisation_sec2">Reading the volume file and making the digital object</a></li>
<li class="level1"><a href="#tutoPolyhedralisation_sec3">Wrapping a surface around the boundary of the digital object</a></li>
<li class="level1"><a href="#tutoPolyhedralisation_sec4">Visualising the surface</a></li>
<li class="level1"><a href="#tutoPolyhedralisation_sec5">Recognizing planar zones on the object</a></li>
<li class="level1"><a href="#tutoPolyhedralisation_sec6">Finding the best decomposition into planes</a></li>
<li class="level1"><a href="#tutoPolyhedralisation_sec7">Decomposing the object boundary into planes</a></li>
<li class="level1"><a href="#tutoPolyhedralisation_sec8">Making a polyhedral surface</a></li>
<li class="level1"><a href="#tutoPolyhedralisation_sec9">Going further</a></li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation:</dt><dd>Jacques-Olivier Lachaud</dd></dl>
<p>This tutorial shows you how to construct a polyhedron (polyhedral surface) from a digital object. It uses several ingredients of <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a>:</p>
<ul>
<li>readers: to read an ".obj" file into memory (class <a class="el" href="structDGtal_1_1VolReader.html" title="Aim: implements methods to read a &quot;Vol&quot; file format. ">VolReader</a>)</li>
<li>images: to store the ".obj" file into memory (class <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>)</li>
<li>predicate: to represent the characteristic function of the digital object (class <a class="el" href="classDGtal_1_1functors_1_1SimpleThresholdForegroundPredicate.html" title="Aim: Define a simple Foreground predicate thresholding image values given a single thresold...">functors::SimpleThresholdForegroundPredicate</a>)</li>
<li>cellular space: the cellular digital space in which the boundary of the digital object is well defined (class <a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex...">KhalimskySpaceND</a>)</li>
<li>digital surface: to connect all boundary elements of the digital object as a graph (class <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>)</li>
<li>graph visitor: to define neighborhoods on the digital object boundary (class <a class="el" href="classDGtal_1_1BreadthFirstVisitor.html" title="Aim: This class is useful to perform a breadth-first exploration of a graph given a starting point or...">BreadthFirstVisitor</a>)</li>
<li>digital plane computer: to recognize points of the boundary that belongs to the same plane (class <a class="el" href="classDGtal_1_1ChordGenericNaivePlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1...">ChordGenericNaivePlaneComputer</a>)</li>
<li>umbrellas: to decompose the digital surface into cells</li>
<li>viewers: to see intermediate and final results of our algorithm (class <a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a>)</li>
</ul>
<h1><a class="anchor" id="tutoPolyhedralisation_sec1"></a>
Set up your project</h1>
<p>We will write a new C++ source file (say makePolyhedron.cpp) that uses the <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a> library. You can follow for instance <a class="el" href="moduleHowToUseDGtal.html">How to use DGtal in my own project ?</a>. Then you can already start with the following skeleton that includes the main required headers (Qt will be used for displaying results).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;set&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;queue&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;QtGui/qapplication.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/base/Common.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/helpers/StdDefs.h&quot;</span></div>
</div><!-- fragment --><p>We will also play with some .vol file. There are a few in the directory DGtal/examples/samples. We pick below the Al Capone volume file. The program will also be parameterized by the <code>threshold</code> value on the volume file and the integers <code>wp</code> and <code>wq</code>, such that <code>wp</code>/<code>wq</code> is the tolerance used for decomposing the volume boundary into planes.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceDGtal.html">DGtal</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceZ3i.html">Z3i</a>;</div>
<div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv )</div>
<div class="line">{</div>
<div class="line">  QApplication application(argc,argv);</div>
<div class="line">  <span class="keywordtype">string</span> inputFilename = argc &gt; 1 ? argv[ 1 ] : <span class="stringliteral">&quot;DGtal/examples/samples/Al.100.vol&quot;</span>;</div>
<div class="line">  <span class="keywordtype">int</span> threshold = argc &gt; 2 ? atoi( argv[ 2 ] ) : 0; <span class="comment">// volume is (val &gt; threshold)</span></div>
<div class="line">  <span class="keywordtype">int</span> wp = argc &gt; 3 ? atoi( argv[ 3 ] ) : 1;</div>
<div class="line">  <span class="keywordtype">int</span> wq = argc &gt; 4 ? atoi( argv[ 4 ] ) : 1;</div>
<div class="line">  ...</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="tutoPolyhedralisation_sec2"></a>
Reading the volume file and making the digital object</h1>
<p>We store our volume as an image, i.e. a raster of value. We therefore use the class <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>, parameterized by the usual Domain of Z3 (defined in namespace <a class="el" href="namespaceDGtal_1_1Z3i.html" title="Z3i this namespace gathers the standard of types for 3D imagery. ">Z3i</a>) and <code>int</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> ImageContainerBySTLVector&lt; Domain, int&gt; Image;</div>
<div class="line">Image image = <a class="code" href="structDGtal_1_1VolReader.html#aa4f1ebd956ed345e4c64e78c83da25d2">VolReader&lt;Image&gt;::importVol</a>(inputFilename);</div>
</div><!-- fragment --><p>However an image is not a digital object. We define a digital object implicitly as a Predicate : Point -&gt; bool. Hence, we define the digital object as a threshold of the image with class <a class="el" href="classDGtal_1_1functors_1_1SimpleThresholdForegroundPredicate.html" title="Aim: Define a simple Foreground predicate thresholding image values given a single thresold...">functors::SimpleThresholdForegroundPredicate</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> functors::SimpleThresholdForegroundPredicate&lt;Image&gt; DigitalObject;</div>
<div class="line">DigitalObject digitalObject( image, threshold );</div>
</div><!-- fragment --><p>Of course, class <a class="el" href="classDGtal_1_1functors_1_1SimpleThresholdForegroundPredicate.html" title="Aim: Define a simple Foreground predicate thresholding image values given a single thresold...">functors::SimpleThresholdForegroundPredicate</a> is a wrapper around the image and only references the image.</p>
<h1><a class="anchor" id="tutoPolyhedralisation_sec3"></a>
Wrapping a surface around the boundary of the digital object</h1>
<p>Up to now, the digital object is just a characteristic function, without any structure nor boundary. Digital surfaces are defined as inter voxel elemnts between face adjacent voxels, such that one is inside and the other is outside the digital object. It is thus natural to enrich the usual digital space \( \mathbb{Z}^d \) with lower dimensional cells. That is exactly the purpose of class <a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex...">KhalimskySpaceND</a>. That kind of space allows to represent cells of arbitary dimension (see moduleCellularTopology). By convention, <em>voxels</em> are cells of maximal dimension <code>d</code>, <em>surfels</em> are <code>d</code>-1 dimensional cells, etc. Note also that surfels are oriented. It is because a surfel indicates not only a boundary element, but also in which direction is the inside.</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceDGtal_1_1Z2i.html#a6183d00ec6f8c4f81748fd20a52e5590">KSpace</a> ks; <span class="comment">// defined in namespace Z3i, alias of KhalimskySpaceND&lt;3,int&gt;</span></div>
<div class="line">ks.init( image.<a class="code" href="classDGtal_1_1ImageContainerBySTLVector.html#a0169236b951921faab6b4827d77eec84">domain</a>().lowerBound(), image.<a class="code" href="classDGtal_1_1ImageContainerBySTLVector.html#a0169236b951921faab6b4827d77eec84">domain</a>().upperBound(), true ); <span class="comment">// can be checked if ok.</span></div>
</div><!-- fragment --><p>There are several kinds of digital surfaces (see also <a class="el" href="moduleDigitalSurfaces.html">Digital surfaces</a>). To address this diversity, the class <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a> is templated by a model of CDigitalSurfaceContainer. Here we wish to define a digital surface as the boundary of a characteristic function (a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a>). We choose in our case the container <a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html">ImplicitDigitalSurface</a>, which does exactly this but around one boundary component only. You must provide one starting surfel for the implicitly defined surface, which indicates the component of the boundary that it is representing. Use <a class="el" href="classDGtal_1_1Surfaces.html#a48e3a0e7c4728f6a6f23ec6f468a41b8">Surfaces::findABel</a> to get a first surfel element. Part of the code is given below</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> KSpace::Surfel Surfel;</div>
<div class="line"><span class="keyword">typedef</span> ImplicitDigitalSurface&lt; KSpace, DigitalObject &gt; MyContainer;</div>
<div class="line"><span class="keyword">typedef</span> DigitalSurface&lt; MyContainer &gt; <a class="code" href="classDGtal_1_1DigitalSurface.html">MyDigitalSurface</a>;</div>
<div class="line">MyContainer container( ks, digitalObject, surfAdj, start_surfel );</div>
<div class="line">MyDigitalSurface digSurf( container );</div>
<div class="line"><a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;Digital surface has &quot;</span> &lt;&lt; digSurf.size() &lt;&lt; <span class="stringliteral">&quot; surfels.&quot;</span></div>
<div class="line">             &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>If everything is fine, you should have a non-null digital surface !</p>
<div class="image">
<img src="polyhedralizer-al-1.png" alt="polyhedralizer-al-1.png"/>
<div class="caption">
The original Al Capone digital object.</div></div>
 <h1><a class="anchor" id="tutoPolyhedralisation_sec4"></a>
Visualising the surface</h1>
<p>Just to check that everything is fine, we can visualize the surface with class <a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a>, which is based on libQGLViewer (which in turn uses Qt and OpenGL). The principle is to instantiate the viewer and then to use output streams to feed the viewer with cells, colors, etc. The following piece of code displays the first surfel of your surface.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> Viewer3D&lt;Space,KSpace&gt; MyViewer3D;</div>
<div class="line">MyViewer3D viewer( ks );</div>
<div class="line">viewer.show(); </div>
<div class="line">viewer &lt;&lt; CustomColors3D( <a class="code" href="classDGtal_1_1Color.html#ac26d8585885e7a354893b7e93c6a9dda">Color::Black</a>, <a class="code" href="classDGtal_1_1Color.html#ab7b17778033da4f2ce2825d385e53d90">Color::White</a> );</div>
<div class="line">viewer &lt;&lt; *( digSurf.begin() ); <span class="comment">// surfel pointed by the begin iterator.</span></div>
<div class="line">viewer &lt;&lt; MyViewer3D::updateDisplay;</div>
<div class="line">application.exec();</div>
</div><!-- fragment --><p>Update this code to display the whole surface, just by iterating on the range provided by the digital surface. To speed up a little bit the display, you may add the following line (after show() ), which forces a simplified display for surfels.</p>
<div class="fragment"><div class="line">viewer &lt;&lt; SetMode3D( start_surfel.className(), <span class="stringliteral">&quot;Basic&quot;</span> );</div>
</div><!-- fragment --><h1><a class="anchor" id="tutoPolyhedralisation_sec5"></a>
Recognizing planar zones on the object</h1>
<p>We need two different elements to decompose the boundary of our object into planar zones.</p>
<ul>
<li>The first one is a way to determine if a set of points is planar. We will use the class <a class="el" href="classDGtal_1_1ChordGenericNaivePlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1...">ChordGenericNaivePlaneComputer</a> to carry out this task, but you may also have a look at page <a class="el" href="modulePlaneRecognition.html">Plane recognition and plane width computation</a> to have a broader view on this topic. Such an object recognizes arbitrary pieces of planes with a given axis width. Hence it recognizes naive planes when the axis width is 1.</li>
<li>The second element is a way to visit the points onto the object boundary in a reasonnable way, so that planar pieces are not too elongated. We adopt a simple approach to produce as "round" as possible planar pieces. The digital surface is a model of graph (concept CUndirectedSimpleGraph) and we may perform several breadth-first traversal onto it with the class <a class="el" href="classDGtal_1_1BreadthFirstVisitor.html">BreadthFirstVisitor</a>. Again, page <a class="el" href="moduleGraphDefinitions.html">Basic graph definitions and concepts</a> gives a more complete overview.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> ChordGenericNaivePlaneComputer&lt;Z3,Z3::Point, DGtal::int64_t&gt; <a class="code" href="classDGtal_1_1COBANaivePlaneComputer.html">NaivePlaneComputer</a>;</div>
<div class="line"><span class="keyword">typedef</span> BreadthFirstVisitor&lt;MyDigitalSurface&gt; <a class="code" href="classDGtal_1_1BreadthFirstVisitor.html">Visitor</a>;</div>
</div><!-- fragment --><p>A breadth first visitor, given a starting vertex on a graph, visits in sequence vertices at increasing (topological) distance. The current <a class="el" href="classDGtal_1_1BreadthFirstVisitor.html#ad66e84867d0eb0c092900af4df0ae026">Visitor::Node</a> holds a pair &lt;Vertex,Size&gt; which represents the current vertex in the traversal and its distance to the starting vertex. You may choose at each step whether you can continue normally to the next vertex (<a class="el" href="classDGtal_1_1BreadthFirstVisitor.html#af171f17c5465cfbf942cda0d33e3fd11">BreadthFirstVisitor::expand</a>) or if you continue to the next vertex but you block the expansion of the visitor through the current vertex (<a class="el" href="classDGtal_1_1BreadthFirstVisitor.html#a68daeb591e9bd1a9310f99cd44ee19ec">BreadthFirstVisitor::ignore</a>). We use the visitor layer by layer (i.e. vertices with same distance). Here is a skeleton code for extracting a "round" and planar neighborhood aroud surfel <code>start_surfel</code>. We call this plane the <b>round</b> <b>plane</b> around <code>start_surfel</code>.</p>
<div class="fragment"><div class="line">NaivePlaneComputer planeComputer;</div>
<div class="line">std::vector&lt;Point&gt; layer;</div>
<div class="line">planeComputer.<a class="code" href="classDGtal_1_1COBANaivePlaneComputer.html#a17098fa05c7e9cf548d69283410c10e2">init</a>( wp, wq );</div>
<div class="line"><span class="comment">// The visitor takes care of all the breadth-first traversal.</span></div>
<div class="line">Visitor visitor( digSurf, start_surfel );</div>
<div class="line"><a class="code" href="classDGtal_1_1BreadthFirstVisitor.html#a7195645fc084657ef1b51ac57e16eddf">Visitor::Size</a> currentSize = visitor.current().second;</div>
<div class="line">layer.clear();</div>
<div class="line"><span class="keywordflow">while</span> ( ! visitor.finished() )</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classDGtal_1_1BreadthFirstVisitor.html#ad66e84867d0eb0c092900af4df0ae026">Visitor::Node</a> node = visitor.current();</div>
<div class="line">  Surfel v = node.first;</div>
<div class="line">  <span class="keywordtype">int</span> axis = ks.sOrthDir( v );</div>
<div class="line">  Point p = ks.sCoords( ks.sDirectIncident( v, axis ) ); <span class="comment">// point interior to surfel</span></div>
<div class="line">  <span class="keywordflow">if</span> ( node.second != currentSize )</div>
<div class="line">    { <span class="comment">// tries to extend the plane with the whole layer.</span></div>
<div class="line">      <span class="keywordtype">bool</span> isExtended = planeComputer.<a class="code" href="classDGtal_1_1COBANaivePlaneComputer.html#af2772a864766a21ee7ab9538c6c8d66e">extend</a>( layer.begin(), layer.end() );</div>
<div class="line">      <span class="keywordflow">if</span> ( isExtended )</div>
<div class="line">        { <span class="comment">// ... do your stuff</span></div>
<div class="line">          ...</div>
<div class="line">          layer.clear();</div>
<div class="line">          currentSize = node.second;</div>
<div class="line">        }</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        <span class="keywordflow">break</span>; <span class="comment">// there is no plane that includes also the next layer.</span></div>
<div class="line">    }</div>
<div class="line">  layer.push_back( p );</div>
<div class="line">  visitor.expand();</div>
<div class="line">}</div>
<div class="line"><a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;Vertex &quot;</span> &lt;&lt; start_surfel &lt;&lt; <span class="stringliteral">&quot; has plane &quot;</span> &lt;&lt; planeComputer.<a class="code" href="classDGtal_1_1COBANaivePlaneComputer.html#ad08a4191c33eabff25911f3c40ffb0a3">primitive</a>() &lt;&lt; std::endl;</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>A surfel has not really integer coordinates that may be used readily for a digital plane recognition algorithm. Our choice here is to see the surfel as if it had the coordinates of its interior voxel. You could use other embeddings: (1) use the four pointels of each surfel, (2) use the doubled half-integer centroid coordinates of the surfel.</dd></dl>
<h1><a class="anchor" id="tutoPolyhedralisation_sec6"></a>
Finding the best decomposition into planes</h1>
<p>Ok, this is not an easy task, the smallest decomposition is even NP-hard in the general case. We use the following heuristic, which is reasonnably costly. First, we associate an integer to each surfel, and we initialize it to zero.</p>
<div class="fragment"><div class="line"><span class="comment">// Initialisation</span></div>
<div class="line">std::map&lt;Surfel,unsigned int&gt; v2size;</div>
<div class="line"><span class="keywordflow">for</span> ( ConstIterator it = digSurf.begin(), itE= digSurf.end(); it != itE; ++it )</div>
<div class="line">  v2size[ *it ] = 0;</div>
</div><!-- fragment --><p>Secondly, for each surfel, we compute its round plane. Then we increment the counter of each surfel that belongs to this round plane. You must reuse the code computing the round plane (<a class="el" href="tutoPolyhedralisation.html#tutoPolyhedralisation_sec5">Recognizing planar zones on the object</a>), but you must not only store the points of the layer bu also the surfels of the layer. This gives something like that.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> j = 0;</div>
<div class="line"><span class="keywordtype">int</span> nb = digSurf.size();</div>
<div class="line">std::vector&lt;Point&gt; layer;</div>
<div class="line">std::vector&lt;Surfel&gt; layer_surfel;</div>
<div class="line"><span class="keywordflow">for</span> ( ConstIterator it = digSurf.begin(), itE= digSurf.end(); it != itE; ++it )</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> ( ( (++j) % 50 == 0 ) || ( j == nb ) ) <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad8efd553b31277903be115e7aa256f74">progressBar</a>( j, nb );</div>
<div class="line">    Surfel v = *it;</div>
<div class="line">    Visitor visitor( digSurf, v );</div>
<div class="line">    layer.clear();</div>
<div class="line">    layer_surfel.clear();</div>
<div class="line">    <span class="comment">// compute round plane here and update v2size accordingly.</span></div>
<div class="line">    ...</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Note that the execution of this part may take some time for big objects. Once this is done, the surfels that belongs to a lot of planes have a high value in <code>v2size</code>. And generally, surfels at the center of big planar regions have a high value. We will thus put the surfels in a priority queue, such that the first surfels to pop out are the one with high value in <code>v2size</code>: they are indeed excellent candidates for finding a good decomposition. To do this, you can use the following generic class for storing pairs and ordering them according to the second member.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</div>
<div class="line"><span class="keyword">struct </span>PairSorted2nd</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> PairSorted2nd&lt;T1,T2&gt; Self;</div>
<div class="line">  PairSorted2nd( <span class="keyword">const</span> T1&amp; t1, <span class="keyword">const</span> T2&amp; t2 ) : first( t1 ), second( t2 ) {}</div>
<div class="line">  <span class="keywordtype">bool</span> operator&lt;( <span class="keyword">const</span> Self&amp; other )<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> second &lt; other.second; }</div>
<div class="line">  T1 first;</div>
<div class="line">  T2 second;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Then we put all the surfels into the priority queue <code>Q</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> PairSorted2nd&lt;Surfel,int&gt; WeightedSurfel;</div>
<div class="line">std::priority_queue&lt;WeightedSurfel&gt; Q;</div>
<div class="line"><span class="keywordflow">for</span> ( ConstIterator it = digSurf.begin(), itE= digSurf.end(); it != itE; ++it )</div>
<div class="line">  Q.push( WeightedSurfel( *it, v2size[ *it ] ) );</div>
</div><!-- fragment --><p>The best candidates for planar decomposition are now waiting in order in the queue.</p>
<h1><a class="anchor" id="tutoPolyhedralisation_sec7"></a>
Decomposing the object boundary into planes</h1>
<p>The idea is to pop the surfels out of the queue in order. If the popped surfel has not been marked before, then we build its round plane. All the unmarked surfels in the round plane are associated to this round plane, and are in turn marked. We process until the queue is empty.</p>
<p>In order to store the round planes (and other information like its color for display), you shoud define a structure like</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</div>
<div class="line"><span class="keyword">struct </span>Triple</div>
<div class="line">{</div>
<div class="line">  T1 first;</div>
<div class="line">  T2 second;</div>
<div class="line">  T3 third;</div>
<div class="line">  Triple( T1 t1 = T1(), T2 t2 = T2(), T3 t3 = T3() )</div>
<div class="line">    : first( t1 ), second( t2 ), third( t3 )</div>
<div class="line">  {}</div>
<div class="line">};</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="keyword">typedef</span> Triple&lt; NaivePlaneComputer, Color, std::pair&lt;RealVector,double&gt; &gt; RoundPlane;</div>
</div><!-- fragment --><p>Since a round plane will be shared by many surfels, it is more convenient to allocate them dynamically. A <a class="el" href="classDGtal_1_1CountedPtr.html">CountedPtr</a> could also be used, but this is enough for a tutorial.</p>
<div class="fragment"><div class="line">std::set&lt;Surfel&gt; markedSurfels;</div>
<div class="line">std::vector&lt;RoundPlane*&gt; roundPlanes;</div>
<div class="line">std::map&lt;Surfel,RoundPlane*&gt; v2plane;</div>
<div class="line">j = 0;</div>
<div class="line"><span class="keywordflow">while</span> ( ! Q.empty() )</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> ( ( (++j) % 50 == 0 ) || ( j == nb ) ) <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad8efd553b31277903be115e7aa256f74">progressBar</a>( j, nb );</div>
<div class="line">  Surfel v = Q.top().first;</div>
<div class="line">  Q.pop();</div>
<div class="line">  <span class="keywordflow">if</span> ( markedSurfels.find( v ) != markedSurfels.end() ) <span class="comment">// already in set</span></div>
<div class="line">        <span class="keywordflow">continue</span>; <span class="comment">// process to next vertex</span></div>
<div class="line">  RoundPlane* ptrRoundPlane = <span class="keyword">new</span> RoundPlane;</div>
<div class="line">  roundPlanes.push_back( ptrRoundPlane ); <span class="comment">// to delete them afterwards.</span></div>
<div class="line">  v2plane[ v ] = ptrRoundPlane;</div>
<div class="line">  ptrRoundPlane-&gt;init( wp, wq );</div>
<div class="line">  ptrRoundPlane-&gt;second = Color( random() % 192 + 64, random() % 192 + 64, random() % 192 + 64, 255 );</div>
<div class="line">  <span class="comment">// same extraction of round plane as above</span></div>
<div class="line">  <span class="comment">// Do not forget to associate ptrRoundPlane to each unmarked visited surfels of the round plane.</span></div>
<div class="line">  <span class="comment">// Do not forget to mark all surfels of the round plane.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>At the end of your program, you should of course call <code>delete</code> on each allocated round plane. Since each round plane has a (random) color, we may update our visualisation to display for each surfel the color of its round plane.</p>
<div class="fragment"><div class="line">MyViewer3D viewer( ks );</div>
<div class="line">viewer.show(); </div>
<div class="line">viewer &lt;&lt; SetMode3D( start_surfel.className(), <span class="stringliteral">&quot;Basic&quot;</span> );</div>
<div class="line"><span class="keywordflow">for</span> ( std::map&lt;Surfel,RoundPlane*&gt;::const_iterator </div>
<div class="line">        it = v2plane.begin(), itE = v2plane.end();</div>
<div class="line">        it != itE; ++it )</div>
<div class="line">  {</div>
<div class="line">    Surfel v = it-&gt;first;</div>
<div class="line">    RoundPlane* rplane = it-&gt;second;</div>
<div class="line">    viewer &lt;&lt; CustomColors3D( rplane-&gt;second, rplane-&gt;second );</div>
<div class="line">    viewer &lt;&lt; v;</div>
<div class="line">  }</div>
<div class="line">viewer &lt;&lt; MyViewer3D::updateDisplay;</div>
<div class="line">application.exec();</div>
</div><!-- fragment --><p>This is the kind of result you should obtain.</p>
<div class="image">
<img src="polyhedralizer-al-round.png" alt="polyhedralizer-al-round.png"/>
<div class="caption">
The round planes of Al Capone digital object, for width=3/2.</div></div>
<h1><a class="anchor" id="tutoPolyhedralisation_sec8"></a>
Making a polyhedral surface</h1>
<p>Now that meaningul planes have been extracted, there are many ways to build a polyhedral surface. We adopt a simple approach, which gives correct results. First of all, we must associate a real plane to each (digital) round plane. The method <a class="el" href="classDGtal_1_1ChordGenericNaivePlaneComputer.html#a60bb3077a127a8cf17f555171a13aff9">ChordGenericNaivePlaneComputer::primitive</a> returns the parallel strip that encloses the digital points. We could for instance take the middle plane of the strip as real plane. Another way is to fit by least-square a plane to the points of the round plane. For our purpose, it gives nicer results. That's what we do here. The function below realizes the least-square fit of a plane <code>N.X=mu</code> to an arbitrary range of points [itB,itE).</p>
<div class="fragment"><div class="line"><span class="comment">// Least-Square Fit of a plane N.x=mu on points [itB,itE). Returns mu.</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> <a class="code" href="namespaceDGtal_1_1Z2i.html#a0db3f1b80b0d65707785c1072244befc">RealVector</a>,</div>
<div class="line">          <span class="keyword">typename</span> ConstIterator&gt;</div>
<div class="line"><span class="keywordtype">double</span> LSF( RealVector&amp; N, ConstIterator itB, ConstIterator itE )</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> RealVector::Component Component;</div>
<div class="line">  <span class="keyword">typedef</span> SimpleMatrix&lt;Component,3,3&gt; Matrix;</div>
<div class="line">  Matrix A; A.clear();</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb = 0;</div>
<div class="line">  <a class="code" href="namespaceDGtal_1_1Z2i.html#a0db3f1b80b0d65707785c1072244befc">RealVector</a> G = RealVector::zero; <span class="comment">// center of gravity</span></div>
<div class="line">  <span class="keywordflow">for</span> ( ConstIterator it = itB; it != itE; ++it )</div>
<div class="line">    {</div>
<div class="line">      G += <a class="code" href="namespaceDGtal_1_1Z2i.html#a0db3f1b80b0d65707785c1072244befc">RealVector</a>( (*it)[ 0 ], (*it)[ 1 ], (*it)[ 2 ] );</div>
<div class="line">      ++nb;</div>
<div class="line">    }</div>
<div class="line">  G /= nb;</div>
<div class="line">  <span class="keywordflow">for</span> ( ConstIterator it = itB; it != itE; ++it )</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="namespaceDGtal_1_1Z2i.html#a0db3f1b80b0d65707785c1072244befc">RealVector</a> p( (*it)[ 0 ], (*it)[ 1 ], (*it)[ 2 ] );</div>
<div class="line">      p -= G;</div>
<div class="line">      <span class="keywordflow">for</span> ( <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> i = 0; i &lt; 3; ++i )</div>
<div class="line">        <span class="keywordflow">for</span> ( <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> j = 0; j &lt; 3; ++j )</div>
<div class="line">          A.setComponent( i, j, A( i, j ) + p[ i ] * p[ j ] );</div>
<div class="line">    }</div>
<div class="line">  <span class="comment">// A is Gram matrix. We look for V such that V^t A V / |V|^2 is</span></div>
<div class="line">  <span class="comment">// minimal. It is thus the first eigenvalue.</span></div>
<div class="line">  Matrix V;</div>
<div class="line">  <a class="code" href="namespaceDGtal_1_1Z2i.html#a0db3f1b80b0d65707785c1072244befc">RealVector</a> values;</div>
<div class="line">  <a class="code" href="classDGtal_1_1EigenDecomposition.html#a062ae590027b118c107dac78f0e9773c">EigenDecomposition&lt;3,Component&gt;::getEigenDecomposition</a>( A, V, values );</div>
<div class="line">  N = V.column( 0 ); <span class="comment">// first eigenvector;</span></div>
<div class="line">  <span class="keywordtype">double</span> mu = 0.0;</div>
<div class="line">  <span class="keywordflow">for</span> ( ConstIterator it = itB; it != itE; ++it )</div>
<div class="line">    mu += N.dot( *it );</div>
<div class="line">  <span class="keywordflow">return</span> mu/(double)nb;</div>
<div class="line">}</div>
</div><!-- fragment --><p>You must now compute the LSF plane for each round plane. This is easily done by iterating over the vector <code>roundPlanes</code>. We store the normal vector <code>N</code> and the offset <code>mu</code> into the <code>RoundPlane</code>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> ( std::vector&lt;RoundPlane*&gt;::iterator </div>
<div class="line">        it = roundPlanes.begin(), itE = roundPlanes.end(); </div>
<div class="line">      it != itE; ++it )</div>
<div class="line">  {</div>
<div class="line">    NaivePlaneComputer&amp; computer = (*it)-&gt;first;</div>
<div class="line">    <a class="code" href="namespaceDGtal_1_1Z2i.html#a0db3f1b80b0d65707785c1072244befc">RealVector</a> normal;</div>
<div class="line">    <span class="keywordtype">double</span> mu = LSF( normal, computer.<a class="code" href="classDGtal_1_1COBANaivePlaneComputer.html#ac984e38fdcfc2b3ae60cbb32847dc58d">begin</a>(), computer.<a class="code" href="classDGtal_1_1COBANaivePlaneComputer.html#ab4f81375ed4264a60239ee982fa88e23">end</a>() );</div>
<div class="line">    (*it)-&gt;third = make_pair( normal, mu );</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Then each surfel is first projected onto the real plane associated to its round plane. In a second sequence, we average the coordinates of the surfels with the coordinates of their neighbors. The effect is that surfels inside a round plane are still projected onto their plane while surfels just on the rim of a round plane are averaged with the neighboring plane.</p>
<div class="fragment"><div class="line">std::map&lt;Surfel, RealPoint&gt; coordinates;</div>
<div class="line"><span class="keywordflow">for</span> ( std::map&lt;Surfel,RoundPlane*&gt;::const_iterator </div>
<div class="line">        it = v2plane.begin(), itE = v2plane.end();</div>
<div class="line">      it != itE; ++it )</div>
<div class="line">  {</div>
<div class="line">    Surfel v = it-&gt;first;</div>
<div class="line">    RoundPlane* rplane = it-&gt;second;</div>
<div class="line">    Point p = ks.sKCoords( v );</div>
<div class="line">    RealPoint rp( (<span class="keywordtype">double</span>)p[ 0 ]/2.0, (<span class="keywordtype">double</span>)p[ 1 ]/2.0, (<span class="keywordtype">double</span>)p[ 2 ]/2.0 );</div>
<div class="line">    <span class="keywordtype">double</span> mu = rplane-&gt;third.second;</div>
<div class="line">    <a class="code" href="namespaceDGtal_1_1Z2i.html#a0db3f1b80b0d65707785c1072244befc">RealVector</a> normal = rplane-&gt;third.first;</div>
<div class="line">    <span class="keywordtype">double</span> lambda = mu - rp.<a class="code" href="classDGtal_1_1PointVector.html#aa0bb99ecab1fcb8a34f94dde061f6eac">dot</a>( normal );</div>
<div class="line">    coordinates[ v ] = rp + lambda*normal;</div>
<div class="line">  }</div>
<div class="line"><span class="keyword">typedef</span> std::vector&lt;Surfel&gt; SurfelRange;</div>
<div class="line">std::map&lt;Surfel, RealPoint&gt; new_coordinates;</div>
<div class="line"><span class="keywordflow">for</span> ( ConstIterator it = digSurf.begin(), itE= digSurf.end(); it != itE; ++it )</div>
<div class="line">  {</div>
<div class="line">    Surfel s = *it;</div>
<div class="line">    SurfelRange neighbors;</div>
<div class="line">    std::back_insert_iterator&lt;SurfelRange&gt; writeIt = std::back_inserter( neighbors );</div>
<div class="line">    digSurf.writeNeighbors( writeIt, *it );</div>
<div class="line">    RealPoint x = RealPoint::zero;</div>
<div class="line">    <span class="keywordflow">for</span> ( SurfelRange::const_iterator its = neighbors.begin(), itsE = neighbors.end();</div>
<div class="line">          its != itsE; ++its )</div>
<div class="line">      x += coordinates[ *its ];</div>
<div class="line">    new_coordinates[ s ] = x / neighbors.size();</div>
<div class="line">  }</div>
</div><!-- fragment --><p>It remains to build the polyhedral surface approximating the digital boundary. We use the class <a class="el" href="classDGtal_1_1Mesh.html">Mesh</a> (from package shapes), which let us construct a polyhedral surface by simply adding vertices and then adding faces as vectors of vertex indices. Class <a class="el" href="classDGtal_1_1Mesh.html">Mesh</a> is devoted to i/o. You can output it on a viewer to display it or use the stream operator to export it as some OBJ or OFF file.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Number;</div>
<div class="line"><span class="keyword">typedef</span> Mesh&lt;RealPoint&gt; MyMesh;</div>
<div class="line"><span class="keyword">typedef</span> MyMesh::MeshFace MeshFace;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classDGtal_1_1DigitalSurface.html#aca5daf921da1f67b921cfc109f2dbb20">MyDigitalSurface::FaceSet</a> FaceSet;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classDGtal_1_1DigitalSurface.html#a7bbab2b7e1bedf06738f5151d1157b37">MyDigitalSurface::VertexRange</a> VertexRange;</div>
<div class="line">std::map&lt;Surfel, Number&gt; index;   <span class="comment">// Numbers all vertices.</span></div>
<div class="line">Number nbv = 0;</div>
<div class="line">MyMesh polyhedron( <span class="keyword">true</span> );</div>
<div class="line"><span class="comment">// Insert all projected surfels as vertices of the polyhedral surface.</span></div>
<div class="line"><span class="keywordflow">for</span> ( ConstIterator it = digSurf.begin(), itE= digSurf.end(); it != itE; ++it )</div>
<div class="line">  {</div>
<div class="line">    polyhedron.addVertex( new_coordinates[ *it ] );</div>
<div class="line">    index[ *it ] = nbv++;</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Since surfels are mapped as vertices into the mesh, we need to build faces on the mesh such that their vertices are surfels. It is in fact a kind of dual surface to the digitized boundary. The class <a class="el" href="classDGtal_1_1DigitalSurface.html">DigitalSurface</a> is also able to list the polygonal faces that joins surfels, through method <a class="el" href="classDGtal_1_1DigitalSurface.html#a41e4a590553eca228cf34fc231ddc22d">DigitalSurface::allClosedFaces</a>. These faces form umbrellas of surfels around some pointel (see the works of Françon).</p>
<div class="fragment"><div class="line">FaceSet faces = digSurf.allClosedFaces();</div>
</div><!-- fragment --><p>It remains just to iterate over all the faces, and for each face, to use method <a class="el" href="classDGtal_1_1Mesh.html#a512479b977525241e1e15794e2c1480d">Mesh::addFace</a> to add a <a class="el" href="classDGtal_1_1Mesh.html#a3d084f2844bebef34c892b058113ba9c">Mesh::MeshFace</a> with the correct vertex indices. Have a look at method <a class="el" href="classDGtal_1_1DigitalSurface.html#a6f4b8d016b2104de1e251f3752de3633">DigitalSurface::verticesAroundFace</a> in order to get the surfels around a given face.</p>
<p>Once the polyhedron is build, you may view it and export it as follows:</p>
<div class="fragment"><div class="line">viewer.clear();</div>
<div class="line">viewer.show();</div>
<div class="line">viewer &lt;&lt; polyhedron;</div>
<div class="line">viewer &lt;&lt; MyViewer3D::updateDisplay;</div>
<div class="line">application.exec();</div>
<div class="line"><span class="keywordtype">bool</span> isOK = polyhedron &gt;&gt; <span class="stringliteral">&quot;test.off&quot;</span>;</div>
<div class="line"><span class="keywordtype">bool</span> isOK2 = polyhedron &gt;&gt; <span class="stringliteral">&quot;test.obj&quot;</span>;</div>
</div><!-- fragment --><p>This gives the following results for different digital objects and plane width.</p>
<div class="image">
<img src="polyhedral-al-finished-w3.png" alt="polyhedral-al-finished-w3.png"/>
<div class="caption">
The polyhedral surface approaching Al Capone digital object, for width=3/1.</div></div>
<div class="image">
<img src="polyhedral-bunny-finished-w2.png" alt="polyhedral-bunny-finished-w2.png"/>
<div class="caption">
The polyhedral surface approaching bunny-256 dataset, for width=2/1.</div></div>
<div class="image">
<img src="polyhedral-ssphere-ctmv.png" alt="polyhedral-ssphere-ctmv.png"/>
<div class="caption">
A nicer viewer for the polyhedral surface approaching sharp-sphere-129, for width=2/1.</div></div>
 <h1><a class="anchor" id="tutoPolyhedralisation_sec9"></a>
Going further</h1>
<p>It is clear that a better polyhedralizer would not keep vertices inside a planar zone. It is not too difficult (although not straightforward) to go further along this path. It remains to identify vertices as surfels touching several round planes, and then to build the faces manually. Have fun... </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Sep 4 2014 12:48:10 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
