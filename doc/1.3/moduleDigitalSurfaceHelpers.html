<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Helpers for digital surfaces</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;1.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Helpers for digital surfaces </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#dgtal_helpsurf_sec1">The 2D case: the boundary is a sequence of cells</a></li>
<li class="level1"><a href="#dgtal_helpsurf_sec2">Tracking a 3D boundary to build a surface.</a></li>
<li class="level1"><a href="#dgtal_helpsurf_sec3">Extracting surface of connected components</a></li>
<li class="level1"><a href="#dgtal_helpsurf_sec4">Filling oriented digital contours</a></li>
<li class="level1"><a href="#dgtal_helpsurf_challenge">Your challenge</a><ul><li class="level2"><a href="#dgtal_helpsurf_challenge_exercice">Exercise</a></li>
<li class="level2"><a href="#dgtal_helpsurf_challenge_hints">Hints</a></li>
<li class="level2"><a href="#dgtal_helpsurf_challenge_results">Result</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Bertrand Kerautret and Jacques-Olivier Lachaud.</dd></dl>
<p>Part of the <a class="el" href="packageTopology.html">Topology package</a>.</p>
<p >This part of the manual describes how to use the helper class <a class="el" href="classDGtal_1_1Surfaces.html" title="Aim: A utility class for constructing surfaces (i.e. set of (n-1)-cells).">Surfaces</a> to build digital surfaces, closed or open, or contours within digital surfaces. A lot of the ideas, concepts, algorithms, documentation and code is a backport from <em>ImaGene</em>.</p>
<p >All the code presented here require: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/topology/helpers/Surfaces.h&quot;</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This class is useful if you wish only to obtain the set of surfels of a given digital surface or if you wish to obtain 2D contours (in 2D or 3D). If you require more advanced operations on surfaces (for instance using afterwards the topology defined on the surface), it is better to wrap a <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a> object around your surface of interest, see <a class="el" href="moduleDigitalSurfaces.html">Digital surfaces</a>.</dd></dl>
<h1><a class="anchor" id="dgtal_helpsurf_sec1"></a>
The 2D case: the boundary is a sequence of cells</h1>
<p >The surfaces classes offers the possibility to extract an open or closed contour as a sequence of surfels obtained from a DigitalSet and a starting surfel. The full code of this example is available in file <a href="topology_2ctopo-2_8cpp-example.html">ctopo-2.cpp </a>.</p>
<p >The first step to extract the surfel boudary of a 2D digital set is to obtain an initial boundary surfel: </p><div class="fragment"><div class="line">aCell = <a class="code hl_function" href="classDGtal_1_1Surfaces.html#a48e3a0e7c4728f6a6f23ec6f468a41b8">Surfaces&lt;Z2i::KSpace&gt;::findABel</a>(ks, set2d);       </div>
<div class="ttc" id="aclassDGtal_1_1Surfaces_html_a48e3a0e7c4728f6a6f23ec6f468a41b8"><div class="ttname"><a href="classDGtal_1_1Surfaces.html#a48e3a0e7c4728f6a6f23ec6f468a41b8">DGtal::Surfaces::findABel</a></div><div class="ttdeci">static SCell findABel(const KSpace &amp;K, const PointPredicate &amp;pp, unsigned int nbtries=1000)</div></div>
</div><!-- fragment --><p >The first surfel can also be displayed in red with <a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (with &lt;&lt;)....">Board2D</a>: <br  />
 </p><div class="fragment"><div class="line">Board2D board;</div>
<div class="line">board &lt;&lt; image.domain() &lt;&lt; set2d; <span class="comment">// display domain and set</span></div>
<div class="line">board &lt;&lt; CustomStyle( aCell.className(), <span class="keyword">new</span> CustomColors(  Board2D::Color( 255, 0, 0 ),</div>
<div class="line">                                                            Board2D::Color( 192, 0, 0 ) ));</div>
<div class="line">board &lt;&lt; aCell;</div>
</div><!-- fragment --><p> <br  />
</p>
<div class="image">
<img src="ctopo2a.png" alt=""/>
<div class="caption">
Start surfel before a tracking (in red).</div></div>
 <pre class="fragment">Then you can extract the sequence of consecutive surfels:
</pre> <div class="fragment"><div class="line">std::vector&lt;Z2i::SCell&gt; vectBdrySCell;</div>
<div class="line">SurfelAdjacency&lt;2&gt; SAdj( <span class="keyword">true</span> );</div>
<div class="line"><a class="code hl_function" href="classDGtal_1_1Surfaces.html#aa02a8a022a501740afd3e1f78382c162">Surfaces&lt;Z2i::KSpace&gt;::track2DBoundary</a>( vectBdrySCell,</div>
<div class="line">                                        ks, SAdj, set2d, aCell );</div>
<div class="ttc" id="aclassDGtal_1_1Surfaces_html_aa02a8a022a501740afd3e1f78382c162"><div class="ttname"><a href="classDGtal_1_1Surfaces.html#aa02a8a022a501740afd3e1f78382c162">DGtal::Surfaces::track2DBoundary</a></div><div class="ttdeci">static void track2DBoundary(std::vector&lt; SCell &gt; &amp;aSCellContour2D, const KSpace &amp;K, const SurfelAdjacency&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const SCell &amp;start_surfel)</div></div>
</div><!-- fragment --> <pre class="fragment">and display it:
</pre> <div class="fragment"><div class="line"> GradientColorMap&lt;int&gt; cmap_grad( 0, vectBdrySCell.size() );</div>
<div class="line"> cmap_grad.addColor( Board2D::Color( 50, 50, 255 ) );</div>
<div class="line"> cmap_grad.addColor( Board2D::Color( 255, 0, 0 ) );</div>
<div class="line"> cmap_grad.addColor( Board2D::Color( 255, 255, 10 ) );</div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0;</div>
<div class="line"> std::vector&lt;Z2i::SCell&gt;::iterator it;</div>
<div class="line"> <span class="keywordflow">for</span> ( it=vectBdrySCell.begin() ; it != vectBdrySCell.end(); it++ ){</div>
<div class="line">      board&lt;&lt; CustomStyle((*it).className() ,</div>
<div class="line">                          <span class="keyword">new</span> CustomColors( Board2D::Color::Black,</div>
<div class="line">                                            cmap_grad( d )))&lt;&lt; *it;</div>
<div class="line">      d++;</div>
<div class="line">}</div>
</div><!-- fragment --><p >You will obtain the following ordered sequence of surfels:</p>
<div class="image">
<img src="ctopo2b.png" alt=""/>
<div class="caption">
Tracking of a closed 2D contour.</div></div>
 <p >The resulting sequence of surfels does not necessary present an open contour (try for instance image "samples/circleR10modif.pgm"):</p>
<div class="image">
<img src="ctopo2c.png" alt=""/>
<div class="caption">
Tracking of an open 2D contour.</div></div>
 <h1><a class="anchor" id="dgtal_helpsurf_sec2"></a>
Tracking a 3D boundary to build a surface.</h1>
<p >With only few modifications we can apply the same extraction on 3D surfel set. The file <a href="topology_2ctopo-2-3d_8cpp-example.html">ctopo-2-3d.cpp </a> shows the same previous example adapted in 3D.</p>
<p >with the same code we can get a surfel boundary: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="namespaceDGtal_1_1Z3i.html#a96583b392d71bd493733117e3136d82b">Z3i::SCell</a> aCell = <a class="code hl_function" href="classDGtal_1_1Surfaces.html#a48e3a0e7c4728f6a6f23ec6f468a41b8">Surfaces&lt;Z3i::KSpace&gt;::findABel</a>(ks, set3d);</div>
<div class="ttc" id="anamespaceDGtal_1_1Z3i_html_a96583b392d71bd493733117e3136d82b"><div class="ttname"><a href="namespaceDGtal_1_1Z3i.html#a96583b392d71bd493733117e3136d82b">DGtal::Z3i::SCell</a></div><div class="ttdeci">KSpace::SCell SCell</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00149">StdDefs.h:149</a></div></div>
</div><!-- fragment --><p >From this SCell all the surfel connected sets can be extracted: </p><div class="fragment"><div class="line"><span class="comment">// Extracting all boundary surfels which are connected to the initial boundary Cell.</span></div>
<div class="line"><a class="code hl_function" href="classDGtal_1_1Surfaces.html#a274dbb659f269382154035ae61d7e7b3">Surfaces&lt;Z3i::KSpace&gt;::trackBoundary</a>( vectBdrySCellALL,</div>
<div class="line">                                      ks,SAdj, set3d, aCell );</div>
<div class="ttc" id="aclassDGtal_1_1Surfaces_html_a274dbb659f269382154035ae61d7e7b3"><div class="ttname"><a href="classDGtal_1_1Surfaces.html#a274dbb659f269382154035ae61d7e7b3">DGtal::Surfaces::trackBoundary</a></div><div class="ttdeci">static void trackBoundary(SCellSet &amp;surface, const KSpace &amp;K, const SurfelAdjacency&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const SCell &amp;start_surfel)</div></div>
</div><!-- fragment --><p >To see both initial surfel and the surfel set, we can use the transparent mode:</p>
<div class="fragment"><div class="line">viewer &lt;&lt; SetMode3D((*(vectBdrySCellALL.begin())).className(), <span class="stringliteral">&quot;Transparent&quot;</span>);</div>
</div><!-- fragment --><p >To avoid surfel superposition we need to increase with a small shift the surfel size, for this purpose you can add the following key: </p><div class="fragment"><div class="line">viewer &lt;&lt; Viewer3D&lt;&gt;::shiftSurfelVisu; </div>
</div><!-- fragment --><p> or use the special mode "Highlighted" which increase automaticly the surfel size.</p>
<p >You can obtain for instance the following visualisation:</p>
<div class="image">
<img src="ctopo3dSurfel.png" alt=""/>
<div class="caption">
Tracking surfaces in 3D (start surfel in green).</div></div>
 <p >Since in 3D there are several choice for the direction used to exctract surfel boundary, we can specify the constant direction need to drive the surfel extraction:</p>
<div class="fragment"><div class="line"><span class="comment">// Extract the boundary contour associated to the initial surfel in its first direction</span></div>
<div class="line"> <a class="code hl_function" href="classDGtal_1_1Surfaces.html#aa02a8a022a501740afd3e1f78382c162">Surfaces&lt;Z3i::KSpace&gt;::track2DBoundary</a>( vectBdrySCell,</div>
<div class="line">                                         ks, *(ks.sDirs( aCell )),SAdj, set3d, aCell );</div>
</div><!-- fragment --><p >After extracting the two surfels cut you may obtain the following visualisation:</p>
<div class="image">
<img src="ctopo3dSurfelCut.png" alt=""/>
<div class="caption">
Tracking surfaces and slices in 3D (start surfel in green).</div></div>
 <h1><a class="anchor" id="dgtal_helpsurf_sec3"></a>
Extracting surface of connected components</h1>
<p >The class <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> provides other useful function to extract connected boundary surfels from a digital set and given a surfel adjacency definition. The example <a href="topology_23dKSSurfaceExtraction_8cpp-example.html">3dKSSurfaceExtraction.cpp </a> shows an example of such an extraction.</p>
<p >From a domain we construct a DigitalSet inserting points under given conditions (see. <a href="topology_23dKSSurfaceExtraction_8cpp-example.html">3dKSSurfaceExtraction.cpp </a> for more details)</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/helpers/Surfaces.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/topology/KhalimskySpaceND.h&quot;</span></div>
<div class="line">...</div>
<div class="line">Domain <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>( p1, p2);</div>
<div class="line"><a class="code hl_typedef" href="testVoronoiMapComplete_8cpp.html#ac14360761d68859fc57ca37aea0b5c93">DigitalSet</a> diamond_set( <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a> );</div>
<div class="line">...</div>
<div class="line">  diamond_set.insertNew( *it );</div>
<div class="line">....</div>
<div class="ttc" id="atestProjection_8cpp_html_a1f1a69f8d8b037b72c2160ed12b3ef51"><div class="ttname"><a href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a></div><div class="ttdeci">Domain domain</div><div class="ttdef"><b>Definition:</b> <a href="testProjection_8cpp_source.html#l00088">testProjection.cpp:88</a></div></div>
<div class="ttc" id="atestVoronoiMapComplete_8cpp_html_ac14360761d68859fc57ca37aea0b5c93"><div class="ttname"><a href="testVoronoiMapComplete_8cpp.html#ac14360761d68859fc57ca37aea0b5c93">DigitalSet</a></div><div class="ttdeci">Z2i::DigitalSet DigitalSet</div><div class="ttdef"><b>Definition:</b> <a href="testVoronoiMapComplete_8cpp_source.html#l00041">testVoronoiMapComplete.cpp:41</a></div></div>
</div><!-- fragment --><p >With this domain bounding points (p1, p2), a KhalimskySpace is constructed and a <a class="el" href="classDGtal_1_1SurfelAdjacency.html" title="Aim: Represent adjacencies between surfel elements, telling if it follows an interior to exterior ord...">SurfelAdjacency</a> definition is introduced.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a> <a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>;</div>
<div class="line"><a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.init(p1, p2, <span class="keyword">true</span>);</div>
<div class="line">SurfelAdjacency&lt;3&gt; SAdj( <span class="keyword">true</span> );</div>
<div class="ttc" id="atestArithmeticalDSSComputerOnSurfels_8cpp_html_aebe586e91159919ccf2f565d4407fff7"><div class="ttname"><a href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a></div><div class="ttdeci">Z3i::KSpace KSpace</div><div class="ttdef"><b>Definition:</b> <a href="testArithmeticalDSSComputerOnSurfels_8cpp_source.html#l00048">testArithmeticalDSSComputerOnSurfels.cpp:48</a></div></div>
<div class="ttc" id="atestCubicalComplex_8cpp_html_a2b87ed989d2519d025bd5d4fbcbac062"><div class="ttname"><a href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a></div><div class="ttdeci">KSpace K</div><div class="ttdef"><b>Definition:</b> <a href="testCubicalComplex_8cpp_source.html#l00062">testCubicalComplex.cpp:62</a></div></div>
</div><!-- fragment --><p >Then we can extract all connected surfels from the digitalSet surface :</p>
<div class="fragment"><div class="line">SetPredicate&lt;DigitalSet&gt; shape_set_predicate( diamond_set );</div>
<div class="line"><a class="code hl_function" href="classDGtal_1_1Surfaces.html#a19b214170d160153376c4ecf3497de3f">Surfaces&lt;KSpace&gt;::extractAllConnectedSCell</a>(vectConnectedSCell,<a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, SAdj, shape_set_predicate);</div>
<div class="ttc" id="aclassDGtal_1_1Surfaces_html_a19b214170d160153376c4ecf3497de3f"><div class="ttname"><a href="classDGtal_1_1Surfaces.html#a19b214170d160153376c4ecf3497de3f">DGtal::Surfaces::extractAllConnectedSCell</a></div><div class="ttdeci">static void extractAllConnectedSCell(std::vector&lt; std::vector&lt; SCell &gt; &gt; &amp;aVectConnectedSCell, const KSpace &amp;aKSpace, const SurfelAdjacency&lt; KSpace::dimension &gt; &amp;aSurfelAdj, const PointPredicate &amp;pp, bool forceOrientCellExterior=false)</div></div>
</div><!-- fragment --><p >After processing a simple display of each resulting connecting component you can obtain such a visualisation:</p>
<div class="image">
<img src="KSurfelsConnectedOrientExt.png" alt=""/>
<div class="caption">
Visualisation of connected set of SignedKhalimskySpaceND</div></div>
 <p >Here since the last argument is set to true, the resulting SignedKhalimskySpaceND are signed in order to indicate the direction of exterior. You can also get the SignedKhalimskySpaceND with default sign:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="classDGtal_1_1Surfaces.html#a19b214170d160153376c4ecf3497de3f">Surfaces&lt;KSpace&gt;::extractAllConnectedSCell</a>(vectConnectedSCell,<a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, SAdj, shape_set_predicate, <span class="keyword">false</span>);</div>
</div><!-- fragment --><p >and you will get the resulting cell display:</p>
<div class="image">
<img src="KSurfelsConnectedDefaultOrient.png" alt=""/>
<div class="caption">
Visualisation of connected set of oriented surfels of a KhalimskySpaceND.</div></div>
 <h1><a class="anchor" id="dgtal_helpsurf_sec4"></a>
Filling oriented digital contours</h1>
<p >The helper class Surface also proposes some methods to fill the interior/exterior of a digital set of 1-SCell which can be defined from an oriented <a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a>. These methods can be usefull in particular to reconstruct images (as given for instance in the tool of freeman2pgm given in <a href="https://github.com/DGtal-team/DGtalTools">DGtalTools</a>.).</p>
<p >The example <a class="el" href="ctopo-fillContours_8cpp.html">ctopo-fillContours.cpp</a> illustrates a basic filling with a shape containing a hole. The main steps to fill a contour represented by a <a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a> are the following:</p>
<p >First we construct two <a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a> to illustrate the fill with two different orientations:</p>
<div class="fragment"><div class="line">  FreemanChain&lt;int&gt; fc1 (<span class="stringliteral">&quot;001001001001001111101111011222222223222222322233333330301033333003&quot;</span>, 6, 14);</div>
<div class="line">  FreemanChain&lt;int&gt; fc2 (<span class="stringliteral">&quot;1111000033332222&quot;</span>, 6, 20);  </div>
</div><!-- fragment --><p >To construct the set of signed SCell, we use the method getInterPixelLinels of <a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a> class:</p>
<div class="fragment"><div class="line">  </div>
<div class="line">  <span class="keyword">typedef</span>  <a class="code hl_typedef" href="classDGtal_1_1KhalimskySpaceND.html#a7d26c7464cdc9dbc684472a204136128">KhalimskySpaceND&lt;2, int&gt;::SCell</a> <a class="code hl_typedef" href="digitalPolyhedronBuilder3D_8cpp.html#a6c4dc4f5610ba8c9b7ee6e83ecea8d24">SCell</a>;</div>
<div class="line">  std::set&lt;DGtal::KhalimskySpaceND&lt; 2, int &gt;::SCell&gt; boundarySCell;</div>
<div class="line">  <a class="code hl_function" href="classDGtal_1_1FreemanChain.html#a9e2abe6893728a71e6570d32f7fd148c">FreemanChain&lt;int&gt;::getInterPixelLinels</a>(<a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, fc1, boundarySCell, <span class="keyword">false</span>); </div>
<div class="ttc" id="aclassDGtal_1_1FreemanChain_html_a9e2abe6893728a71e6570d32f7fd148c"><div class="ttname"><a href="classDGtal_1_1FreemanChain.html#a9e2abe6893728a71e6570d32f7fd148c">DGtal::FreemanChain::getInterPixelLinels</a></div><div class="ttdeci">static void getInterPixelLinels(const KhalimskySpaceND&lt; 2, TInteger &gt; &amp;aKSpace, const FreemanChain &amp;fc, typename KhalimskySpaceND&lt; 2, TInteger &gt;::SCellSet &amp;aSCellContour, bool aFlagForAppend=false)</div></div>
<div class="ttc" id="aclassDGtal_1_1KhalimskySpaceND_html_a7d26c7464cdc9dbc684472a204136128"><div class="ttname"><a href="classDGtal_1_1KhalimskySpaceND.html#a7d26c7464cdc9dbc684472a204136128">DGtal::KhalimskySpaceND::SCell</a></div><div class="ttdeci">SignedKhalimskyCell&lt; dim, Integer &gt; SCell</div><div class="ttdef"><b>Definition:</b> <a href="KhalimskySpaceND_8h_source.html#l00417">KhalimskySpaceND.h:417</a></div></div>
<div class="ttc" id="adigitalPolyhedronBuilder3D_8cpp_html_a6c4dc4f5610ba8c9b7ee6e83ecea8d24"><div class="ttname"><a href="digitalPolyhedronBuilder3D_8cpp.html#a6c4dc4f5610ba8c9b7ee6e83ecea8d24">SCell</a></div><div class="ttdeci">Z3i::SCell SCell</div><div class="ttdef"><b>Definition:</b> <a href="digitalPolyhedronBuilder3D_8cpp_source.html#l00079">digitalPolyhedronBuilder3D.cpp:79</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The that the resulting Cell orientation is defined by convention such that a contour defined in the direct orientation will generate the fill of the interior of the shape (with the uComputeInterior method) while the indirect orientation should be used to define a hole (see example below).</dd></dl>
<p>Afterwards the region associated with the direct oriented contour (fc1) can be filled by using the method uComputeInterior with the parameter empty_is_inside set to false. This parameter choice is justified since here a line which does not contain any boundary element is necessary at the outside of the contour.</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ImageContainerBySTLMap&lt; Z2i::Domain, bool&gt; BoolImage2D;</div>
<div class="line">  BoolImage2D::Domain imageDomain( <a class="code hl_typedef" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(0,10), <a class="code hl_typedef" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(20,30) );</div>
<div class="line">  BoolImage2D interiorCellImage( imageDomain );</div>
<div class="line">  Surfaces&lt;DGtal::KhalimskySpaceND&lt; 2, int &gt; &gt;::uFillInterior(<a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, functors::SurfelSetPredicate&lt;std::set&lt;SCell&gt;,<a class="code hl_typedef" href="digitalPolyhedronBuilder3D_8cpp.html#a6c4dc4f5610ba8c9b7ee6e83ecea8d24">SCell</a>&gt;(boundarySCell), </div>
<div class="line">                                                              interiorCellImage, 1, <span class="keyword">false</span>);  </div>
<div class="ttc" id="anamespaceDGtal_1_1Z2i_html_ac0a04516c81db6f4a583eddda0f64875"><div class="ttname"><a href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">DGtal::Z2i::Point</a></div><div class="ttdeci">Space::Point Point</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00095">StdDefs.h:95</a></div></div>
</div><!-- fragment --><p >The interior Cells obtained from such a contour are illustrated here:</p>
<div class="image">
<img src="ctopo-fillContours0.png" alt=""/>
<div class="caption">
Filling interior of direct oriented contour.</div></div>
<p >We can also reconstruct region with hole by using a contour in the indirect direction. For instance we can define</p>
<div class="fragment"><div class="line">  std::set&lt;DGtal::KhalimskySpaceND&lt; 2, int &gt;::SCell&gt; boundarySCellhole;</div>
<div class="line">  <a class="code hl_function" href="classDGtal_1_1FreemanChain.html#a9e2abe6893728a71e6570d32f7fd148c">FreemanChain&lt;int&gt;::getInterPixelLinels</a>(<a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, fc2, boundarySCellhole, <span class="keyword">false</span>); </div>
</div><!-- fragment --><p >And after adding it to the previous set boundarySCell you will obtain such a display:</p>
<div class="image">
<img src="ctopo-fillContours1.png" alt=""/>
<div class="caption">
Filling interior of direct oriented contour.</div></div>
<dl class="section note"><dt>Note</dt><dd>From an indirect oriented contour you can also fill both the interior and exterior: <div class="fragment"><div class="line">  BoolImage2D interiorCellHoleImage( imageDomain );</div>
<div class="line">  BoolImage2D exteriorCellHoleImage( imageDomain );</div>
<div class="line"> </div>
<div class="line">  </div>
<div class="line">  Surfaces&lt;DGtal::KhalimskySpaceND&lt; 2, int &gt; &gt;::uFillInterior(<a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, functors::SurfelSetPredicate&lt;std::set&lt;SCell&gt;, <a class="code hl_typedef" href="digitalPolyhedronBuilder3D_8cpp.html#a6c4dc4f5610ba8c9b7ee6e83ecea8d24">SCell</a>&gt;(boundarySCellhole), </div>
<div class="line">                                                              interiorCellHoleImage, 1, <span class="keyword">true</span>);  </div>
<div class="line">  Surfaces&lt;DGtal::KhalimskySpaceND&lt; 2, int &gt; &gt;::uFillExterior(<a class="code hl_variable" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, functors::SurfelSetPredicate&lt;std::set&lt;SCell&gt;, <a class="code hl_typedef" href="digitalPolyhedronBuilder3D_8cpp.html#a6c4dc4f5610ba8c9b7ee6e83ecea8d24">SCell</a>&gt;(boundarySCellhole), </div>
<div class="line">                                                              exteriorCellHoleImage, 1,  <span class="keyword">false</span>);  </div>
</div><!-- fragment --> For the interior region, the parameter empty_is_inside parameter is set to true since a line without boundary element will correspond to the interior of the shape (since the contour is given the indirect orientation). In the same way, the parameter empty_is_outside is set to false. You will obtain such a representation: <div class="image">
<img src="ctopo-fillContours3.png" alt=""/>
<div class="caption">
Filling interior (lightgray) and exterior (dark gray) of indirect oriented contour.</div></div>
</dd></dl>
<h1><a class="anchor" id="dgtal_helpsurf_challenge"></a>
Your challenge</h1>
<p >Now you are able both to extract a set of contours and to fill contours. The exercise is now to reconstruct an image from a given set of contours.</p>
<h2><a class="anchor" id="dgtal_helpsurf_challenge_exercice"></a>
Exercise</h2>
<p >You challenge is to code:</p>
<ol type="1">
<li>The load the set of all the Freeman Chains given in a text file.</li>
<li>Transform Freeman Chains into signed cells of <a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex,...">KhalimskySpaceND</a> (SCell).</li>
<li>Reconstruct an image associated to its Freeman Chains by filling.</li>
<li>Identify image hole and fill it with specific gray level.</li>
<li>Exporting resulting image in pgm format.</li>
</ol>
<h2><a class="anchor" id="dgtal_helpsurf_challenge_hints"></a>
Hints</h2>
<ul>
<li>The class <a class="el" href="structDGtal_1_1PointListReader.html" title="Aim: Implements method to read a set of points represented in each line of a file.">PointListReader</a> contains various method to read input from text file. In particular you can use the method getFreemanChainsFromFile (step 1). To reconstruct the image you can first define some types from <a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex,...">KhalimskySpaceND</a> with also the resulting image: <div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_typedef" href="classDGtal_1_1KhalimskySpaceND.html#af87a8fec76262bec1a3b33881fa38f1f">KhalimskySpaceND&lt;2, int&gt;::Cell</a> <a class="code hl_typedef" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">Cell</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_typedef" href="classDGtal_1_1KhalimskySpaceND.html#a7d26c7464cdc9dbc684472a204136128">KhalimskySpaceND&lt;2, int&gt;::SCell</a> <a class="code hl_typedef" href="digitalPolyhedronBuilder3D_8cpp.html#a6c4dc4f5610ba8c9b7ee6e83ecea8d24">SCell</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1KhalimskySpaceND.html">DGtal::KhalimskySpaceND&lt; 2, int &gt;</a> <a class="code hl_typedef" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#aebe586e91159919ccf2f565d4407fff7">KSpace</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classDGtal_1_1ImageContainerBySTLVector.html">DGtal::ImageContainerBySTLVector&lt;Z2i::Domain, unsigned char&gt;</a> Image2D ; </div>
<div class="ttc" id="aclassDGtal_1_1ImageContainerBySTLVector_html"><div class="ttname"><a href="classDGtal_1_1ImageContainerBySTLVector.html">DGtal::ImageContainerBySTLVector</a></div><div class="ttdef"><b>Definition:</b> <a href="ImageContainerBySTLVector_8h_source.html#l00126">ImageContainerBySTLVector.h:127</a></div></div>
<div class="ttc" id="aclassDGtal_1_1KhalimskySpaceND_html"><div class="ttname"><a href="classDGtal_1_1KhalimskySpaceND.html">DGtal::KhalimskySpaceND</a></div><div class="ttdoc">Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex,...</div><div class="ttdef"><b>Definition:</b> <a href="KhalimskySpaceND_8h_source.html#l00392">KhalimskySpaceND.h:394</a></div></div>
<div class="ttc" id="aclassDGtal_1_1KhalimskySpaceND_html_af87a8fec76262bec1a3b33881fa38f1f"><div class="ttname"><a href="classDGtal_1_1KhalimskySpaceND.html#af87a8fec76262bec1a3b33881fa38f1f">DGtal::KhalimskySpaceND::Cell</a></div><div class="ttdeci">KhalimskyCell&lt; dim, Integer &gt; Cell</div><div class="ttdef"><b>Definition:</b> <a href="KhalimskySpaceND_8h_source.html#l00415">KhalimskySpaceND.h:415</a></div></div>
<div class="ttc" id="atestCubicalComplex_8cpp_html_a9b10591d95c90247f1c7b3bd52853782"><div class="ttname"><a href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">Cell</a></div><div class="ttdeci">KSpace::Cell Cell</div><div class="ttdef"><b>Definition:</b> <a href="testCubicalComplex_8cpp_source.html#l00056">testCubicalComplex.cpp:56</a></div></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>To apply the reconstruction, you can use the following file given in this path: DGtal/examples/samples/contourS2.fc</dd></dl>
</li>
<li>Then you will also need to transform the freeman chain into signed cells (SCell) given in the <a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex,...">KhalimskySpaceND</a>. For this purpose you can use the <a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a> method getInterPixelLinels (step 2).</li>
<li>For the step (3) you have first to save on cell by exploiting the filling described in the previous section. Then you can update the resulting image in particular with the method uCoords from <a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex,...">KhalimskySpaceND</a> which allows you to recover the coordinate in image domain. For instance to set to 255 the image pixel associated to the Cell c, you can do: <div class="fragment"><div class="line">imageResult.setValue(ks.uCoords(*it), 255);</div>
</div><!-- fragment --></li>
<li>To identify the holes of step (4) you have to exploit the contour orientation. For this purpose you can use the method ccwLoops of the <a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a> class. <dl class="section note"><dt>Note</dt><dd>We recall that by convention holes are oriented in the CW direction (or indirect order).</dd></dl>
</li>
<li>Finally you can export the result just by including the <a class="el" href="structDGtal_1_1GenericWriter.html" title="Aim: Provide a mechanism to save image (2D or 3D) into file with the best saver loader according to a...">GenericWriter</a> and the flux operator: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/io/writers/GenericWriter.h&quot;</span></div>
<div class="line"> ...</div>
<div class="line">yourImage &gt;&gt; <span class="stringliteral">&quot;yourImageName.pgm&quot;</span>;</div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="dgtal_helpsurf_challenge_results"></a>
Result</h2>
<p >If you succeed the exercise you will obtain the following pgm image:</p>
<div class="image">
<img src="resulExerciceHelpSurface.png" alt=""/>
<div class="caption">
Awaited result of exercice with the main region filled in white and holes represented in gray.</div></div>
 </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 17 2022 17:06:53 for DGtal by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
