<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: nD Fast Marching Methods</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;1.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">nD Fast Marching Methods </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sectmoduleFMM1">Overview</a><ul><li class="level2"><a href="#sectmoduleFMM11">Data structures</a></li>
<li class="level2"><a href="#sectmoduleFMM13">Computing distances</a></li>
<li class="level2"><a href="#sectmoduleFMM12">Basic usage</a></li>
<li class="level2"><a href="#sectmoduleFMM14">Stopping criteria</a></li>
</ul>
</li>
<li class="level1"><a href="#sectmoduleFMM3">Applications</a><ul><li class="level2"><a href="#subsectmoduleFMM31">Signed distance field to an interface  &lt;br&gt;</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Tristan Roussillon</dd></dl>
<p>Part of the <a class="el" href="packageGeometry.html">Geometry package</a>.</p>
<p >The Fast Marching Method (<a class="el" href="classDGtal_1_1FMM.html" title="Aim: Fast Marching Method (FMM) for nd distance transforms.">FMM</a> for short) is a numerical technique for tracking the evolution of an expanding front within the level-set framework (see <a class="el" href="citelist.html#CITEREF_Sethian1998">[107]</a> for a review). <br  />
 If the front evolves in the normal direction at unit speed, the arrival time at a point \( x \) corresponds to the distance of \( x \) to the initial front. <br  />
</p>
<div class="image">
<img src="FMM-interface.png" alt=""/>
<div class="caption">
Arrival time and distance to the initial front</div></div>
 <p >That is why <a class="el" href="classDGtal_1_1FMM.html" title="Aim: Fast Marching Method (FMM) for nd distance transforms.">FMM</a> can be used to compute a (signed) distance field from an initial point set (which may be located around an interface or not). <br  />
 However, <a class="el" href="classDGtal_1_1FMM.html" title="Aim: Fast Marching Method (FMM) for nd distance transforms.">FMM</a> can be used to other tasks: e.g. the extrapolation of a scalar field out of an interface, such that it is constant on rays normal to the interface <a class="el" href="citelist.html#CITEREF_Adalsteinsson1999">[2]</a>. <br  />
</p>
<p >Related examples are <a class="el" href="exampleFMM2D_8cpp.html" title="Computation of a distance field from a given point">exampleFMM2D.cpp</a> and <a class="el" href="exampleFMM3D_8cpp.html" title="The aim of this example is to use the FMM (fast marching method) class in order to incrementally comp...">exampleFMM3D.cpp</a>. <br  />
</p>
<h1><a class="anchor" id="sectmoduleFMM1"></a>
Overview</h1>
<p >Let us assume that we compute in the fundamental lattice \( \mathbb{Z}^n \) the distance field from a given lattice point set. The distance value of each lattice point is computed by marching out from the initial set of lattice points for which the distance values are known. This set is an initialization of the so-called <b>accepted</b> <b>point</b> <b>set</b>, which incrementally grows until all lattice points of the computation domain have been accepted or until a stopping criterion has been met. <br  />
 Each lattice point adjacent to one of the accepted points is put into the so-called <b>candidate</b> <b>point</b> <b>set</b>.</p>
<p >The accepted point set and the candidate point set are depicted below. See <a class="el" href="moduleFMM.html#sectmoduleFMM11">Data structures</a> for details about how these sets are stored. </p><div class="image">
<img src="FMM-diagram.png" alt=""/>
<div class="caption">
Upwind update of the accepted point set</div></div>
 <p >For each candidate point, a tentative value is computed for its distance, using only the values of the accepted points lying in its neighborhood. This task is delegated to an instance of a model of CPointFunctor, which is defined as <a class="el" href="classDGtal_1_1L2FirstOrderLocalDistance.html" title="Aim: Class for the computation of the Euclidean distance at some point p, from the available distance...">L2FirstOrderLocalDistance</a> by default. However, you are free to use <a class="el" href="classDGtal_1_1L2SecondOrderLocalDistance.html" title="Aim: Class for the computation of the Euclidean distance at some point p, from the available distance...">L2SecondOrderLocalDistance</a>, for second order convergence, <a class="el" href="classDGtal_1_1L1LocalDistance.html" title="Aim: Class for the computation of the L1-distance at some point p, from the available distance values...">L1LocalDistance</a> and <a class="el" href="classDGtal_1_1LInfLocalDistance.html" title="Aim: Class for the computation of the LInf-distance at some point p, from the available distance valu...">LInfLocalDistance</a> for other norms. See <a class="el" href="moduleFMM.html#sectmoduleFMM13">Computing distances</a> for further details.</p>
<p >Then, the point of smallest tentative value is iteratively added to the set of accepted points. The tentative values of the candidates adjacent to the newly added point are updated using the distance value of the newly added point.</p>
<h2><a class="anchor" id="sectmoduleFMM11"></a>
Data structures</h2>
<p >The class <a class="el" href="classDGtal_1_1FMM.html" title="Aim: Fast Marching Method (FMM) for nd distance transforms.">FMM</a>, which implements the fast marching method, is based on two external data structures and one internal data structure:</p>
<ul>
<li>External data structures:<ul>
<li>an instance of a model of CDigitalSet for the accepted point set. <br  />
</li>
<li>an instance of a model of CImage, which stores the distance values.</li>
</ul>
</li>
</ul>
<p >In practice, you can choose either <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a> and <a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim: A container class for storing sets of digital points within some given domain.">DigitalSetBySTLSet</a> if you work on the whole domain:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> ImageContainerBySTLVector&lt;Domain,double&gt; DistanceImage; </div>
<div class="line"><span class="keyword">typedef</span> DigitalSetBySTLSet&lt;Domain&gt; AcceptedPointSet; </div>
</div><!-- fragment --><p >or <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> and <a class="el" href="classDGtal_1_1DigitalSetFromMap.html" title="Aim: An adapter for viewing an associative image container like ImageContainerBySTLMap as a simple di...">DigitalSetFromMap</a> if you work on a small fraction of the domain:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> ImageContainerBySTLMap&lt;Domain,double&gt; DistanceImage; </div>
<div class="line"><span class="keyword">typedef</span> DigitalSetFromMap&lt;DistanceImage&gt; AcceptedPointSet; </div>
</div><!-- fragment --><ul>
<li>Internal data structure:<ul>
<li><p class="startli">a data structure for the candidate point set. Three operations are required:</p><ul>
<li>insert a new point with its distance value,</li>
<li>find a given point, update its tentative value if found,</li>
<li>get the point of smallest tentative value,</li>
</ul>
<p class="startli">This data structure is usually a min-heap data structure with back pointers from the lattice to the min-heap (see <a class="el" href="citelist.html#CITEREF_Sethian1998">[107]</a>). The memory cost of such solution is however high. That is why, we implemented the candidate point set as a STL set of pairs &lt;point, tentative value&gt;. Instead of updating the tentative values, we insert a new pair &lt;point, tentative value&gt;. This solution is less memory consumming and experimentally (nearly) as efficient as the former one. <br  />
</p>
</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="sectmoduleFMM13"></a>
Computing distances</h2>
<p >In a numerical point of view, the key point of the algorithm is to accurately approximate the distance value of a given point from the distance value of its neighbors.</p>
<p >Four models of CPointFunctor can be used for this task:</p>
<ul>
<li><a class="el" href="classDGtal_1_1L2FirstOrderLocalDistance.html" title="Aim: Class for the computation of the Euclidean distance at some point p, from the available distance...">L2FirstOrderLocalDistance</a> (default)</li>
<li><a class="el" href="classDGtal_1_1L2SecondOrderLocalDistance.html" title="Aim: Class for the computation of the Euclidean distance at some point p, from the available distance...">L2SecondOrderLocalDistance</a></li>
<li><a class="el" href="classDGtal_1_1L1LocalDistance.html" title="Aim: Class for the computation of the L1-distance at some point p, from the available distance values...">L1LocalDistance</a></li>
<li><a class="el" href="classDGtal_1_1LInfLocalDistance.html" title="Aim: Class for the computation of the LInf-distance at some point p, from the available distance valu...">LInfLocalDistance</a></li>
</ul>
<p >We detail below how <a class="el" href="classDGtal_1_1L2FirstOrderLocalDistance.html" title="Aim: Class for the computation of the Euclidean distance at some point p, from the available distance...">L2FirstOrderLocalDistance</a>, which is used by default, approximate the Euclidean distance at some point \( x \), from the available distance values of the lattice points lying in the 1-neighborhood of \( x \).</p>
<p >The distance value is computed such that the upwind gradient of the distance image is one. Let us denote by \( d \) the distance value at \( x \). Moreover, for a given quadrant, let us denote by \( d_i \) the distance value of the unique 1-neighbor of \( x \) along the \( i \) axis. The distance value \( d \) is taken as the minimum solution of the following quadratic equation <br  />
 over all the quadrants:</p>
<p >\( \sum_{i = 1 \ldots n } ( d - d_i )^2 = 1 \)</p>
<p >Obviously, if the distance value \( d&#39; \) of only one 1-neighbor is available, then \( d = d&#39; \pm 1 \) ( \( + \) for positive distance values, \( - \) for negative ones). <br  />
 If the distance values of two (or more than two in nD) 1-neighbors are available, the previous quadratic equation should have two solutions and we take the larger one for \( d \). <br  />
 The numerical approach implemented in L2FirstOrderLocalDistance::operator() to compute \( d \), even with poor initial data or with numerical errors, is detailed in <a class="el" href="citelist.html#CITEREF_OsherFedkiw2003">[91]</a> [p. 72-73]. Note that if \( h \) is the lattice spacing, the approximation error tends to zero in \( O(h) \) (first-order convergence).</p>
<dl class="section note"><dt>Note</dt><dd>This class deals with positive or negative distance values (0 is arbitrarily considered as a positive value, ie. starting with a seed of null value, you must get positive values). However, the behavior is undefined when there are both positive and negative distance values in the neighborhood of \( x \). See <a class="el" href="moduleFMM.html#subsectmoduleFMM31">Signed distance field to an interface <br  />
</a> for an example of the use of <em>signed</em> distance values.</dd></dl>
<h2><a class="anchor" id="sectmoduleFMM12"></a>
Basic usage</h2>
<p >In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>, the class <a class="el" href="classDGtal_1_1FMM.html" title="Aim: Fast Marching Method (FMM) for nd distance transforms.">FMM</a> is parametrized by the following types:</p><ul>
<li>a model of <a class="el" href="structDGtal_1_1concepts_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">concepts::CDigitalSet</a> (for the accepted point set)</li>
<li>a model of <a class="el" href="structDGtal_1_1concepts_1_1CImage.html" title="Aim: Defines the concept describing a read/write image, having an output iterator.">concepts::CImage</a> (which stores the distance values)</li>
<li>a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">concepts::CPointPredicate</a> (which implicitly represents the finite point set where the distance values must be computed)</li>
<li>an optional type to compute the distance value of a given point from the distance values of its neighbors (a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html" title="Aim: Defines a functor on points.">concepts::CPointFunctor</a> set to <a class="el" href="classDGtal_1_1L2FirstOrderLocalDistance.html" title="Aim: Class for the computation of the Euclidean distance at some point p, from the available distance...">L2FirstOrderLocalDistance</a> by default). <br  />
</li>
</ul>
<p >After the inclusion of the following file</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/volumes/distance/FMM.h&quot;</span></div>
</div><!-- fragment --><p >you may define the <a class="el" href="classDGtal_1_1FMM.html" title="Aim: Fast Marching Method (FMM) for nd distance transforms.">FMM</a> type as follows:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ImageContainerBySTLMap&lt;Z2i::Domain,double&gt; DistanceImage; </div>
<div class="line">  <span class="keyword">typedef</span> DigitalSetFromMap&lt;DistanceImage&gt; AcceptedPointSet; </div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_typedef" href="classDGtal_1_1HyperRectDomain.html#a431536af83438afd5392c08d89cfe5d5">Z2i::Domain::Predicate</a> DomainPredicate;</div>
<div class="line">  <span class="keyword">typedef</span> FMM&lt;DistanceImage, AcceptedPointSet, DomainPredicate&gt; FMM;</div>
<div class="ttc" id="aclassDGtal_1_1HyperRectDomain_html_a431536af83438afd5392c08d89cfe5d5"><div class="ttname"><a href="classDGtal_1_1HyperRectDomain.html#a431536af83438afd5392c08d89cfe5d5">DGtal::HyperRectDomain&lt; Space &gt;::Predicate</a></div><div class="ttdeci">functors::IsWithinPointPredicate&lt; Point &gt; Predicate</div><div class="ttdef"><b>Definition:</b> <a href="HyperRectDomain_8h_source.html#l00128">HyperRectDomain.h:128</a></div></div>
</div><!-- fragment --><p >Since an instance of <a class="el" href="classDGtal_1_1FMM.html" title="Aim: Fast Marching Method (FMM) for nd distance transforms.">FMM</a> keeps a reference to the accepted point set, a reference to the distance image, and a constant reference to the point predicate, you must be sure that these three objects have been constructed and exist before constructing a <a class="el" href="classDGtal_1_1FMM.html" title="Aim: Fast Marching Method (FMM) for nd distance transforms.">FMM</a> instance.</p>
<div class="fragment"><div class="line">  <a class="code hl_typedef" href="namespaceDGtal_1_1Z2i.html#aca523bebdae58eb19385aaefffff8bc5">Z2i::Domain</a> <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>(<a class="code hl_function" href="classDGtal_1_1PointVector.html#aba9def1d899ca259f6fa532a6eb9a8b5">Z2i::Point::diagonal</a>(-size), </div>
<div class="line">                     <a class="code hl_function" href="classDGtal_1_1PointVector.html#aba9def1d899ca259f6fa532a6eb9a8b5">Z2i::Point::diagonal</a>(size) ); </div>
<div class="line">  DistanceImage distanceImage( <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a> ); </div>
<div class="line">  AcceptedPointSet set( distanceImage );</div>
<div class="ttc" id="aclassDGtal_1_1PointVector_html_aba9def1d899ca259f6fa532a6eb9a8b5"><div class="ttname"><a href="classDGtal_1_1PointVector.html#aba9def1d899ca259f6fa532a6eb9a8b5">DGtal::PointVector&lt; dim, Integer &gt;::diagonal</a></div><div class="ttdeci">static Self diagonal(Component val=1)</div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z2i_html_aca523bebdae58eb19385aaefffff8bc5"><div class="ttname"><a href="namespaceDGtal_1_1Z2i.html#aca523bebdae58eb19385aaefffff8bc5">DGtal::Z2i::Domain</a></div><div class="ttdeci">HyperRectDomain&lt; Space &gt; Domain</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00099">StdDefs.h:99</a></div></div>
<div class="ttc" id="atestProjection_8cpp_html_a1f1a69f8d8b037b72c2160ed12b3ef51"><div class="ttname"><a href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a></div><div class="ttdeci">Domain domain</div><div class="ttdef"><b>Definition:</b> <a href="testProjection_8cpp_source.html#l00088">testProjection.cpp:88</a></div></div>
</div><!-- fragment --><p >In this example, we start from one point whose distance value is zero:</p>
<div class="fragment"><div class="line">  <a class="code hl_typedef" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a> origin = <a class="code hl_function" href="classDGtal_1_1PointVector.html#aba9def1d899ca259f6fa532a6eb9a8b5">Z2i::Point::diagonal</a>(0); </div>
<div class="line">  set.insert( origin ); </div>
<div class="line">  distanceImage.setValue( origin, 0.0 ); </div>
<div class="ttc" id="anamespaceDGtal_1_1Z2i_html_ac0a04516c81db6f4a583eddda0f64875"><div class="ttname"><a href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">DGtal::Z2i::Point</a></div><div class="ttdeci">Space::Point Point</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00095">StdDefs.h:95</a></div></div>
</div><!-- fragment --><p >We now construct a <a class="el" href="classDGtal_1_1FMM.html" title="Aim: Fast Marching Method (FMM) for nd distance transforms.">FMM</a> instance as follows:</p>
<div class="fragment"><div class="line">  FMM fmm( distanceImage, set, <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.predicate() ); </div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Since the candidate point set is initialized at construction (see <a class="el" href="classDGtal_1_1FMM.html#a64b9b961c268e17b1eb8cfb1f79509d1">FMM::init()</a>), you must construct the initial set of accepted points before the construction of the <a class="el" href="classDGtal_1_1FMM.html" title="Aim: Fast Marching Method (FMM) for nd distance transforms.">FMM</a> instance. If the accepted point set is empty at construction, a <a class="el" href="classDGtal_1_1InputException.html">DGtal::InputException</a> is raised.</dd></dl>
<p>After the call of the method <a class="el" href="classDGtal_1_1FMM.html#a2f99dbe7f15b0f95997112e9d7027f44">FMM::compute()</a>, the distance value of all the accepted points is available in the distance image. <br  />
</p>
<div class="fragment"><div class="line">  fmm.compute(); </div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>You must be sure that the point predicate implicitly represents a <b>finite</b> point set that is <b>included</b> in the image domain. Otherwise, the computation may never end or may raise an execution error. <br  />
</dd></dl>
<p>Here is the computed distance field:</p>
<div class="image">
<img src="DTbyFMM-25.png" alt=""/>
<div class="caption">
Approximation by the FMM of the Euclidean distance field from a given point</div></div>
 <dl class="section note"><dt>Note</dt><dd>The computed distance field is a (convergent) estimation. See <a class="el" href="moduleVolumetric.html">nD Volumetric Analysis using Separable Processes</a> for an exact Euclidean distance transform.</dd></dl>
<p>The whole example may be found in <a class="el" href="exampleFMM2D_8cpp.html" title="Computation of a distance field from a given point">exampleFMM2D.cpp</a>.</p>
<h2><a class="anchor" id="sectmoduleFMM14"></a>
Stopping criteria</h2>
<p >The computation ends either if all the points represented by the point predicate have been accepted, or if one of the following stopping criteria have been met:</p>
<ul>
<li>the number of accepted points equals to a given threshold.</li>
<li>the maximal distance (in absolute value) exceed a given threshold.</li>
</ul>
<p >In order to use these stopping criteria, you must provide the corresponding thresholds at construction as follows:</p>
<div class="fragment"><div class="line">FMM fmm( imageDistance, initialPointSet, <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.predicate(),</div>
<div class="line">         maximalNumberOfPoints, maximalDistance );</div>
</div><!-- fragment --><p >With the above code, we stop the computation as soon as the number of accepted points equals to <em>maximalNumberOfPoints</em> or the distance value of the next candidate point exceed <em>maximalDistance</em>.</p>
<p >Note that you can also perform the computation step by step. This approach may be useful to better control the computation and its end. You must use <a class="el" href="classDGtal_1_1FMM.html#a38c8a40dcdd3c1728824deb8e86b758d">FMM::computeOneStep()</a>, which takes as input and returns the last accepted point and its distance value, as follows:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> lastPt = Point::diagonal(0); <span class="comment">//the last accepted point...</span></div>
<div class="line"><span class="keywordtype">double</span> lastDist = 0.0;             <span class="comment">//and its distance value</span></div>
<div class="line"><span class="keywordflow">while</span> ( (fmm.computeOneStep( lastPt, lastDist )) </div>
<div class="line">        &amp;&amp; ( <span class="comment">/* optional stopping criterion */</span> ) )</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">/* you can do something before the next step */</span></div>
<div class="line">  }</div>
<div class="ttc" id="atestClone2_8cpp_html_a15e9592ccc512dc691b46185e6814758"><div class="ttname"><a href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a></div><div class="ttdeci">MyPointD Point</div><div class="ttdef"><b>Definition:</b> <a href="testClone2_8cpp_source.html#l00383">testClone2.cpp:383</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="sectmoduleFMM3"></a>
Applications</h1>
<p >As reported in <a class="el" href="citelist.html#CITEREF_Sethian1998">[107]</a>, the Fast Marching Method has numerous applications.</p>
<h2><a class="anchor" id="subsectmoduleFMM31"></a>
Signed distance field to an interface  &lt;br&gt;</h2>
<p >A signed distance field can be used to</p>
<ul>
<li>compute geometrical quantities by differential operators: e.g. the mean curvature at a point \( x \) of an interface</li>
<li>implicitly evolve an interface: e.g. adding a scalar to a distance field is a way of moving each point of the interface in the normal direction with a constant speed (operation known as a dilation).</li>
</ul>
<p >In <a class="el" href="exampleFMM3D_8cpp.html" title="The aim of this example is to use the FMM (fast marching method) class in order to incrementally comp...">exampleFMM3D.cpp</a>, we show how to compute a signed distance field to a <b>digital</b> <b>surface</b>.</p>
<p >First, we define the <a class="el" href="classDGtal_1_1FMM.html" title="Aim: Fast Marching Method (FMM) for nd distance transforms.">FMM</a> type as follows:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ImageContainerBySTLMap&lt;Domain,double&gt; DistanceImage;</div>
<div class="line">  <span class="keyword">typedef</span> DigitalSetFromMap&lt;DistanceImage&gt; AcceptedPointSet;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="structDGtal_1_1functors_1_1IsWithinPointPredicate.html">Domain::Predicate</a> DomainPredicate;</div>
<div class="line">  <span class="keyword">typedef</span> FMM&lt;DistanceImage, AcceptedPointSet, DomainPredicate &gt; FMM;</div>
<div class="ttc" id="astructDGtal_1_1functors_1_1IsWithinPointPredicate_html"><div class="ttname"><a href="structDGtal_1_1functors_1_1IsWithinPointPredicate.html">DGtal::functors::IsWithinPointPredicate&lt; Point &gt;</a></div></div>
</div><!-- fragment --><p >Then, we construct and initialize the external data structures as follows:</p>
<div class="fragment"><div class="line">  DistanceImage imageDistance( <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>, 0.0 );</div>
<div class="line">  AcceptedPointSet initialPointSet( imageDistance );</div>
<div class="line">  <a class="code hl_function" href="classDGtal_1_1FMM.html#a916d52b626b680f5ed3505989c4ad87a">FMM::initFromBelsRange</a>( ks, frontier.begin(), frontier.end(),</div>
<div class="line">        imageDistance, initialPointSet, 0.5 );</div>
<div class="ttc" id="aclassDGtal_1_1FMM_html_a916d52b626b680f5ed3505989c4ad87a"><div class="ttname"><a href="classDGtal_1_1FMM.html#a916d52b626b680f5ed3505989c4ad87a">DGtal::FMM::initFromBelsRange</a></div><div class="ttdeci">static void initFromBelsRange(const KSpace &amp;aK, const TIteratorOnBels &amp;itb, const TIteratorOnBels &amp;ite, Image &amp;aImg, AcceptedPointSet &amp;aSet, const Value &amp;aValue, bool aFlagIsPositive=true)</div></div>
</div><!-- fragment --><p >In the above snippet, we insert all the 3D lattice points incident to the digital surface in the initial point set and we assign to them an initial distance value (equal to \( 0.5 \) for outer points and \( -0.5 \) for inner points) by merely calling the static method <a class="el" href="classDGtal_1_1FMM.html#a916d52b626b680f5ed3505989c4ad87a">FMM::initFromBelsRange()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>There are several static methods that help to construct the initial point set and to provide a distance value for all the points of this set:</dd></dl>
<ul>
<li><a class="el" href="classDGtal_1_1FMM.html#af3edd2ea0abafd4df5d4f39541a4d582">FMM::initFromPointsRange()</a></li>
<li><a class="el" href="classDGtal_1_1FMM.html#a916d52b626b680f5ed3505989c4ad87a">FMM::initFromBelsRange()</a></li>
<li><a class="el" href="classDGtal_1_1FMM.html#a18b9193216e9aa4e7b70f1b86a746372">FMM::initFromIncidentPointsRange()</a></li>
</ul>
<p >Finally, we instanciate the <a class="el" href="classDGtal_1_1FMM.html" title="Aim: Fast Marching Method (FMM) for nd distance transforms.">FMM</a> class and we perform the whole computation: <br  />
</p>
<div class="fragment"><div class="line">  FMM fmm( imageDistance, initialPointSet, <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.predicate(),</div>
<div class="line">     <a class="code hl_variable" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.size(), maximalDistance );</div>
<div class="line">  fmm.compute();</div>
<div class="line">  <a class="code hl_variable" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code hl_function" href="classDGtal_1_1Trace.html#a9b36f5ab76b1945c8156cb4dba780bfb">info</a>() &lt;&lt; fmm &lt;&lt; std::endl;</div>
<div class="ttc" id="aclassDGtal_1_1Trace_html_a9b36f5ab76b1945c8156cb4dba780bfb"><div class="ttname"><a href="classDGtal_1_1Trace.html#a9b36f5ab76b1945c8156cb4dba780bfb">DGtal::Trace::info</a></div><div class="ttdeci">std::ostream &amp; info()</div></div>
<div class="ttc" id="anamespaceDGtal_html_a8fc7012708b0416880a5c8b12dfdf9dd"><div class="ttname"><a href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">DGtal::trace</a></div><div class="ttdeci">Trace trace</div><div class="ttdef"><b>Definition:</b> <a href="Common_8h_source.html#l00154">Common.h:154</a></div></div>
</div><!-- fragment --><p >The computation is limited to a narrow band around the digital surface: each point of the band are located at a distance less than <em>maximalDistance</em> to the digital surface. <br  />
</p>
<p >The result is displayed below.</p>
<div class="image">
<img src="exampleFMM3D.png" alt=""/>
<div class="caption">
Signed distance field computed in a narrow band around a digital surface. </div></div>
  </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Nov 27 2022 15:16:00 for DGtal by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
