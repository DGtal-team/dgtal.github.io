<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: DGtal Concepts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;1.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle"><div class="title">DGtal Concepts</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CPositiveIrreducibleFraction.html">DGtal::concepts::CPositiveIrreducibleFraction&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines positive irreducible fractions, i.e. fraction p/q, p and q non-negative integers, with gcd(p,q)=1.  <a href="structDGtal_1_1concepts_1_1CPositiveIrreducibleFraction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CBackInsertable.html">DGtal::concepts::CBackInsertable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents types for which a std::back_insert_iterator can be constructed with std::back_inserter. Back Insertion Sequence are refinements of <a class="el" href="structDGtal_1_1concepts_1_1CBackInsertable.html" title="Aim: Represents types for which a std::back_insert_iterator can be constructed with std::back_inserte...">CBackInsertable</a>. They require more services than <a class="el" href="structDGtal_1_1concepts_1_1CBackInsertable.html" title="Aim: Represents types for which a std::back_insert_iterator can be constructed with std::back_inserte...">CBackInsertable</a>, for instance read services or erase services.  <a href="structDGtal_1_1concepts_1_1CBackInsertable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CBidirectionalRange.html">DGtal::concepts::CBidirectionalRange&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a bidirectional range.  <a href="structDGtal_1_1concepts_1_1CBidirectionalRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CBidirectionalRangeFromPoint.html">DGtal::concepts::CBidirectionalRangeFromPoint&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of single pass range with a begin() method from a point.  <a href="structDGtal_1_1concepts_1_1CBidirectionalRangeFromPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CBidirectionalRangeWithWritableIterator.html">DGtal::concepts::CBidirectionalRangeWithWritableIterator&lt; T, Value &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of bidirectional range which require that a reverse output iterator exists.  <a href="structDGtal_1_1concepts_1_1CBidirectionalRangeWithWritableIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CBidirectionalRangeWithWritableIteratorFromPoint.html">DGtal::concepts::CBidirectionalRangeWithWritableIteratorFromPoint&lt; T, Value &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of single pass range with an routputIterator() method from a point.  <a href="structDGtal_1_1concepts_1_1CBidirectionalRangeWithWritableIteratorFromPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CConstBidirectionalRange.html">DGtal::concepts::CConstBidirectionalRange&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a bidirectional const range.  <a href="structDGtal_1_1concepts_1_1CConstBidirectionalRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CConstBidirectionalRangeFromPoint.html">DGtal::concepts::CConstBidirectionalRangeFromPoint&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of const bidirectional range with a begin() method from a point.  <a href="structDGtal_1_1concepts_1_1CConstBidirectionalRangeFromPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CConstSinglePassRange.html">DGtal::concepts::CConstSinglePassRange&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a const single pass range.  <a href="structDGtal_1_1concepts_1_1CConstSinglePassRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CConstSinglePassRangeFromPoint.html">DGtal::concepts::CConstSinglePassRangeFromPoint&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of const single pass range with a begin() method from a point.  <a href="structDGtal_1_1concepts_1_1CConstSinglePassRangeFromPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CLabel.html">DGtal::concepts::CLabel&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define the concept of <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> labels. Models of <a class="el" href="structDGtal_1_1concepts_1_1CLabel.html" title="Aim: Define the concept of DGtal labels. Models of CLabel can be default-constructible,...">CLabel</a> can be default-constructible, assignable and equality comparable.  <a href="structDGtal_1_1concepts_1_1CLabel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CPredicate.html">DGtal::concepts::CPredicate&lt; T, TElement &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a predicate function, ie. a functor mapping a domain into the set of booleans.  <a href="structDGtal_1_1concepts_1_1CPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CQuantity.html">DGtal::concepts::CQuantity&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: defines the concept of quantity in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>.  <a href="structDGtal_1_1concepts_1_1CQuantity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSinglePassRange.html">DGtal::concepts::CSinglePassRange&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a range.  <a href="structDGtal_1_1concepts_1_1CSinglePassRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSinglePassRangeFromPoint.html">DGtal::concepts::CSinglePassRangeFromPoint&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of single pass range with a begin() method from a point.  <a href="structDGtal_1_1concepts_1_1CSinglePassRangeFromPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSinglePassRangeWithWritableIterator.html">DGtal::concepts::CSinglePassRangeWithWritableIterator&lt; T, Value &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of const single pass range which require that an output iterator exists.  <a href="structDGtal_1_1concepts_1_1CSinglePassRangeWithWritableIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSinglePassRangeWithWritableIteratorFromPoint.html">DGtal::concepts::CSinglePassRangeWithWritableIteratorFromPoint&lt; T, Value &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of single pass range with a outputIterator() method from a point.  <a href="structDGtal_1_1concepts_1_1CSinglePassRangeWithWritableIteratorFromPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CStack.html">DGtal::concepts::CStack&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept gathers classes that provide a stack interface.  <a href="structDGtal_1_1concepts_1_1CStack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSTLAssociativeContainer.html">DGtal::concepts::CSTLAssociativeContainer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing an Associative Container of the STL (<a href="https://www.sgi.com/tech/stl/AssociativeContainer.html">https://www.sgi.com/tech/stl/AssociativeContainer.html</a>).  <a href="structDGtal_1_1concepts_1_1CSTLAssociativeContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CUnaryFunctor.html">DGtal::concepts::CUnaryFunctor&lt; X, A, R &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a unary functor, which associates arguments to results.  <a href="structDGtal_1_1concepts_1_1CUnaryFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDiscreteExteriorCalculusVectorSpace.html">DGtal::concepts::CDiscreteExteriorCalculusVectorSpace&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Lift linear algebra container concept into the dec package.  <a href="structDGtal_1_1concepts_1_1CDiscreteExteriorCalculusVectorSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CBidirectionalSegmentComputer.html">DGtal::concepts::CBidirectionalSegmentComputer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a bidirectional segment computer, <br  />
 ie. a model of <a class="el" href="structDGtal_1_1concepts_1_1CSegment.html" title="Aim: Defines the concept describing a segment, ie. a valid and not empty range.">concepts::CSegment</a> that can extend itself in the two possible directions.  <a href="structDGtal_1_1concepts_1_1CBidirectionalSegmentComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDynamicBidirectionalSegmentComputer.html">DGtal::concepts::CDynamicBidirectionalSegmentComputer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie. a model of <a class="el" href="structDGtal_1_1concepts_1_1CSegment.html" title="Aim: Defines the concept describing a segment, ie. a valid and not empty range.">concepts::CSegment</a> that can extend and retract itself in either direction.  <a href="structDGtal_1_1concepts_1_1CDynamicBidirectionalSegmentComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDynamicSegmentComputer.html">DGtal::concepts::CDynamicSegmentComputer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a dynamic segment computer, <br  />
 ie. a model of <a class="el" href="structDGtal_1_1concepts_1_1CSegment.html" title="Aim: Defines the concept describing a segment, ie. a valid and not empty range.">CSegment</a> that can extend and retract itself (in the direction that is relative to the underlying iterator). <br  />
  <a href="structDGtal_1_1concepts_1_1CDynamicSegmentComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CForwardSegmentComputer.html">DGtal::concepts::CForwardSegmentComputer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a forward segment computer. Like any model of <a class="el" href="structDGtal_1_1concepts_1_1CIncrementalSegmentComputer.html" title="Aim: Defines the concept describing an incremental segment computer,   ie. a model of CSegmentFactory...">CIncrementalSegmentComputer</a>, it can control its own extension (in the direction that is relative to the underlying iterator) so that an implicit predicate P remains true. However, contrary to models of <a class="el" href="structDGtal_1_1concepts_1_1CIncrementalSegmentComputer.html" title="Aim: Defines the concept describing an incremental segment computer,   ie. a model of CSegmentFactory...">CIncrementalSegmentComputer</a>, it garantees that P is also true for any subrange of the whole segment at any time. This extra constraint is necessary to be able to incrementally check whether or not the segment is maximal.  <a href="structDGtal_1_1concepts_1_1CForwardSegmentComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CIncrementalSegmentComputer.html">DGtal::concepts::CIncrementalSegmentComputer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing an incremental segment computer, <br  />
 ie. a model of <a class="el" href="structDGtal_1_1concepts_1_1CSegmentFactory.html" title="Aim: Defines the concept describing a segment ie. a valid and not empty subrange, which can construct...">CSegmentFactory</a> that can, in addition, incrementally check whether or not an implicit predicate P is true. In other words, it can control its own extension from a range of one element (in the direction that is relative to the underlying iterator) so that an implicit predicate P remains true. <br  />
  <a href="structDGtal_1_1concepts_1_1CIncrementalSegmentComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSegment.html">DGtal::concepts::CSegment&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a segment, ie. a valid and not empty range.  <a href="structDGtal_1_1concepts_1_1CSegment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSegmentFactory.html">DGtal::concepts::CSegmentFactory&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a segment ie. a valid and not empty subrange, which can construct instances of its own type or of derived type.  <a href="structDGtal_1_1concepts_1_1CSegmentFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CCurveLocalGeometricEstimator.html">DGtal::concepts::CCurveLocalGeometricEstimator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept describes an object that can process a range so as to return one estimated quantity for each element of the range (or a given subrange).  <a href="structDGtal_1_1concepts_1_1CCurveLocalGeometricEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CGlobalGeometricEstimator.html">DGtal::concepts::CGlobalGeometricEstimator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept describes an object that can process a range so as to return one estimated quantity for the whole range.  <a href="structDGtal_1_1concepts_1_1CGlobalGeometricEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CLMSTDSSFilter.html">DGtal::concepts::CLMSTDSSFilter&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a functor which filters DSSes for L-MST calculations.  <a href="structDGtal_1_1concepts_1_1CLMSTDSSFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CLMSTTangentFromDSS.html">DGtal::concepts::CLMSTTangentFromDSS&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a functor which calculates a direction of the 2D DSS and an eccentricity <a class="el" href="citelist.html#CITEREF_LachaudIVC2007">[70]</a> of a given point in this DSS.  <a href="structDGtal_1_1concepts_1_1CLMSTTangentFromDSS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSegmentComputerEstimator.html">DGtal::concepts::CSegmentComputerEstimator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept is a refinement of <a class="el" href="structDGtal_1_1concepts_1_1CCurveLocalGeometricEstimator.html" title="Aim: This concept describes an object that can process a range so as to return one estimated quantity...">CCurveLocalGeometricEstimator</a> devoted to the estimation of a geometric quantiy along a segment detected by a segment computer.  <a href="structDGtal_1_1concepts_1_1CSegmentComputerEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1C3DParametricCurve.html">DGtal::concepts::C3DParametricCurve&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="structDGtal_1_1concepts_1_1C3DParametricCurve.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1C3DParametricCurveDecorator.html">DGtal::concepts::C3DParametricCurveDecorator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="structDGtal_1_1concepts_1_1C3DParametricCurveDecorator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CAdditivePrimitiveComputer.html">DGtal::concepts::CAdditivePrimitiveComputer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing an object that computes some primitive from input points given group by group, while keeping some internal state. At any moment, the object is supposed to store at least one valid primitive for the formerly given input points. A primitive is an informal word that describes some family of objects that share common characteristics. Often, the primitives are geometric, e.g. digital planes.  <a href="structDGtal_1_1concepts_1_1CAdditivePrimitiveComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CIncrementalPrimitiveComputer.html">DGtal::concepts::CIncrementalPrimitiveComputer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing an object that computes some primitive from input points given one at a time, while keeping some internal state. At any moment, the object is supposed to store at least one valid primitive for the formerly given input points. A primitive is an informal word that describes some family of objects that share common characteristics. Often, the primitives are geometric, e.g. digital planes.  <a href="structDGtal_1_1concepts_1_1CIncrementalPrimitiveComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CPrimitiveComputer.html">DGtal::concepts::CPrimitiveComputer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing an object that computes some primitive from input points, while keeping some internal state. At any moment, the object is supposed to store at least one valid primitive for the formerly given input points. A primitive is an informal word that describes some family of objects that share common characteristics. Often, the primitives are geometric, e.g. digital planes.  <a href="structDGtal_1_1concepts_1_1CPrimitiveComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1deprecated_1_1concepts_1_1CConvolutionWeights.html">DGtal::deprecated::concepts::CConvolutionWeights&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: defines models of centered convolution kernel used for normal vector integration for instance.  <a href="structDGtal_1_1deprecated_1_1concepts_1_1CConvolutionWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDigitalSurfaceLocalEstimator.html">DGtal::concepts::CDigitalSurfaceLocalEstimator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept describes an object that can process a range over some generic digital surface so as to return one estimated quantity for each element of the range (or a given subrange).  <a href="structDGtal_1_1concepts_1_1CDigitalSurfaceLocalEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CNormalVectorEstimator.html">DGtal::concepts::CNormalVectorEstimator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents the concept of estimator of normal vector along digital surfaces.  <a href="structDGtal_1_1concepts_1_1CNormalVectorEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSurfelLocalEstimator.html">DGtal::concepts::CSurfelLocalEstimator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept describes an object that can process a range of surfels (that are supposed to belong to some (abstract) surface) so as to return one estimated quantity for each element of the range (or a given subrange).  <a href="structDGtal_1_1concepts_1_1CSurfelLocalEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CLocalEstimatorFromSurfelFunctor.html">DGtal::concepts::CLocalEstimatorFromSurfelFunctor&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: this concept describes functors on digtal surface surfel which can be used to define local estimator using the adapter <a class="el" href="classDGtal_1_1LocalEstimatorFromSurfelFunctorAdapter.html" title="Aim: this class adapts any local functor on digital surface element to define a local estimator....">LocalEstimatorFromSurfelFunctorAdapter</a>.  <a href="structDGtal_1_1concepts_1_1CLocalEstimatorFromSurfelFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CPolarPointComparator2D.html">DGtal::concepts::CPolarPointComparator2D&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept gathers classes that are able to compare the position of two given points \( P, Q \) around a pole \( O \). More precisely, they compare the oriented angles lying between the horizontal line passing by \( O \) and the rays \( [OP) \) and \( [OQ) \) (in a counter-clockwise orientation). This is equivalent to compare the angle in radians from 0 (included) to 2 &pi; (excluded).  <a href="structDGtal_1_1concepts_1_1CPolarPointComparator2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1C2x2DetComputer.html">DGtal::C2x2DetComputer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept gathers all models that are able to compute the (sign of the) determinant of a 2x2 matrix with integral entries.  <a href="structDGtal_1_1C2x2DetComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1COrientationFunctor.html">DGtal::concepts::COrientationFunctor&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept gathers models implementing an orientation test of \( k+1 \) points in a space of dimension \( n \).  <a href="structDGtal_1_1concepts_1_1COrientationFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1COrientationFunctor2.html">DGtal::concepts::COrientationFunctor2&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept is a refinement of <a class="el" href="structDGtal_1_1concepts_1_1COrientationFunctor.html" title="Aim: This concept gathers models implementing an orientation test of  points in a space of dimension ...">COrientationFunctor</a>, useful for simple algebraic curves that can be uniquely defined by only two points. <br  />
  <a href="structDGtal_1_1concepts_1_1COrientationFunctor2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDigitalMetricSpace.html">DGtal::concepts::CDigitalMetricSpace&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: defines the concept of digital metric spaces.  <a href="structDGtal_1_1concepts_1_1CDigitalMetricSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CMetricSpace.html">DGtal::concepts::CMetricSpace&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: defines the concept of metric spaces.  <a href="structDGtal_1_1concepts_1_1CMetricSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CPowerMetric.html">DGtal::concepts::CPowerMetric&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: defines the concept of special weighted metrics, so called power metrics.  <a href="structDGtal_1_1concepts_1_1CPowerMetric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CPowerSeparableMetric.html">DGtal::concepts::CPowerSeparableMetric&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: defines the concept of separable metrics.  <a href="structDGtal_1_1concepts_1_1CPowerSeparableMetric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSeparableMetric.html">DGtal::concepts::CSeparableMetric&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: defines the concept of separable metrics.  <a href="structDGtal_1_1concepts_1_1CSeparableMetric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CGraphVisitor.html">DGtal::concepts::CGraphVisitor&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept of a visitor onto a graph, that is an object that traverses vertices of the graph according to some order. The user can either use the visitor as is, or even constrain the traversal with a given predicate.  <a href="structDGtal_1_1concepts_1_1CGraphVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CUndirectedSimpleGraph.html">DGtal::concepts::CUndirectedSimpleGraph&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not necessarily know all the vertices.  <a href="structDGtal_1_1concepts_1_1CUndirectedSimpleGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CUndirectedSimpleLocalGraph.html">DGtal::concepts::CUndirectedSimpleLocalGraph&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not necessarily know all the vertices.  <a href="structDGtal_1_1concepts_1_1CUndirectedSimpleLocalGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CVertexMap.html">DGtal::concepts::CVertexMap&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: models of <a class="el" href="structDGtal_1_1concepts_1_1CVertexMap.html" title="Aim: models of CVertexMap concept implement mapping between graph vertices and values.">CVertexMap</a> concept implement mapping between graph vertices and values.  <a href="structDGtal_1_1concepts_1_1CVertexMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CVertexPredicate.html">DGtal::concepts::CVertexPredicate&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a predicate on a vertex.  <a href="structDGtal_1_1concepts_1_1CVertexPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CConstImage.html">DGtal::concepts::CConstImage&lt; I &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a read-only image, which is a refinement of <a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html" title="Aim: Defines a functor on points.">CPointFunctor</a>.  <a href="structDGtal_1_1concepts_1_1CConstImage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CImage.html">DGtal::concepts::CImage&lt; I &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a read/write image, having an output iterator.  <a href="structDGtal_1_1concepts_1_1CImage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CImageCacheReadPolicy.html">DGtal::concepts::CImageCacheReadPolicy&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a cache read policy.  <a href="structDGtal_1_1concepts_1_1CImageCacheReadPolicy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CImageCacheWritePolicy.html">DGtal::concepts::CImageCacheWritePolicy&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a cache write policy.  <a href="structDGtal_1_1concepts_1_1CImageCacheWritePolicy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CImageFactory.html">DGtal::concepts::CImageFactory&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing an image factory.  <a href="structDGtal_1_1concepts_1_1CImageFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CTrivialConstImage.html">DGtal::concepts::CTrivialConstImage&lt; I &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a read-only image, which is a refinement of <a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html" title="Aim: Defines a functor on points.">CPointFunctor</a>.  <a href="structDGtal_1_1concepts_1_1CTrivialConstImage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CTrivialImage.html">DGtal::concepts::CTrivialImage&lt; I &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing an image without extra ranges, which is a refinement of <a class="el" href="structDGtal_1_1concepts_1_1CTrivialConstImage.html" title="Aim: Defines the concept describing a read-only image, which is a refinement of CPointFunctor.">CTrivialConstImage</a>.  <a href="structDGtal_1_1concepts_1_1CTrivialImage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDrawableWithBoard2D.html">DGtal::concepts::CDrawableWithBoard2D&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The concept <a class="el" href="structDGtal_1_1concepts_1_1CDrawableWithBoard2D.html" title="Aim: The concept CDrawableWithBoard2D specifies what are the classes that admit an export with Board2...">CDrawableWithBoard2D</a> specifies what are the classes that admit an export with <a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (with &lt;&lt;)....">Board2D</a>.  <a href="structDGtal_1_1concepts_1_1CDrawableWithBoard2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1concepts_1_1Board3DTo2D.html">DGtal::concepts::Board3DTo2D&lt; S, KS &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The concept <a class="el" href="structDGtal_1_1concepts_1_1CDrawableWithBoard3DTo2D.html">CDrawableWithBoard3DTo2D</a> specifies what are the classes that admit an export with <a class="el" href="classDGtal_1_1concepts_1_1Board3DTo2D.html" title="Aim: The concept CDrawableWithBoard3DTo2D specifies what are the classes that admit an export with Bo...">Board3DTo2D</a>.  <a href="classDGtal_1_1concepts_1_1Board3DTo2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1concepts_1_1Display3D.html">DGtal::concepts::Display3D&lt; S, KS &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The concept <a class="el" href="structDGtal_1_1concepts_1_1CDrawableWithDisplay3D.html">CDrawableWithDisplay3D</a> specifies what are the classes that admit an export with <a class="el" href="classDGtal_1_1concepts_1_1Display3D.html" title="Aim: The concept CDrawableWithDisplay3D specifies what are the classes that admit an export with Disp...">Display3D</a>.  <a href="classDGtal_1_1concepts_1_1Display3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CColorMap.html">DGtal::concepts::CColorMap&lt; CMap &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a color map. A color map converts a value within a given range into an RGB triple.  <a href="structDGtal_1_1concepts_1_1CColorMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDrawableWithViewer3D.html">DGtal::concepts::CDrawableWithViewer3D&lt; T, S, KS &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The concept <a class="el" href="structDGtal_1_1concepts_1_1CDrawableWithViewer3D.html" title="Aim: The concept CDrawableWithViewer3D specifies what are the classes that admit an export with Viewe...">CDrawableWithViewer3D</a> specifies what are the classes that admit an export with <a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a>.  <a href="structDGtal_1_1concepts_1_1CDrawableWithViewer3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CBoundedNumber.html">DGtal::concepts::CBoundedNumber&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The concept <a class="el" href="structDGtal_1_1concepts_1_1CBoundedNumber.html" title="Aim: The concept CBoundedNumber specifies what are the bounded numbers. Models of this concept should...">CBoundedNumber</a> specifies what are the bounded numbers. Models of this concept should be listed in <a class="el" href="structDGtal_1_1NumberTraits.html" title="Aim: The traits class for all models of Cinteger.">NumberTraits</a> class and should have the isBounded property.  <a href="structDGtal_1_1concepts_1_1CBoundedNumber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CCommutativeRing.html">DGtal::concepts::CCommutativeRing&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the mathematical concept equivalent to a unitary commutative ring.  <a href="structDGtal_1_1concepts_1_1CCommutativeRing.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CEuclideanRing.html">DGtal::concepts::CEuclideanRing&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the mathematical concept equivalent to a unitary commutative ring with a division operator.  <a href="structDGtal_1_1concepts_1_1CEuclideanRing.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CInteger.html">DGtal::concepts::CInteger&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Concept checking for Integer Numbers. More precisely, this concept is a refinement of both <a class="el" href="structDGtal_1_1concepts_1_1CEuclideanRing.html" title="Aim: Defines the mathematical concept equivalent to a unitary commutative ring with a division operat...">CEuclideanRing</a> and <a class="el" href="structDGtal_1_1concepts_1_1CIntegralNumber.html" title="Aim: Concept checking for Integral Numbers. Models of this concept should be listed in NumberTraits c...">CIntegralNumber</a>.  <a href="structDGtal_1_1concepts_1_1CInteger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CIntegralNumber.html">DGtal::concepts::CIntegralNumber&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Concept checking for Integral Numbers. Models of this concept should be listed in <a class="el" href="structDGtal_1_1NumberTraits.html" title="Aim: The traits class for all models of Cinteger.">NumberTraits</a> class and should have the isIntegral property.  <a href="structDGtal_1_1concepts_1_1CIntegralNumber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CPointEmbedder.html">DGtal::concepts::CPointEmbedder&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A point embedder is a mapping from digital points to Euclidean points. It adds inner types to functor.  <a href="structDGtal_1_1concepts_1_1CPointEmbedder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html">DGtal::concepts::CPointFunctor&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a functor on points.  <a href="structDGtal_1_1concepts_1_1CPointFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html">DGtal::concepts::CPointPredicate&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a predicate on a point.  <a href="structDGtal_1_1concepts_1_1CPointPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSignedNumber.html">DGtal::concepts::CSignedNumber&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Concept checking for Signed Numbers. Models of this concept should be listed in <a class="el" href="structDGtal_1_1NumberTraits.html" title="Aim: The traits class for all models of Cinteger.">NumberTraits</a> class and should have the isSigned property.  <a href="structDGtal_1_1concepts_1_1CSignedNumber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSpace.html">DGtal::concepts::CSpace&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a digital space, ie a cartesian product of integer lines.  <a href="structDGtal_1_1concepts_1_1CSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CUnsignedNumber.html">DGtal::concepts::CUnsignedNumber&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Concept checking for Unsigned numbers. Models of this concept should be listed in <a class="el" href="structDGtal_1_1NumberTraits.html" title="Aim: The traits class for all models of Cinteger.">NumberTraits</a> class and should have the isUnsigned property.  <a href="structDGtal_1_1concepts_1_1CUnsignedNumber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CWithGradientMap.html">DGtal::concepts::CWithGradientMap&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Such object provides a gradient map that associates to each argument some real vector.  <a href="structDGtal_1_1concepts_1_1CWithGradientMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDigitalSet.html">DGtal::concepts::CDigitalSet&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a set of points within the given domain. This set of points is modifiable by the user. It is thus very close to the STL concept of simple associative container (like set std::set&lt;Point&gt;), except that there is a notion of maximal set of points (the whole domain).  <a href="structDGtal_1_1concepts_1_1CDigitalSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CBinner.html">DGtal::concepts::CBinner&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents an object that places a quantity into a bin, i.e. a functor that associates a natural integer to a continuous value.  <a href="structDGtal_1_1concepts_1_1CBinner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDenseMatrix.html">DGtal::concepts::CDenseMatrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent any dynamic or static sized matrix having dense representation.  <a href="structDGtal_1_1concepts_1_1CDenseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDenseVector.html">DGtal::concepts::CDenseVector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent any dynamic or static sized matrix having dense representation.  <a href="structDGtal_1_1concepts_1_1CDenseVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDynamicMatrix.html">DGtal::concepts::CDynamicMatrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent any dynamic sized matrix having sparse or dense representation.  <a href="structDGtal_1_1concepts_1_1CDynamicMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDynamicVector.html">DGtal::concepts::CDynamicVector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent any dynamic sized column vector having sparse or dense representation.  <a href="structDGtal_1_1concepts_1_1CDynamicVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CLinearAlgebra.html">DGtal::concepts::CLinearAlgebra&lt; V, M &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Check right multiplication between matrix and vector and internal matrix multiplication. Matrix and vector scalar types should be the same.  <a href="structDGtal_1_1concepts_1_1CLinearAlgebra.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CLinearAlgebraSolver.html">DGtal::concepts::CLinearAlgebraSolver&lt; S, V, M &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Describe a linear solver defined over a linear algebra. Problems are of the form:  <a href="structDGtal_1_1concepts_1_1CLinearAlgebraSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CMatrix.html">DGtal::concepts::CMatrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent any static or dynamic sized matrix having sparse or dense representation.  <a href="structDGtal_1_1concepts_1_1CMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSparseMatrix.html">DGtal::concepts::CSparseMatrix&lt; T, TripletInterator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent any dynamic or static sized matrix having sparse representation.  <a href="structDGtal_1_1concepts_1_1CSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CStaticMatrix.html">DGtal::concepts::CStaticMatrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent any static sized matrix having sparse or dense representation.  <a href="structDGtal_1_1concepts_1_1CStaticMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CStaticVector.html">DGtal::concepts::CStaticVector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent any static sized column vector having sparse or dense representation.  <a href="structDGtal_1_1concepts_1_1CStaticVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CVector.html">DGtal::concepts::CVector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent any static or dynamic sized column vector having sparse or dense representation.  <a href="structDGtal_1_1concepts_1_1CVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CVectorSpace.html">DGtal::concepts::CVectorSpace&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Base concept for vector space structure.  <a href="structDGtal_1_1concepts_1_1CVectorSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDigitalBoundedShape.html">DGtal::concepts::CDigitalBoundedShape&lt; TShape &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: designs the concept of bounded shapes in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> (shape for which upper and lower bounding bounds are available).  <a href="structDGtal_1_1concepts_1_1CDigitalBoundedShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDigitalOrientedShape.html">DGtal::concepts::CDigitalOrientedShape&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: characterizes models of digital oriented shapes. For example, models should provide an orientation method for points on a <a class="el" href="classDGtal_1_1SpaceND.html">SpaceND</a>. Returned value type corresponds to <a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41">DGtal::Orientation</a>.  <a href="structDGtal_1_1concepts_1_1CDigitalOrientedShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CEuclideanBoundedShape.html">DGtal::concepts::CEuclideanBoundedShape&lt; TShape &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CEuclideanOrientedShape.html">DGtal::concepts::CEuclideanOrientedShape&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: characterizes models of digital oriented shapes. For example, models should provide an orientation method for real points. Returned value type corresponds to <a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41">DGtal::Orientation</a>.  <a href="structDGtal_1_1concepts_1_1CEuclideanOrientedShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CImplicitFunction.html">DGtal::concepts::CImplicitFunction&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Describes any function of the form f(x), where x is some real point in the given space, and f(x) is some value.  <a href="structDGtal_1_1concepts_1_1CImplicitFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CImplicitFunctionDiff1.html">DGtal::concepts::CImplicitFunctionDiff1&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Describes a 1-differentiable function of the form f(x), where x is some real point in the given space, and f(x) is some value.  <a href="structDGtal_1_1concepts_1_1CImplicitFunctionDiff1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CAdjacency.html">DGtal::concepts::CAdjacency&lt; Adj &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The concept <a class="el" href="structDGtal_1_1concepts_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">CAdjacency</a> defines an elementary adjacency relation between points of a digital space.  <a href="structDGtal_1_1concepts_1_1CAdjacency.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CCellEmbedder.html">DGtal::concepts::CCellEmbedder&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A cell embedder is a mapping from unsigned cells to Euclidean points. It adds inner types to functor.  <a href="structDGtal_1_1concepts_1_1CCellEmbedder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CCellFunctor.html">DGtal::concepts::CCellFunctor&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a functor on cells.  <a href="structDGtal_1_1concepts_1_1CCellFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CCellularGridSpaceND.html">DGtal::concepts::CCellularGridSpaceND&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian product, cells have a cubic shape that depends on the dimension: 0-cells are points, 1-cells are unit segments, 2-cells are squares, 3-cells are cubes, and so on.  <a href="structDGtal_1_1concepts_1_1CCellularGridSpaceND.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDigitalSurfaceContainer.html">DGtal::concepts::CDigitalSurfaceContainer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The digital surface container concept describes a minimal set of inner types and methods so as to describe the data of digital surfaces.  <a href="structDGtal_1_1concepts_1_1CDigitalSurfaceContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDigitalSurfaceEmbedder.html">DGtal::concepts::CDigitalSurfaceEmbedder&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A digital surface embedder is a specialized mapping from signed cells to Euclidean points. It adds inner types to functor as well as a method to access the digital surface.  <a href="structDGtal_1_1concepts_1_1CDigitalSurfaceEmbedder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDigitalSurfaceTracker.html">DGtal::concepts::CDigitalSurfaceTracker&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="structDGtal_1_1concepts_1_1CDigitalSurfaceTracker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CDomainAdjacency.html">DGtal::concepts::CDomainAdjacency&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Refines the concept <a class="el" href="structDGtal_1_1concepts_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">CAdjacency</a> by telling that the adjacency is specific to a given domain of the embedding digital space.  <a href="structDGtal_1_1concepts_1_1CDomainAdjacency.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CPreCellularGridSpaceND.html">DGtal::concepts::CPreCellularGridSpaceND&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept describes an unbounded cellular grid space in nD. In these spaces obtained by cartesian product, cells have a cubic shape that depends on the dimension: 0-cells are points, 1-cells are unit segments, 2-cells are squares, 3-cells are cubes, and so on.  <a href="structDGtal_1_1concepts_1_1CPreCellularGridSpaceND.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSCellEmbedder.html">DGtal::concepts::CSCellEmbedder&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A cell embedder is a mapping from signed cells to Euclidean points. It adds inner types to functor.  <a href="structDGtal_1_1concepts_1_1CSCellEmbedder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1concepts_1_1CSurfelPredicate.html">DGtal::concepts::CSurfelPredicate&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a predicate on a surfel.  <a href="structDGtal_1_1concepts_1_1CSurfelPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 17 2022 17:06:53 for DGtal by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
