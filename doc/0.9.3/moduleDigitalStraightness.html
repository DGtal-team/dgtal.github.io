<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Patterns, digital straight lines and subsegments</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.9.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Patterns, digital straight lines and subsegments </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#dgtal_digstraighness_sec1">Standard digital straight lines and patterns</a></li>
<li class="level1"><a href="#dgtal_digstraighness_sec2">Patterns</a><ul><li class="level2"><a href="#dgtal_digstraighness_sec2_1">Definition of patterns</a></li>
<li class="level2"><a href="#dgtal_digstraighness_sec2_2">Creating patterns in DGtal</a></li>
<li class="level2"><a href="#dgtal_digstraighness_sec2_3">Recursive properties of patterns</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtal_digstraighness_sec3">Digital straight lines and subsegments</a><ul><li class="level2"><a href="#dgtal_digstraighness_sec3_1">Creating a digital straight line</a></li>
<li class="level2"><a href="#dgtal_digstraighness_sec3_2">A DSL is a sequence of points in the digital plane</a></li>
<li class="level2"><a href="#dgtal_digstraighness_sec3_3">Getting several characteristics</a></li>
<li class="level2"><a href="#dgtal_digstraighness_sec3_4">Getting points on a DSL</a></li>
<li class="level2"><a href="#dgtal_digstraighness_sec3_5">Fast computation of subsegments</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation:</dt><dd>Jacques-Olivier Lachaud</dd></dl>
<p>Part of the <a class="el" href="packageArithmetic.html">Arithmetic package</a>.</p>
<p>This part of the manual describes digital straightness from a combinatoric and arithmetic point of view. It tells you how to create patterns, digital straight lines in the first quadrant, and how to compute subsegments in sublinear time (algorithms SmartDSS [Said, Lachaud, Feschet 2009 : <a class="el" href="citelist.html#CITEREF_Said_2009_dgci">[68]</a> ] and ReversedSmartDSS [Said, Lachaud 2011 : <a class="el" href="citelist.html#CITEREF_Said_2011_dgci">[67]</a>]). Full proofs and details on these two algorithms are given in [Lachaud, Said 2013 : <a class="el" href="citelist.html#CITEREF_Lachaud_2013-dam-ap">[44]</a> ].</p>
<h1><a class="anchor" id="dgtal_digstraighness_sec1"></a>
Standard digital straight lines and patterns</h1>
<p>A <b>standard</b> <b>digital</b> <b>straight</b> <b>line</b> in 2D (DSL) is the following subset of \( Z^2 \):</p>
<p>\( \{(x,y) \in Z^2, \mu \le a x - by &lt; \mu + |a| +|b|-1 \} \)</p>
<p>where the integers \( (a,b,\mu) \), \( gcd(a,b)=1 \), are called the <b>characteristics</b> of the straight line [ Reveilles <a class="el" href="citelist.html#CITEREF_Reveilles_1991_thesis">[62]</a> , Debled and Reveilles <a class="el" href="citelist.html#CITEREF_Debled_1995_ijprai">[29]</a> ].</p>
<p>It is well known that this set of digital points is a simple 4-connected curve. Here is a representation of the straight line (3,5,-5).</p>
<div class="image">
<img src="dsl-standard-s.png" alt="dsl-standard-s.png"/>
<div class="caption">
Standard Digital Straight Line of characteristics (3,5,-5)</div></div>
<p>The <b>slope</b> of the DSL is \( a/b \), while \( \mu \) is the <b>shift</b> at origin. The <em>remainder</em> of the DSL is the value \( ax-by \). <b>Upper</b> <b>leaning</b> <b>points</b> have remainer \( \mu \) while <b>lower</b> <b>leaning</b> <b>points</b> have value \( \mu + |a| +|b|-1 \).</p>
<h1><a class="anchor" id="dgtal_digstraighness_sec2"></a>
Patterns</h1>
<h2><a class="anchor" id="dgtal_digstraighness_sec2_1"></a>
Definition of patterns</h2>
<p>A <b>pattern</b> of slope \( a/b \) is the freeman chaincode between two consecutive upper leaning points of any DSL with slope \( a/b \).</p>
<p>Patterns are specific subsegments of digital straight lines (DSL). They depend only on the slope of the DSL, i.e. the irreducible fraction \( a/b \).</p>
<h2><a class="anchor" id="dgtal_digstraighness_sec2_2"></a>
Creating patterns in DGtal</h2>
<p>Package Arithmetic provides the class <a class="el" href="classDGtal_1_1Pattern.html" title="Aim: This class represents a pattern, i.e. the path between two consecutive upper leaning points on a...">Pattern</a> to represent a pattern. Patterns are instantiated either by a fraction or two integers <em>p</em> and <em>q</em>. They are therefore parameterized by the type of irreducible fraction you wish to use (see <a class="el" href="moduleIrreducibleFraction.html">Irreducible fraction, continued fractions</a>). You may define patterns as follows:</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="pattern_8cpp.html">pattern.cpp</a></dd></dl>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> <a class="code" href="namespaceDGtal.html#ac1e9ac6a329319ae13c51c0c9e92486a">DGtal::int32_t</a> <a class="code" href="namespaceDGtal_1_1Z2i.html#a5d93c6632713d21e2662c93af3a941e6">Integer</a>;</div><div class="line">  <span class="keyword">typedef</span> <a class="code" href="namespaceDGtal.html#ac1e9ac6a329319ae13c51c0c9e92486a">DGtal::int32_t</a> Quotient;</div><div class="line">  <span class="keyword">typedef</span> LighterSternBrocot&lt;Integer, Quotient, StdMapRebinder&gt; SB; <span class="comment">// the type of the Stern-Brocot tree</span></div><div class="line">  <span class="keyword">typedef</span> SB::Fraction Fraction; <span class="comment">// the type for fractions</span></div><div class="line">  <span class="keyword">typedef</span> Pattern&lt;Fraction&gt; MyPattern; <span class="comment">// the type for patterns</span></div></div><!-- fragment --><div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal.html#ac1e9ac6a329319ae13c51c0c9e92486a">DGtal::int32_t</a> p = atoi( argv[ 1 ] );</div><div class="line">  <a class="code" href="namespaceDGtal.html#ac1e9ac6a329319ae13c51c0c9e92486a">DGtal::int32_t</a> q = atoi( argv[ 2 ] );</div><div class="line">  MyPattern pattern( p, q );</div></div><!-- fragment --><p> To get the freeman chaincode of the pattern, you may use the methods <a class="el" href="classDGtal_1_1Pattern.html#a9243ee329d0226e255341cf0e99eaa5c">Pattern::rE</a> and <a class="el" href="classDGtal_1_1Pattern.html#ad9f191d28e826d5765d2407b4df4e757">Pattern::rEs</a>.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">bool</span> sub = ( argc &gt; 3 ) &amp;&amp; ( std::string( argv[ 3 ] ) == <span class="stringliteral">&quot;SUB&quot;</span> );</div><div class="line">  std::cout &lt;&lt; ( ! sub ? pattern.rE() : pattern.rEs( <span class="stringliteral">&quot;(|)&quot;</span> ) ) &lt;&lt; std::endl;</div></div><!-- fragment --> <pre class="fragment">$ ./examples/arithmetic/pattern 11 17 
0010010100101001010010100101
$ ./examples/arithmetic/pattern 11 17 SUB
((00|1)|(0|0101)(0|0101)(0|0101)(0|0101)(0|0101))
</pre><h2><a class="anchor" id="dgtal_digstraighness_sec2_3"></a>
Recursive properties of patterns</h2>
<p>Recursive definitions of pattern are related to the continued fraction of the slope. We choose here to present the Berstel recursive definition. If \( z=p/q=[u_0;u_1,\ldots,u_n] \) is the slope of the pattern, the pattern may be obtained from the following recursive formulas:</p>
<p>\( E(z_{-1})=1, E(z_{0})=0, E(z_{2k+1})=E(z_{2k})^{u_{2k+1}} E(z_{2k-1}), E(z_{2k})=E(z_{2k-2}) E(z_{2k-1})^{u_{2k}}. \)</p>
<p>Let us look again at the pattern of 11/17. First, the convergents are:</p>
<pre class="fragment">$ ./examples/arithmetic/convergents 11 17 
z = [0,1,1,1,5]
z_0 = 0 / 1
z_1 = 1 / 1
z_2 = 1 / 2
z_3 = 2 / 3
z_4 = 11 / 17
</pre><pre class="fragment">E(0/1) = 0
E(1/1) = E([0;1]) = E(0/1)^1 E(z_-1) = 0.1
E(1/2) = E([0;1,1]) = E(0/1) E(1/1)^1 = 0.01
E(2/3) = E([0;1,1,1]) = E(1/2)^1 E(1/1) = 001.01
E(11/17) = E([0;1,1,1,5]) = E(1/2) E(2/3)^5 = 001.(00101)^5
</pre><p>Which is exactly the sought pattern.</p>
<p>There are several methods to compute the Bézout vector of a pattern or the coordinates of its upper and lower leaning points (see reference of class <a class="el" href="classDGtal_1_1Pattern.html" title="Aim: This class represents a pattern, i.e. the path between two consecutive upper leaning points on a...">Pattern</a>).</p>
<h1><a class="anchor" id="dgtal_digstraighness_sec3"></a>
Digital straight lines and subsegments</h1>
<h2><a class="anchor" id="dgtal_digstraighness_sec3_1"></a>
Creating a digital straight line</h2>
<p>For now, you may only instantiate digital straight lines whose slope is in the first quadrant. If \( (a,b,\mu) \) are the characteristics of the line, then \( a \ge 0, b \ge 0 \).</p>
<div class="fragment"><div class="line">...</div><div class="line">#include <span class="stringliteral">&quot;DGtal/arithmetic/StandardDSLQ0.h&quot;</span></div><div class="line">...</div><div class="line">typedef ... Fraction;</div><div class="line"><span class="keyword">typedef</span> StandardDSLQ0&lt;Fraction&gt; DSL;</div><div class="line">...</div><div class="line">DSL D( 3, 5, -5 );</div></div><!-- fragment --><h2><a class="anchor" id="dgtal_digstraighness_sec3_2"></a>
A DSL is a sequence of points in the digital plane</h2>
<p>A DSL provides the function operator StandardDSLQ0::operator(), taking a <em>Point</em> <em>p</em> and returning 'true' iff <em>p</em> belongs to the set of points of the DSL. It is indeed a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a>.</p>
<p>The <em>Point</em> type is PointVector&lt;2,Fraction::Integer&gt;.</p>
<p>You may visit the DSL from left to right with iterators of type <a class="el" href="structDGtal_1_1StandardDSLQ0_1_1ConstIterator.html">StandardDSLQ0::ConstIterator</a>. You just precise the starting point with <a class="el" href="classDGtal_1_1StandardDSLQ0.html#aafac5d357340f3ad1fa48e133ddaf8a4">StandardDSLQ0::begin</a> and the point after the last with <a class="el" href="classDGtal_1_1StandardDSLQ0.html#ab5eef99d9e34411e81174ee01741db7d">StandardDSLQ0::end</a>.</p>
<p>You can compare if a point precedes another point (to the left) on the DSL with methods <a class="el" href="classDGtal_1_1StandardDSLQ0.html#a106ad76affd9047de4a31860bbfa059b">StandardDSLQ0::before</a> and <a class="el" href="classDGtal_1_1StandardDSLQ0.html#ae6902e4d94ffedaf936d384ac26415b0">StandardDSLQ0::beforeOrEqual</a>.</p>
<h2><a class="anchor" id="dgtal_digstraighness_sec3_3"></a>
Getting several characteristics</h2>
<p>You have access to the following information:</p><ul>
<li>characteristics \((a,b,\mu)\) with <a class="el" href="classDGtal_1_1StandardDSLQ0.html#aa451ac6d2fcf55193e4d4b43b39e6e6f">StandardDSLQ0::a</a>, <a class="el" href="classDGtal_1_1StandardDSLQ0.html#aec1cb5c98d4f87ac0cf67ffa53b5cd1b">StandardDSLQ0::b</a>, <a class="el" href="classDGtal_1_1StandardDSLQ0.html#ae8d7e62951879c8f7b2b428cbc73a90d">StandardDSLQ0::mu</a></li>
<li>value \(\mu+a+b-1\) with <a class="el" href="classDGtal_1_1StandardDSLQ0.html#a8f4e86ba8aaf2b2c8b6f34527d741128">StandardDSLQ0::mup</a></li>
<li>slope as irreducible fraction with <a class="el" href="classDGtal_1_1StandardDSLQ0.html#a4a2035eaa15785bea0d0e688597bd703">StandardDSLQ0::slope</a></li>
<li>pattern of same slope with <a class="el" href="classDGtal_1_1StandardDSLQ0.html#a04a1f6eb9c656f4b0434dcb2a39dc441">StandardDSLQ0::pattern</a></li>
<li>vector of the pattern (i.e (b,a)) with <a class="el" href="classDGtal_1_1StandardDSLQ0.html#a2980d1559f74a83bbb82d65e29c68db9">StandardDSLQ0::v</a></li>
<li>remainder of the DSL with <a class="el" href="classDGtal_1_1StandardDSLQ0.html#a3c763ba64375fef240b96246e2b7277f">StandardDSLQ0::r</a></li>
<li>first upper leaning point with x&gt;=0 with <a class="el" href="classDGtal_1_1StandardDSLQ0.html#a7aaf98371db5f6ec14c4c030b2ac0f71">StandardDSLQ0::U</a></li>
<li>first lower leaning point after the first upper leaning point with <a class="el" href="classDGtal_1_1StandardDSLQ0.html#ad3fff6e41a2c886d1bf74f97b1121f86">StandardDSLQ0::L</a></li>
</ul>
<h2><a class="anchor" id="dgtal_digstraighness_sec3_4"></a>
Getting points on a DSL</h2>
<p>For convenience, you have the following methods to determine points belonging to a DSL:</p><ul>
<li>given an x-coordinate, find the point with lowest y-coordinate on the DSL with <a class="el" href="classDGtal_1_1StandardDSLQ0.html#a867de772cdfc85cd348afcfe9482a9d0">StandardDSLQ0::lowestY</a></li>
<li>given an x-coordinate, find the point with uppermost y-coordinate on the DSL with <a class="el" href="classDGtal_1_1StandardDSLQ0.html#a127f7c9009632fb081bcc9d4d9eebde9">StandardDSLQ0::uppermostY</a></li>
<li>given a y-coordinate, find the point with lowest x-coordinate on the DSL with <a class="el" href="classDGtal_1_1StandardDSLQ0.html#accb92c02df6ada92b57d2ee82a2ddb35">StandardDSLQ0::lowestX</a></li>
<li>given a y-coordinate, find the point with uppermost x-coordinate on the DSL with <a class="el" href="classDGtal_1_1StandardDSLQ0.html#abd6b02159e356b7eb981a23355d367e2">StandardDSLQ0::uppermostX</a></li>
</ul>
<h2><a class="anchor" id="dgtal_digstraighness_sec3_5"></a>
Fast computation of subsegments</h2>
<p>Given two points <em>A</em> and <em>B</em> on the DSL, you can determine the exact characteristics of the subsegment [A,B] in sublinear time with two algorithms: SmartDSS [Said, Lachaud, Feschet 2009 : <a class="el" href="citelist.html#CITEREF_Said_2009_dgci">[68]</a> ] and ReversedSmartDSS [Said, Lachaud 2011 : <a class="el" href="citelist.html#CITEREF_Said_2011_dgci">[67]</a>]. In fact, these algorithms return the DSL which covers [A,B] and whose characteristics are minimal.</p>
<ul>
<li>method <a class="el" href="classDGtal_1_1StandardDSLQ0.html#a2ffe39c5656786768cebc01dfc25676a">StandardDSLQ0::smartDSS</a>, given this DSL, <em>A</em> and <em>B</em>, returns this minimal DSL in time proportional to the sum of the quotients of the output DSL.</li>
<li>method <a class="el" href="classDGtal_1_1StandardDSLQ0.html#a2548ce4c9fcb01f5537d21868c012130">StandardDSLQ0::reversedSmartDSS</a>, given this DSL, <em>A</em> and <em>B</em>, returns this minimal DSL in time proportional to the difference of depth between the input and the output slope.</li>
</ul>
<p>You may have a look at the following programs to check these algorithms (the many variants come from the different choices for the algorithm and the fraction type):</p>
<ul>
<li><a class="el" href="testStandardDSLQ0-smartDSS-benchmark_8cpp.html">testStandardDSLQ0-smartDSS-benchmark.cpp</a></li>
<li><a class="el" href="testStandardDSLQ0-reversedSmartDSS-benchmark_8cpp.html">testStandardDSLQ0-reversedSmartDSS-benchmark.cpp</a></li>
<li><a class="el" href="testStandardDSLQ0-LSB-reversedSmartDSS-benchmark_8cpp.html">testStandardDSLQ0-LSB-reversedSmartDSS-benchmark.cpp</a></li>
<li><a class="el" href="testStandardDSLQ0-LrSB-reversedSmartDSS-benchmark_8cpp.html">testStandardDSLQ0-LrSB-reversedSmartDSS-benchmark.cpp</a> </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Feb 12 2017 10:25:18 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
