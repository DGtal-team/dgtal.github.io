<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>DGtal: Integral invariant curvature estimator 2D/3D</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Integral invariant curvature estimator 2D/3D </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sectOverview">Overview</a><ul><li class="level2"><a href="#subsectIntegralInvariant">Integral Invariants for curvature computation</a></li>
</ul>
</li>
<li class="level1"><a href="#sectAlgo">Algorithm</a><ul><li class="level2"><a href="#subsectDef">Overall algorithm</a></li>
<li class="level2"><a href="#subsectDetails">Technical details</a></li>
</ul>
</li>
<li class="level1"><a href="#sectImplementation">Implementation in DGtal</a></li>
<li class="level1"><a href="#sectResults">Some results</a></li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Jérémy Levallois</dd></dl>
<h1><a class="anchor" id="sectOverview"></a>
Overview</h1>
<p>The algorithm implemented in the class <a class="el" href="classDGtal_1_1IntegralInvariantMeanCurvatureEstimator.html" title="Aim: This class implement a Integral Invariant mean curvature estimation.">DGtal::IntegralInvariantMeanCurvatureEstimator</a> (resp. <a class="el" href="classDGtal_1_1IntegralInvariantGaussianCurvatureEstimator.html" title="Aim: This class implement a Integral Invariant Gaussian curvature estimation.">DGtal::IntegralInvariantGaussianCurvatureEstimator</a>) are detailed in the article<a class="el" href="citelist.html#CITEREF_Coeurjo2013">[8]</a> .</p>
<p>In geometry processing, interesting mathematical tools have been developed to design differential estimators on smooth surfaces based on integral invariants<a class="el" href="citelist.html#CITEREF_Pottmann2007">[17]</a><a class="el" href="citelist.html#CITEREF_Pottmann2009">[18]</a> . The principle is simple: we move a convolution kernel along the shape surface and we compute integrals on the intersection between the shape and the convolution kernel, as follow in dimension 3:</p>
<p class="formulaDsp">
\[ V_r(x) = \int_{B_r(x)} \chi(p)dp\ \]
</p>
<p>where \( B_r(x) \) is the Euclidean ball of radius \( r \), centered at \( x \) and \( \chi(p) \) the characteristic function of \( X \). In dimension 2, we simply denote \( A_r(x) \) such quantity (represented in orange color on the following figure).</p>
<div class="image">
<img src="integral2D.png" alt="integral2D.png"/>
<div class="caption">
Integral invariant computation in dimension 2.</div></div>
 <div class="image">
<img src="integral3D.png" alt="integral3D.png"/>
<div class="caption">
Integral invariant computation in dimension 3.</div></div>
 <div class="image">
<img src="notations_integral.png" alt="notations_integral.png"/>
<div class="caption">
Notations.</div></div>
<h2><a class="anchor" id="subsectIntegralInvariant"></a>
Integral Invariants for curvature computation</h2>
<p>In<a class="el" href="citelist.html#CITEREF_Coeurjo2013">[8]</a> , we have demonstrated that some digital integral quantities provide curvature information when the kernel size tends to zero for a sufficiently smooth shape. Indeed, at \( x \) of the surface \( X \) and with a fixed radius \( r \), we obtain convergent local curvature estimators \( \tilde{\kappa}_r(X,x) \) and \( \tilde{H}_r(X,x) \) of quantities \( \kappa(X,x) \) and \( H(X,x) \) respectively:</p>
<p class="formulaDsp">
\[ \tilde{\kappa}_r(X,x) = \frac{3\pi}{2r} - \frac{3A_r(x)}{r^3},\quad \tilde{\kappa}_r(X,x) = \kappa(X,x)+ O(r) \]
</p>
<p class="formulaDsp">
\[ \tilde{H}_r(X,x) = \frac{8}{3r} - \frac{4V_r(x)}{\pi r^4},\quad \tilde{H}_r(X,x) = H(X,x) + O(r) \]
</p>
<p>where \( \kappa_r(X,x) \) is the 2d curvature of \( X \) at \( x \) and \( H_r(X,x) \) is the 3d mean curvature of \( X \) at \( x \).</p>
<p>Then we showed that we can obtain local digital curvature estimators : </p>
<p class="formulaDsp">
\[ \forall 0 &lt; h &lt; r,\quad \hat{\kappa}_r(Z,x,h) = \frac{3\pi}{2r}-\frac{3\widehat{Area}(B_{r/h}(\frac{1}{h} \cdot x ) \cap Z, h)}{r^3} \]
</p>
<p> where \( \hat{\kappa}_r \) is an integral digital curvature estimator of a digital shape \( Z \subset ℤ^2 \) at point \( x \in \rm I\! R^2 \) and step \( h \). \( B_{r/h}(\frac{1}{h} \cdot x ) \cap Z, h) \) means the intersection between \( Z \) and a Ball \( B \) of radius \( r \) digitized by \( h \) centered in \( x \).</p>
<p>In the same way, we have in 3d : </p>
<p class="formulaDsp">
\[ \forall 0 &lt; h &lt; r,\quad \hat{H}_r(Z&#39;,x,h) = \frac{8}{3r}-\frac{4\widehat{Vol}(B_{r/h}(\frac{1}{h} \cdot x ) \cap Z&#39;, h)}{\pi r^4}. \]
</p>
<p> where \( \hat{H}_r \) is an integral digital mean curvature estimator of a digital shape \( Z&#39; \subset ℤ^3 \) at point \( x \in \rm I\! R^3 \) and step \( h \) .</p>
<p>We have demonstrated in<a class="el" href="citelist.html#CITEREF_Coeurjo2013">[8]</a> that to prove the multigrid convergence with a convergence speed of \( O(h^{\frac{1}{3}}) \), the Euclidean radius of the kernel must follow the rule \( r = k_mh^{\alpha_m} \) ( \( \alpha_m = \frac{1}{3} \) provides better worst-case errors, so we will use this value).</p>
<p>Experimental results can be found at <a href="https://liris.cnrs.fr/jeremy.levallois/Papers/DGCI2013/">https://liris.cnrs.fr/jeremy.levallois/Papers/DGCI2013/</a></p>
<h1><a class="anchor" id="sectAlgo"></a>
Algorithm</h1>
<h2><a class="anchor" id="subsectDef"></a>
Overall algorithm</h2>
<p>The user part is rather simple by using only <a class="el" href="classDGtal_1_1IntegralInvariantMeanCurvatureEstimator.html" title="Aim: This class implement a Integral Invariant mean curvature estimation.">DGtal::IntegralInvariantMeanCurvatureEstimator</a> or <a class="el" href="classDGtal_1_1IntegralInvariantGaussianCurvatureEstimator.html" title="Aim: This class implement a Integral Invariant Gaussian curvature estimation.">DGtal::IntegralInvariantGaussianCurvatureEstimator</a>. These classes are parametrized by a Khalimsky space of a digital shape and a functor who return a value for a given Khalimsky cell. It must be a model of <a class="el" href="structDGtal_1_1CCellFunctor.html" title="Aim: Defines a functor on cells.">DGtal::CCellFunctor</a> . Indeed, the \( \chi(p) \) characteristic function is defined as a functor (here with values in \( \{0,1\} \) for each spel of the Khalimsky space).</p>
<p>At initialization (<a class="el" href="classDGtal_1_1IntegralInvariantMeanCurvatureEstimator.html#a96602201ee3487c8193229b3e6264b37">DGtal::IntegralInvariantMeanCurvatureEstimator::init()</a>), we specify the current grid step \( h \), and an Euclidean radius \( r_e \) in order to construct the convolution kernel. As described below, this parameter \( r_e \) determines the level of feature detected by the estimator.</p>
<p>For the evaluation (<a class="el" href="classDGtal_1_1IntegralInvariantMeanCurvatureEstimator.html#a6f47aabd709cb708f64b78ad593a06e9">DGtal::IntegralInvariantMeanCurvatureEstimator::eval()</a>), the user has two possibilities: evaluate the curvature at a specific surfel of the digitized shape surface, or at a range of surfels. This choice can be important because optimizations are available with the second option (see in Technical details ). For the first one, the estimator return a curvature value at the given surfel. If you choose the second possibility, the estimator will try to optimize computations by using previous results. But it requires to set a range of 0-adjacent surfels. If the range of surfels does not follow that rule, no optimization is performed.</p>
<h2><a class="anchor" id="subsectDetails"></a>
Technical details</h2>
<p>To sum up, we need a convolution kernel which will be integrated along a digitized shape boundary. At initialization, we first create a convolution kernel (<a class="el" href="classDGtal_1_1Ball2D.html" title="Aim: Model of the concept StarShaped represents any circle in the plane.">DGtal::Ball2D</a> in 2d, <a class="el" href="classDGtal_1_1Ball3D.html" title="Aim: Model of the concept StarShaped3D represents any Sphere in the space.">DGtal::Ball3D</a> in 3d) of Euclidean radius \( r_e \) and digitized at the grid step \( h \). <a class="el" href="classDGtal_1_1DigitalSurfaceConvolver.html">DGtal::DigitalSurfaceConvolver</a> is in charge of centering the convolution kernel on the surfel on the digitized shape border. Its objective is to compute \( B_{r/h}(\frac{1}{h} \cdot x ) \cap Z \) and \( B_{r/h} (\frac{1}{h} \cdot x ) \cap Z&#39; \) from previous equation.</p>
<p>At evaluation, it will place the convolution kernel in order to lie his center with the cell to estimate. After, it will iterate on all spels of the kernel, and compute the integral:</p>
<p class="formulaDsp">
\[ V(x) = \sum_{spel \in B_{r/h}(\frac{1}{h} \cdot x ) \cap Z}f(x)g(s-x) \]
</p>
<p>where \( x \) is the current spel, \( f \) is the shape functor (set by user), \( g \) is the kernel functor (return 1 on all spels from the kernel). <a class="el" href="classDGtal_1_1IntegralInvariantMeanCurvatureEstimator.html" title="Aim: This class implement a Integral Invariant mean curvature estimation.">DGtal::IntegralInvariantMeanCurvatureEstimator</a> uses this result to get \( \widehat{Area}(B_{r/h}(\frac{1}{h} \cdot x ) \cap Z, h) \) in 2d and \( \widehat{Vol}(B_{r/h}(\frac{1}{h} \cdot x ) \cap Z&#39;, h) \) in 3d. With equation defined previously, it finally returns curvature quantities. Using this approach, we obtain a computation cost in \( O((r/h)^d) \) per surface element.</p>
<p>For <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>:<a class="el" href="classDGtal_1_1IntegralInvariantGaussianCurvatureEstimator.html" title="Aim: This class implement a Integral Invariant Gaussian curvature estimation.">IntegralInvariantGaussianCurvatureEstimator</a>, the initialization is the same but at evaluation <a class="el" href="classDGtal_1_1DigitalSurfaceConvolver.html">DGtal::DigitalSurfaceConvolver</a> computes a covariance matrix of \( B_{r/h}(\frac{1}{h} \cdot x ) \cap Z&#39; \). Eigenvectors and eigenvalues analysis of this covariance matrix helps us to extract principal curvatures information. We can easily obtain mean or Gaussian curvature from them.</p>
<p>When we move the convolution kernel to 0-adjacent cells, we see that only few cells need to be updated from the previous convolution.</p>
<div class="image">
<img src="MovingKernel.png" alt="MovingKernel.png"/>
<div class="caption">
Illustration of a displacement of a full kernel from $ x $ to $ x+{} $ </div></div>
<p>As seen on this illustration, only the green and the red part are interesting, the grey part is the same from the previous result. This effect can produce a lot of computations, so we only need to remove the green part, and add the red one (by additivity of the convolution).</p>
<p class="formulaDsp">
\[ \widehat{Area}(B_{r/h}(\frac{1}{h} \cdot x + \vec{\delta} ) \cap Z, h) = \widehat{Area}(B_{r/h}(\frac{1}{h} \cdot x ) \cap Z, h) - \widehat{Area}(B1_{r/h}(\frac{1}{h} \cdot x ) \cap Z, h) + \widehat{Area}(B2_{r/h}(\frac{1}{h} \cdot x + \vec{\delta} ) \cap Z, h). \label{eq:eqmasks} \]
</p>
<p>where \( \vec{\delta} \) is a translation vector in 0-adjacency, \( B1_{r/h} \) is the mask to remove, and \( B2_{r/h} \) the mask to add (both depending to \( \vec{\delta} \)).</p>
<div class="image">
<img src="IntegralInvariantCurvatureEstimator-FullMask.png" alt="IntegralInvariantCurvatureEstimator-FullMask.png"/>
<div class="caption">
Full kernel support</div></div>
 <div class="image">
<img src="IntegralInvariantCurvatureEstimator-PartialMask.png" alt="IntegralInvariantCurvatureEstimator-PartialMask.png"/>
<div class="caption">
0-adjacent 2d partial displacement masks of kernel support</div></div>
<p>We pre-compute at initialization of estimators a set a displacement masks from the full convolution kernel as shown above. At evaluation, we use the full kernel for the first computation. If the next surfel is adjacent to the previous one, we use a pair of masks (depending to the shift) to remove/add interested quantities to the last. In the worst case, all surfels set by user to the estimator are not adjacent and it will compute the curvature always with the full convolution kernel, which means no optimizations. The computation cost per surface element can be reduced from \( O((r/h)^{d}) \) (size of the complete kernel) to \( O((r/h)^{d-1}) \), and the extra-cost of pre-computing displacement masks is meaningless: for example, with a full 2d kernel support size of 91893, the optimization built 8 supplementary masks of size \( \approx \) 450.</p>
<h1><a class="anchor" id="sectImplementation"></a>
Implementation in DGtal</h1>
<p>It is important to consider connected range when evaluating with the Integral Invariant Curvature estimators in order to benefit the kernel optimization. Note that the methodology is the same with both <a class="el" href="classDGtal_1_1IntegralInvariantMeanCurvatureEstimator.html" title="Aim: This class implement a Integral Invariant mean curvature estimation.">IntegralInvariantMeanCurvatureEstimator</a> and <a class="el" href="classDGtal_1_1IntegralInvariantGaussianCurvatureEstimator.html" title="Aim: This class implement a Integral Invariant Gaussian curvature estimation.">IntegralInvariantGaussianCurvatureEstimator</a>. The only change is for "typedef IntegralInvariantXXXXXCurvatureEstimator&lt;...&gt; MyCurvatureEstimator"</p>
<div class="fragment"><div class="line">    <span class="keywordtype">double</span> re_convolution_kernel = 4.5; <span class="comment">// Euclidean radius of the convolution kernel. Set by user.</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> FunctorOnCells&lt; MyPointFunctor, Z2i::KSpace &gt; MyCellFunctor;</div>
<div class="line">    <span class="keyword">typedef</span> IntegralInvariantMeanCurvatureEstimator&lt; Z2i::KSpace, MyCellFunctor &gt; MyCurvatureEstimator; <span class="comment">// mean curvature estimator</span></div>
<div class="line"></div>
<div class="line">    MyCellFunctor functor ( pointFunctor, KSpaceShape ); <span class="comment">// Creation of a functor on Cells, returning true if the cell is inside the shape</span></div>
<div class="line">    MyCurvatureEstimator estimator ( KSpaceShape, functor );</div>
<div class="line">    estimator.init( h, re_convolution_kernel ); <span class="comment">// Initialisation for a grid step h and a given Euclidean radius of convolution kernel re</span></div>
<div class="line">    std::vector&lt; double &gt; results;</div>
<div class="line">    back_insert_iterator&lt; std::vector&lt; double &gt; &gt; resultsIterator( results ); <span class="comment">// output iterator for results of Integral Invariant curvature computation</span></div>
<div class="line">    estimator.eval ( abegin, aend, resultsIterator ); <span class="comment">// Computation of the estimator between two iterators of surfels on the digitized shape border</span></div>
</div><!-- fragment --> <h1><a class="anchor" id="sectResults"></a>
Some results</h1>
<p>Here is some results on 2D and 3D :</p>
<div class="image">
<img src="example-integralinvariant2D.png" alt="example-integralinvariant2D.png"/>
<div class="caption">
Curvature mapped on a DGtal::Flower2D</div></div>
 <div class="image">
<img src="snapshot-mean-zero.png" alt="snapshot-mean-zero.png"/>
<div class="caption">
Mean curvature mapped on a blobby cube 3D</div></div>
 <div class="image">
<img src="snapshot-K-zero.png" alt="snapshot-K-zero.png"/>
<div class="caption">
Gaussian curvature mapped on a blobby cube 3D</div></div>
 <div class="image">
<img src="AlGuy_Gaussian_re_7.jpg" alt="AlGuy_Gaussian_re_7.jpg"/>
<div class="caption">
Gaussian curvature mapped on a Al vol ( http://tc18.org/code_data_set/3D_images.html ) with a Euclidean kernel radius of 7</div></div>
 <div class="image">
<img src="AlGuy_Gaussian_re_7.jpg" alt="AlGuy_Gaussian_re_7.jpg"/>
<div class="caption">
Gaussian curvature mapped on a Al vol ( http://tc18.org/code_data_set/3D_images.html ) with a Euclidean kernel radius of 14</div></div>
 </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 22 2013 14:15:44 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
