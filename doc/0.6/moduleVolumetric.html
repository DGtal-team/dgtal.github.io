<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>DGtal: nD Volumetric Analysis using Separable Processes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">nD Volumetric Analysis using Separable Processes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#introVol">Introduction</a></li>
<li class="level1"><a href="#voronoiSect">Digital Voronoi Diagram Computation</a></li>
<li class="level1"><a href="#DTsec">Distance Transformation</a></li>
<li class="level1"><a href="#RDTSec">Digital Power Map and Reverse Distance Transformation</a></li>
<li class="level1"><a href="#metricSec">Metric and Separable Metric concepts</a><ul><li class="level2"><a href="#subConcepts">Main concepts</a></li>
<li class="level2"><a href="#subSepMetrics">SeparableMetric models</a></li>
</ul>
</li>
<li class="level1"><a href="#CostSec">Computational Costs</a></li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>David Coeurjolly</dd></dl>
<p>This part of the manual describes the <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> volumetric module. We focus here on separable process based volumetric analysis such as distance transformation, reverse distance transformation and medial axis extraction.</p>
<h1><a class="anchor" id="introVol"></a>
Introduction</h1>
<p>For decades, distance transformation (DT) and geometrical skeleton extraction have been classic tools for shape analysis <a class="el" href="citelist.html#CITEREF_Rosenfeld1966">[21]</a> <a class="el" href="citelist.html#CITEREF_Rosenfeld1968">[22]</a> . The DT of a shape consists in labelling object grid points with the distance to the closest background pixel. From the DT values, we thus have information on the shape geometry. Beside its applications in shape description, DT has been used in many situations such as shape analysis, shape matching, shape-based interpolation, motion planning, image registration, or differential measurement estimation.</p>
<p>In the literature, many techniques have been proposed to compute the DT given a metric with a trade-off between algorithmic performances and the <em>accuracy</em> of the metric compared to the Euclidean one. Hence, many papers have considered distances based on chamfer masks <a class="el" href="citelist.html#CITEREF_Rosenfeld1966">[21]</a><a class="el" href="citelist.html#CITEREF_Rosenfeld1968">[22]</a><a class="el" href="citelist.html#CITEREF_Borgefors1986CVGIP">[4]</a> , or sequences of chamfer distances; the vector displacement based Euclidean distance <a class="el" href="citelist.html#CITEREF_Danielsson1980">[10]</a><a class="el" href="citelist.html#CITEREF_Ragnemalm1993">[19]</a> the Voronoi diagram based Euclidean distance <a class="el" href="citelist.html#CITEREF_Breu1995">[5]</a><a class="el" href="citelist.html#CITEREF_Maurer2003PAMI">[16]</a> or the square of the Euclidean distance <a class="el" href="citelist.html#CITEREF_Saito1994-DT">[25]</a><a class="el" href="citelist.html#CITEREF_Hirata1996">[12]</a> . From a computational point of view, several of these methods lead to time optimal algorithms to compute the error-free Euclidean Distance Transformation (EDT) for <em>n-</em> dimensional binary images: the extension of these algorithms is straightforward since they use separable techniques to compute the DT; <em>n</em> one-dimensional operations -one per direction of the coordinate axis- are performed.</p>
<p>In<a class="el" href="citelist.html#CITEREF_dcoeurjo_pami_RDMA">[7]</a>, it has been demonstrated that a similar decomposition can be used to compute both the reverse distance transformation and a discrete medial axis of the binary shape.</p>
<p>In fact, the separable decomposition and the associated algorithmic tools can be used on a wider class of metrics (see<a class="el" href="citelist.html#CITEREF_Hirata1996">[12]</a> or <a class="el" href="citelist.html#CITEREF_Maurer2003PAMI">[16]</a>). For instance, all weighted \(l_p\) metrics defined in \(R^n\) by </p>
<p class="formulaDsp">
\[ d_{L_p} (u,v) = \left ( \sum_{i=0}^n w_i|u_i-v_i |^p \right )^{\frac{1}{p}}\]
</p>
<p> can be considered.</p>
<p>In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>, we have chosen to implement such volumetric tools such that the underlying metric could be specified independently.</p>
<h1><a class="anchor" id="voronoiSect"></a>
Digital Voronoi Diagram Computation</h1>
<p>The generic distance transformation is based on a prior Voronoi map consturction. Indeed, if we compute the Voronoi diagram of background points, the distance transformation at an object point is exactly its distance to the site associated with the Voronoi cell it belongs to.</p>
<p>The core of the implementation is based on a separable approach: For example, in dimension 2, partial digital Voronoi maps of dimension one are first computed in each row independently. Then such partial Voronoi maps are updated using independent processes along the columns, leading to a valid Voronoi map of dimension 2. In an algorithmic point of view, the 1D processes used for both columns and rows are exactly the same. In higher dimensions, the other dimensions are processed similarly.</p>
<dl class="section note"><dt>Note</dt><dd>We say digital Voronoi map instead of Voronoi diagram since the output of the result is the intersection between the Voronoi diagram of exterior points with \( \mathbb{Z}^d \). Furthermore, along Voronoi faces (<em>e.i</em>. when two sites are equidistant), only one sites is considered when intersection with \( \mathbb{Z}^d \).</dd></dl>
<p>In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>, the class <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a> implements such digital Vornoi map extraction. Such class is parametrized by the following types:</p>
<ul>
<li>a type representing the underlying digital space (model of <a class="el" href="structDGtal_1_1CSpace.html" title="Aim: Defines the concept describing a digital space, ie a cartesian product of integer lines...">CSpace</a>);</li>
<li>a type representing the object \( X \) as a point predicate (model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>) ;</li>
<li>a type representing the underlying metric (model of <a class="el" href="structDGtal_1_1CSeparableMetric.html" title="Aim: defines the concept of separable metrics.">CSeparableMetric</a>, see below)</li>
<li>and an optional image container to store the resulting Voronoi map (by default, the type is <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>&lt;HyperRectDomain&lt;TSpace&gt;,typename TSpace::Vector&gt;).</li>
</ul>
<p>The <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a> constructor is parametrized by</p>
<ul>
<li>an instance of Domain (the Domain type associated with the image container);</li>
<li>an instance of the PointPredicate ;</li>
<li>and an instance of the separable metric.</li>
</ul>
<p>The <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a> will be computed on the specified and will use the point predicate to decide if a point of such domain is in the object or note.</p>
<dl class="section warning"><dt>Warning</dt><dd>The point predicate must be valid for each point in the specified domain. Basically, the domain can a sub-domain of the point predicate definition domain.</dd></dl>
<p>Once the <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a> object is created, the voronoi map is computed and the class itself is a model of <a class="el" href="structDGtal_1_1CConstImage.html" title="Aim: Defines the concept describing a read-only image, which is a refinement of CPointFunctor.">CConstImage</a>. In other words, you can access to the <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a> value at a point <em>p</em> and iterate of values using image ranges (see <a class="el" href="moduleImages.html">Images</a>). For example</p>
<div class="fragment"><div class="line">VoronoiMap&lt;....&gt; myVoronoiMap( .... ); <span class="comment">//object construction</span></div>
<div class="line">VoronoiMap&lt;....&gt;::Point p(12,34);</div>
<div class="line"></div>
<div class="line">VoronoiMap&lt;....&gt;::Value vectorToClosestSiteAtP = myVoronoiMap( p );</div>
<div class="line"><span class="keywordflow">for</span>(<a class="code" href="classDGtal_1_1HyperRectDomain.html#ad460a9309eb81ab5391a57f7d2a17055">VoronoiMap&lt;....&gt;::Domain::ConstIterator</a> it  = myVoronoiMap.domain().begin() , itend = myVoronoiMap.domain().end();</div>
<div class="line">it != itend ; ++it)</div>
<div class="line">     <span class="comment">//do something on myVoronoiMap(it)</span></div>
</div><!-- fragment --><p>Since we are constructing a <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a>, the value type of the map is a vector (pointing to the closest site) of type Space::Vector (if Space was the underlying digital space type used when specifying <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a> template parameters).</p>
<p>Let us illustrate the construction in dimension 2 (see <a class="el" href="voronoimap2D_8cpp_source.html">voronoimap2D.cpp</a>). Other examples can be found in <a class="el" href="distancetransform2D_8cpp_source.html">distancetransform2D.cpp</a> and <a class="el" href="distancetransform3D_8cpp_source.html">distancetransform3D.cpp</a>.</p>
<p>First of all, we need couple of includes:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/kernel/BasicPointPredicates.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/images/imagesSetsUtils/SimpleThresholdForegroundPredicate.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/volumes/distance/ExactPredicateLpSeparableMetric.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/volumes/distance/VoronoiMap.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/volumes/distance/DistanceTransformation.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/io/colormaps/HueShadeColorMap.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/io/boards/Board2D.h&quot;</span></div>
</div><!-- fragment --><p> We will discuss later about the metric definition but let us consider a classical Euclidean \( l_2 \) metric:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ExactPredicateLpSeparableMetric&lt;Z2i::Space, 2&gt; L2Metric;</div>
<div class="line">  L2Metric l2;</div>
</div><!-- fragment --><p> We now consider an object in a [0,0]x[16,16] domain with three background points. To construct such point predicate, we first define a set containing the three points, then we consider the point predicate defined on this set (which returns true at a point if the point is inside the set) and we consider the negation of such predicate in order to return true for object points. Here you have the construction:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a> lower(0,0);</div>
<div class="line">  <a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a> upper(16,16);</div>
<div class="line">  <a class="code" href="namespaceDGtal_1_1Z2i.html#aca523bebdae58eb19385aaefffff8bc5">Z2i::Domain</a> domain(lower,upper);</div>
<div class="line"></div>
<div class="line">  <a class="code" href="namespaceDGtal_1_1Z2i.html#a371252c324e496cf8650757c1a2b4eb0">Z2i::DigitalSet</a> <span class="keyword">set</span>(domain);</div>
<div class="line">  <span class="keyword">set</span>.insertNew(<a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(2,3));</div>
<div class="line">  <span class="keyword">set</span>.insertNew(<a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(7,15));</div>
<div class="line">  <span class="keyword">set</span>.insertNew(<a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(12,5));</div>
<div class="line">  Board2D board;</div>
<div class="line">  </div>
<div class="line">  board&lt;&lt; domain &lt;&lt; <span class="keyword">set</span>;</div>
<div class="line">  board.saveSVG(<span class="stringliteral">&quot;voronoimap-inputset.svg&quot;</span>);</div>
</div><!-- fragment --><p> and the resulting set:</p>
<div class="image">
<img src="voronoimap-inputset.png" alt="voronoimap-inputset.png"/>
<div class="caption">
Input set.</div></div>
 The voronoi map is simply given by:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> VoronoiMap&lt;Z2i::Space, NotPredicate, L2Metric &gt; Voronoi2D;</div>
<div class="line">  Voronoi2D voronoimap(domain,notSetPred,l2);</div>
</div><!-- fragment --><p> At each point of the object, we thus have a vector to the closest background point. We can display this information as follows:</p>
<div class="fragment"><div class="line">  board.clear();</div>
<div class="line">  board &lt;&lt; domain;</div>
<div class="line">  <span class="keywordflow">for</span>(Voronoi2D::Domain::ConstIterator it = voronoimap.domain().begin(),</div>
<div class="line">      itend = voronoimap.domain().end(); it != itend; ++it)</div>
<div class="line">  {</div>
<div class="line">    Voronoi2D::Value site = voronoimap( *it );   <span class="comment">//closest site to (*it)</span></div>
<div class="line">    <span class="keywordflow">if</span> (site != (*it))</div>
<div class="line">      <a class="code" href="structDGtal_1_1Display2DFactory.html#a05cf13574f32647dc08d04e94aa07584">Display2DFactory::draw</a>( board,   site - (*it), (*it)); <span class="comment">//Draw an arrow</span></div>
<div class="line">  }</div>
<div class="line">  board.saveSVG(<span class="stringliteral">&quot;voronoimap-voro.svg&quot;</span>);</div>
</div><!-- fragment --><p> To obtain:</p>
<div class="image">
<img src="voronoimap-voro.png" alt="voronoimap-voro.png"/>
<div class="caption">
Voronoi map.</div></div>
 Changing the board output, we can see the Voronoi cells accordingly:</p>
<div class="fragment"><div class="line">  board.clear();</div>
<div class="line">  <span class="keywordflow">for</span>(Voronoi2D::Domain::ConstIterator it = voronoimap.domain().begin(),</div>
<div class="line">      itend = voronoimap.domain().end(); it != itend; ++it)</div>
<div class="line">  {</div>
<div class="line">    Voronoi2D::Value site = voronoimap( *it );   <span class="comment">//closest site to (*it)</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c = (site[1]*13 + site[0] * 7) % 256; <span class="comment">//basic hashfunction</span></div>
<div class="line">    board &lt;&lt; CustomStyle( (*it).className(), <span class="keyword">new</span> CustomColors(Color(c,c,c),Color(c,c,c)))</div>
<div class="line">      &lt;&lt; (*it);</div>
<div class="line">  }</div>
<div class="line">  board.saveSVG(<span class="stringliteral">&quot;voronoimap-cells.svg&quot;</span>);</div>
</div><!-- fragment --><p> To get:</p>
<div class="image">
<img src="voronoimap-cells.png" alt="voronoimap-cells.png"/>
<div class="caption">
Voronoi map cells.</div></div>
 We could easily change the metric (here to the \( l_8 \)) and get a new Voronoi map: </p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ExactPredicateLpSeparableMetric&lt;Z2i::Space, 8&gt; L8Metric;</div>
<div class="line">  L8Metric l8;</div>
<div class="line">  <span class="keyword">typedef</span> VoronoiMap&lt;Z2i::Space, NotPredicate, L8Metric &gt; Voronoi2D_l8;</div>
<div class="line">  Voronoi2D_l8 voronoimap_l8(domain,notSetPred,l8);</div>
<div class="line">  board.clear();</div>
<div class="line">  board &lt;&lt; domain;</div>
<div class="line">  <span class="keywordflow">for</span>(Voronoi2D_l8::Domain::ConstIterator it = voronoimap_l8.domain().begin(),</div>
<div class="line">      itend = voronoimap_l8.domain().end(); it != itend; ++it)</div>
<div class="line">  {</div>
<div class="line">    Voronoi2D::Value site = voronoimap_l8( *it );   <span class="comment">//closest site to (*it)</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c = (site[1]*13 + site[0] * 7) % 256; <span class="comment">//basic hashfunction</span></div>
<div class="line">    board &lt;&lt; CustomStyle( (*it).className(), <span class="keyword">new</span> CustomColors(Color(c,c,c),Color(c,c,c)))</div>
<div class="line">          &lt;&lt; (*it);</div>
<div class="line">  }</div>
<div class="line">  board.saveSVG(<span class="stringliteral">&quot;voronoimap-vorol8.svg&quot;</span>);</div>
</div><!-- fragment --> <div class="image">
<img src="voronoimap-vorol8.png" alt="voronoimap-vorol8.png"/>
<div class="caption">
Voronoi map for the l_8 metric.</div></div>
 <h1><a class="anchor" id="DTsec"></a>
Distance Transformation</h1>
<p>As discussed earlier, the distance transformation is given by computing distances once the Voronoi map is obtained. In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>, the class <a class="el" href="classDGtal_1_1DistanceTransformation.html" title="Aim: Implementation of the linear in time distance transformation for separable metrics.">DistanceTransformation</a> simply adapts the <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a> class in order to override output image getters to return the distance for the given metric to the closest site instead of the vector.</p>
<p>As a consequence, the <a class="el" href="classDGtal_1_1DistanceTransformation.html" title="Aim: Implementation of the linear in time distance transformation for separable metrics.">DistanceTransformation</a> class simply inherits from the <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a> class and overrides methods required by the <a class="el" href="structDGtal_1_1CConstImage.html" title="Aim: Defines the concept describing a read-only image, which is a refinement of CPointFunctor.">CConstImage</a> concept. Note that the DistanceTransfomation::Value type is double. If you want to get the underlying vector instead of the distance to perform exact computations, you can use the <a class="el" href="classDGtal_1_1DistanceTransformation.html#a262cfa7c9c2520fe448aaf00c551ef05">DistanceTransformation::getVoronoiVector</a> method.</p>
<p>In the following example, we consider the previous small image and use a colormap to display distance values for the \( l_2 \) mertic:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> DistanceTransformation&lt;Z2i::Space, NotPredicate, L2Metric &gt; DT;</div>
<div class="line">  DT dt(domain,notSetPred,l2);</div>
<div class="line">  board.clear();</div>
<div class="line">  board &lt;&lt; domain;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">//Fast max computation on the range value</span></div>
<div class="line">  DT::Value maxDT=0.0;</div>
<div class="line">  <span class="keywordflow">for</span>(DT::ConstRange::ConstIterator it = dt.constRange().begin(), itend = dt.constRange().end();</div>
<div class="line">      it != itend ; ++it)</div>
<div class="line">    <span class="keywordflow">if</span> ((*it)&gt;maxDT) maxDT = (*it);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">//Colormap</span></div>
<div class="line">  HueShadeColorMap&lt;DT::Value,1&gt; hueMap(0.0,maxDT);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">//Drawing</span></div>
<div class="line">  <span class="keywordflow">for</span>(DT::Domain::ConstIterator it = dt.domain().begin(),</div>
<div class="line">      itend = dt.domain().end(); it != itend; ++it)</div>
<div class="line">  {</div>
<div class="line">    DT::Value dist = dt( *it );   <span class="comment">//distance to closest site to (*it)</span></div>
<div class="line">    board &lt;&lt; CustomStyle( (*it).className(), <span class="keyword">new</span> CustomColors( hueMap(dist), hueMap(dist)))</div>
<div class="line">          &lt;&lt; (*it);</div>
<div class="line">  }</div>
<div class="line">  board.saveSVG(<span class="stringliteral">&quot;voronoimap-dt.svg&quot;</span>);</div>
</div><!-- fragment --> <div class="image">
<img src="voronoimap-dt.png" alt="voronoimap-dt.png"/>
<div class="caption">
Distance transformation for the l_2 metric.</div></div>
 <h1><a class="anchor" id="RDTSec"></a>
Digital Power Map and Reverse Distance Transformation</h1>
<p>Similarly to Voronoi diagram and digital Voronoi maps, digital Power maps are defined as the intersection between the integer grid and a power diagram. Given a set of weighed points, power diagram can be seen as Voronoi diagram where the metric is modified with additive weights. For example, considering the \( l_2\) metric, the power distance between a point \(p\) and a weighted point \((q,w)\) is defined by </p>
<p class="formulaDsp">
\[ pow(p,q) = \| p - q\|_2^2 - w \]
</p>
<p>Hence, similarly to Voronoi diagram, the power diagram is a decomposition of the space ino cells from weighed sites where each cell (maybe empty) is associated with a site and each point in the cell has got minimal power distance to the cell site (compared to its power distance to all other sites)<a class="el" href="citelist.html#CITEREF_Aurenhammer1987">[3]</a> .</p>
<p>Separable algorithms similar to VoronoiMap/DistanceTransformation can be designed to compute respectively <a class="el" href="classDGtal_1_1PowerMap.html" title="Aim: Implementation of the linear in time Power map construction.">PowerMap</a> and <a class="el" href="classDGtal_1_1ReverseDistanceTransformation.html" title="Aim: Implementation of the linear in time reverse distance transformation for separable metrics...">ReverseDistanceTransformation</a>. The only difference is that the input of <a class="el" href="classDGtal_1_1PowerMap.html" title="Aim: Implementation of the linear in time Power map construction.">PowerMap</a> is a weighted set of points instead of a point predicate.</p>
<dl class="section note"><dt>Note</dt><dd>for \(l_p\) metrics, the power distance is defined by \( pow(p,q) = \| p - q\|_p^p - w \). Hence, both the distance and the weight value type capacity must be able to represent d-sums of power p numbers (if d is the dimension of the space).</dd></dl>
<p>Hence such class is parametrized by the following types:</p>
<ul>
<li>a type representing the mapping between points and weights (WeightImage, model of <a class="el" href="structDGtal_1_1CImage.html" title="Aim: Defines the concept describing a read/write image, having an output iterator.">CImage</a>);</li>
<li>a type representing the underlying power metric (model of CSeparablePowerMetric, see below)</li>
<li>and an optional image container to store the resulting Power map (by default, the type is <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>).</li>
</ul>
<p>The <a class="el" href="classDGtal_1_1PowerMap.html" title="Aim: Implementation of the linear in time Power map construction.">PowerMap</a> constructor is parametrized by</p>
<ul>
<li>an instance of Domain (the Domain type associated with the image container);</li>
<li>an instance of <a class="el" href="classDGtal_1_1PowerMap.html#a96d646a0a331d6d6c3c2075bf4fa1a44" title="Copy of the distance image types.">PowerMap::WeightImage</a>;</li>
<li>and an instance of the power separable metric.</li>
</ul>
<p>Similarly to <a class="el" href="classDGtal_1_1DistanceTransformation.html" title="Aim: Implementation of the linear in time distance transformation for separable metrics.">DistanceTransformation</a>, <a class="el" href="classDGtal_1_1ReverseDistanceTransformation.html" title="Aim: Implementation of the linear in time reverse distance transformation for separable metrics...">ReverseDistanceTransformation</a> remaps the <a class="el" href="classDGtal_1_1PowerMap.html" title="Aim: Implementation of the linear in time Power map construction.">PowerMap</a> vectors to map the power metric to the closest weighted site.</p>
<p>As a consequence, for the Euclidean \( l_2 \) metric, if we consider a set of balls \( B_i(p_i,r_i) \) and if we create an WiehgtImage whose domain would be the set of points \(\{ p_i \}\) and with values \( r_i^2\), negative (strictly) values of the <a class="el" href="classDGtal_1_1ReverseDistanceTransformation.html" title="Aim: Implementation of the linear in time reverse distance transformation for separable metrics...">ReverseDistanceTransformation</a> will correspond to digital points belonging to the union \( \bigcup \{B_i\}\) (see<a class="el" href="citelist.html#CITEREF_dcoeurjo_pami_RDMA">[7]</a>).</p>
<p><a class="el" href="classDGtal_1_1ReverseDistanceTransformation.html" title="Aim: Implementation of the linear in time reverse distance transformation for separable metrics...">ReverseDistanceTransformation</a> can thus be used to reconstructed a binary shape from a given Medial Axis or any set of balls. Another consequence is that given a binary shape, the pipeline </p>
<p class="formulaDsp">
\[ Shape \rightarrow DT \rightarrow ReverseDT \rightarrow \text{ strictly negative values }\]
</p>
<p> for the same metric/power metric, returns the input binary shape.</p>
<dl class="section note"><dt>Note</dt><dd>Power separable metrics are formalized in <a class="el" href="structDGtal_1_1CPowerMetric.html" title="Aim: defines the concept of special weighted metrics, so called power metrics.">CPowerMetric</a> and CSeparablePowerMetric concepts whose main concept is ExactLpPowerSeparableMetric.</dd></dl>
<h1><a class="anchor" id="metricSec"></a>
Metric and Separable Metric concepts</h1>
<p>As discussed, several models of metrics can be used in the separable algorithms such as the <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a>. In this section, we discuss about these concepts.</p>
<h2><a class="anchor" id="subConcepts"></a>
Main concepts</h2>
<p>Beside separable algorithms, metrics in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> have been structured in terms of concepts:</p>
<div align="center">
<img src="dot_inline_dotgraph_6.png" alt="dot_inline_dotgraph_6.png" border="0" usemap="#dot_inline_dotgraph_6.map"/>
<map name="dot_inline_dotgraph_6.map" id="dot_inline_dotgraph_6.map"><area shape="poly" id="node1" href="structDGtal_1_1CLocalPremetric.html" title="CLocalPremetric" alt="" coords="216,221,211,214,196,207,174,202,145,199,113,197,82,199,53,202,30,207,16,214,11,221,16,229,30,235,53,241,82,244,113,245,145,244,174,241,196,235,211,229"/><area shape="poly" id="node2" href="structDGtal_1_1CMetric.html" title="CMetric" alt="" coords="171,125,168,118,160,111,147,106,131,103,113,101,96,103,79,106,67,111,59,118,56,125,59,133,67,139,79,145,96,148,113,149,131,148,147,145,160,139,168,133"/><area shape="poly" id="node3" href="structDGtal_1_1CSeparableMetric.html" title="CSeparableMetric" alt="" coords="222,29,216,22,201,15,177,10,147,7,113,5,80,7,50,10,26,15,10,22,5,29,10,37,26,43,50,49,80,52,113,53,147,52,177,49,201,43,216,37"/><area shape="poly" id="node4" href="structDGtal_1_1CPowerMetric.html" title="CPowerMetric" alt="" coords="477,125,473,118,460,111,440,106,415,103,387,101,359,103,333,106,313,111,301,118,296,125,301,133,313,139,333,145,359,148,387,149,415,148,440,145,460,139,473,133"/><area shape="poly" id="node5" href="structDGtal_1_1CPowerSeparableMetric.html" title="CPowerSeparableMetric" alt="" coords="528,29,521,22,501,15,470,10,430,7,387,5,343,7,304,10,272,15,252,22,245,29,252,37,272,43,304,49,343,52,387,53,430,52,470,49,501,43,521,37"/></map>
</div>
<p>For instance, <a class="el" href="structDGtal_1_1CLocalPremetric.html" title="Aim: Defines the concept of local premetric. Models of such concept should implement a distance metho...">CLocalPremetric</a> models only requires that a local metric is defined (<em>i.e</em>. between a point and a neighboring point in a given direction). <a class="el" href="structDGtal_1_1CMetric.html" title="Aim: defines the concept of metrics.">CMetric</a> requires to have a binary operator to compute the distance between any two points of the digital space. Furthermore, it requires to have a method he <em>closest(p,q)</em> which returns the closest point from <em>p</em> and <em>q</em> to the origin. Such closest method can be easily implemented from the binary distance operator. However, for some metric, more efficient implementation can be obtained to answer to <em>closest()</em> requests.</p>
<h2><a class="anchor" id="subSepMetrics"></a>
SeparableMetric models</h2>
<p>The Separable metric concept is a refinement of the <a class="el" href="structDGtal_1_1CMetric.html" title="Aim: defines the concept of metrics.">CMetric</a> (resp. <a class="el" href="structDGtal_1_1CPowerMetric.html" title="Aim: defines the concept of special weighted metrics, so called power metrics.">CPowerMetric</a>) concept in which we require models to implement a method <em>hiddenBy(u,v,w,startingPoint,endPoint,dim)</em>: given three digital points <em>u</em>, <em>v</em>, <em>w</em> and an isothetic segment defined by the pair [<em>startingPoint</em>, <em>endPoint</em>] along the dimension <em>dim</em>, such method returns true if Voronoi cells of <em>u</em> and <em>w</em> <em>hide</em> the Voronoi cell if <em>v</em> on the segment. Such predicate can be illustrated as follows:</p>
<div class="image">
<img src="hiddenBy.png" alt="hiddenBy.png"/>
<div class="caption">
HiddenBy predicate in dimension 2 for the l_2 metric (the predicate returns true in this case).</div></div>
 This predicate (with the <em>closest()</em> one as discussed above) is crucial for separable VoronoiMap/DistanceTransformation algorithms. The next section discusses about complexity of such volumetric algorithm with respect to computation costs of the two predicates.</p>
<p><a class="el" href="structDGtal_1_1CPowerSeparableMetric.html" title="Aim: defines the concept of separable metrics.">CPowerSeparableMetric</a> concepts is a similar refinement of the <a class="el" href="structDGtal_1_1CPowerMetric.html" title="Aim: defines the concept of special weighted metrics, so called power metrics.">CPowerMetric</a> concept. Indeed, <a class="el" href="structDGtal_1_1CPowerSeparableMetric.html" title="Aim: defines the concept of separable metrics.">CPowerSeparableMetric</a> models must implement an <em>hiddenByPower(u, wu,v,wv,w,ww,startingPoint,endPoint,dim)</em> on triplet of weighted points {(u,wu),(v,wv),(w,ww)}.</p>
<p>The class of metrics for which such <em>hiddenBy</em> method can be defined and for which the <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a> will be exact is quite large. This class contains</p>
<ul>
<li>all \( l_p \) metrics (<a class="el" href="classDGtal_1_1ExactPredicateLpSeparableMetric.html" title="Aim: implements separable l_p metrics with exact predicates.">ExactPredicateLpSeparableMetric</a> and <a class="el" href="classDGtal_1_1InexactPredicateLpSeparableMetric.html" title="Aim: implements separable l_p metrics with approximated predicates.">InexactPredicateLpSeparableMetric</a>)</li>
<li>all local metric inducing a norm (chamfer norms, some of the neighborhood sequences, ...) (see<a class="el" href="citelist.html#CITEREF_Hirata1996">[12]</a> for more details).</li>
<li>...</li>
</ul>
<h1><a class="anchor" id="CostSec"></a>
Computational Costs</h1>
<p>As discussed, both <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a> and <a class="el" href="classDGtal_1_1PowerMap.html" title="Aim: Implementation of the linear in time Power map construction.">PowerMap</a> (and their associated subclasses) are parametrized by a generic separable metric (model of <a class="el" href="structDGtal_1_1CSeparableMetric.html" title="Aim: defines the concept of separable metrics.">CSeparableMetric</a> or <a class="el" href="structDGtal_1_1CPowerSeparableMetric.html" title="Aim: defines the concept of separable metrics.">CPowerSeparableMetric</a>). If \( C \) corresponds to the cost of the <em>closest()</em> or <em>closestPower()</em> methods for the given metric, and \( H \) the cost of the <em>hiddenBy()</em> or <em>hiddenByWeigthed()</em>, the computational costs of the separable metrics can be summarized as follows:</p>
<table class="doxtable">
<tr>
<th>Models of CSeparableMetric/CPowerSeparableMetric</th><th>C </th><th>H </th><th>Note </th></tr>
<tr>
<td><p class="starttd"><a class="el" href="classDGtal_1_1ExactPredicateLpSeparableMetric.html" title="Aim: implements separable l_p metrics with exact predicates.">ExactPredicateLpSeparableMetric</a></p>
<p class="endtd"></p>
</td><td>\( O(log(p)) \) </td><td>\( O(log(p)log(n)) \) </td><td>Exact computations </td></tr>
<tr>
<td><a class="el" href="classDGtal_1_1ExactPredicateLpSeparableMetric.html" title="Aim: implements separable l_p metrics with exact predicates.">ExactPredicateLpSeparableMetric</a> specialized for p=2 </td><td>\( O(1) \) </td><td>\( O(1) \) </td><td>Exact computations </td></tr>
<tr>
<td><a class="el" href="classDGtal_1_1ExactPredicateLpSeparableMetric.html" title="Aim: implements separable l_p metrics with exact predicates.">ExactPredicateLpSeparableMetric</a> specialized for p=1 </td><td>\( O(1) \) </td><td>\( O(log(n)) \) </td><td>Exact computations </td></tr>
<tr>
<td><a class="el" href="classDGtal_1_1InexactPredicateLpSeparableMetric.html" title="Aim: implements separable l_p metrics with approximated predicates.">InexactPredicateLpSeparableMetric</a> with p at construction </td><td>\( O(1) \) </td><td>\( O(log(n)) \) </td><td>Inexact computations since std::pow on double is used (supposed to be \( O(1) \)) </td></tr>
<tr>
<td><p class="starttd"><a class="el" href="classDGtal_1_1ExactPredicateLpPowerSeparableMetric.html" title="Aim: implements weighted separable l_p metrics with exact predicates.">ExactPredicateLpPowerSeparableMetric</a></p>
<p class="endtd"></p>
</td><td>\( O(log(p)) \) </td><td>\( O(log(p)log(n)) \) </td><td>Exact computations </td></tr>
<tr>
<td><a class="el" href="classDGtal_1_1ExactPredicateLpPowerSeparableMetric.html" title="Aim: implements weighted separable l_p metrics with exact predicates.">ExactPredicateLpPowerSeparableMetric</a> specialized for p=2 </td><td>\( O(1) \) </td><td>\( O(1) \) </td><td>Exact computations </td></tr>
</table>
<p>Following this table, <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a>, <a class="el" href="classDGtal_1_1DistanceTransformation.html" title="Aim: Implementation of the linear in time distance transformation for separable metrics.">DistanceTransformation</a>, <a class="el" href="classDGtal_1_1PowerMap.html" title="Aim: Implementation of the linear in time Power map construction.">PowerMap</a>, <a class="el" href="classDGtal_1_1ReverseDistanceTransformation.html" title="Aim: Implementation of the linear in time reverse distance transformation for separable metrics...">ReverseDistanceTransformation</a> have the following computational cost:</p>
<p class="formulaDsp">
\[ O(d\cdot n^d\cdot (C+H)) \]
</p>
<p>For example, for the \( l_2 \) metric, all algorithms are in \( \Theta(dn^d)\). </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 22 2013 14:15:44 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
