<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Voxel Complex</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Voxel Complex </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation:</dt><dd>Pablo Hernandez-Cerdan</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.9.4</dd></dl>
<p>Part of the <a class="el" href="packageTopology.html">Topology package</a>.</p>
<p>This part of the manual describes how to represent and process arbitrary voxel complexes, which are cubical complexes specialized to work with voxels.</p>
<p>The following programs are related to this documentation: <a class="el" href="testVoxelComplex_8cpp.html">testVoxelComplex.cpp</a>.</p>
<h1><a class="anchor" id="dgtal_vcomplex_sec1"></a>
Introduction to voxel complexes</h1>
<p>This is an implementation of the Critical Kernel framework based on M.Couprie and G.Bertrand articles:</p><ul>
<li>Asymmetric parallel 3D thinning scheme and algorithms based on isthmuses: <a href="https://hal.archives-ouvertes.fr/hal-01217974/document">https://hal.archives-ouvertes.fr/hal-01217974/document</a></li>
<li>Powerful Parallel and Symmetric 3D Thinning Schemes Based on Critical Kernels: <a href="https://hal.archives-ouvertes.fr/hal-00828450/">https://hal.archives-ouvertes.fr/hal-00828450/</a></li>
<li>A 3D Sequential Thinning Scheme Based on Critical Kernels: <a href="https://hal.archives-ouvertes.fr/hal-01217952/file/Critical3Dseq.pdf">https://hal.archives-ouvertes.fr/hal-01217952/file/Critical3Dseq.pdf</a></li>
</ul>
<p>DGtalTools has an associated command line interface executable: criticalKernelsThinning3D.</p>
<h1><a class="anchor" id="dgtal_vcomplex_sec2"></a>
Definitions</h1>
<p>Summary of definitions used, but highly recommended to read the original manuscripts <a class="el" href="citelist.html#CITEREF_Couprie201622">[28]</a>.</p>
<ul>
<li><b>Isthmus:</b> </li>
</ul>
<p>"Intuitively a voxel x of an object X is said to be a 1-isthmus (resp. a 2-isthmus) if the neighborhood of x corresponds -up to a thinning- to the one of a point belonging to a curve (resp. a surface)."</p>
<ul>
<li><b>Reducible:</b> </li>
</ul>
<p>We say that the complex X is reducible only if it is possible to reduce it (with thinning) to a single voxel.</p>
<ul>
<li><b>Clique:</b> </li>
</ul>
<p>Let \( d \in \{0,1,2,3\} \) and let \( C \in V^3 \) with \(V^3\) being the collection of all voxel complexes (a finite set composed solely of voxels). We say that C is a d-clique if the intersection of all voxels of C is a d-face.</p>
<p>Any complex C made of a single voxel is a 3-clique. Furthermore, any voxel of a complex constitutes a 3-clique that is <em>essential</em> for X. Essential is the minimal clique for X.</p>
<ul>
<li><b>K-neighborhood</b> of a voxel S:</li>
</ul>
<p>Written \(K(S)\) is the set of all voxels adjacent to S. And \(K^*(S) = K \setminus S\).</p>
<ul>
<li><b>Regular</b> clique for the complex X:</li>
</ul>
<p>We say that the clique C is <em>regular</em> for X if \(K^*(C) \cap X \) is <em>reducible</em> to a single voxel. We say that C is <em>critical</em> for X if C is not regular.</p>
<dl class="section note"><dt>Note</dt><dd>If C is a single voxel x, then C is regular for X, only if x is simple for X.</dd></dl>
<ul>
<li><b>Theorem:</b> </li>
</ul>
<p>The complex Y is a thinning of X if any clique that is <b>critical</b> for X, contains at least one voxel of Y.</p>
<p><b>Critical</b> <b>Kernels:</b> </p>
<p>If we remove simple voxels in parallel is known we may change its topology. Collapse operations used in <a class="el" href="classDGtal_1_1ParDirCollapse.html" title="Aim: Implements thinning algorithms in cubical complexes. The implementation supports any model of cu...">ParDirCollapse</a> and similar only remove voxels that keep the same topology. Here we use <em>critical</em> <em>kernels</em> to ensure the same homotopy type after thinning.</p>
<h1><a class="anchor" id="dgtal_vcomplex_sec3"></a>
Initializing a voxel complex.</h1>
<p>A <b>voxel</b> <b>complex</b> <em>V</em> is a <b>cubical</b> <b>complex</b> (living in a Khalimsky space).</p>
<p>To create a <a class="el" href="classDGtal_1_1VoxelComplex.html" title="This class represents a voxel complex living in some Khalimsky space. Voxel complexes are derived fro...">VoxelComplex</a>, we need to specify in which Khalimsky space it lives and also, optionally, the type of container used for storing cells.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceDGtal.html">DGtal</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="classDGtal_1_1KhalimskySpaceND.html">KSpace</a> = <a class="code" href="namespaceDGtal_1_1Z3i.html#a4c1b0b50dafb838783bc2347a840147d">DGtal::Z3i::KSpace</a>;      <span class="comment">// ZxZxZ</span></div><div class="line"><span class="keyword">using</span> <a class="code" href="classDGtal_1_1HyperRectDomain.html">Domain</a> = <a class="code" href="classDGtal_1_1HyperRectDomain.html">DGtal::Z3i::Domain</a></div><div class="line"><span class="keyword">using</span> <a class="code" href="classDGtal_1_1DigitalTopology.html">DigitalTopology</a> = <a class="code" href="namespaceDGtal_1_1Z3i.html#ae6e790b7439eafa5c22f890a025e3b80">DGtal::Z3i::DT26_6</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="namespaceDGtal_1_1Z2i.html#a371252c324e496cf8650757c1a2b4eb0">DigitalSet</a> =  <a class="code" href="classDGtal_1_1DigitalSetByAssociativeContainer.html">DGtal::DigitalSetByAssociativeContainer</a>&lt;</div><div class="line">    <a class="code" href="namespaceDGtal_1_1Z3i.html#a39a69f8da09f1094df563ca067927c61">DGtal::Z3i::Domain</a>,</div><div class="line">    std::unordered_set&lt; typename DGtal::Z3i::Domain::Point&gt; &gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> CellContainerMap = std::unordered_map&lt;KSpace::Cell, DGtal::CubicalCellData&gt;:</div><div class="line"><span class="keyword">using</span> Complex = <a class="code" href="classDGtal_1_1VoxelComplex.html">DGtal::VoxelComplex&lt;KSpace, CellContainerMap&gt;</a>;    <span class="comment">// Type of VoxelComplex.</span></div><div class="line"></div><div class="line"><a class="code" href="classDGtal_1_1KhalimskySpaceND.html">KSpace</a> ks;                                               <span class="comment">// The cellular grid space</span></div><div class="line">ks.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a15dcbcaae831dd1c36090e6336c177d4">init</a>( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>( 0,0,0 ), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>( 100,100,100 ), <span class="keyword">true</span> );   <span class="comment">// Limits of the grid space</span></div><div class="line"><span class="comment">// Voxel Complex needs a KSpace and can be populated with a digital set.</span></div><div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> p1(-10, -10, -10);</div><div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> p2(10, 10, 10);</div><div class="line"><a class="code" href="classDGtal_1_1HyperRectDomain.html">Domain</a> <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>(p1, p2);</div><div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> c(0, 0, 0);</div><div class="line"><a class="code" href="namespaceDGtal_1_1Z2i.html#a371252c324e496cf8650757c1a2b4eb0">DigitalSet</a> a_set(<a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>);</div><div class="line">Complex complex( ks );</div><div class="line">complex.construct( a_set );</div><div class="line"><span class="comment">// load LUT to check for simplicity faster.</span></div><div class="line">complex.setSimplicityTable(<a class="code" href="namespaceDGtal_1_1functions.html#a96aab076fc2c3bd049f041f5867be7a5">functions::loadTable</a>(simplicity::tableSimple26_6));</div></div><!-- fragment --><p>Last, there is a data associated with each cell of a complex. The data type must either be <a class="el" href="structDGtal_1_1CubicalCellData.html">CubicalCellData</a> or a type that derives from <a class="el" href="structDGtal_1_1CubicalCellData.html">CubicalCellData</a>. This data is used by the thinning algorithm with persistence. But can be used for other purposes, take a look at the documentation of <a class="el" href="structDGtal_1_1CubicalCellData.html">CubicalCellData</a> to see the default stored flags and data.</p>
<h1><a class="anchor" id="dgtal_vcomplex_sec4"></a>
Implementation Details</h1>
<p>The details of the implementation can be summarized int he implementation of four masks that given a d-cell (pointel, linel, surfel, spel) returns a d-clique and a boolean flag with its criticality.</p>
<p><a class="el" href="classDGtal_1_1VoxelComplex.html#acae2984aeabdf9cb98a74d553d549e9f">VoxelComplex::K_0</a>,<a class="el" href="classDGtal_1_1VoxelComplex.html#ad6e4b8f4265245a5ecbc03b9a62caca1">VoxelComplex::K_1</a>, <a class="el" href="classDGtal_1_1VoxelComplex.html#a9a1fed29fae4207a47a8183493a788af">VoxelComplex::K_2</a>, and <a class="el" href="classDGtal_1_1VoxelComplex.html#a149f719435ada8b1c2737adce17ccbd4">VoxelComplex::K_3</a> return a pair&lt;bool, Clique&gt; where Clique=<a class="el" href="classDGtal_1_1CubicalComplex.html" title="Aim: This class represents an arbitrary cubical complex living in some Khalimsky space....">CubicalComplex</a>, and the bool is true if the Clique is critical.</p>
<p><a class="el" href="classDGtal_1_1VoxelComplex.html#a149f719435ada8b1c2737adce17ccbd4">VoxelComplex::K_3</a> applies to Voxels, it can either create a small object to use the isSimple method of <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a>, or if a pre-compute LUT table of simplicity is loaded, it will look up the result based on the occupancy of the neighborhood (recommended).</p>
<p><a class="el" href="classDGtal_1_1VoxelComplex.html#a9a1fed29fae4207a47a8183493a788af">VoxelComplex::K_2</a> applies to surfels,</p>
<p><a class="el" href="classDGtal_1_1VoxelComplex.html#ad6e4b8f4265245a5ecbc03b9a62caca1">VoxelComplex::K_1</a> to linels, and <a class="el" href="classDGtal_1_1VoxelComplex.html#acae2984aeabdf9cb98a74d553d549e9f">VoxelComplex::K_0</a> to pointels.</p>
<h1><a class="anchor" id="dgtal_vcomplex_sec5"></a>
Thinning in voxel complexes</h1>
<p>In <a class="el" href="VoxelComplexFunctions_8h_source.html">VoxelComplexFunctions.h</a> a couple of thinning methods are implemented in a functional style, taking a <a class="el" href="classDGtal_1_1VoxelComplex.html" title="This class represents a voxel complex living in some Khalimsky space. Voxel complexes are derived fro...">VoxelComplex</a>, a Select function, and a Skel function.</p>
<p><a class="el" href="namespaceDGtal_1_1functions.html#a8f2a4664af776ca513141edb552a4461">functions::asymetricThinningScheme</a> and <a class="el" href="namespaceDGtal_1_1functions.html#a46d491155b4e945e904080855a3bae28">functions::persistenceAsymetricThinningScheme</a>. These algorithms are homeotopic, keeping the topology of the original object.</p>
<p>The only difference between both algorithms is the <b>persistence</b> parameter, which allow to perform trimming on spurious or branches generated by noise.</p>
<p><b>Select</b> <b>function:</b> Select a voxel from a clique (set of voxels)</p>
<ul>
<li><a class="el" href="namespaceDGtal_1_1functions.html#aa469c81c1af173fe1758bba410f4a940">functions::selectRandom</a>.</li>
<li><a class="el" href="namespaceDGtal_1_1functions.html#a96220e2a64c64f8380043319b6c5e329">functions::selectFirst</a>: just the first voxel of the set ordered in a lexicographical order.</li>
<li><a class="el" href="namespaceDGtal_1_1functions.html#a8833a616f9e288f432a67eea853217d9">functions::selectMaxValue</a>: Wrap to use with a lambda, to use a <a class="el" href="classDGtal_1_1DistanceTransformation.html" title="Aim: Implementation of the linear in time distance transformation for separable metrics.">DistanceTransformation</a> to select the voxel with greatest distance value.</li>
</ul>
<p><b>Skel</b> <b>function:</b> Predicate to check if input voxel is part of the skeleton that we are interested to preserve.</p>
<ul>
<li><a class="el" href="namespaceDGtal_1_1functions.html#ad1a335e8f7956c3188e031a8d83a5ea7">functions::skelUltimate</a>: Null, preserve only to keep same topology. The result of the thinning in a connected object without holes is just one voxel.</li>
<li><a class="el" href="namespaceDGtal_1_1functions.html#a73b08e83670143586a55950e050aa6ad">functions::skelEnd</a>: preserve if voxel has only one neighbor.</li>
<li>OneIsthmus: preserve if voxel is oneIsthmus, as described in articles. Prefer to use the 1isthmus LUT for speed.</li>
<li>TwoIsthmus: idem, this conserves planar structures.</li>
<li>skelIsthmus : (OneIsthmus || TwoIsthmus). Prefer to use the isthmus LUT for speed.</li>
<li><a class="el" href="namespaceDGtal_1_1functions.html#a23d911a3be8b0751f42bc11e96d3af1b">functions::skelWithTable</a>: Wrap to use with a lambda, that accept any table from LookUpTable. Right now we provide tables for 26_6 topology for isthmus and one-isthmus. Generated using: <a class="el" href="namespaceDGtal_1_1functions.html#a1fc0eb12f18205fd5335ef3068753109">functions::generateVoxelComplexTable</a>.</li>
</ul>
<p><a class="el" href="testVoxelComplex_8cpp.html">testVoxelComplex.cpp</a> provides example of how to use with isIsthmus table.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> table = *<a class="code" href="namespaceDGtal_1_1functions.html#a96aab076fc2c3bd049f041f5867be7a5">functions::loadTable</a>(isthmusicity::tableOneIsthmus);</div><div class="line"><span class="comment">// auto table = *functions::loadTable(isthmusicity::tableIsthmus);</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> pointToMaskMap = *functions::mapZeroPointNeighborhoodToConfigurationMask&lt; Point&gt;();</div><div class="line"></div><div class="line"><span class="keyword">auto</span> isthmusTable = [&amp;table, &amp;pointToMaskMap](<span class="keyword">const</span> Complex &amp;fc, <span class="keyword">const</span> <a class="code" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">Complex::Cell</a> &amp;c)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceDGtal_1_1functions.html#a23d911a3be8b0751f42bc11e96d3af1b">skelWithTable</a>(table, pointToMaskMap, fc, c);</div><div class="line">};</div></div><!-- fragment --><p>The only difference between both algorithms is the <b>persistence</b> parameter, which allow to perform trimming on spurious or branches generated by noise.</p>
<div class="image">
<img src="voxelComplexAlgoAsym.png" alt="voxelComplexAlgoAsym.png"/>
<div class="caption">
AsymetricThinningScheme algorithm</div></div>
 <div class="image">
<img src="voxelComplexAlgoPersistence.png" alt="voxelComplexAlgoPersistence.png"/>
<div class="caption">
PersistenceAsymetricThinningScheme algorithm</div></div>
 <div class="fragment"><div class="line"><span class="keywordtype">int</span> persistence = 1</div><div class="line"><span class="keyword">auto</span> complex_new = functions::persistenceAsymetricThinningScheme&lt;Complex&gt;(</div><div class="line">complex, selectRandom&lt;Complex&gt;, isthmusTable, persistence);</div></div><!-- fragment --><p>The persistence parameter controls the removal of voxels from the skeleton (voxels where the Skel function returns true). Every generation in the algorithm runs over every voxel, checking if they can be removed (because they don't change the topology) and if they have to be kept because they are part of the skeleton.</p>
<p>So every voxel, through the associated CellData of <a class="el" href="classDGtal_1_1VoxelComplex.html" title="This class represents a voxel complex living in some Khalimsky space. Voxel complexes are derived fro...">VoxelComplex</a> store the value of the first generation they became an isthmus (or any other Skel function), as a birth date. Then, they are finally kept into the constraint K set if they are still an isthmus and they are persistent enough.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> &amp; birth_date = ccdata;</div><div class="line"><span class="keywordtype">bool</span> is_skel = Skel(X, voxel);</div><div class="line"><span class="keywordtype">bool</span> is_persistent_enough = (generation + 1 - birth_date) &gt;= persistence;</div><div class="line"><span class="keywordflow">if</span> (is_skel &amp;&amp; is_persistent_enough)</div><div class="line"><a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.insertVoxelCell(voxel, close_it, birth_date);</div></div><!-- fragment --><h1><a class="anchor" id="dgtal_vcomplex_sec6"></a>
Examples</h1>
<p>DGtalTools provide a script <b>criticalKernelsThinning3D.cpp</b> ready to use for 3D inputs. Some results:</p>
<div class="fragment"><div class="line">./volumetric/criticalKernelsThinning3D --input ${<a class="code" href="namespaceDGtal.html">DGtal</a>}/examples/samples/Al.100.vol \</div><div class="line">--select dmax --skel ulti -p 0 --verbose --visualize</div></div><!-- fragment --><div class="image">
<img src="voxelComplexAlUltiP0.png" alt="voxelComplexAlUltiP0.png"/>
<div class="caption">
AsymetricThinningScheme with Ultimate skeleton.</div></div>
 <div class="fragment"><div class="line">./volumetric/criticalKernelsThinning3D --input ${<a class="code" href="namespaceDGtal.html">DGtal</a>}/examples/samples/Al.100.vol \</div><div class="line">--select dmax --skel 1isthmus -p 0 --verbose --visualize</div></div><!-- fragment --><div class="image">
<img src="voxelComplexAl1IsthtmusP0.png" alt="voxelComplexAl1IsthtmusP0.png"/>
<div class="caption">
AsymetricThinningScheme with one-isthmus skeleton.</div></div>
 <div class="fragment"><div class="line">./volumetric/criticalKernelsThinning3D --input ${<a class="code" href="namespaceDGtal.html">DGtal</a>}/examples/samples/Al.100.vol \</div><div class="line">--select dmax --skel 1isthmus -p 10 --verbose --visualize</div></div><!-- fragment --><div class="image">
<img src="voxelComplexAl1IsthtmusP10.png" alt="voxelComplexAl1IsthtmusP10.png"/>
<div class="caption">
Persistence Scheme with one-isthmus skeleton and p=10</div></div>
<p> When the input set has noise in the borders, the persistence automatic trimming is pretty useful. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 27 2019 12:04:14 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
