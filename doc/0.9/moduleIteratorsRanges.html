<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>DGtal: Iterators and ranges</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Iterators and ranges </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#secIteratorRangesIterators">Introduction to iterators</a></li>
<li class="level1"><a href="#secIteratorRangesRanges">Introduction to ranges</a><ul><li class="level2"><a href="#subsecIteratorRangesRangesMainConcepts">Main concepts</a></li>
</ul>
</li>
<li class="level1"><a href="#secIteratorRangesAdatpers">Adapters to iterators</a><ul><li class="level2"><a href="#subsecIteratorRangesAdaptersReverse">Reverse iterator</a></li>
<li class="level2"><a href="#subsecIteratorRangesAdaptersAdapters">On-line transformations</a></li>
<li class="level2"><a href="#subsecIteratorRangesAdaptersCirculators">Circulators</a></li>
</ul>
</li>
<li class="level1"><a href="#secIteratorRangesUtils">Iterator Utilities</a><ul><li class="level2"><a href="#subsecIteratorRangesUtilsFuns">Useful functions</a></li>
<li class="level2"><a href="#subsecIteratorRangesUtilsTags">Categories and other associated types</a></li>
<li class="level2"><a href="#subsecIteratorRangesUtilsTagsDispatching">For developers: Tag dispatching</a></li>
<li class="level2"><a href="#subsecIteratorRangesUtilsTagsNew">For developers: How to create new iterators ?</a></li>
<li class="level2"><a href="#subsecIteratorRangesUtilsConcepts">Concepts checking</a></li>
</ul>
</li>
<li class="level1"><a href="#secIteratorRangesApps">Applications</a><ul><li class="level2"><a href="#secIteratorRangesAppsGeometry">Iterators and ranges in the Geometry package</a></li>
<li class="level2"><a href="#secIteratorRangesAppsImage">Iterators and ranges in the Image package</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation:</dt><dd>Tristan Roussillon</dd></dl>
<p>This part of the manual describes basic concepts of iterators and ranges. It also presents several tools available in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a> to ease their use: traits class, useful functions, adapters, etc.</p>
<p><a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a> users usually have to play with ranges to iterate over finite sets of elements.</p>
<h1><a class="anchor" id="secIteratorRangesIterators"></a>
Introduction to iterators</h1>
<p>The concept of <em>iterator</em> is one of the main concept introduced in the <a href="www.cplusplus.com/reference/std/iterator/" title="STL iterators">STL</a> in order to make data structures and algorithms independent: a programmer would be able to apply one algorithm on different data structures. Algorithms typically take iterators as arguments, so a data structure is only required to provide a way to access its elements using iterators. An iterator is any object that, pointing to some element stored in a data structure, can be incremented so that it points to the next element. An iterator has at least, the dereference (<code>*</code>) and increment (<code>++</code>) operators, but can have more operators to implement extra functionalities. Depending on the functionality they implement, they belong to one of the several categories of iterators. Following <a href="http://www.boost.org/doc/libs/1_49_0/libs/iterator/doc/index.html" title="Boost iterators">The Boost.Iterator Library</a>, which extends the hierarchy of concepts proposed in the STL and separates access and traversal functionalities, we consider in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a> the following access and traversal categories:</p>
<ul>
<li>Readable iterator: <code>*i</code> returns an instance of V (value type) and <code>i-&gt;m</code> is equivalent to <code>(*i).m</code></li>
<li>Writable iterator: <code>*i = o</code></li>
<li>LValue iterator: <code>*i</code> returns an instance of <code>V&amp;</code></li>
</ul>
<ol type="1">
<li>Incrementable iterator: dereference (<code>*</code>), indirection (<code>-&gt;</code>) and increment (<code>++</code>) operators.</li>
<li>Single-pass iterator: equality operators (<code>==</code> and <code>!=</code>).</li>
<li>Forward iterator: default constructor.</li>
<li>Bidirectional iterator: decrement (<code>--</code>) operator.</li>
<li>Random access iterator: arithmetic and comparison operators (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>).</li>
</ol>
<p>Each traversal category of level <em>l</em> obviously implements the functionalities of all the categories <em>k &lt; l</em> and one or more extra functionalities. For each category, the main difference with the previous categories is provided in the above list, but <a href="http://www.boost.org/doc/libs/1_49_0/libs/iterator/doc/index.html" title="Boost iterators">The Boost.Iterator Library</a> gives more details.</p>
<p>The following diagram sums up the main iterator concepts:</p>
<div align="center">
<img src="dot_inline_dotgraph_2.png" alt="dot_inline_dotgraph_2.png" border="0" usemap="#dot_inline_dotgraph_2.map"/>
<map name="dot_inline_dotgraph_2.map" id="dot_inline_dotgraph_2.map"></map>
</div>
<h1><a class="anchor" id="secIteratorRangesRanges"></a>
Introduction to ranges</h1>
<p>A <em>range</em> of elements stored in a data structure (container) may be implicitly described by a well-chosen pair of iterators. Any pair does not define a valid range, even with iterators having nonsingular values. An iterator <code>j</code> is reachable from an iterator <code>i</code> if and only if <code>i</code> can be made equal to <code>j</code> with finitely many applications of the increment operator. If <code>j</code> is reachable from <code>i</code>, one can iterate over the range bounded by <code>i</code> and <code>j</code>, from the one pointed to by <code>i</code> and up to, but not including, the one pointed to by <code>j</code>. Such a range is valid and is denoted by [<code>i,j</code>).</p>
<p>In linear data structures, any iterator pointing to the last element is incremented so that it points to the <em>past-the-end</em> element, ie. it points past the last element (just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element of the array).</p>
<p>If an iterator <code>begin</code> points to the first element of a data structure and an iterator <code>end</code> points to the past-the-end element, iterating over the range [<code>begin,end</code>) is a way of iterating over all the elements of the underlying data structure. Note that if the underlying data structure is empty, it only has a past-the-end element. As a consequence, a range [<code>i,i</code>) denotes an empty range. A range of a linear data structure is illustrated below (normal values are depicted with a small straight segment, whereas the past-the-end value is depicted with a cross). In this example, [<code>i,j</code>) is not a valid range because <code>j</code> cannot be reached from <code>i</code> and the whole range may be denoted by [<code>begin,end</code>).</p>
<div class="image">
<img src="linearRange.png" alt="linearRange.png"/>
<div class="caption">
Linear range</div></div>
  <h2><a class="anchor" id="subsecIteratorRangesRangesMainConcepts"></a>
Main concepts</h2>
<p>Some objects have the capability to provide a pair of iterators describing a (valid) range. For instance, methods <code>begin()</code> and <code>end()</code> of STL containers return two iterators bounding the range of elements contained in the data structure. Similarly, in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a>, there are several concepts of range having at least these <code>begin()</code> and <code>end()</code> methods.</p>
<p>The concept <a class="el" href="structDGtal_1_1CConstSinglePassRange.html">CConstSinglePassRange</a> describes any object for which, one can iterate at least one time over a range of elements. Models of <a class="el" href="structDGtal_1_1CConstSinglePassRange.html" title="Aim: Defines the concept describing a const single pass range. ">CConstSinglePassRange</a> have a nested type ConstIterator, which is a readable and (at least) single-pass iterator. Instances of ConstIterator are returned by <code>begin()</code> and <code>end()</code> methods.</p>
<p>The concept <a class="el" href="structDGtal_1_1CConstBidirectionalRange.html">CConstBidirectionalRange</a>, which is a refinement of <a class="el" href="structDGtal_1_1CConstSinglePassRange.html" title="Aim: Defines the concept describing a const single pass range. ">CConstSinglePassRange</a>, describes any collection of elements that can be scanned several times, either forward or backward. Models of this concept have obviously a nested type ConstIterator, but it is a readable and (at least) bidirectional iterator. They have in addition a nested type ConstReverseIterator, which is a readable and bidirectional iterator too. Finally, <code>begin()</code> and <code>end()</code> methods return instances of ConstIterator, whereas <code>rbegin()</code> and <code>rend()</code> methods return instances of ConstReverseIterator.</p>
<p>The concept <a class="el" href="structDGtal_1_1CSinglePassRange.html">CSinglePassRange</a> (resp. <a class="el" href="structDGtal_1_1CBidirectionalRange.html">CBidirectionalRange</a>) is a refinement of <a class="el" href="structDGtal_1_1CConstSinglePassRange.html" title="Aim: Defines the concept describing a const single pass range. ">CConstSinglePassRange</a> (resp. <a class="el" href="structDGtal_1_1CConstBidirectionalRange.html" title="Aim: Defines the concept describing a bidirectional const range. ">CConstBidirectionalRange</a>) for not constant, mutable elements. All their models have a nested type Iterator (resp. <a class="el" href="classDGtal_1_1ReverseIterator.html" title="This class adapts any bidirectional iterator so that operator++ calls operator-- and vice versa...">ReverseIterator</a>), which are the readable and writable counterparts of ConstIterator (resp. ConstReverseIterator).</p>
<p>These four concepts and their links are depicted in the following figure:</p>
<div align="center">
<img src="dot_inline_dotgraph_3.png" alt="dot_inline_dotgraph_3.png" border="0" usemap="#dot_inline_dotgraph_3.map"/>
<map name="dot_inline_dotgraph_3.map" id="dot_inline_dotgraph_3.map"></map>
</div>
<h1><a class="anchor" id="secIteratorRangesAdatpers"></a>
Adapters to iterators</h1>
<p>In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a>, several adapters to iterators are provided.</p>
<h2><a class="anchor" id="subsecIteratorRangesAdaptersReverse"></a>
Reverse iterator</h2>
<p>Any bidirectional iterator may have a reverse counterpart, ie. an adapter that enables a backward scanning by calling the decrement operator instead of the increment operator and conversely. Bidirectional ranges provide reverse iterators that can be used as follows: </p><pre class="fragment">template&lt;typename Range&gt;
void anyProcedure(const Range&amp; aRange)
  {
    BOOST_CONCEPT_ASSERT(( CBidirectionalRange&lt;Range&gt; )); 
    ...
    for (typename Range::ReverseIterator ri = r.rbegin(), 
         typename Range::ReverseIterator riEnd = r.rend(); 
         ri != riEnd; ++ri)
      {
         ...
      }
   }
</pre><p>In order to take profit of the whole <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a> framework, you should use <a class="el" href="classDGtal_1_1ReverseIterator.html" title="This class adapts any bidirectional iterator so that operator++ calls operator-- and vice versa...">DGtal::ReverseIterator</a> instead of std::reverse_iterator or even boost::reverse_iterator. </p><pre class="fragment">#include "DGtal/base/ReverseIterator.h"
...
template&lt;typename Iterator&gt;
void anyProcedure(const Iterator&amp; anIterator)
  {
    ...
    DGtal::ReverseIterator&lt;Iterator&gt; ri(anIterator); 
    ASSERT( ri.base() == anIterator ); //ie. anIterator is the underlying iterator of ri
    ...
  }
</pre><dl class="section note"><dt>Note</dt><dd>Reverse iterators are a little tricky because <code>*ri == *--ri.base()</code> (or equivalently <code>*++ri == *ri.base()</code>), so that when an iterator is reversed, the reversed version does not point to the same element in the range, but to the one preceding it.</dd>
<dd>
<b>Developer trick</b>: there is no erase or insert method taking a reverse iterator as input argument in STL containers. Static methods are provided to do that in a small struct called <a class="el" href="structDGtal_1_1OpInSTLContainers.html" title="Aim: Implementation of an adapter for erase and insert methods of STL containers so that they not onl...">OpInSTLContainers</a>.</dd></dl>
<h2><a class="anchor" id="subsecIteratorRangesAdaptersAdapters"></a>
On-line transformations</h2>
<p><a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a> also provides adapters to iterators that transforms the data returned by the dereference (and indirection) operator into other data, possibly of different type. The transformation is delegated to a <em>functor</em>. Dereferencing any adapted iterator consists in applying the functor on the data to which points the underlying iterator: </p><pre class="fragment">#include "DGtal/base/ConstIteratorAdapter.h"
...
template&lt;typename Iterator, typename Functor, typename ReturnType&gt;
void anyProcedure(const Iterator&amp; anIterator, const Functor&amp; aFunctor)
  {
    ...
    DGtal::ConstAdapterIterator&lt;Iterator, Functor, ReturnType&gt; a(i, f);
    ASSERT( *a == f(*i) ); //ie. *a and f(*i) return equivalent instances of ReturnType  
    ...
  } 
</pre><p>The class <a class="el" href="classDGtal_1_1ConstIteratorAdapter.html" title="This class adapts any iterator so that operator* returns another element than the one pointed to by t...">ConstIteratorAdapter</a> adapts any (at least) readable and (at least) incremental iterator with any functor, whereas the class <a class="el" href="classDGtal_1_1IteratorAdapter.html" title="This class adapts any lvalue iterator so that operator* returns a member on the element pointed to by...">IteratorAdapter</a> adapts any readable, writable, Lvalue and (at least) incremental iterator.</p>
<h2><a class="anchor" id="subsecIteratorRangesAdaptersCirculators"></a>
Circulators</h2>
<p>Like <a href="http://www.cgal.org/" title="CGAL">Cgal</a>, <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a> extends the concept of iterator to circular data structures by defining the concept of circular iterator or <em>circulator</em> for short.</p>
<p>The class <a class="el" href="classDGtal_1_1Circulator.html" title="Aim: Provides an adapter for classical iterators that can iterate through the underlying data structu...">Circulator</a> is an adatper that creates a circulator from a classic iterator.</p>
<p>In circular data structures, any pairs of iterators [<code>i,j</code>) always describes a valid range (ie. <code>j</code> is always reachable from <code>i</code>) and there is no past-the-end element. A range of a circular data structure is illustrated below. In this example, [<code>i,j</code>) is of course a valid range.</p>
<div class="image">
<img src="circularRange.png" alt="circularRange.png"/>
<div class="caption">
Circular range</div></div>
  As long as <code>i != j</code>, circulators are quite similar to classic iterator in the subrange [<code>i,j</code>). More precisely, forward and bidirectional circulators behave exactly like classic forward and bidirectional iterators (note that there is no incrementable or single-pass circulator). However, there is a semantic difference between random access circulators and iterators for some arithmetic and comparison operators. Indeed, even if we have <code>i + (j-i) = j</code>, (ie. <code>i</code> must be incremented <code>j-i</code> times so that it reaches <code>j</code>) for both circulators and iterators, we have two major differences, sum up in the following table:</p>
<table class="doxtable">
<tr>
<th>classic iterators </th><th>circulators  </th></tr>
<tr>
<td>(i &lt;= j) iff ((j-i) &gt;= 0) </td><td>(i &lt;= j) is always true </td></tr>
<tr>
<td>(i-j) + (j-i) = 0 </td><td>(i-j) + (j-i) = range size </td></tr>
</table>
<p>On the other hand, circulators and iterators are quite different for iterating over <b>all</b> the elements of a given range. In linear data structures, due to the existence of a past-the-end element, the whole range is not different from any subranges: it is described by a pair of iterators [<code>i,j</code>) such that <code>j</code> is reachable from <code>i</code>. If the data structure does not contain any element, an iterator <code>k</code> can point to the past-the-end element and [<code>k,k</code>) describes the valid and empty associated range.</p>
<p>However, in (truly) circular data structures, there is no past-the-end element. How to describe a whole range using circulators ? Circulators have a specific state in the case of an empty data structure so that it is enough to consider one circulator <code>k</code> to check whether the underlying data structure is empty or not. Note that any default-constructed circulator, by convention, is in the same state as circulators provided by empty data structures.</p>
<p>Since the empty case is managed by this internal state, [<code>k,k</code>) can be viewed then as describing a whole range of elements, if a whole range is required.</p>
<p>The do-while structure is the basic way of circulating over a range of elements: </p><pre class="fragment">do 
  {
    ...
    ++c; 
  } while( c != cEnd);   
</pre><p>The generic way of iterating over a range of elements whatever the type of iterators (either iterator or circulator) uses the generic function <code><a class="el" href="namespaceDGtal.html#a6f1b22211474c60437654c3a0decb8ef">isNotEmpty()</a></code>: </p><pre class="fragment">#include "DGtal/base/IteratorFunctions.h"
...
template&lt;typename IC&gt;
void anyProcedure(const IC&amp; ic1, const IC&amp; ic2)
  {
    if ( isNotEmpty( ic1, ic2 ) )
      { //if the range is not empty
        IC ic = ic1; 
        do 
          {//iterating over the range
          ...
          ++ic; 
          } while( ic != ic2);   
      }
  }
</pre><h1><a class="anchor" id="secIteratorRangesUtils"></a>
Iterator Utilities</h1>
<p>To ease the use of iterators and circulators, several tools are available.</p>
<h2><a class="anchor" id="subsecIteratorRangesUtilsFuns"></a>
Useful functions</h2>
<p>In the file <a class="el" href="IteratorFunctions_8h_source.html">DGtal/base/IteratorFunctions.h</a>, there are several functions, like the <code><a class="el" href="namespaceDGtal.html#a6f1b22211474c60437654c3a0decb8ef">isNotEmpty()</a></code> function used above, that are specialized with respect to the type and category of iterators.</p>
<p>Here is the list of available functions:</p><ul>
<li><code><a class="el" href="namespaceDGtal.html#a6b49e997d09ccb163eb82529e8970996">isEmpty()</a></code>, <code><a class="el" href="namespaceDGtal.html#a6f1b22211474c60437654c3a0decb8ef">isNotEmpty()</a></code>: check if a (whole) range is empty.</li>
<li><code><a class="el" href="namespaceDGtal.html#ac30d89880d1c9d74deadc8f199e4051b">advanceIterator()</a></code>: increments a given iterator <code>n</code> times.</li>
<li><code><a class="el" href="namespaceDGtal.html#a5272d9b624e986d687282c2d2ba21527">subRangeSize()</a></code>, <code><a class="el" href="namespaceDGtal.html#a25eb68dd5105a89999495322717ad375">rangeSize()</a></code>: return the size of a given range, described by a pair of iterators.</li>
<li><code><a class="el" href="namespaceDGtal.html#a66b5d1c71b11470ae43ced01591c326d">subRangeMiddle()</a></code>, <code><a class="el" href="namespaceDGtal.html#a7cb96c2af7c44c9d1b5f6690317c8530">rangeMiddle()</a></code>: return the iterator lying in the middle of a given range, described by a pair of iterators.</li>
</ul>
<p>Note that in the <code>rangeXXX()</code> methods, the range given as input argument is assumed to be the whole range of elements stored in a container possibly empty, whereas in the <code>subRangeXXX()</code> methods, the range given as input argument is assumed to be any subrange of an existing and not empty container. This distinction is only relevant for circulators and the <code>subRangeXXX()</code> functions are perfectly equivalent to the <code>rangeXXX()</code> functions for classic iterators.</p>
<h2><a class="anchor" id="subsecIteratorRangesUtilsTags"></a>
Categories and other associated types</h2>
<p>Sometimes, we need information about iterators. Is it a circulator ? What is its traversal category ? What is the type of the data ? In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a>, the traits class <a class="el" href="structDGtal_1_1IteratorCirculatorTraits.html" title="Aim: Provides nested types for both iterators and circulators: Type, Category, Value, Difference, Pointer and Reference. ">IteratorCirculatorTraits</a> provides this information thanks to the following nested types:</p>
<ul>
<li>Type: type of iterator (either <a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a> or <a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>)</li>
<li>Category: traversal category, (either <a class="el" href="structDGtal_1_1ForwardCategory.html">ForwardCategory</a>, <a class="el" href="structDGtal_1_1BidirectionalCategory.html">BidirectionalCategory</a> or <a class="el" href="structDGtal_1_1RandomAccessCategory.html">RandomAccessCategory</a>)</li>
<li>Value: type T of the data</li>
<li>Difference: difference between two iterators</li>
<li>Pointer: pointer to the data (usually T*).</li>
<li>Reference: reference to the data (usually T&amp;).</li>
</ul>
<p>For instance, redefining the value type is done as follows: </p><pre class="fragment">#include "DGtal/base/IteratorTraits.h" 
...
template&lt;typename IC&gt;
void anyProcedure(const IC&amp; ic)
  {
    typedef typename IteratorCirculatorTraits&lt;IC&gt;::Value ValueType; 
    ...
  }
</pre><h2><a class="anchor" id="subsecIteratorRangesUtilsTagsDispatching"></a>
For developers: Tag dispatching</h2>
<p>If you want to specialize some classes or functions according to iterators tags (basically type and category), you may use function overloading. This technique is called <a href="http://www.generic-programming.org/languages/cpp/techniques.php#tag_dispatching">tag dispatching</a>. You may find examples of tag dispatching in <a class="el" href="IteratorFunctions_8h_source.html">IteratorFunctions.h</a> and <a class="el" href="IteratorFunctions_8ih_source.html">IteratorFunctions.ih</a></p>
<h2><a class="anchor" id="subsecIteratorRangesUtilsTagsNew"></a>
For developers: How to create new iterators ?</h2>
<p>When you create a new iterator, you have to be sure that it contains all STL required nested types so that <a class="el" href="structDGtal_1_1IteratorCirculatorTraits.html" title="Aim: Provides nested types for both iterators and circulators: Type, Category, Value, Difference, Pointer and Reference. ">IteratorCirculatorTraits</a> works fine:</p><ul>
<li>iterator_category</li>
<li>value_type</li>
<li>difference_type</li>
<li>pointer</li>
<li>reference</li>
</ul>
<p>By default, the type of any new iterator is <a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>. If you create a new circulator, you have to define a nested type called <em>Type</em> as <a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>. The class <a class="el" href="classDGtal_1_1Circulator.html" title="Aim: Provides an adapter for classical iterators that can iterate through the underlying data structu...">Circulator</a> is a good example of what a circulator should look like.</p>
<p>Moreover, you have to be sure that it implements all operators required by its category (dereference, indirection, pre- and post- incrementation, etc.). If your iterator should be readable and forward, you have to be sure that it is both a model of readable and forward iterator by concept checking.</p>
<h2><a class="anchor" id="subsecIteratorRangesUtilsConcepts"></a>
Concepts checking</h2>
<p>The basic way of checking whether a given type is a model of a given concept or not is to use the BOOST_CONCEPT_ASSERT mechanism. In the following snippet, type <em>I</em> is expected to be a model of readable iterator and forward iterator. If it turns out that it is not a model of these concepts, a compilation error is raised. </p><pre class="fragment">template&lt;typename I&gt;
void anyProcedure(const I&amp; i)
  {
    BOOST_CONCEPT_ASSERT(( boost_concepts::ReadableIteratorConcept&lt;I&gt; )); 
    BOOST_CONCEPT_ASSERT(( boost_concepts::ForwardTraversalConcept&lt;I&gt; )); 
    ...
  }
</pre><h1><a class="anchor" id="secIteratorRangesApps"></a>
Applications</h1>
<p>In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a>, iterators and ranges are heavily used in several packages. We detail below their use in two packages: Geometry and <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values. ">Image</a>.</p>
<h2><a class="anchor" id="secIteratorRangesAppsGeometry"></a>
Iterators and ranges in the Geometry package</h2>
<p>One module of the geometry package is the analysis of one-dimensional discrete structures. This is a (not exhaustive) list of such structures used in digital geometry:</p>
<ul>
<li>digital curves<ul>
<li>2d, 3d, nd</li>
<li>4-connected, 8-connected, disconnected</li>
<li>interpixels, pixels</li>
<li>open, closed</li>
</ul>
</li>
<li>chaincodes</li>
</ul>
<p>Since these structures are one-dimensional, discrete and finite, they can be viewed as linear or circular range of elements. Segmentation algorithms extract from the whole range of elements, possibly overlapping subranges called <em>segments</em>.</p>
<p>See <a class="el" href="moduleGridCurveAnalysis.html">Analysis of one-dimensional discrete structures</a> for further details.</p>
<h2><a class="anchor" id="secIteratorRangesAppsImage"></a>
Iterators and ranges in the Image package</h2>
<p>The concept of image is a refinement of the concept of <em>point functor</em>, which describes a mapping between the points of a digital space and a set of values. In addition, an image is bounded by a domain, ie. a finite and constant set of digital points.</p>
<p>All images provide an access to its domain (<code>domain()</code> method), which is a range of digital points, as well as an access to a range of values (<code>constRange() or range()</code> methods).</p>
<p>See <a class="el" href="moduleSpacePointVectorDomain.html">Digital Spaces, Points, Vectors and Domains</a> and moduleImage for further details. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 31 2015 11:19:00 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
