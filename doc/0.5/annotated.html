<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DGtal: Data Structures</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.5.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Data Structures</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock">Here are the data structures with brief descriptions:</div><table>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1AbsFunctor.html">DGtal::AbsFunctor&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1AccFlower2D.html">DGtal::AccFlower2D&lt; TSpace &gt;</a></td><td class="indexvalue">Aim: Model of the concept StarShaped represents any accelerated flower in the plane </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Adapter.html">DGtal::Adapter&lt; ArithmeticalDSS &gt;</a></td><td class="indexvalue">Aim: abstract adapter for <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: Dynamic recognition of a digital straight segment (DSS) defined as the sequence of simply connec...">ArithmeticalDSS</a>. Has 2 virtual methods: </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Adapter4ConcavePart.html">DGtal::Adapter4ConcavePart&lt; ArithmeticalDSS &gt;</a></td><td class="indexvalue">Aim: adapter for <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: Dynamic recognition of a digital straight segment (DSS) defined as the sequence of simply connec...">ArithmeticalDSS</a> used by <a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a> in concave parts. Has 2 methods: </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Adapter4ConvexPart.html">DGtal::Adapter4ConvexPart&lt; ArithmeticalDSS &gt;</a></td><td class="indexvalue">Aim: adapter for <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: Dynamic recognition of a digital straight segment (DSS) defined as the sequence of simply connec...">ArithmeticalDSS</a> used by <a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a> in convex parts. Has 2 methods: </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1AndBoolFct2.html">DGtal::AndBoolFct2</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1AngleComputer.html">DGtal::AngleComputer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1AngleLinearMinimizer.html">DGtal::AngleLinearMinimizer</a></td><td class="indexvalue">Aim: Used to minimize the angle variation between different angles while taking into accounts min and max constraints. Example ( </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1AngleLinearMinimizerByAdaptiveStepGradientDescent.html">DGtal::AngleLinearMinimizerByAdaptiveStepGradientDescent</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1AngleLinearMinimizerByGradientDescent.html">DGtal::AngleLinearMinimizerByGradientDescent</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1AngleLinearMinimizerByRelaxation.html">DGtal::AngleLinearMinimizerByRelaxation</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1KhalimskySpaceND_1_1AnyCellCollection.html">DGtal::KhalimskySpaceND&lt; dim, TInteger &gt;::AnyCellCollection&lt; CellType &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DigitalSurface_1_1Arc.html">DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt;::Arc</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ArithmeticalDSS.html">DGtal::ArithmeticalDSS&lt; TIterator, TInteger, connectivity &gt;</a></td><td class="indexvalue">Aim: Dynamic recognition of a digital straight segment (DSS) defined as the sequence of simply connected points (x,y) such that mu &lt;= ax - by &lt; mu + omega </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ArithmeticalDSS3d.html">DGtal::ArithmeticalDSS3d&lt; TIterator, TInteger, connectivity &gt;</a></td><td class="indexvalue">Aim: Dynamic recognition of a 3d-digital straight segment (DSS) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classArrowsRange.html">ArrowsRange</a></td><td class="indexvalue">Aim: model of CConstRange that provides services to (circularly)iterate over the signed 1-cells of a grid curve, viewed as pairs (point - shift vector), both in integer coordinates </td></tr>
  <tr><td class="indexkey"><a class="el" href="classboost_1_1Assignable.html">Assignable</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Ball2D.html">DGtal::Ball2D&lt; TSpace &gt;</a></td><td class="indexvalue">Aim: Model of the concept StarShaped represents any circle in the plane </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBallFunctor.html">BallFunctor&lt; TPoint &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classBallPredicate.html">BallPredicate&lt; TPoint &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1bidirectional__circulator__tag.html">DGtal::bidirectional_circulator_tag</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1BidirectionalCategory.html">DGtal::BidirectionalCategory</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1BinaryPointPredicate.html">DGtal::BinaryPointPredicate&lt; TPointPredicate1, TPointPredicate2, TBinaryFunctor &gt;</a></td><td class="indexvalue">Aim: The predicate returns true when the given binary functor returns true for the two PointPredicates given at construction </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1BinomialConvolver.html">DGtal::BinomialConvolver&lt; TConstIteratorOnPoints, TValue &gt;</a></td><td class="indexvalue">Aim: This class represents a 2D contour convolved by some binomial. It computes first and second order derivatives so as to be able to estimate tangent and curvature. In particular, it smoothes digital contours but could be used for other kind of contours </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1BinomialConvolverEstimator.html">DGtal::BinomialConvolverEstimator&lt; TBinomialConvolver, TBinomialConvolverFunctor &gt;</a></td><td class="indexvalue">Aim: This class encapsulates a <a class="el" href="classDGtal_1_1BinomialConvolver.html" title="Aim: This class represents a 2D contour convolved by some binomial. It computes first and second orde...">BinomialConvolver</a> and a functor on <a class="el" href="classDGtal_1_1BinomialConvolver.html" title="Aim: This class represents a 2D contour convolved by some binomial. It computes first and second orde...">BinomialConvolver</a> so as to be a model of CLocalGeometricEstimator </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1Bits.html">DGtal::Bits</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1BLUELocalLengthEstimator.html">DGtal::BLUELocalLengthEstimator&lt; TConstIterator &gt;</a></td><td class="indexvalue">Aim: Best Linear Unbiased Two step length estimator </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Board2D.html">DGtal::Board2D</a></td><td class="indexvalue">Aim: This class specializes a 'Board' class so as to display <a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a> objects more naturally (with &lt;&lt;). The user has simply to declare a <a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (with &lt;&lt;)...">Board2D</a> object and uses stream operators to display most digital objects. Furthermore, one can use this class to modify the current style for drawing </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Board3DTo2D.html">DGtal::Board3DTo2D</a></td><td class="indexvalue">Class for PDF, PNG, PS, EPS, SVG export drawings with Cairo with 3D-&gt;2D projection </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1BoundaryPredicate.html">DGtal::BoundaryPredicate&lt; TKSpace, TImage &gt;</a></td><td class="indexvalue">Aim: The predicate on surfels that represents the frontier between a region and its complementary in an image. It can be used with <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">ExplicitDigitalSurface</a> or <a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">LightExplicitDigitalSurface</a> so as to define a digital surface. Such surfaces may of course be open </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1BreadthFirstVisitor.html">DGtal::BreadthFirstVisitor&lt; TGraph, TMarkSet &gt;</a></td><td class="indexvalue">Aim: This class is useful to perform a breadth-first exploration of a graph given a starting point or set (called initial core) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CAdjacency.html">DGtal::CAdjacency&lt; Adj &gt;</a></td><td class="indexvalue">Aim: The concept <a class="el" href="structDGtal_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">CAdjacency</a> defines an elementary adjacency relation between points of a digital space </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CameraDirection.html">DGtal::CameraDirection</a></td><td class="indexvalue"><a class="el" href="structDGtal_1_1CameraDirection.html" title="CameraDirection class to set camera direction.">CameraDirection</a> class to set camera direction </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CameraPosition.html">DGtal::CameraPosition</a></td><td class="indexvalue"><a class="el" href="structDGtal_1_1CameraPosition.html" title="CameraPosition class to set camera position.">CameraPosition</a> class to set camera position </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CameraUpVector.html">DGtal::CameraUpVector</a></td><td class="indexvalue"><a class="el" href="structDGtal_1_1CameraUpVector.html" title="CameraUpVector class to set camera up-vector.">CameraUpVector</a> class to set camera up-vector </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CameraZNearFar.html">DGtal::CameraZNearFar</a></td><td class="indexvalue"><a class="el" href="structDGtal_1_1CameraZNearFar.html" title="CameraZNearFar class to set near and far distance.">CameraZNearFar</a> class to set near and far distance </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CanonicCellEmbedder.html">DGtal::CanonicCellEmbedder&lt; TKSpace &gt;</a></td><td class="indexvalue">Aim: A trivial embedder for unsigned cell, which corresponds to the canonic injection of cell centroids into Rn </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CanonicDigitalSurfaceEmbedder.html">DGtal::CanonicDigitalSurfaceEmbedder&lt; TDigitalSurface &gt;</a></td><td class="indexvalue">Aim: A trivial embedder for digital surfaces, which corresponds to the canonic injection of cell centroids into Rn </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CanonicEmbedder.html">DGtal::CanonicEmbedder&lt; TSpace &gt;</a></td><td class="indexvalue">Aim: A trivial embedder for digital points, which corresponds to the canonic injection of Zn into Rn </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CanonicSCellEmbedder.html">DGtal::CanonicSCellEmbedder&lt; TKSpace &gt;</a></td><td class="indexvalue">Aim: A trivial embedder for signed cell, which corresponds to the canonic injection of cell centroids into Rn </td></tr>
  <tr><td class="indexkey"><a class="el" href="structCastFunctor.html">CastFunctor&lt; TOutput &gt;</a></td><td class="indexvalue">Aim: Define a simple functor using the static cast operator </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CBackInsertable.html">DGtal::CBackInsertable&lt; T &gt;</a></td><td class="indexvalue">Aim: Represents types for which a std::back_insert_iterator can be constructed with std::back_inserter. Back Insertion Sequence are refinements of <a class="el" href="structDGtal_1_1CBackInsertable.html" title="Aim: Represents types for which a std::back_insert_iterator can be constructed with std::back_inserte...">CBackInsertable</a>. They require more services than <a class="el" href="structDGtal_1_1CBackInsertable.html" title="Aim: Represents types for which a std::back_insert_iterator can be constructed with std::back_inserte...">CBackInsertable</a>, for instance read services or erase services </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CBidirectionalIteratorArchetype.html">DGtal::CBidirectionalIteratorArchetype&lt; T &gt;</a></td><td class="indexvalue">An archetype of BidirectionalIterator </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CBidirectionalOutputRange.html">DGtal::CBidirectionalOutputRange&lt; T, Value &gt;</a></td><td class="indexvalue">Aim: refined concept of bidirectional range which require that a reverse output iterator exists </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CBidirectionalOutputRangeFromPoint.html">DGtal::CBidirectionalOutputRangeFromPoint&lt; T, Value &gt;</a></td><td class="indexvalue">Aim: refined concept of single pass range with an routputIterator() method from a point </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CBidirectionalRange.html">DGtal::CBidirectionalRange&lt; T &gt;</a></td><td class="indexvalue">Aim: Defines the concept describing a bidirectional range </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CBidirectionalRangeFromPoint.html">DGtal::CBidirectionalRangeFromPoint&lt; T &gt;</a></td><td class="indexvalue">Aim: refined concept of single pass range with a begin() method from a point </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html">DGtal::CBidirectionalSegmentComputer&lt; T &gt;</a></td><td class="indexvalue">Aim: Defines the concept describing a bidirectional segment computer, ie. a model of <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment of a range, ie. a valid and not empty subrange...">CSegment</a> that can extend itself in the two possible directions </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CBoundedInteger.html">DGtal::CBoundedInteger&lt; T &gt;</a></td><td class="indexvalue">Aim: The concept <a class="el" href="structDGtal_1_1CBoundedInteger.html" title="Aim: The concept CBoundedInteger specifies what are the bounded integer numbers. Hence, it is a refinement of CInteger Concept ensuring that the numbers are bounded.">CBoundedInteger</a> specifies what are the bounded integer numbers. Hence, it is a refinement of <a class="el" href="structDGtal_1_1CInteger.html" title="Aim: The concept CInteger specifies what are the usual integer numbers, more precisely the ones that ...">CInteger</a> Concept ensuring that the numbers are bounded </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CCellEmbedder.html">DGtal::CCellEmbedder&lt; T &gt;</a></td><td class="indexvalue">Aim: A cell embedder is a mapping from unsigned cells to Euclidean points. It adds inner types to functor </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CCellularGridSpaceND.html">DGtal::CCellularGridSpaceND&lt; T &gt;</a></td><td class="indexvalue">Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian product, cells have a cubic shape that depends on the dimension: 0-cells are points, 1-cells are unit segments, 2-cells are squares, 3-cells are cubes, and so on </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CColorMap.html">DGtal::CColorMap&lt; CMap &gt;</a></td><td class="indexvalue">Aim: Defines the concept describing a color map. A color map converts a value within a given range into an RGB triple </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CCommutativeRing.html">DGtal::CCommutativeRing&lt; T &gt;</a></td><td class="indexvalue">Aim: Defines the mathematical concept equivalent to a unitary commutative ring </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CConstBidirectionalIteratorArchetype.html">DGtal::CConstBidirectionalIteratorArchetype&lt; T &gt;</a></td><td class="indexvalue">An archetype of ConstBidirectionalIterator </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CConstBidirectionalRange.html">DGtal::CConstBidirectionalRange&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CConstBidirectionalRangeFromPoint.html">DGtal::CConstBidirectionalRangeFromPoint&lt; T &gt;</a></td><td class="indexvalue">Aim: refined concept of const bidirectional range with a begin() method from a point </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CConstImage.html">DGtal::CConstImage&lt; I &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CConstSinglePassRange.html">DGtal::CConstSinglePassRange&lt; T &gt;</a></td><td class="indexvalue">Aim: Defines the concept describing a const range </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CConstSinglePassRangeFromPoint.html">DGtal::CConstSinglePassRangeFromPoint&lt; T &gt;</a></td><td class="indexvalue">Aim: refined concept of const single pass range with a begin() method from a point </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CConvolutionWeights.html">DGtal::CConvolutionWeights&lt; T &gt;</a></td><td class="indexvalue">Aim: defines models of centered convolution kernel used for normal vector integration for instance </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CDigitalBoundedShape.html">DGtal::CDigitalBoundedShape&lt; TShape &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CDigitalOrientedShape.html">DGtal::CDigitalOrientedShape&lt; T &gt;</a></td><td class="indexvalue">Aim: characterizes models of digital oriented shapes. For example, models should provide an orientation method for points on a <a class="el" href="classDGtal_1_1SpaceND.html" title="Aim: SpaceND is a utility class that defines the fundamental structure of a Digital Space in ND...">SpaceND</a>. Returned value type corresponds to <a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41">DGtal::Orientation</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CDigitalSet.html">DGtal::CDigitalSet&lt; T &gt;</a></td><td class="indexvalue">Aim: Represents a set of points within the given domain. This set of points is modifiable by the user </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1CDigitalSetArchetype.html">DGtal::CDigitalSetArchetype&lt; TDomain &gt;</a></td><td class="indexvalue">Aim: The archetype of a container class for storing sets of digital points within some given domain </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CDigitalSurfaceContainer.html">DGtal::CDigitalSurfaceContainer&lt; T &gt;</a></td><td class="indexvalue">Aim: </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CDigitalSurfaceEmbedder.html">DGtal::CDigitalSurfaceEmbedder&lt; T &gt;</a></td><td class="indexvalue">Aim: A digital surface embedder is a specialized mapping from signed cells to Euclidean points. It adds inner types to functor as well as a method to access the digital surface </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CDigitalSurfaceTracker.html">DGtal::CDigitalSurfaceTracker&lt; T &gt;</a></td><td class="indexvalue">Aim: </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CDomain.html">DGtal::CDomain&lt; T &gt;</a></td><td class="indexvalue">Aim: This concept represents a digital domain, i.e. a non mutable subset of points of the given digital space </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CDomainAdjacency.html">DGtal::CDomainAdjacency&lt; T &gt;</a></td><td class="indexvalue">Aim: Refines the concept <a class="el" href="structDGtal_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">CAdjacency</a> by telling that the adjacency is specific to a given domain of the embedding digital space </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1CDomainArchetype.html">DGtal::CDomainArchetype&lt; TSpace &gt;</a></td><td class="indexvalue">Aim: The archetype of a class that represents a digital domain, i.e. a non mutable subset of points of the given digital space </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CDrawableWithBoard2D.html">DGtal::CDrawableWithBoard2D&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CDrawableWithDisplay3D.html">DGtal::CDrawableWithDisplay3D&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html">DGtal::CDynamicBidirectionalSegmentComputer&lt; T &gt;</a></td><td class="indexvalue">Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie. a model of <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment of a range, ie. a valid and not empty subrange...">CSegment</a> that can extend and retract itself in either direction </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html">DGtal::CDynamicSegmentComputer&lt; T &gt;</a></td><td class="indexvalue">Aim: Defines the concept describing a dynamic segment computer, ie. a model of <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment of a range, ie. a valid and not empty subrange...">CSegment</a> that can extend and retract itself (in the direction that is relative to the underlying iterator) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1CellDirectionIterator.html">DGtal::CellDirectionIterator&lt; dim, TInteger &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1KhalimskySpaceND_1_1CellMap.html">DGtal::KhalimskySpaceND&lt; dim, TInteger &gt;::CellMap&lt; Value &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CEuclideanBoundedShape.html">DGtal::CEuclideanBoundedShape&lt; TShape &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CEuclideanOrientedShape.html">DGtal::CEuclideanOrientedShape&lt; T &gt;</a></td><td class="indexvalue">Aim: characterizes models of digital oriented shapes. For example, models should provide an orientation method for real points. Returned value type corresponds to <a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41">DGtal::Orientation</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CEuclideanRing.html">DGtal::CEuclideanRing&lt; T &gt;</a></td><td class="indexvalue">Aim: Defines the mathematical concept equivalent to a unitary commutative ring with a division operator </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CForwardIteratorArchetype.html">DGtal::CForwardIteratorArchetype&lt; T &gt;</a></td><td class="indexvalue">An archetype of ForwardIterator </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CForwardSegmentComputer.html">DGtal::CForwardSegmentComputer&lt; T &gt;</a></td><td class="indexvalue">Aim: Defines the concept describing a forward segment computer, ie. a model of <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment of a range, ie. a valid and not empty subrange...">CSegment</a> that can extend itself (in the direction that is relative to the underlying iterator) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1ConceptUtils_1_1CheckFalse.html">DGtal::ConceptUtils::CheckFalse&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1ConceptUtils_1_1CheckTag.html">DGtal::ConceptUtils::CheckTag&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1ConceptUtils_1_1CheckTrue.html">DGtal::ConceptUtils::CheckTrue&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1ConceptUtils_1_1CheckTrue_3_01TagTrue_01_4.html">DGtal::ConceptUtils::CheckTrue&lt; TagTrue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1ConceptUtils_1_1CheckTrueOrFalse.html">DGtal::ConceptUtils::CheckTrueOrFalse&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1ConceptUtils_1_1CheckUnknown.html">DGtal::ConceptUtils::CheckUnknown&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1ConceptUtils_1_1CheckUnknown_3_01TagUnknown_01_4.html">DGtal::ConceptUtils::CheckUnknown&lt; TagUnknown &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CImage.html">DGtal::CImage&lt; I &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CImplicitFunction.html">DGtal::CImplicitFunction&lt; T &gt;</a></td><td class="indexvalue">Aim: Describes any function of the form f(x), where x is some real point in the given space, and f(x) is some value </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CImplicitFunctionDiff1.html">DGtal::CImplicitFunctionDiff1&lt; T &gt;</a></td><td class="indexvalue">Aim: Describes a 1-differentiable function of the form f(x), where x is some real point in the given space, and f(x) is some value </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CInteger.html">DGtal::CInteger&lt; T &gt;</a></td><td class="indexvalue">Aim: The concept <a class="el" href="structDGtal_1_1CInteger.html" title="Aim: The concept CInteger specifies what are the usual integer numbers, more precisely the ones that ...">CInteger</a> specifies what are the usual integer numbers, more precisely the ones that are representable on a computer </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1CircleFrom2Points.html">DGtal::CircleFrom2Points&lt; TPoint &gt;</a></td><td class="indexvalue">Aim: Represents a circle that passes through a given point and that is thus uniquely defined by two other points. It is able to return for any given point its signed distance to itself </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1CircleFrom3Points.html">DGtal::CircleFrom3Points&lt; TPoint &gt;</a></td><td class="indexvalue">Aim: Represents a circle uniquely defined by three 2D points and that is able to return for any given 2D point its signed distance to itself </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Circulator.html">DGtal::Circulator&lt; TIterator &gt;</a></td><td class="indexvalue">Aim: Provides an adapter for STL iterators that can iterate through the underlying data structure as in a loop. The increment (resp. decrement if at least bidirectionnal) operator encapsulates the validity test and the assignement to the first (resp. last) iterator of a given range. For instance, the pre-increment operator does: </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CirculatorTagTraits.html">DGtal::CirculatorTagTraits&lt; T &gt;</a></td><td class="indexvalue">Aim: Transform std::forward_iterator_tag into <a class="el" href="structDGtal_1_1forward__circulator__tag.html">forward_circulator_tag</a> Transform std::bidirectional_iterator_tag into <a class="el" href="structDGtal_1_1bidirectional__circulator__tag.html">bidirectional_circulator_tag</a> Transform std::random_access_iterator_tag into <a class="el" href="structDGtal_1_1random__access__circulator__tag.html">random_access_circulator_tag</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CirculatorTagTraits_3_01std_1_1bidirectional__iterator__tag_01_4.html">DGtal::CirculatorTagTraits&lt; std::bidirectional_iterator_tag &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CirculatorTagTraits_3_01std_1_1forward__iterator__tag_01_4.html">DGtal::CirculatorTagTraits&lt; std::forward_iterator_tag &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CirculatorTagTraits_3_01std_1_1random__access__iterator__tag_01_4.html">DGtal::CirculatorTagTraits&lt; std::random_access_iterator_tag &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CirculatorType.html">DGtal::CirculatorType</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CLabel.html">DGtal::CLabel&lt; T &gt;</a></td><td class="indexvalue">Aim: Define the concept of <a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a> labels. Models of <a class="el" href="structDGtal_1_1CLabel.html" title="Aim: Define the concept of DGtal labels. Models of CLabel can be default-constructible, assignable and equality comparable.">CLabel</a> can be default-constructible, assignable and equality comparable </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1ClippingPlane.html">DGtal::ClippingPlane</a></td><td class="indexvalue">Class for adding a Clipping plane through the <a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a> stream. Realizes the concept CDrawableWithViewer3D </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1Display3D_1_1clippingPlaneD3D.html">DGtal::Display3D::clippingPlaneD3D</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Clock.html">DGtal::Clock</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CNormalVectorEstimator.html">DGtal::CNormalVectorEstimator&lt; T &gt;</a></td><td class="indexvalue">Aim: Represents the concept of estimator of normal vector along digital surfaces </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1CombinatorialDSS_1_1CodeHandler.html">DGtal::CombinatorialDSS&lt; TConstIterator, TInteger &gt;::CodeHandler&lt; TIterator, iterator_type &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1CombinatorialDSS_1_1CodeHandler_3_01TIterator_00_01bidirectional__iterator__tag_01_4.html">DGtal::CombinatorialDSS&lt; TConstIterator, TInteger &gt;::CodeHandler&lt; TIterator, bidirectional_iterator_tag &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1CombinatorialDSS_1_1CodeHandler_3_01TIterator_00_01random__access__iterator__tag_01_4.html">DGtal::CombinatorialDSS&lt; TConstIterator, TInteger &gt;::CodeHandler&lt; TIterator, random_access_iterator_tag &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1FreemanChain_1_1CodesRange.html">DGtal::FreemanChain&lt; TInteger &gt;::CodesRange</a></td><td class="indexvalue">Aim: model of CRange that provides services to (circularly)iterate over the letters of the freeman chain </td></tr>
  <tr><td class="indexkey"><a class="el" href="classCodesRange.html">CodesRange</a></td><td class="indexvalue">Aim: model of CConstRange that provides services to (circularly)iterate over the 1-cells of a 2d grid curve, viewed as chain codes: </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Color.html">DGtal::Color</a></td><td class="indexvalue">Structure representing an RGB triple </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ColorBrightnessColorMap.html">DGtal::ColorBrightnessColorMap&lt; PValue, PDefaultColor &gt;</a></td><td class="indexvalue">Aim: This class template may be used to (linearly) convert scalar values in a given range into a color with given lightness </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1CombinatorialDSS.html">DGtal::CombinatorialDSS&lt; TConstIterator, TInteger &gt;</a></td><td class="indexvalue">Aim: </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CompareLocalEstimators.html">DGtal::CompareLocalEstimators&lt; TFirstEsimator, TSecondEstimator &gt;</a></td><td class="indexvalue">Aim: Functor to compare two local geometric estimators </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1Viewer3D_1_1compFarthestSurfelFromCamera.html">DGtal::Viewer3D::compFarthestSurfelFromCamera</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1Viewer3D_1_1compFarthestVoxelFromCamera.html">DGtal::Viewer3D::compFarthestVoxelFromCamera</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classComposer.html">Composer&lt; TFunctor1, TFunctor2, ReturnType &gt;</a></td><td class="indexvalue">Aim: Define a new Functor from the composition of two other functors </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ConnectivityException.html">DGtal::ConnectivityException</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ConstantConvolutionWeights.html">DGtal::ConstantConvolutionWeights&lt; TDistance &gt;</a></td><td class="indexvalue">Aim: implement a trivial constant convolution kernel which returns 1 to each distance </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1ConstantPointPredicate.html">DGtal::ConstantPointPredicate&lt; TPoint, boolCst &gt;</a></td><td class="indexvalue">Aim: The predicate that returns always the same value boolCst </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ConstImageAdapter.html">DGtal::ConstImageAdapter&lt; TImage, TFunctor, TValue &gt;</a></td><td class="indexvalue">Aim: implements a model of <a class="el" href="structDGtal_1_1CConstImage.html">CConstImage</a> that adapts an underlying image </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1StandardDSLQ0_1_1ConstIterator.html">DGtal::StandardDSLQ0&lt; TFraction &gt;::ConstIterator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1BreadthFirstVisitor_1_1ConstIterator.html">DGtal::BreadthFirstVisitor&lt; TGraph, TMarkSet &gt;::ConstIterator&lt; TAccessor &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1FreemanChain_1_1ConstIterator.html">DGtal::FreemanChain&lt; TInteger &gt;::ConstIterator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ConstIteratorAdapter.html">DGtal::ConstIteratorAdapter&lt; TIterator, TFunctor, TReturnType &gt;</a></td><td class="indexvalue">This class adapts any iterator (at least forward) so that operator* returns another element than the one pointed to by the iterator </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CombinatorialDSS_1_1ConstPointIterator.html">DGtal::CombinatorialDSS&lt; TConstIterator, TInteger &gt;::ConstPointIterator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ConstRangeAdapter.html">DGtal::ConstRangeAdapter&lt; TIterator, TFunctor, TReturnType &gt;</a></td><td class="indexvalue">Aim: model of <a class="el" href="structDGtal_1_1CConstBidirectionalRange.html">CConstBidirectionalRange</a> that adapts any range of elements bounded by two iterators [itb, ite) and provides services to (circularly)iterate over it (in a read-only manner) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ConstRangeFromPointAdapter.html">DGtal::ConstRangeFromPointAdapter&lt; TRange, TFunctor, TReturnType &gt;</a></td><td class="indexvalue">Aim: model of <a class="el" href="structDGtal_1_1CConstBidirectionalRangeFromPoint.html" title="Aim: refined concept of const bidirectional range with a begin() method from a point.">CConstBidirectionalRangeFromPoint</a> that adapts any bidirectional range and provides services to iterate over it (in a read-only manner) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1HyperRectDomain_1_1ConstSubRange.html">DGtal::HyperRectDomain&lt; TSpace &gt;::ConstSubRange</a></td><td class="indexvalue">Aim: range through some subdomain of all the points in the domain. Defines a constructor taking a domain in parameter plus some additional parameters to specify the subdomain, begin and end methods returning ConstIterator, and rbegin and rend methods returning ConstReverseIterator </td></tr>
  <tr><td class="indexkey"><a class="el" href="classConstValueFunctor.html">ConstValueFunctor&lt; TValue &gt;</a></td><td class="indexvalue">Aim: Define a simple functor that returns a constant value (0 by default) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ContourHelper.html">DGtal::ContourHelper</a></td><td class="indexvalue">Aim: a helper class to process sequences of points </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1CountedPtr.html">DGtal::CountedPtr&lt; T &gt;</a></td><td class="indexvalue">Aim: Smart pointer based on reference counts </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CountedPtr_1_1counter.html">DGtal::CountedPtr&lt; T &gt;::counter</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1CowPtr.html">DGtal::CowPtr&lt; T &gt;</a></td><td class="indexvalue">Aim: Copy on write shared pointer </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CPointEmbedder.html">DGtal::CPointEmbedder&lt; T &gt;</a></td><td class="indexvalue">Aim: A point embedder is a mapping from digital points to Euclidean points. It adds inner types to functor </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CPointFunctor.html">DGtal::CPointFunctor&lt; T &gt;</a></td><td class="indexvalue">Aim: Defines a functor on points </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CPointPredicate.html">DGtal::CPointPredicate&lt; T &gt;</a></td><td class="indexvalue">Aim: Defines a predicate on a point </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CPositiveIrreducibleFraction.html">DGtal::CPositiveIrreducibleFraction&lt; T &gt;</a></td><td class="indexvalue">Aim: Defines positive irreducible fractions, i.e. fraction p/q, p and q non-negative integers, with gcd(p,q)=1 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CPredicate.html">DGtal::CPredicate&lt; T, TElement &gt;</a></td><td class="indexvalue">Aim: Defines a predicate function, ie. a functor mapping a domain into the set of booleans </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CQuantity.html">DGtal::CQuantity&lt; T &gt;</a></td><td class="indexvalue">Aim: defines the concept of quantity in <a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CSCellEmbedder.html">DGtal::CSCellEmbedder&lt; T &gt;</a></td><td class="indexvalue">Aim: A cell embedder is a mapping from signed cells to Euclidean points. It adds inner types to functor </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CSegment.html">DGtal::CSegment&lt; T &gt;</a></td><td class="indexvalue">Aim: Defines the concept describing a segment of a range, ie. a valid and not empty subrange </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CSeparableMetric.html">DGtal::CSeparableMetric&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CSignedInteger.html">DGtal::CSignedInteger&lt; T &gt;</a></td><td class="indexvalue">Aim: Concept checking for Signed Integer </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CSinglePassOutputRange.html">DGtal::CSinglePassOutputRange&lt; T, Value &gt;</a></td><td class="indexvalue">Aim: refined concept of single pass range which require that an output iterator exists </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CSinglePassOutputRangeFromPoint.html">DGtal::CSinglePassOutputRangeFromPoint&lt; T, Value &gt;</a></td><td class="indexvalue">Aim: refined concept of single pass range with a outputIterator() method from a point </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CSinglePassRange.html">DGtal::CSinglePassRange&lt; T &gt;</a></td><td class="indexvalue">Aim: Defines the concept describing a range </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CSinglePassRangeFromPoint.html">DGtal::CSinglePassRangeFromPoint&lt; T &gt;</a></td><td class="indexvalue">Aim: refined concept of single pass range with a begin() method from a point </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CSpace.html">DGtal::CSpace&lt; T &gt;</a></td><td class="indexvalue">Aim: Defines the concept describing a digital space, ie a cartesian product of integer lines </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CSurfelPredicate.html">DGtal::CSurfelPredicate&lt; T &gt;</a></td><td class="indexvalue">Aim: Defines a predicate on a surfel </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CTrivialConstImage.html">DGtal::CTrivialConstImage&lt; I &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CTrivialImage.html">DGtal::CTrivialImage&lt; I &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CTrivialSegmentComputer.html">DGtal::CTrivialSegmentComputer&lt; T &gt;</a></td><td class="indexvalue">Aim: Defines the concept describing the most trivial segment computer, ie. a model of <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment of a range, ie. a valid and not empty subrange...">CSegment</a> that can extend itself </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CUnaryFunctor.html">DGtal::CUnaryFunctor&lt; X, A, R &gt;</a></td><td class="indexvalue">Aim: Defines a unary functor, which associates arguments to results </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CUndirectedSimpleGraph.html">DGtal::CUndirectedSimpleGraph&lt; T &gt;</a></td><td class="indexvalue">Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not necessarily know all the vertices </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CUndirectedSimpleLocalGraph.html">DGtal::CUndirectedSimpleLocalGraph&lt; T &gt;</a></td><td class="indexvalue">Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not necessarily know all the vertices </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CUnsignedInteger.html">DGtal::CUnsignedInteger&lt; T &gt;</a></td><td class="indexvalue">Aim: Concept checking for Unsigned Integer </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CurvatureFromBinomialConvolverFunctor.html">DGtal::CurvatureFromBinomialConvolverFunctor&lt; TBinomialConvolver, TReal &gt;</a></td><td class="indexvalue">Aim: This class is a functor for getting the tangent vector of a binomial convolver </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1CurvatureFromDSSFunctor.html">DGtal::CurvatureFromDSSFunctor&lt; DSSComputer &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1CurvatureFromDSSLengthFunctor.html">DGtal::CurvatureFromDSSLengthFunctor&lt; DSSComputer &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CustomColors.html">DGtal::CustomColors</a></td><td class="indexvalue">Custom style class redefining the pen color and the fill color. You may use Board2D::Color::None for transparent color </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CustomColors3D.html">DGtal::CustomColors3D</a></td><td class="indexvalue">Custom style class redefining the fill color and the gl_LINE/gl_POINT color. You can use <a class="el" href="classDGtal_1_1Color.html" title="Structure representing an RGB triple.">DGtal::Color</a> with alpha transparency value but you nedd to take into account the z-buffer during the Open-GL based rendering </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CustomFillColor.html">DGtal::CustomFillColor</a></td><td class="indexvalue">Custom style class redefining the fill color. You may use Board2D::Color::None for transparent color </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CustomPen.html">DGtal::CustomPen</a></td><td class="indexvalue">Custom style class redefining the pen attributes. You may use Board2D::Color::None for transparent color </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CustomPenColor.html">DGtal::CustomPenColor</a></td><td class="indexvalue">Custom style class redefining the pen color. You may use Board2D::Color::None for transparent color </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CustomStyle.html">DGtal::CustomStyle</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CustomStyle3D.html">DGtal::CustomStyle3D</a></td><td class="indexvalue">Modifier class in a <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like PointVector...">Display3D</a> stream. Useful to choose your own style for a given class. Realizes the concept <a class="el" href="structDGtal_1_1CDrawableWithDisplay3D.html">CDrawableWithDisplay3D</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CVertexPredicate.html">DGtal::CVertexPredicate&lt; T &gt;</a></td><td class="indexvalue">Aim: Defines a predicate on a vertex </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CWithGradientMap.html">DGtal::CWithGradientMap&lt; T &gt;</a></td><td class="indexvalue">Aim: Such object provides a gradient map that associates to each argument some real vector </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1DefaultConstImageRange.html">DGtal::DefaultConstImageRange&lt; TImage &gt;</a></td><td class="indexvalue">Aim: model of <a class="el" href="structDGtal_1_1CConstBidirectionalRangeFromPoint.html" title="Aim: refined concept of const bidirectional range with a begin() method from a point.">CConstBidirectionalRangeFromPoint</a> that adapts the domain of an image in order to iterate over the values associated to its domain points (in a read-only as well as a write-only manner) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DefaultDrawStyle__DigitalSetBySTLSet.html">DGtal::DefaultDrawStyle_DigitalSetBySTLSet</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DefaultDrawStyle__DigitalSetBySTLVector.html">DGtal::DefaultDrawStyle_DigitalSetBySTLVector</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DefaultDrawStyle__FP.html">DGtal::DefaultDrawStyle_FP</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DefaultDrawStyle__GeometricalDCA.html">DGtal::DefaultDrawStyle_GeometricalDCA</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DefaultDrawStyle__GeometricalDSS.html">DGtal::DefaultDrawStyle_GeometricalDSS</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DefaultDrawStyle__ImageContainerByHashTree.html">DGtal::DefaultDrawStyle_ImageContainerByHashTree</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DefaultDrawStyle__ImageContainerBySTLVector.html">DGtal::DefaultDrawStyle_ImageContainerBySTLVector</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DefaultDrawStyle__KhalimskyCell.html">DGtal::DefaultDrawStyle_KhalimskyCell</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DefaultDrawStyle__Object.html">DGtal::DefaultDrawStyle_Object</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DefaultDrawStyle__SignedKhalimskyCell.html">DGtal::DefaultDrawStyle_SignedKhalimskyCell</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DefaultDrawStyleBB__ArithmeticalDSS.html">DGtal::DefaultDrawStyleBB_ArithmeticalDSS</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DefaultDrawStyleCircular__AngleLinearMinimizer.html">DGtal::DefaultDrawStyleCircular_AngleLinearMinimizer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DefaultDrawStyleGrid__FreemanChain.html">DGtal::DefaultDrawStyleGrid_FreemanChain</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DefaultDrawStyleGrid__HyperRectDomain.html">DGtal::DefaultDrawStyleGrid_HyperRectDomain</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DefaultDrawStyleGrid__PointVector.html">DGtal::DefaultDrawStyleGrid_PointVector</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DefaultDrawStyleInterGrid__FreemanChain.html">DGtal::DefaultDrawStyleInterGrid_FreemanChain</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DefaultDrawStylePaving__HyperRectDomain.html">DGtal::DefaultDrawStylePaving_HyperRectDomain</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DefaultDrawStylePaving__PointVector.html">DGtal::DefaultDrawStylePaving_PointVector</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DefaultDrawStylePoints__ArithmeticalDSS.html">DGtal::DefaultDrawStylePoints_ArithmeticalDSS</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDefaultFunctor.html">DefaultFunctor</a></td><td class="indexvalue">Aim: Define a simple default functor that just returns its argument </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1DefaultImageRange.html">DGtal::DefaultImageRange&lt; TImage &gt;</a></td><td class="indexvalue">Aim: model of <a class="el" href="structDGtal_1_1CConstBidirectionalRangeFromPoint.html" title="Aim: refined concept of const bidirectional range with a begin() method from a point.">CConstBidirectionalRangeFromPoint</a> and <a class="el" href="structDGtal_1_1CBidirectionalOutputRangeFromPoint.html" title="Aim: refined concept of single pass range with an routputIterator() method from a point...">CBidirectionalOutputRangeFromPoint</a> that adapts the domain of an image in order to iterate over the values associated to its domain points (in a read-only as well as a write-only manner) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1DGtalInventor.html">DGtal::DGtalInventor&lt; TSpace &gt;</a></td><td class="indexvalue">Aim: A stream object based on Open Inventor for exporting or displaying <a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a> objects </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1DigitalSetBoundary.html">DGtal::DigitalSetBoundary&lt; TKSpace, TDigitalSet &gt;</a></td><td class="indexvalue">Aim: A model of <a class="el" href="structDGtal_1_1CDigitalSurfaceContainer.html" title="Aim:">CDigitalSurfaceContainer</a> which defines the digital surface as the boundary of a given digital set </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html">DGtal::DigitalSetBySTLSet&lt; TDomain &gt;</a></td><td class="indexvalue">Aim: A container class for storing sets of digital points within some given domain </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1DigitalSetBySTLVector.html">DGtal::DigitalSetBySTLVector&lt; TDomain &gt;</a></td><td class="indexvalue">Aim: Realizes the concept <a class="el" href="structDGtal_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">CDigitalSet</a> by using the STL container std::vector </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DigitalSetConverter.html">DGtal::DigitalSetConverter&lt; OutputDigitalSet &gt;</a></td><td class="indexvalue">Aim: Utility class to convert between types of sets </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1DigitalSetDomain.html">DGtal::DigitalSetDomain&lt; TDigitalSet &gt;</a></td><td class="indexvalue">Aim: Constructs a domain limited to the given digital set </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1DigitalSetFromMap.html">DGtal::DigitalSetFromMap&lt; TMapImage &gt;</a></td><td class="indexvalue">Aim: An adapter for viewing an associative image container like <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> as a simple digital set. This class is merely based on an aliasing pointer on the image, which must exists elsewhere </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1DigitalSetInserter.html">DGtal::DigitalSetInserter&lt; TDigitalSet &gt;</a></td><td class="indexvalue">Aim: this output iterator class is designed to allow algorithms to insert points in the digital set. Using the assignment operator, even when dereferenced, causes the digital set to insert a point </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DigitalSetSelector.html">DGtal::DigitalSetSelector&lt; Domain, Preferences &gt;</a></td><td class="indexvalue">Aim: Automatically defines an adequate digital set type according to the hints given by the user </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DigitalSetSelector_3_01Domain_00_01SMALL__DS_09LOW__VAR__DS_09HIGH__ITER__DS_09LOW__BEL__DS_01_4.html">DGtal::DigitalSetSelector&lt; Domain, SMALL_DS+LOW_VAR_DS+HIGH_ITER_DS+LOW_BEL_DS &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DigitalSetSelector_3_01Domain_00_01SMALL__DS_09LOW__VAR__DS_09LOW__ITER__DS_09LOW__BEL__DS_01_4.html">DGtal::DigitalSetSelector&lt; Domain, SMALL_DS+LOW_VAR_DS+LOW_ITER_DS+LOW_BEL_DS &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1DigitalSurface.html">DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt;</a></td><td class="indexvalue">Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cells. Therefore, a digital surface is a pure cubical complex (model of CCubicalComplex), made of k-cells, 0 &lt;= k &lt; n. This complex is generally not a manifold (i.e. a kind of surface), except when it has the property of being well-composed </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1DigitalSurface2DSlice.html">DGtal::DigitalSurface2DSlice&lt; TDigitalSurfaceTracker &gt;</a></td><td class="indexvalue">Aim: Represents a 2-dimensional slice in a <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>. In a sense, it is a 4-connected contour, open or not. To be valid, it must be connected to some digital surface and a starting surfel </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1DigitalSurfaceEmbedderWithNormalVectorEstimator.html">DGtal::DigitalSurfaceEmbedderWithNormalVectorEstimator&lt; TDigitalSurfaceEmbedder, TNormalVectorEstimator &gt;</a></td><td class="indexvalue">Aim: Combines a digital surface embedder with a normal vector estimator to get a model of <a class="el" href="structDGtal_1_1CDigitalSurfaceEmbedder.html" title="Aim: A digital surface embedder is a specialized mapping from signed cells to Euclidean points...">CDigitalSurfaceEmbedder</a> and <a class="el" href="structDGtal_1_1CWithGradientMap.html" title="Aim: Such object provides a gradient map that associates to each argument some real vector...">CWithGradientMap</a>. (also default constructible, copy constructible, assignable) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1DigitalSurfaceEmbedderWithNormalVectorEstimatorGradientMap.html">DGtal::DigitalSurfaceEmbedderWithNormalVectorEstimatorGradientMap&lt; TDigitalSurfaceEmbedder, TNormalVectorEstimator &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1DigitalTopology.html">DGtal::DigitalTopology&lt; TForegroundAdjacency, TBackgroundAdjacency &gt;</a></td><td class="indexvalue">Aim: Represents a digital topology as a couple of adjacency relations </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Display3D.html">DGtal::Display3D</a></td><td class="indexvalue">Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like <a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a>, <a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim: A container class for storing sets of digital points within some given domain.">DigitalSetBySTLSet</a>, <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> ...). The class <a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a> and <a class="el" href="classDGtal_1_1Board3DTo2D.html" title="Class for PDF, PNG, PS, EPS, SVG export drawings with Cairo with 3D-&gt;2D projection.">Board3DTo2D</a> implement two different ways to display 3D objects. The first one (<a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a>), permits an interactive visualisation (based on  OpenGL ) and the second one (<a class="el" href="classDGtal_1_1Board3DTo2D.html" title="Class for PDF, PNG, PS, EPS, SVG export drawings with Cairo with 3D-&gt;2D projection.">Board3DTo2D</a>) provides 3D visualisation from 2D vectorial display (based on the CAIRO library) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1Display3DFactory.html">DGtal::Display3DFactory</a></td><td class="indexvalue">Factory for GPL <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like PointVector...">Display3D</a>: </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1DistanceFunctorFromPoint.html">DGtal::DistanceFunctorFromPoint&lt; TImage &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDistanceTraits.html">DistanceTraits&lt; TImage, TSet, norm &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDistanceTraits_3_01TImage_00_01TSet_00_011_01_4.html">DistanceTraits&lt; TImage, TSet, 1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1DistanceTransformation.html">DGtal::DistanceTransformation&lt; Image, p, IntegerLong &gt;</a></td><td class="indexvalue">Aim: Implementation of the linear in time distance transformation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1DomainAdjacency.html">DGtal::DomainAdjacency&lt; TDomain, TAdjacency &gt;</a></td><td class="indexvalue">Aim: Given a domain and an adjacency, limits the given adjacency to the specified domain for all adjacency and neighborhood computations </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1deprecated_1_1DomainMetricAdjacency.html">DGtal::deprecated::DomainMetricAdjacency&lt; Domain, maxNorm1, dimension &gt;</a></td><td class="indexvalue">Aim: Describes digital adjacencies in a digital domain that are defined with the 1-norm and the infinity-norm </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DomainPredicate.html">DGtal::DomainPredicate&lt; TDomain &gt;</a></td><td class="indexvalue">Aim: The predicate returning true iff the point is in the domain given at construction. It is just a wrapper class around the methods Domain::isInside( const Point &amp; ), where <code>Domain</code> stands for any model of <a class="el" href="structDGtal_1_1CDomain.html" title="Aim: This concept represents a digital domain, i.e. a non mutable subset of points of the given digit...">CDomain</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DrawableWithBoard2D.html">DGtal::DrawableWithBoard2D</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DrawableWithDisplay3D.html">DGtal::DrawableWithDisplay3D</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DrawWithBoardModifier.html">DGtal::DrawWithBoardModifier</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DrawWithDisplay3DModifier.html">DGtal::DrawWithDisplay3DModifier</a></td><td class="indexvalue">Base class specifying the methods for classes which intend to modify a <a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a> stream </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1DSSLengthEstimator.html">DGtal::DSSLengthEstimator&lt; TConstIterator &gt;</a></td><td class="indexvalue">Aim: a model of CGlobalCurveEstimator that segments the digital curve into DSS and computes the length of the resulting (not uniquely defined) polygon </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DummyObject.html">DGtal::DummyObject&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DigitalSurface_1_1Edge.html">DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt;::Edge</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Ellipse2D.html">DGtal::Ellipse2D&lt; TSpace &gt;</a></td><td class="indexvalue">Aim: Model of the concept StarShaped represents any ellipse in the plane </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1EqualPointPredicate.html">DGtal::EqualPointPredicate&lt; TPoint &gt;</a></td><td class="indexvalue">Aim: The predicate returns true when the point given as argument equals the reference point given at construction </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1MPolynomialEvaluatorImpl_3_011_00_01TRing_00_01TOwner_00_01TAlloc_00_01TX_01_4_1_1EvalFun.html">DGtal::MPolynomialEvaluatorImpl&lt; 1, TRing, TOwner, TAlloc, TX &gt;::EvalFun</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1MPolynomialEvaluatorImpl_1_1EvalFun.html">DGtal::MPolynomialEvaluatorImpl&lt; n, TRing, TOwner, TAlloc, TX &gt;::EvalFun&lt; XX, Fun &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1MPolynomialEvaluatorImpl_1_1EvalFun2.html">DGtal::MPolynomialEvaluatorImpl&lt; n, TRing, TOwner, TAlloc, TX &gt;::EvalFun2</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Expander.html">DGtal::Expander&lt; TObject &gt;</a></td><td class="indexvalue">Aim: This class is useful to visit an object by adjacencies, layer by layer </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html">DGtal::ExplicitDigitalSurface&lt; TKSpace, TSurfelPredicate &gt;</a></td><td class="indexvalue">Aim: A model of <a class="el" href="structDGtal_1_1CDigitalSurfaceContainer.html" title="Aim:">CDigitalSurfaceContainer</a> which defines the digital surface as connected surfels. The shape is determined by a predicate telling whether a given surfel belongs or not to the shape boundary. Compute once the boundary of the surface with a tracking </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DigitalSurface_1_1Face.html">DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt;::Face</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1FalseBoolFct0.html">DGtal::FalseBoolFct0</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1FalsePointPredicate.html">DGtal::FalsePointPredicate&lt; TPoint &gt;</a></td><td class="indexvalue">Aim: The predicate that returns always false </td></tr>
  <tr><td class="indexkey"><a class="el" href="structFindAndGetValue.html">FindAndGetValue&lt; I, S, D, V &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structFindAndGetValue_3_01ImageContainerBySTLMap_3_01D_00_01V_01_4_00_01DigitalSetFromMap_3_01Im952d802389315baaf944149692bc3151.html">FindAndGetValue&lt; ImageContainerBySTLMap&lt; D, V &gt;, DigitalSetFromMap&lt; ImageContainerBySTLMap&lt; D, V &gt; &gt;, D, V &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Flower2D.html">DGtal::Flower2D&lt; TSpace &gt;</a></td><td class="indexvalue">Aim: Model of the concept StarShaped represents any flower with k-petals in the plane </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1FMM.html">DGtal::FMM&lt; TImage, TSet, TPointPredicate, TPointFunctor &gt;</a></td><td class="indexvalue">Aim: Fast Marching Method (<a class="el" href="classDGtal_1_1FMM.html" title="Aim: Fast Marching Method (FMM) for nd distance transforms.">FMM</a>) for nd distance transforms </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1forward__circulator__tag.html">DGtal::forward_circulator_tag</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1ForwardCategory.html">DGtal::ForwardCategory</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1FP.html">DGtal::FP&lt; TIterator, TInteger, connectivity &gt;</a></td><td class="indexvalue">Aim: Computes the faithful polygon (<a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a>) of a range of 4/8-connected 2D Points </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1FPLengthEstimator.html">DGtal::FPLengthEstimator&lt; TConstIterator &gt;</a></td><td class="indexvalue">Aim: a model of CGlobalCurveEstimator that computes the length of a digital curve using its <a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a> (faithful polygon) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1LighterSternBrocot_1_1Fraction.html">DGtal::LighterSternBrocot&lt; TInteger, TQuotient, TMap &gt;::Fraction</a></td><td class="indexvalue">This fraction is a model of <a class="el" href="structDGtal_1_1CPositiveIrreducibleFraction.html" title="Aim: Defines positive irreducible fractions, i.e. fraction p/q, p and q non-negative integers...">CPositiveIrreducibleFraction</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1LightSternBrocot_1_1Fraction.html">DGtal::LightSternBrocot&lt; TInteger, TQuotient, TMap &gt;::Fraction</a></td><td class="indexvalue">This fraction is a model of <a class="el" href="structDGtal_1_1CPositiveIrreducibleFraction.html" title="Aim: Defines positive irreducible fractions, i.e. fraction p/q, p and q non-negative integers...">CPositiveIrreducibleFraction</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1SternBrocot_1_1Fraction.html">DGtal::SternBrocot&lt; TInteger, TQuotient &gt;::Fraction</a></td><td class="indexvalue">This fraction is a model of <a class="el" href="structDGtal_1_1CPositiveIrreducibleFraction.html" title="Aim: Defines positive irreducible fractions, i.e. fraction p/q, p and q non-negative integers...">CPositiveIrreducibleFraction</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1FreemanChain.html">DGtal::FreemanChain&lt; TInteger &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1FrontierPredicate.html">DGtal::FrontierPredicate&lt; TKSpace, TImage &gt;</a></td><td class="indexvalue">Aim: The predicate on surfels that represents the frontier between two regions in an image. It can be used with <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">ExplicitDigitalSurface</a> or <a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">LightExplicitDigitalSurface</a> so as to define a digital surface. Such surfaces may of course be open </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1GaussDigitizer.html">DGtal::GaussDigitizer&lt; TSpace, TEuclideanShape &gt;</a></td><td class="indexvalue">Aim: A class for computing the Gauss digitization of some Euclidean shape, i.e. its intersection with some <img class="formulaInl" alt="$ h_1 Z \times h_2 Z \times \cdots \times h_n Z $" src="form_76.png"/>. Note that the real point (0,...,0) is mapped onto the digital point (0,...,0) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1GaussianConvolutionWeights.html">DGtal::GaussianConvolutionWeights&lt; TDistance &gt;</a></td><td class="indexvalue">Aim: implement a Gaussian centered convolution kernel </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1GeometricalDCA.html">DGtal::GeometricalDCA&lt; TConstIterator &gt;</a></td><td class="indexvalue">Aim: On-line recognition of a digital circular arcs (DCA) defined as a sequence of connected grid edges such that there is at least one (Euclidean) circle that separates the centers of the two incident pixels of each grid edge </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1GeometricalDSS.html">DGtal::GeometricalDSS&lt; TConstIterator &gt;</a></td><td class="indexvalue">Aim: On-line recognition of a digital straight segment (DSS) defined as a sequence of connected grid edges such that there is at least one straight line that separates the centers of the two incident pixels of each grid edge </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1GradientColorMap.html">DGtal::GradientColorMap&lt; PValue, PDefaultPreset, PDefaultFirstColor, PDefaultLastColor &gt;</a></td><td class="indexvalue">Aim: This class template may be used to (linearly) convert scalar values in a given range into a color in a gradient defined by two or more colors </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1GrayscaleColorMap.html">DGtal::GrayscaleColorMap&lt; PValue &gt;</a></td><td class="indexvalue">Aim: This class template may be used to (linearly) convert scalar values in a given range into gray levels </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1deprecated_1_1GreedyDecomposition.html">DGtal::deprecated::GreedyDecomposition&lt; TSegment &gt;</a></td><td class="indexvalue">Aim: Computes the greedy decomposition of a sequence into segments (the last element of a given segment is the first one one of the next segment) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1GreedySegmentation.html">DGtal::GreedySegmentation&lt; TSegmentComputer &gt;</a></td><td class="indexvalue">Aim: Computes the greedy segmentation of a range given by a pair of ConstIterators. The last element of a given segment is the first one one of the next segment </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1GridCurve.html">DGtal::GridCurve&lt; TKSpace &gt;</a></td><td class="indexvalue">Aim: describes an alternative sequence of signed 0-cell (pointels) and 1-cell (linels) in any dimension, closed or open. For instance, the topological boundary of a simply connected digital set is a closed grid curve in 2d </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1LongvolReader_1_1HeaderField.html">DGtal::LongvolReader&lt; TImageContainer &gt;::HeaderField</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1VolReader_1_1HeaderField.html">DGtal::VolReader&lt; TImageContainer &gt;::HeaderField</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1HueShadeColorMap.html">DGtal::HueShadeColorMap&lt; PValue, DefaultCycles &gt;</a></td><td class="indexvalue">Aim: This class template may be used to (linearly) convert scalar values in a given range into a color in a <em>cyclic</em> hue shade colormap, maybe aka rainbow color map. This color map is suitable, for example, to colorize distance functions. By default, only one hue cycle is used </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1HyperRectDomain.html">DGtal::HyperRectDomain&lt; TSpace &gt;</a></td><td class="indexvalue">Aim: Parallelepidec region of a digital space, model of a '<a class="el" href="structDGtal_1_1CDomain.html" title="Aim: This concept represents a digital domain, i.e. a non mutable subset of points of the given digit...">CDomain</a>' </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1HyperRectDomain__Iterator.html">DGtal::HyperRectDomain_Iterator&lt; TPoint &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1HyperRectDomain__subIterator.html">DGtal::HyperRectDomain_subIterator&lt; TPoint &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1IdentityBoolFct1.html">DGtal::IdentityBoolFct1</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Image.html">DGtal::Image&lt; TImageContainer &gt;</a></td><td class="indexvalue">Aim: implements association bewteen points lying in a digital domain and values </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ImageContainerByHashTree.html">DGtal::ImageContainerByHashTree&lt; TDomain, TValue, THashKey &gt;</a></td><td class="indexvalue">Model of CImageContainer implementing the association key&lt;-&gt;Value using a hash tree. This class provides a built-in iterator </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1experimental_1_1ImageContainerByITKImage.html">DGtal::experimental::ImageContainerByITKImage&lt; TDomain, TValue &gt;</a></td><td class="indexvalue">Aim: implements a model of CImageContainer using a ITK <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">DGtal::ImageContainerBySTLMap&lt; TDomain, TValue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">DGtal::ImageContainerBySTLVector&lt; TDomain, TValue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1ImageFromSet.html">DGtal::ImageFromSet&lt; TImage &gt;</a></td><td class="indexvalue">Aim: Define utilities to convert a digital set into an image </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ImageLinearCellEmbedder.html">DGtal::ImageLinearCellEmbedder&lt; TKSpace, TImage, TEmbedder &gt;</a></td><td class="indexvalue">Aim: a cellular embedder for images. (default constructible, copy constructible, assignable). Model of <a class="el" href="structDGtal_1_1CCellEmbedder.html" title="Aim: A cell embedder is a mapping from unsigned cells to Euclidean points. It adds inner types to fun...">CCellEmbedder</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1ImageSelector.html">DGtal::ImageSelector&lt; Domain, Value, Preferences &gt;</a></td><td class="indexvalue">Aim: Automatically defines an adequate image type according to the hints given by the user </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1ImageSelector_3_01Domain_00_01Value_00_01LOW__ITER__I_09LOW__BEL__I_01_4.html">DGtal::ImageSelector&lt; Domain, Value, LOW_ITER_I+LOW_BEL_I &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ImplicitBall.html">DGtal::ImplicitBall&lt; TSpace &gt;</a></td><td class="indexvalue">Aim: model of <a class="el" href="structDGtal_1_1CEuclideanOrientedShape.html" title="Aim: characterizes models of digital oriented shapes. For example, models should provide an orientati...">CEuclideanOrientedShape</a> and <a class="el" href="structDGtal_1_1CEuclideanBoundedShape.html">CEuclideanBoundedShape</a> concepts to create a ball in nD. </td></tr>
  <tr><td class="indexkey"><a class="el" href="structImplicitDigitalEllipse3.html">ImplicitDigitalEllipse3&lt; TPoint3 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1ImplicitDigitalEllipse3.html">DGtal::ImplicitDigitalEllipse3&lt; TPoint3 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html">DGtal::ImplicitDigitalSurface&lt; TKSpace, TPointPredicate &gt;</a></td><td class="indexvalue">Aim: A model of <a class="el" href="structDGtal_1_1CDigitalSurfaceContainer.html" title="Aim:">CDigitalSurfaceContainer</a> which defines the digital surface as the boundary of an implicitly define shape. Compute once the boundary of the surface with a tracking </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ImplicitFunctionDiff1LinearCellEmbedder.html">DGtal::ImplicitFunctionDiff1LinearCellEmbedder&lt; TKSpace, TImplicitFunctionDiff1, TEmbedder &gt;</a></td><td class="indexvalue">Aim: a cellular embedder for implicit functions, (default constructible, copy constructible, assignable). Model of <a class="el" href="structDGtal_1_1CCellEmbedder.html" title="Aim: A cell embedder is a mapping from unsigned cells to Euclidean points. It adds inner types to fun...">CCellEmbedder</a> and <a class="el" href="structDGtal_1_1CWithGradientMap.html" title="Aim: Such object provides a gradient map that associates to each argument some real vector...">CWithGradientMap</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1ImplicitFunctionDiff1LinearCellEmbedderGradientMap.html">DGtal::ImplicitFunctionDiff1LinearCellEmbedderGradientMap&lt; TKSpace, TImplicitFunctionDiff1, TEmbedder &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ImplicitFunctionLinearCellEmbedder.html">DGtal::ImplicitFunctionLinearCellEmbedder&lt; TKSpace, TImplicitFunction, TEmbedder &gt;</a></td><td class="indexvalue">Aim: a cellular embedder for implicit functions, (default constructible, copy constructible, assignable). Model of <a class="el" href="structDGtal_1_1CCellEmbedder.html" title="Aim: A cell embedder is a mapping from unsigned cells to Euclidean points. It adds inner types to fun...">CCellEmbedder</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ImplicitHyperCube.html">DGtal::ImplicitHyperCube&lt; TSpace &gt;</a></td><td class="indexvalue">Aim: model of <a class="el" href="structDGtal_1_1CEuclideanOrientedShape.html" title="Aim: characterizes models of digital oriented shapes. For example, models should provide an orientati...">CEuclideanOrientedShape</a> and <a class="el" href="structDGtal_1_1CEuclideanBoundedShape.html">CEuclideanBoundedShape</a> concepts to create an hypercube in nD. </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ImplicitNorm1Ball.html">DGtal::ImplicitNorm1Ball&lt; TSpace &gt;</a></td><td class="indexvalue">Aim: model of <a class="el" href="structDGtal_1_1CEuclideanOrientedShape.html" title="Aim: characterizes models of digital oriented shapes. For example, models should provide an orientati...">CEuclideanOrientedShape</a> and <a class="el" href="structDGtal_1_1CEuclideanBoundedShape.html">CEuclideanBoundedShape</a> concepts to create a ball for the L_1 norm in nD </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ImplicitPolynomial3Shape.html">DGtal::ImplicitPolynomial3Shape&lt; TSpace &gt;</a></td><td class="indexvalue">Aim: model of <a class="el" href="structDGtal_1_1CEuclideanOrientedShape.html" title="Aim: characterizes models of digital oriented shapes. For example, models should provide an orientati...">CEuclideanOrientedShape</a> concepts to create a shape from a polynomial </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ImplicitRoundedHyperCube.html">DGtal::ImplicitRoundedHyperCube&lt; TSpace &gt;</a></td><td class="indexvalue">Aim: model of <a class="el" href="structDGtal_1_1CEuclideanOrientedShape.html" title="Aim: characterizes models of digital oriented shapes. For example, models should provide an orientati...">CEuclideanOrientedShape</a> and <a class="el" href="structDGtal_1_1CEuclideanBoundedShape.html">CEuclideanBoundedShape</a> concepts to create a rounded hypercube in nD. </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1ImpliesBoolFct2.html">DGtal::ImpliesBoolFct2</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classIncidentPointsRange.html">IncidentPointsRange</a></td><td class="indexvalue">Aim: model of CConstRange that provides services to (circularly)iterate over the two 2-cells (viewed as points of integer coordinates) that are (directly and indirectly) incident to the signed 1-cells of a 2d grid curve </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1InfiniteNumberException.html">DGtal::InfiniteNumberException</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classInnerPointsRange.html">InnerPointsRange</a></td><td class="indexvalue">Aim: model of CConstRange that provides services to (circularly)iterate over the 2-cells (viewed as points of integer coordinates) that are directly incident to the signed 1-cells of a 2d grid curve </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1InputException.html">DGtal::InputException</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1InputIteratorWithRankOnSequence.html">DGtal::InputIteratorWithRankOnSequence&lt; TSequence, TRank &gt;</a></td><td class="indexvalue">Aim: Useful to create an iterator that returns a pair (value,rank) when visiting a sequence. The sequence is smartly copied within the iterator. Hence, the given sequence need not to persist during the visit. Since it is only an input sequence, it is not necessary to give a valid sequence when creating the end() iterator </td></tr>
  <tr><td class="indexkey"><a class="el" href="structInsertAndAlwaysSetValue.html">InsertAndAlwaysSetValue&lt; I, S, D, V &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structInsertAndAlwaysSetValue_3_01ImageContainerBySTLMap_3_01D_00_01V_01_4_00_01DigitalSetFromMa6b49f85effea2a47b4579052c04de318.html">InsertAndAlwaysSetValue&lt; ImageContainerBySTLMap&lt; D, V &gt;, DigitalSetFromMap&lt; ImageContainerBySTLMap&lt; D, V &gt; &gt;, D, V &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structInsertAndSetValue.html">InsertAndSetValue&lt; I, S, D, V &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structInsertAndSetValue_3_01ImageContainerBySTLMap_3_01D_00_01V_01_4_00_01DigitalSetFromMap_3_01aa23adb4bbc0c557a0679dcdc9f54a0a.html">InsertAndSetValue&lt; ImageContainerBySTLMap&lt; D, V &gt;, DigitalSetFromMap&lt; ImageContainerBySTLMap&lt; D, V &gt; &gt;, D, V &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1IntegerComputer.html">DGtal::IntegerComputer&lt; TInteger &gt;</a></td><td class="indexvalue">Aim: This class gathers several types and methods to make computation with integers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1IntervalForegroundPredicate.html">DGtal::IntervalForegroundPredicate&lt; Image &gt;</a></td><td class="indexvalue">Aim: Define a simple Foreground predicate thresholding image values between two constant values </td></tr>
  <tr><td class="indexkey"><a class="el" href="classIntervalThresholder.html">IntervalThresholder&lt; T &gt;</a></td><td class="indexvalue">Aim: A small functor with an operator () that compares one value to an interval </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1IOException.html">DGtal::IOException</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1IsLowerPointPredicate.html">DGtal::IsLowerPointPredicate&lt; TPoint &gt;</a></td><td class="indexvalue">Aim: The predicate returns true when the point is below (or equal) the given upper bound </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1IsUpperPointPredicate.html">DGtal::IsUpperPointPredicate&lt; TPoint &gt;</a></td><td class="indexvalue">Aim: The predicate returns true when the point is above (or equal) the given lower bound </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1IsWithinPointPredicate.html">DGtal::IsWithinPointPredicate&lt; TPoint &gt;</a></td><td class="indexvalue">Aim: The predicate returns true when the point is within the given bounds </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ImageContainerByHashTree_1_1Iterator.html">DGtal::ImageContainerByHashTree&lt; TDomain, TValue, THashKey &gt;::Iterator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1IteratorAdapter.html">DGtal::IteratorAdapter&lt; TIterator, TFunctor, TReturnType &gt;</a></td><td class="indexvalue">This class adapts any iterator (at least forward) so that operator* returns a member on the element pointed to by the iterator, instead the element itself </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits.html">DGtal::IteratorCirculatorTagTraits&lt; C &gt;</a></td><td class="indexvalue">Aim: Provides the category of the iterator (resp. circulator) {<a class="el" href="structDGtal_1_1ForwardCategory.html">ForwardCategory</a>,<a class="el" href="structDGtal_1_1BidirectionalCategory.html">BidirectionalCategory</a>,<a class="el" href="structDGtal_1_1RandomAccessCategory.html">RandomAccessCategory</a>} and the type {<a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>,<a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>} </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01bidirectional__circulator__tag_01_4.html">DGtal::IteratorCirculatorTagTraits&lt; bidirectional_circulator_tag &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01forward__circulator__tag_01_4.html">DGtal::IteratorCirculatorTagTraits&lt; forward_circulator_tag &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01random__access__circulator__tag_01_4.html">DGtal::IteratorCirculatorTagTraits&lt; random_access_circulator_tag &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01std_1_1bidirectional__iterator__tag_01_4.html">DGtal::IteratorCirculatorTagTraits&lt; std::bidirectional_iterator_tag &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01std_1_1forward__iterator__tag_01_4.html">DGtal::IteratorCirculatorTagTraits&lt; std::forward_iterator_tag &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01std_1_1random__access__iterator__tag_01_4.html">DGtal::IteratorCirculatorTagTraits&lt; std::random_access_iterator_tag &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1IteratorCirculatorTraits.html">DGtal::IteratorCirculatorTraits&lt; IC &gt;</a></td><td class="indexvalue">Aim: Provides definition types for both iterators and circulators: Type, Category, Value, Difference, Pointer and Reference </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1IteratorCirculatorTraits_3_01T_01_5_01_4.html">DGtal::IteratorCirculatorTraits&lt; T * &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1IteratorType.html">DGtal::IteratorType</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1IVector.html">DGtal::IVector&lt; T, TAlloc, usePointers &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1IVector_3_01T_00_01TAlloc_00_01true_01_4.html">DGtal::IVector&lt; T, TAlloc, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1IVViewer.html">DGtal::IVViewer</a></td><td class="indexvalue">Aim: A facade to represent an inventor window for 3D objects. May be a SoXt or a SoQt examiner viewer. NB: backported from ImaGeneUtils library </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1KhalimskyCell.html">DGtal::KhalimskyCell&lt; dim, TInteger &gt;</a></td><td class="indexvalue">Represents an (unsigned) cell in a cellular grid space by its Khalimsky coordinates </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1KhalimskySpaceND.html">DGtal::KhalimskySpaceND&lt; dim, TInteger &gt;</a></td><td class="indexvalue">Aim: This class is a model of <a class="el" href="structDGtal_1_1CCellularGridSpaceND.html" title="Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian produc...">CCellularGridSpaceND</a>. It represents the cubical grid as a cell complex, whose cells are defined as an array of integers. The topology of the cells is defined by the parity of the coordinates (even: closed, odd: open) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1L1LengthEstimator.html">DGtal::L1LengthEstimator&lt; TConstIterator &gt;</a></td><td class="indexvalue">Aim: a simple model of CGlobalCurveEstimator that compute the length of a curve using the l_1 metric (just add 1/h for every step) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1L1LocalDistance.html">DGtal::L1LocalDistance&lt; TImage, TSet &gt;</a></td><td class="indexvalue">Aim: Class for the computation of the L1-distance at some point p, from the available distance values of some points lying in the 1-neighborhood of p (ie. points at a L1-distance to p equal to 1) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1L2FirstOrderLocalDistance.html">DGtal::L2FirstOrderLocalDistance&lt; TImage, TSet &gt;</a></td><td class="indexvalue">Aim: Class for the computation of the Euclidean distance at some point p, from the available distance values of some points lying in the 1-neighborhood of p (ie. points at a L1-distance to p equal to 1) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1L2FirstOrderLocalDistanceFromCells.html">DGtal::L2FirstOrderLocalDistanceFromCells&lt; TKSpace, TMap, isIndirect &gt;</a></td><td class="indexvalue">Aim: Class for the computation of the Euclidean distance at some point p, from the available distance values in the neighborhood of p. Contrary to <a class="el" href="classDGtal_1_1L2FirstOrderLocalDistance.html" title="Aim: Class for the computation of the Euclidean distance at some point p, from the available distance...">L2FirstOrderLocalDistance</a>, the distance values are not available from the points adjacent to p but instead from the (d-1)-cells lying between p and these points </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1L2SecondOrderLocalDistance.html">DGtal::L2SecondOrderLocalDistance&lt; TImage, TSet &gt;</a></td><td class="indexvalue">Aim: Class for the computation of the Euclidean distance at some point p, from the available distance values of some points lying in the neighborhood of p, such that only one of their coordinate differ from the coordinates of p by at most two </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Lattice.html">DGtal::Lattice&lt; TSpace &gt;</a></td><td class="indexvalue">Aim: Represents an n-dimensional integer lattice in an m-dimensional real vector space </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1LighterSternBrocot.html">DGtal::LighterSternBrocot&lt; TInteger, TQuotient, TMap &gt;</a></td><td class="indexvalue">Aim: The Stern-Brocot tree is the tree of irreducible fractions. This class allows to construct it progressively and to navigate within fractions in O(1) time for most operations. It is well known that the structure of this tree is a coding of the continued fraction representation of fractions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html">DGtal::LightExplicitDigitalSurface&lt; TKSpace, TSurfelPredicate &gt;</a></td><td class="indexvalue">Aim: A model of <a class="el" href="structDGtal_1_1CDigitalSurfaceContainer.html" title="Aim:">CDigitalSurfaceContainer</a> which defines the digital surface as connected surfels. The shape is determined by a predicate telling whether a given surfel belongs or not to the shape boundary. The whole boundary is not precomputed nor stored. You may use an iterator to visit it </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html">DGtal::LightImplicitDigitalSurface&lt; TKSpace, TPointPredicate &gt;</a></td><td class="indexvalue">Aim: A model of <a class="el" href="structDGtal_1_1CDigitalSurfaceContainer.html" title="Aim:">CDigitalSurfaceContainer</a> which defines the digital surface as the boundary of an implicitly define shape. The whole boundary is not precomputed nor stored. You may use an iterator to visit it </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1LightSternBrocot.html">DGtal::LightSternBrocot&lt; TInteger, TQuotient, TMap &gt;</a></td><td class="indexvalue">Aim: The Stern-Brocot tree is the tree of irreducible fractions. This class allows to construct it progressively and to navigate within fractions in O(1) time for most operations. It is well known that the structure of this tree is a coding of the continued fraction representation of fractions </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1LinearAlgebra.html">DGtal::LinearAlgebra&lt; Space &gt;</a></td><td class="indexvalue">Aim: A utility class that contains methods to perform integral linear algebra </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1Display3D_1_1lineD3D.html">DGtal::Display3D::lineD3D</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1LInfLocalDistance.html">DGtal::LInfLocalDistance&lt; TImage, TSet &gt;</a></td><td class="indexvalue">Aim: Class for the computation of the LInf-distance at some point p, from the available distance values of some points lying in the 1-neighborhood of p (ie. points at a L1-distance to p equal to 1) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1LocalConvolutionNormalVectorEstimator.html">DGtal::LocalConvolutionNormalVectorEstimator&lt; TDigitalSurface, TKernelFunctor &gt;</a></td><td class="indexvalue">Aim: Computes the normal vector at a surface element by convolution of elementary normal vector to adjacent surfel </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1LOG2.html">DGtal::LOG2&lt; X &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1LOG2_3_011_01_4.html">DGtal::LOG2&lt; 1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1LOG2_3_012_01_4.html">DGtal::LOG2&lt; 2 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1LongvolReader.html">DGtal::LongvolReader&lt; TImageContainer &gt;</a></td><td class="indexvalue">Aim: implements methods to read a "Longvol" file format (with <a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5" title="unsigned 64-bit integer.">DGtal::uint64_t</a> value type) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1LongvolWriter.html">DGtal::LongvolWriter&lt; TImage, TColormap &gt;</a></td><td class="indexvalue">Aim: Export a 3D <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> using the Longvol formats (volumetric image with <a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5" title="unsigned 64-bit integer.">DGtal::uint64_t</a> value type) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1MagickReader.html">DGtal::MagickReader&lt; TImageContainer &gt;</a></td><td class="indexvalue">Aim: implements methods to read a 2D image using the ImageMagick library </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1MaxFunctor.html">DGtal::MaxFunctor&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1deprecated_1_1MaximalSegments.html">DGtal::deprecated::MaximalSegments&lt; TSegment &gt;</a></td><td class="indexvalue">Aim: Computes the set of maximal segments of a sequence. Maximal segments are segments that cannot be included in other segments. This class is a model of CDecomposition </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Measure.html">DGtal::Measure&lt; TSet &gt;</a></td><td class="indexvalue">Aim: Implements a simple measure computation (in the Lesbegue sens) of a set. In dimension 2, it corresponds to the area of the set, to the volume in dimension 3,.. </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1MeasureOfStraightLines.html">DGtal::MeasureOfStraightLines</a></td><td class="indexvalue">The aim of this class is to compute the measure in the Lebesgues sense of the set of straight lines associated to domains defined as polygons in the (a,b)-parameter space. This parameter space maps the line $ax-y+b=0$ to the point $(a,b)$ </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1MemoryException.html">DGtal::MemoryException</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1MetricAdjacency.html">DGtal::MetricAdjacency&lt; TSpace, maxNorm1, dimension &gt;</a></td><td class="indexvalue">Aim: Describes digital adjacencies in digital spaces that are defined with the 1-norm and the infinity-norm </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1MetricAdjacency_3_01TSpace_00_011_00_012_01_4.html">DGtal::MetricAdjacency&lt; TSpace, 1, 2 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1MetricAdjacency_3_01TSpace_00_012_00_012_01_4.html">DGtal::MetricAdjacency&lt; TSpace, 2, 2 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classMidPointsRange.html">MidPointsRange</a></td><td class="indexvalue">Aim: model of CConstRange that provides services to (circularly)iterate over the signed 1-cells of a grid curve, viewed as points of half-integer coordinates </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1MinFunctor.html">DGtal::MinFunctor&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1MinusFunctor.html">DGtal::MinusFunctor&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1MLPLengthEstimator.html">DGtal::MLPLengthEstimator&lt; TConstIterator &gt;</a></td><td class="indexvalue">Aim: a model of CGlobalCurveEstimator that computes the length of a digital curve using its MLP (given by the <a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ModuloComputer.html">DGtal::ModuloComputer&lt; TInteger &gt;</a></td><td class="indexvalue">Implements basic functions on modular arithmetic </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Morton.html">DGtal::Morton&lt; THashKey, TPoint &gt;</a></td><td class="indexvalue">Aim: Implements the binary <a class="el" href="classDGtal_1_1Morton.html" title="Aim: Implements the binary Morton code construction in nD.">Morton</a> code construction in nD </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1MostCenteredMaximalSegmentEstimator.html">DGtal::MostCenteredMaximalSegmentEstimator&lt; SegmentComputer, Functor &gt;</a></td><td class="indexvalue">Aim:Computes a quantity to each element of a range associated to the most centered maximal segment </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1MPolynomial.html">DGtal::MPolynomial&lt; n, TRing, TAlloc &gt;</a></td><td class="indexvalue">Aim: Represents a multivariate polynomial, i.e. an element of <img class="formulaInl" alt="$ K[X_0, ..., X_{n-1}] $" src="form_70.png"/>, where <em>K</em> is some ring or field </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1MPolynomial_3_010_00_01TRing_00_01TAlloc_01_4.html">DGtal::MPolynomial&lt; 0, TRing, TAlloc &gt;</a></td><td class="indexvalue">Aim: Specialization of <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a> for degree 0 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1MPolynomialDerivativeComputer.html">DGtal::MPolynomialDerivativeComputer&lt; N, n, Ring, Alloc &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1MPolynomialDerivativeComputer_3_010_00_010_00_01Ring_00_01Alloc_01_4.html">DGtal::MPolynomialDerivativeComputer&lt; 0, 0, Ring, Alloc &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1MPolynomialDerivativeComputer_3_010_00_01n_00_01Ring_00_01Alloc_01_4.html">DGtal::MPolynomialDerivativeComputer&lt; 0, n, Ring, Alloc &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1MPolynomialDerivativeComputer_3_01N_00_010_00_01Ring_00_01Alloc_01_4.html">DGtal::MPolynomialDerivativeComputer&lt; N, 0, Ring, Alloc &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1MPolynomialEvaluator.html">DGtal::MPolynomialEvaluator&lt; n, TRing, TAlloc, TX &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1MPolynomialEvaluator_3_011_00_01TRing_00_01TAlloc_00_01TX_01_4.html">DGtal::MPolynomialEvaluator&lt; 1, TRing, TAlloc, TX &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1MPolynomialEvaluatorImpl.html">DGtal::MPolynomialEvaluatorImpl&lt; n, TRing, TOwner, TAlloc, TX &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1MPolynomialEvaluatorImpl_3_011_00_01TRing_00_01TOwner_00_01TAlloc_00_01TX_01_4.html">DGtal::MPolynomialEvaluatorImpl&lt; 1, TRing, TOwner, TAlloc, TX &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structMyDomainStyleCustomRed.html">MyDomainStyleCustomRed</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structMyDrawStyleCustomBlue.html">MyDrawStyleCustomBlue</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structMyDrawStyleCustomColor.html">MyDrawStyleCustomColor</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structMyDrawStyleCustomFillColor.html">MyDrawStyleCustomFillColor</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structMyDrawStyleCustomGreen.html">MyDrawStyleCustomGreen</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structMyDrawStyleCustomRed.html">MyDrawStyleCustomRed</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structMyObjectStyleCustom.html">MyObjectStyleCustom</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structMyObjectStyleCustomRed.html">MyObjectStyleCustomRed</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classmyreverse__iterator.html">myreverse_iterator&lt; _Iterator &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structMyStyleCustom.html">MyStyleCustom</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structMyStyleCustomRed.html">MyStyleCustomRed</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1Negate.html">DGtal::Negate&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1Negate_3_01TagFalse_01_4.html">DGtal::Negate&lt; TagFalse &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1Negate_3_01TagTrue_01_4.html">DGtal::Negate&lt; TagTrue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1NGon2D.html">DGtal::NGon2D&lt; TSpace &gt;</a></td><td class="indexvalue">Aim: Model of the concept StarShaped represents any regular k-gon in the plane </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1LighterSternBrocot_1_1Node.html">DGtal::LighterSternBrocot&lt; TInteger, TQuotient, TMap &gt;::Node</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1LightSternBrocot_1_1Node.html">DGtal::LightSternBrocot&lt; TInteger, TQuotient, TMap &gt;::Node</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1SternBrocot_1_1Node.html">DGtal::SternBrocot&lt; TInteger, TQuotient &gt;::Node</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ImageContainerByHashTree_1_1Node.html">DGtal::ImageContainerByHashTree&lt; TDomain, TValue, THashKey &gt;::Node</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1BreadthFirstVisitor_1_1NodeAccessor.html">DGtal::BreadthFirstVisitor&lt; TGraph, TMarkSet &gt;::NodeAccessor</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structNorm1.html">Norm1&lt; P &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1NormalVectorEstimatorLinearCellEmbedder.html">DGtal::NormalVectorEstimatorLinearCellEmbedder&lt; TDigitalSurface, TNormalVectorEstimator, TEmbedder &gt;</a></td><td class="indexvalue">Aim: model of cellular embedder for normal vector estimators on digital surface, (default constructible, copy constructible, assignable) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1NotBoolFct1.html">DGtal::NotBoolFct1</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1NotPointPredicate.html">DGtal::NotPointPredicate&lt; TPointPredicate &gt;</a></td><td class="indexvalue">Aim: The predicate returns true when the point predicate given at construction return false. Thus inverse a predicate: NOT operator </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1NumberTraits.html">DGtal::NumberTraits&lt; T &gt;</a></td><td class="indexvalue">Aim: The traits class for all models of Cinteger </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1NumberTraits_3_01double_01_4.html">DGtal::NumberTraits&lt; double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1NumberTraits_3_01float_01_4.html">DGtal::NumberTraits&lt; float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1NumberTraits_3_01int16__t_01_4.html">DGtal::NumberTraits&lt; int16_t &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1NumberTraits_3_01int32__t_01_4.html">DGtal::NumberTraits&lt; int32_t &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1NumberTraits_3_01int64__t_01_4.html">DGtal::NumberTraits&lt; int64_t &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1NumberTraits_3_01int8__t_01_4.html">DGtal::NumberTraits&lt; int8_t &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1NumberTraits_3_01long_01double_01_4.html">DGtal::NumberTraits&lt; long double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1NumberTraits_3_01uint16__t_01_4.html">DGtal::NumberTraits&lt; uint16_t &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1NumberTraits_3_01uint32__t_01_4.html">DGtal::NumberTraits&lt; uint32_t &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1NumberTraits_3_01uint64__t_01_4.html">DGtal::NumberTraits&lt; uint64_t &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1NumberTraits_3_01uint8__t_01_4.html">DGtal::NumberTraits&lt; uint8_t &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Object.html">DGtal::Object&lt; TDigitalTopology, TDigitalSet &gt;</a></td><td class="indexvalue">Aim: An object (or digital object) represents a set in some digital space associated with a digital topology </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1OpInSTLContainers.html">DGtal::OpInSTLContainers&lt; Container, Iterator &gt;</a></td><td class="indexvalue">Aim: Implementation of an adapter for erase and insert methods of STL containers so that they not only work for the iterator type, but also for the reverse_iterator type </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1OpInSTLContainers_3_01Container_00_01std_1_1reverse__iterator_3_01typename_01Container_1_1iterator_01_4_01_4.html">DGtal::OpInSTLContainers&lt; Container, std::reverse_iterator&lt; typename Container::iterator &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1OrBoolFct2.html">DGtal::OrBoolFct2</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1OrderedAlphabet.html">DGtal::OrderedAlphabet</a></td><td class="indexvalue">Aim: Describes an alphabet over an interval of (ascii) letters, where the lexicographic order can be changed (shifted, reversed, ...). Useful for the arithmetic minimum length polygon (AMLP) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOuterPointsRange.html">OuterPointsRange</a></td><td class="indexvalue">Aim: model of CConstRange that provides services to (circularly)iterate over the 2-cells (viewed as points of integer coordinates) that are indirectly incident to the signed 1-cells of a 2d grid curve </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1OutputIteratorAdapter.html">DGtal::OutputIteratorAdapter&lt; TIterator, TFunctor, TInputValue &gt;</a></td><td class="indexvalue">Aim: Adapts an output iterator i with a unary functor f, both given at construction, so that the element pointed to by i is updated with a given value through f </td></tr>
  <tr><td class="indexkey"><a class="el" href="classPair1st.html">Pair1st&lt; ReturnType &gt;</a></td><td class="indexvalue">Aim: Define a simple functor that returns the first member of a pair </td></tr>
  <tr><td class="indexkey"><a class="el" href="classPair1stMutator.html">Pair1stMutator&lt; ReturnType &gt;</a></td><td class="indexvalue">Aim: Define a simple unary functor that returns a reference on the first member of a pair in order to update it </td></tr>
  <tr><td class="indexkey"><a class="el" href="classPair2nd.html">Pair2nd&lt; ReturnType &gt;</a></td><td class="indexvalue">Aim: Define a simple functor that returns the second member of a pair </td></tr>
  <tr><td class="indexkey"><a class="el" href="classPair2ndMutator.html">Pair2ndMutator&lt; ReturnType &gt;</a></td><td class="indexvalue">Aim: Define a simple unary functor that returns a reference on the first member of a pair in order to update it </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ParametricShapeArcLengthFunctor.html">DGtal::ParametricShapeArcLengthFunctor&lt; TParametricShape &gt;</a></td><td class="indexvalue">Aim: implements a functor that estimates the arc length of a paramtric curve </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ParametricShapeCurvatureFunctor.html">DGtal::ParametricShapeCurvatureFunctor&lt; TParametricShape &gt;</a></td><td class="indexvalue">Aim: implements a functor that computes the curvature at a given point of a parametric shape </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ParametricShapeTangentFunctor.html">DGtal::ParametricShapeTangentFunctor&lt; TParametricShape &gt;</a></td><td class="indexvalue">Aim: implements a functor that computes the tangent vector at a given point of a parametric shape </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Pattern.html">DGtal::Pattern&lt; TFraction &gt;</a></td><td class="indexvalue">Aim: This class represents a pattern, i.e. the path between two consecutive upper leaning points on a digital straight line </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1PNMReader.html">DGtal::PNMReader&lt; TImageContainer &gt;</a></td><td class="indexvalue">Aim: Import a 2D or 3D using the Netpbm formats (ASCII mode) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1PNMWriter.html">DGtal::PNMWriter&lt; TImage, TColormap &gt;</a></td><td class="indexvalue">Aim: Export a 2D and a 3D <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> using the Netpbm formats (ASCII mode) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Point2ShapePredicate.html">DGtal::Point2ShapePredicate&lt; TSurface, isUpward, isClosed &gt;</a></td><td class="indexvalue">Aim: Predicate returning 'true' iff a given point is in the 'interior' of a given shape, 'false' otherwise </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1Point2ShapePredicateComparator.html">DGtal::Point2ShapePredicateComparator&lt; T, b1, b2 &gt;</a></td><td class="indexvalue">Aim: A small struct with an operator that compares two values according to two bool template parameters </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01false_00_01false_01_4.html">DGtal::Point2ShapePredicateComparator&lt; T, false, false &gt;</a></td><td class="indexvalue">Aim: A small struct with an operator that compares two values (&lt;) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01false_00_01true_01_4.html">DGtal::Point2ShapePredicateComparator&lt; T, false, true &gt;</a></td><td class="indexvalue">Aim: A small struct with an operator that compares two values (&lt;=) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01true_00_01false_01_4.html">DGtal::Point2ShapePredicateComparator&lt; T, true, false &gt;</a></td><td class="indexvalue">Aim: A small struct with an operator that compares two values (&gt;) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01true_00_01true_01_4.html">DGtal::Point2ShapePredicateComparator&lt; T, true, true &gt;</a></td><td class="indexvalue">Aim: A small struct with an operator that compares two values (&gt;=) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1deprecated_1_1Point3dTo2dXY.html">DGtal::deprecated::Point3dTo2dXY&lt; Coordinate &gt;</a></td><td class="indexvalue">Aim: transforms a 3d point into a 2d point due to a projection on the xy-plane </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1deprecated_1_1Point3dTo2dXZ.html">DGtal::deprecated::Point3dTo2dXZ&lt; Coordinate &gt;</a></td><td class="indexvalue">Aim: transforms a 3d point into a 2d point due to a projection on the xz-plane </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1deprecated_1_1Point3dTo2dYZ.html">DGtal::deprecated::Point3dTo2dYZ&lt; Coordinate &gt;</a></td><td class="indexvalue">Aim: transforms a 3d point into a 2d point due to a projection on the yz-plane </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1Display3D_1_1pointD3D.html">DGtal::Display3D::pointD3D</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1PointFunctorPredicate.html">DGtal::PointFunctorPredicate&lt; TPointFunctor, TPredicate &gt;</a></td><td class="indexvalue">Aim: The predicate returns true when the predicate returns true for the value assigned to a given point in the point functor </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1PointListReader.html">DGtal::PointListReader&lt; TPoint &gt;</a></td><td class="indexvalue">Aim: Implements method to read a set of points represented in each line of a file </td></tr>
  <tr><td class="indexkey"><a class="el" href="classPointsRange.html">PointsRange</a></td><td class="indexvalue">Aim: model of CConstRange that provides services to (circularly)iterate over the 0-cells of a grid curve, viewed as points of integer coordinates </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1details_1_1PointValueCompare.html">DGtal::details::PointValueCompare&lt; T &gt;</a></td><td class="indexvalue">Aim: Small binary predicate to order candidates points according to their (absolute) distance value </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt; dim, TEuclideanRing &gt;</a></td><td class="indexvalue">Aim: Implements basic operations that will be used in Point and Vector classes </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1POW.html">DGtal::POW&lt; X, exponent &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1POW_3_01X_00_011_01_4.html">DGtal::POW&lt; X, 1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structPredicateCombiner.html">PredicateCombiner&lt; TPredicate1, TPredicate2, TBinaryFunctor &gt;</a></td><td class="indexvalue">Aim: The predicate returns true when the given binary functor returns true for the two Predicates given at construction </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Preimage2D.html">DGtal::Preimage2D&lt; Shape &gt;</a></td><td class="indexvalue">Aim: Computes the preimage of the 2D Euclidean shapes crossing a sequence of n straigth segments in O(n), with the algorithm of O'Rourke (1981) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1Projector.html">DGtal::Projector&lt; S &gt;</a></td><td class="indexvalue">Aim: Functor that maps a point P of dimension i to a point Q of dimension j. The member <em>myDims</em> is an array containing the coordinates - (0, 1, ..., j-1) by default - that are copied from P to Q </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1promote__trait.html">DGtal::promote_trait&lt; A, B &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1promote__trait_3_01int32__t_00_01int64__t_01_4.html">DGtal::promote_trait&lt; int32_t, int64_t &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1Display3D_1_1quadD3D.html">DGtal::Display3D::quadD3D</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1random__access__circulator__tag.html">DGtal::random_access_circulator_tag</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1RandomAccessCategory.html">DGtal::RandomAccessCategory</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1RandomColorMap.html">DGtal::RandomColorMap</a></td><td class="indexvalue">Aim: access to random color from a gradientColorMap </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1RawReader.html">DGtal::RawReader&lt; TImageContainer &gt;</a></td><td class="indexvalue">Aim: implements methods to read a "Vol" file format </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1RawWriter.html">DGtal::RawWriter&lt; TImage, TColormap &gt;</a></td><td class="indexvalue">Aim: Raw binary export of an <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1StdMapRebinder_1_1Rebinder.html">DGtal::StdMapRebinder::Rebinder&lt; Key, Value &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1RegularPointEmbedder.html">DGtal::RegularPointEmbedder&lt; TSpace &gt;</a></td><td class="indexvalue">Aim: A simple point embedder where grid steps are given for each axis. Note that the real point (0,...,0) is mapped onto the digital point (0,...,0) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ReverseDistanceTransformation.html">DGtal::ReverseDistanceTransformation&lt; Image, p, IntegerShort &gt;</a></td><td class="indexvalue">Aim: Implementation of the linear in time reverse distance transformation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1RosenProffittLocalLengthEstimator.html">DGtal::RosenProffittLocalLengthEstimator&lt; TConstIterator &gt;</a></td><td class="indexvalue">Aim: Rosen-Proffitt Length Estimator </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1ConceptUtils_1_1SameType.html">DGtal::ConceptUtils::SameType&lt; T1, T2 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1ConceptUtils_1_1SameType_3_01T_00_01T_01_4.html">DGtal::ConceptUtils::SameType&lt; T, T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1SaturatedSegmentation.html">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;</a></td><td class="indexvalue">Aim: Computes the saturated segmentation, that is the whole set of maximal segments within a range given by a pair of ConstIterators (maximal segments are segments that cannot be included in greater segments) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1KhalimskySpaceND_1_1SCellMap.html">DGtal::KhalimskySpaceND&lt; dim, TInteger &gt;::SCellMap&lt; Value &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSCellsRange.html">SCellsRange</a></td><td class="indexvalue">Aim: model of CConstRange that provides services to (circularly)iterate over the signed d-cells of a grid curve </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1SCellToArrow.html">DGtal::SCellToArrow&lt; KSpace &gt;</a></td><td class="indexvalue">Aim: transforms a signed cell into an arrow, ie. a pair point-vector </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1deprecated_1_1SCellToArrow.html">DGtal::deprecated::SCellToArrow&lt; KSpace &gt;</a></td><td class="indexvalue">Aim: transforms a signed cell into an arrow, ie. a pair point-vector </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1SCellToCode.html">DGtal::SCellToCode&lt; KSpace &gt;</a></td><td class="indexvalue">Aim: transforms a 2d signed cell, basically a linel, into a code (0,1,2 or 3), </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1deprecated_1_1SCellToCode.html">DGtal::deprecated::SCellToCode&lt; KSpace &gt;</a></td><td class="indexvalue">Aim: transforms a 2d scell, basically a linel, into a code (0,1,2 or 3), </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1SCellToIncidentPoints.html">DGtal::SCellToIncidentPoints&lt; KSpace &gt;</a></td><td class="indexvalue">Aim: transforms a signed cell c into a pair of points corresponding to the signed cells of greater dimension that are indirectly and directly incident to c </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1deprecated_1_1SCellToIncidentPoints.html">DGtal::deprecated::SCellToIncidentPoints&lt; KSpace &gt;</a></td><td class="indexvalue">Aim: transforms a linel into a pair of points, which are the centers of the two incident pixels </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1SCellToInnerPoint.html">DGtal::SCellToInnerPoint&lt; KSpace &gt;</a></td><td class="indexvalue">Aim: transforms a signed cell c into a point corresponding to the signed cell of greater dimension that is indirectly incident to c </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1deprecated_1_1SCellToInnerPoint.html">DGtal::deprecated::SCellToInnerPoint&lt; KSpace &gt;</a></td><td class="indexvalue">Aim: transforms a signed cell into a point, basically a linel into the indirect incident pixel center </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1SCellToMidPoint.html">DGtal::SCellToMidPoint&lt; KSpace &gt;</a></td><td class="indexvalue">Aim: transforms a scell into a real point (the coordinates are divided by 2) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1deprecated_1_1SCellToMidPoint.html">DGtal::deprecated::SCellToMidPoint&lt; KSpace &gt;</a></td><td class="indexvalue">Aim: transforms a scell into a real point (the coordinates are divided by 2) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1SCellToOuterPoint.html">DGtal::SCellToOuterPoint&lt; KSpace &gt;</a></td><td class="indexvalue">Aim: transforms a signed cell c into a point corresponding to the signed cell of greater dimension that is directly incident to c </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1deprecated_1_1SCellToOuterPoint.html">DGtal::deprecated::SCellToOuterPoint&lt; KSpace &gt;</a></td><td class="indexvalue">Aim: transforms a sigend cell into a point, basically a linel into the direct incident pixel center </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1SCellToPoint.html">DGtal::SCellToPoint&lt; KSpace &gt;</a></td><td class="indexvalue">Aim: transforms a scell into a point </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1deprecated_1_1SCellToPoint.html">DGtal::deprecated::SCellToPoint&lt; KSpace &gt;</a></td><td class="indexvalue">Aim: transforms a scell into a point </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1GreedySegmentation_1_1SegmentComputerIterator.html">DGtal::GreedySegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator</a></td><td class="indexvalue">Aim: Specific iterator to visit all the segments of a greedy segmentation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1SaturatedSegmentation_1_1SegmentComputerIterator.html">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator</a></td><td class="indexvalue">Aim: Specific iterator to visit all the maximal segments of a saturated segmentation </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1SegmentComputerTraits.html">DGtal::SegmentComputerTraits&lt; SC &gt;</a></td><td class="indexvalue">Aim: Provides the category of the segment computer {<a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">ForwardSegmentComputer</a>,<a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a>, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DynamicSegmentComputer</a>, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DynamicBidirectionalSegmentComputer</a>} </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1deprecated_1_1GreedyDecomposition_1_1SegmentIterator.html">DGtal::deprecated::GreedyDecomposition&lt; TSegment &gt;::SegmentIterator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1deprecated_1_1MaximalSegments_1_1SegmentIterator.html">DGtal::deprecated::MaximalSegments&lt; TSegment &gt;::SegmentIterator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1SeparableMetricHelper.html">DGtal::SeparableMetricHelper&lt; TAbscissa, TInternalValue, tp &gt;</a></td><td class="indexvalue">Aim: Implements basic functions associated to metrics used by separable volumetric algorithms </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1SeparableMetricHelper_3_01TAbscissa_00_01TInternalValue_00_010_01_4.html">DGtal::SeparableMetricHelper&lt; TAbscissa, TInternalValue, 0 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1SeparableMetricHelper_3_01TAbscissa_00_01TInternalValue_00_011_01_4.html">DGtal::SeparableMetricHelper&lt; TAbscissa, TInternalValue, 1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1SeparableMetricHelper_3_01TAbscissa_00_01TInternalValue_00_012_01_4.html">DGtal::SeparableMetricHelper&lt; TAbscissa, TInternalValue, 2 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1SetFromImage.html">DGtal::SetFromImage&lt; TSet &gt;</a></td><td class="indexvalue">Aim: Define utilities to convert a digital set into an image </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1SetMode.html">DGtal::SetMode</a></td><td class="indexvalue">Modifier class in a <a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (with &lt;&lt;)...">Board2D</a> stream. Useful to choose your own mode for a given class. Realizes the concept <a class="el" href="structDGtal_1_1CDrawableWithBoard2D.html">CDrawableWithBoard2D</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1SetMode3D.html">DGtal::SetMode3D</a></td><td class="indexvalue">Modifier class in a <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like PointVector...">Display3D</a> stream. Useful to choose your own mode for a given class. Realizes the concept <a class="el" href="structDGtal_1_1CDrawableWithDisplay3D.html">CDrawableWithDisplay3D</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1SetOfSurfels.html">DGtal::SetOfSurfels&lt; TKSpace, TSurfelSet &gt;</a></td><td class="indexvalue">Aim: A model of <a class="el" href="structDGtal_1_1CDigitalSurfaceContainer.html" title="Aim:">CDigitalSurfaceContainer</a> which defines the digital surface as connected surfels. The shape is determined by the set of surfels that composed the surface. The set of surfels is stored in this container </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1SetPredicate.html">DGtal::SetPredicate&lt; TDigitalSet &gt;</a></td><td class="indexvalue">Aim: The predicate returning true iff the point is in the domain given at construction </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1SetValueIterator.html">DGtal::SetValueIterator&lt; TImage, TIteratorOnPts &gt;</a></td><td class="indexvalue">Aim: implements an output iterator, which is able to write values in an underlying image, by calling its setValue method </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Shapes.html">DGtal::Shapes&lt; TDomain &gt;</a></td><td class="indexvalue">Aim: A utility class for constructing different shapes (balls, diamonds, and others) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Signal.html">DGtal::Signal&lt; TValue &gt;</a></td><td class="indexvalue">Aim: Represents a discrete signal, periodic or not. The signal can be passed by value since it is only cloned when modified </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1SignalData.html">DGtal::SignalData&lt; TValue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1SignedKhalimskyCell.html">DGtal::SignedKhalimskyCell&lt; dim, TInteger &gt;</a></td><td class="indexvalue">Represents a signed cell in a cellular grid space by its Khalimsky coordinates and a boolean value </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1SimpleConstRange.html">DGtal::SimpleConstRange&lt; TConstIterator &gt;</a></td><td class="indexvalue">Aim: model of CConstRange that adapts any range of elements bounded by two iterators [itb, ite) and provides services to (circularly)iterate over it (in a read-only manner) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1SimpleRandomAccessConstRangeFromPoint.html">DGtal::SimpleRandomAccessConstRangeFromPoint&lt; TConstIterator, DistanceFunctor &gt;</a></td><td class="indexvalue">Aim: model of <a class="el" href="structDGtal_1_1CConstBidirectionalRangeFromPoint.html" title="Aim: refined concept of const bidirectional range with a begin() method from a point.">CConstBidirectionalRangeFromPoint</a> that adapts any range of elements bounded by two iterators [itb, ite) and provides services to (circularly)iterate over it (in a read-only manner) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1SimpleRandomAccessRangeFromPoint.html">DGtal::SimpleRandomAccessRangeFromPoint&lt; TConstIterator, TIterator, DistanceFunctor &gt;</a></td><td class="indexvalue">Aim: model of <a class="el" href="structDGtal_1_1CBidirectionalRangeFromPoint.html" title="Aim: refined concept of single pass range with a begin() method from a point.">CBidirectionalRangeFromPoint</a> that adapts any range of elements bounded by two iterators [itb, ite) and provides services to (circularly)iterate over it (in a read-only manner) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1SimpleThresholdForegroundPredicate.html">DGtal::SimpleThresholdForegroundPredicate&lt; Image &gt;</a></td><td class="indexvalue">Aim: Define a simple Foreground predicate thresholding image values given a single thresold. More precisely, the functor operator() returns true if the value is greater than a given threshold </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1SpaceND.html">DGtal::SpaceND&lt; dim, TInteger &gt;</a></td><td class="indexvalue">Aim: <a class="el" href="classDGtal_1_1SpaceND.html" title="Aim: SpaceND is a utility class that defines the fundamental structure of a Digital Space in ND...">SpaceND</a> is a utility class that defines the fundamental structure of a Digital Space in ND </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ImageContainerBySTLVector_1_1SpanIterator.html">DGtal::ImageContainerBySTLVector&lt; TDomain, TValue &gt;::SpanIterator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1SpeedExtrapolator.html">DGtal::SpeedExtrapolator&lt; TDistanceImage, TSet, TSpeedFunctor &gt;</a></td><td class="indexvalue">Aim: Class for the computation of the a speed value at some point p, from the available distance values and speed values of some points lying in the 1-neighborhood of p (ie. points at a L1-distance to p equal to 1) in order to extrapolate a speed field in the normal direction to the interface </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1StandardDSLQ0.html">DGtal::StandardDSLQ0&lt; TFraction &gt;</a></td><td class="indexvalue">Aim: Represents a digital straight line with slope in the first quadrant (Q0: x &gt;= 0, y &gt;= 0 ) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1StarShaped2D.html">DGtal::StarShaped2D&lt; TSpace &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1UmbrellaComputer_1_1State.html">DGtal::UmbrellaComputer&lt; TDigitalSurfaceTracker &gt;::State</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Statistic.html">DGtal::Statistic&lt; RealNumberType &gt;</a></td><td class="indexvalue">Aim: This class processes a set of sample values for one variable and can then compute different statistics, like sample mean, sample variance, sample unbiased variance, etc. It is minimalistic for space efficiency. For multiple variables, sample storage and others, see Statistics class </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1StdMapRebinder.html">DGtal::StdMapRebinder</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1SternBrocot.html">DGtal::SternBrocot&lt; TInteger, TQuotient &gt;</a></td><td class="indexvalue">Aim: The Stern-Brocot tree is the tree of irreducible fractions. This class allows to construct it progressively and to navigate within fractions in O(1) time for most operations. It is well known that the structure of this tree is a coding of the continued fraction representation of fractions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1StraightLineFrom2Points.html">DGtal::StraightLineFrom2Points&lt; TPoint &gt;</a></td><td class="indexvalue">Aim: Represents a straight line uniquely defined by two 2D points and that is able to return for any given 2D point its signed distance to itself </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1SpaceND_1_1Subcospace.html">DGtal::SpaceND&lt; dim, TInteger &gt;::Subcospace&lt; codimension &gt;</a></td><td class="indexvalue">Define the type of a sub co-Space </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1SpaceND_1_1Subspace.html">DGtal::SpaceND&lt; dim, TInteger &gt;::Subspace&lt; subdimension &gt;</a></td><td class="indexvalue">Define the type of a subspace </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces&lt; TKSpace &gt;</a></td><td class="indexvalue">Aim: A utility class for constructing surfaces (i.e. set of (n-1)-cells) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1SurfelAdjacency.html">DGtal::SurfelAdjacency&lt; dim &gt;</a></td><td class="indexvalue">Aim: Represent adjacencies between surfel elements, telling if it follows an interior to exterior ordering or exterior to interior ordering. It allows tracking of boundaries and of surfaces </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1KhalimskySpaceND_1_1SurfelMap.html">DGtal::KhalimskySpaceND&lt; dim, TInteger &gt;::SurfelMap&lt; Value &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DigitalSurface_1_1SurfelMap.html">DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt;::SurfelMap&lt; Value &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1SurfelNeighborhood.html">DGtal::SurfelNeighborhood&lt; TKSpace &gt;</a></td><td class="indexvalue">Aim: This helper class is useful to compute the neighboring surfels of a given surfel, especially over a digital surface or over an object boundary. Two signed surfels are incident if they share a common n-2 cell. This class uses a <a class="el" href="classDGtal_1_1SurfelAdjacency.html" title="Aim: Represent adjacencies between surfel elements, telling if it follows an interior to exterior ord...">SurfelAdjacency</a> so as to determine adjacent surfels (either looking for them from interior to exterior or inversely) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1SurfelSetPredicate.html">DGtal::SurfelSetPredicate&lt; TSurfelSet, TSurfel &gt;</a></td><td class="indexvalue">Aim: The predicate returning true iff the point is in the domain given at construction </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1TagFalse.html">DGtal::TagFalse</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1TagTrue.html">DGtal::TagTrue</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1TagUnknown.html">DGtal::TagUnknown</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1TangentAngleFromDSSFunctor.html">DGtal::TangentAngleFromDSSFunctor&lt; DSSComputer &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1TangentFromBinomialConvolverFunctor.html">DGtal::TangentFromBinomialConvolverFunctor&lt; TBinomialConvolver, TRealPoint &gt;</a></td><td class="indexvalue">Aim: This class is a functor for getting the tangent vector of a binomial convolver </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1TangentFromDSSFunctor.html">DGtal::TangentFromDSSFunctor&lt; DSSComputer &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classThresholder.html">Thresholder&lt; T, isLower, isEqual &gt;</a></td><td class="indexvalue">Aim: A small functor with an operator () that compares one value to a threshold value according to two bool template parameters </td></tr>
  <tr><td class="indexkey"><a class="el" href="structThresholder_3_01T_00_01false_00_01false_01_4.html">Thresholder&lt; T, false, false &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structThresholder_3_01T_00_01false_00_01true_01_4.html">Thresholder&lt; T, false, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structThresholder_3_01T_00_01true_00_01false_01_4.html">Thresholder&lt; T, true, false &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structThresholder_3_01T_00_01true_00_01true_01_4.html">Thresholder&lt; T, true, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1ArithmeticalDSS_1_1Tools.html">DGtal::ArithmeticalDSS&lt; TIterator, TInteger, connectivity &gt;::Tools&lt; TInt, c &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1ArithmeticalDSS_1_1Tools_3_01TInt_00_014_01_4.html">DGtal::ArithmeticalDSS&lt; TIterator, TInteger, connectivity &gt;::Tools&lt; TInt, 4 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Trace.html">DGtal::Trace</a></td><td class="indexvalue">Implementation of basic methods to trace out messages with indentation levels </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1TraceWriter.html">DGtal::TraceWriter</a></td><td class="indexvalue">Virtual Class to implement trace writers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1TraceWriterFile.html">DGtal::TraceWriterFile</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1TraceWriterTerm.html">DGtal::TraceWriterTerm</a></td><td class="indexvalue">Implements trace prefix for color terminals </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1DigitalSetBoundary_1_1Tracker.html">DGtal::DigitalSetBoundary&lt; TKSpace, TDigitalSet &gt;::Tracker</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ImplicitDigitalSurface_1_1Tracker.html">DGtal::ImplicitDigitalSurface&lt; TKSpace, TPointPredicate &gt;::Tracker</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1ExplicitDigitalSurface_1_1Tracker.html">DGtal::ExplicitDigitalSurface&lt; TKSpace, TSurfelPredicate &gt;::Tracker</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1SetOfSurfels_1_1Tracker.html">DGtal::SetOfSurfels&lt; TKSpace, TSurfelSet &gt;::Tracker</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1LightExplicitDigitalSurface_1_1Tracker.html">DGtal::LightExplicitDigitalSurface&lt; TKSpace, TSurfelPredicate &gt;::Tracker</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1LightImplicitDigitalSurface_1_1Tracker.html">DGtal::LightImplicitDigitalSurface&lt; TKSpace, TPointPredicate &gt;::Tracker</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1TrueBoolFct0.html">DGtal::TrueBoolFct0</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1TrueGlobalEstimatorOnPoints.html">DGtal::TrueGlobalEstimatorOnPoints&lt; TConstIteratorOnPoints, TParametricShape, TParametricShapeFunctor &gt;</a></td><td class="indexvalue">Aim: Computes the true quantity to each element of a range associated to a parametric shape </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1TrueLocalEstimatorOnPoints.html">DGtal::TrueLocalEstimatorOnPoints&lt; TConstIteratorOnPoints, TParametricShape, TParametricShapeFunctor &gt;</a></td><td class="indexvalue">Aim: Computes the true quantity to each element of a range associated to a parametric shape </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1TruePointPredicate.html">DGtal::TruePointPredicate&lt; TPoint &gt;</a></td><td class="indexvalue">Aim: The predicate that returns always true </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1TwoStepLocalLengthEstimator.html">DGtal::TwoStepLocalLengthEstimator&lt; TConstIterator &gt;</a></td><td class="indexvalue">Aim: a simple model of CGlobalCurveEstimator that compute the length of a curve using the l_1 metric (just add 1/h for every step) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1UmbrellaComputer.html">DGtal::UmbrellaComputer&lt; TDigitalSurfaceTracker &gt;</a></td><td class="indexvalue">Aim: Useful for computing umbrellas on '<a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>'s, ie set of n-1 cells around a n-3 cell </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1AngleLinearMinimizer_1_1ValueInfo.html">DGtal::AngleLinearMinimizer::ValueInfo</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1BreadthFirstVisitor_1_1VertexAccessor.html">DGtal::BreadthFirstVisitor&lt; TGraph, TMarkSet &gt;::VertexAccessor</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1DigitalSurface_1_1VertexMap.html">DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt;::VertexMap&lt; Value &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1LightImplicitDigitalSurface_1_1VertexMap.html">DGtal::LightImplicitDigitalSurface&lt; TKSpace, TPointPredicate &gt;::VertexMap&lt; Value &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1CUndirectedSimpleLocalGraph_1_1VertexMap.html">DGtal::CUndirectedSimpleLocalGraph&lt; T &gt;::VertexMap&lt; Value &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1LightExplicitDigitalSurface_1_1VertexMap.html">DGtal::LightExplicitDigitalSurface&lt; TKSpace, TSurfelPredicate &gt;::VertexMap&lt; Value &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Viewer3D.html">DGtal::Viewer3D</a></td><td class="indexvalue">Aim: Display 3D primitive (like <a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a>, <a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim: A container class for storing sets of digital points within some given domain.">DigitalSetBySTLSet</a>, <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> ...). This class uses the libQGLViewer library (<a href="http://www.libqglviewer.com">http://www.libqglviewer.com </a>). It inherits of the class <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like PointVector...">Display3D</a> and permits to display object using a simple stream mechanism of "&lt;&lt;" </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1VolReader.html">DGtal::VolReader&lt; TImageContainer &gt;</a></td><td class="indexvalue">Aim: implements methods to read a "Vol" file format </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1VolWriter.html">DGtal::VolWriter&lt; TImage, TColormap &gt;</a></td><td class="indexvalue">Aim: Export a 3D <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> using the Vol formats </td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1Display3D_1_1voxelD3D.html">DGtal::Display3D::voxelD3D</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Warning__promote__trait__not__specialized__for__this__case.html">DGtal::Warning_promote_trait_not_specialized_for_this_case</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Xe__kComputer.html">DGtal::Xe_kComputer&lt; n, Ring, Alloc &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classDGtal_1_1Xe__kComputer_3_010_00_01Ring_00_01Alloc_01_4.html">DGtal::Xe_kComputer&lt; 0, Ring, Alloc &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structDGtal_1_1XorBoolFct2.html">DGtal::XorBoolFct2</a></td><td class="indexvalue"></td></tr>
</table>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu May 10 2012 16:10:19 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
