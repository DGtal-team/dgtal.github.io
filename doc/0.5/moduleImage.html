<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DGtal: Images</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.5.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
<div class="header">
  <div class="headertitle">
<div class="title">Images </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#dgtalImagesAbstract">Overview</a></li>
<li class="level1"><a href="#dgtalImagesDetails">Let us go into details</a><ul><li class="level2"><a href="#dgtalImagesConcepts">Concepts</a></li>
<li class="level2"><a href="#dgtalImagesMainMethods">Main methods</a></li>
<li class="level2"><a href="#dgtalImagesRanges">Ranges of values</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtalImagesModels">Main models</a><ul><li class="level2"><a href="#dgtalImagesModelsVector">ImageContainerBySTLVector</a></li>
<li class="level2"><a href="#dgtalImagesModelsMap">ImageContainerBySTLMap</a></li>
<li class="level2"><a href="#dgtalImagesModelsHashTree">ImageContainerByHashTree</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtalImagesFunctions">Useful classes and functions</a></li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation:</b></dt><dd>Tristan Roussillon </dd></dl>
<dl class="section date"><dt>Date:</dt><dd>2012/03/28</dd></dl>
<h2><a class="anchor" id="dgtalImagesAbstract"></a>
Overview</h2>
<p>The concept of <em>point</em> functor describe a mapping between the points of a digital space and a set of values. The only method of a point functor is the <code>operator()</code>, which must take a point as input parameter and must return a value.</p>
<p>The concept of <em>constant</em> image is a point functor bounded by a domain. It is thus a refinement of the concept of point functor, describing a mapping between points and values, but having in addition a domain, returned by the <code>domain</code> method, and a range of values (for each point of the domain), returned by the <code>constRange</code> method.</p>
<p>The concept of <em>image</em>, which is a refinement of the concept of constant image, provides extra services to update values. Any model of image must have a method <code>setValue</code> taking a point and a value as input parameters and updating the value associated with the given point with the given value. In addition, they must have a range, returned by the <code>range</code> method, providing output iterators.</p>
<p>Different models of images are available: <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>, <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a>, and --- coming soon --- <a class="el" href="classDGtal_1_1ImageContainerByHashTree.html" title="Model of CImageContainer implementing the association key&lt;-&gt;Value using a hash tree. This class provides a built-in iterator.">ImageContainerByHashTree</a>, ImageContainerByITKImage, a wrapper for ITK images.</p>
<h2><a class="anchor" id="dgtalImagesDetails"></a>
Let us go into details</h2>
<p>In this section, the concepts and the main services to read and write values in images are detailed.</p>
<h3><a class="anchor" id="dgtalImagesConcepts"></a>
Concepts</h3>
<p>Any model of the concept <a class="el" href="structDGtal_1_1CPointFunctor.html" title="Aim: Defines a functor on points.">CPointFunctor</a> must have two nested types:</p>
<ul>
<li>Point, which specifies the type for a point.<ul>
<li>Value, which specifies the type for a value.</li>
</ul>
</li>
</ul>
<p>Moreover, it must have the following method:</p>
<ul>
<li><code>operator()</code>, which takes a point as input parameter and returns a value, like a function.</li>
</ul>
<p>The concept <a class="el" href="structDGtal_1_1CConstImage.html">CConstImage</a> is a refinement of <a class="el" href="structDGtal_1_1CPointFunctor.html" title="Aim: Defines a functor on points.">CPointFunctor</a>. Its models must have two extra nested types:</p>
<ul>
<li>Domain, a model of <a class="el" href="structDGtal_1_1CDomain.html" title="Aim: This concept represents a digital domain, i.e. a non mutable subset of points of the given digit...">CDomain</a><ul>
<li>ConstRange, a model of CConstBidirectionnalRangeFromPoint</li>
</ul>
</li>
</ul>
<p>Obviously, there are two methods that return instances of these two types:</p>
<ul>
<li><code>domain</code>, which returns a constant reference on the image domain<ul>
<li><code>constRange</code>, which returns a range providing constant bidirectional iterators on the image values (associated to each point of the image domain)</li>
</ul>
</li>
</ul>
<p>You can see <a class="el" href="moduleSpacePointVectorDomain.html">Digital Spaces, Points, Vectors and Domains</a> for more details about spaces and domains and <a class="el" href="moduleImage.html#dgtalImagesRanges">Ranges of values</a> for more details about ranges in images.</p>
<p>The concept <a class="el" href="structDGtal_1_1CImage.html">CImage</a> is refinement of <a class="el" href="structDGtal_1_1CConstImage.html">CConstImage</a>. Images, instead of constant ones, provide services to update values. The main way of assigning values to points is the following method:</p>
<ul>
<li><code>setValue</code>, which updates a given value at a given point.</li>
</ul>
<p>Moreover, in addition to the ConstRange, images must have the following inner type:</p>
<ul>
<li>Range, a model of <a class="el" href="structDGtal_1_1CConstBidirectionalRangeFromPoint.html" title="Aim: refined concept of const bidirectional range with a begin() method from a point.">CConstBidirectionalRangeFromPoint</a>, like ConstRange, and a model of <a class="el" href="structDGtal_1_1CBidirectionalOutputRangeFromPoint.html" title="Aim: refined concept of single pass range with an routputIterator() method from a point...">CBidirectionalOutputRangeFromPoint</a>, which must provide output iterators for incrementally updating a (sub)range of values.</li>
</ul>
<p>Obviously, you can get an instance of this type using the following method:</p>
<ul>
<li><code>range</code>, which returns a range providing both constant bidirectional iterators and output iterators.</li>
</ul>
<p>Lastly, note that the Value type in the (constant) images is expected to be at least a model of <a class="el" href="structDGtal_1_1CLabel.html" title="Aim: Define the concept of DGtal labels. Models of CLabel can be default-constructible, assignable and equality comparable.">CLabel</a>, ie. to be default-constructible, assignable and equality comparable.</p>
<dl class="section note"><dt>Note:</dt><dd>In the snippets of the following subsections, the type of image used is <code><a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a></code> and its instances are <code>image</code>, <code>image1</code>, <code>image2</code>.</dd></dl>
<h3><a class="anchor" id="dgtalImagesMainMethods"></a>
Main methods</h3>
<p>All models of images have a domain returned by the method <code>domain</code>. This domain is the set of points for which the image is defined and has values. Since a domain is a range, you can straightforwardly use it in order to iterate over the points of an image.</p>
<p>iterate over the points <a class="el" href="classDGtal_1_1Image.html#ace481f886b37a80824817b5f1494df58">Image::Domain</a> d = image.domain(); for (Image::Domain::ConstIterator it = d.begin(), itEnd = d.end(); it != itEnd; ++it) {}</p>
<p>Models of images have also two main methods in order to read or write values at a given point:</p>
<ul>
<li><code>operator()</code> to get the value associated to a given point</li>
<li><code>setValue</code> to assign a value to a given point.</li>
</ul>
<p>process the values <a class="el" href="classDGtal_1_1Image.html#ace481f886b37a80824817b5f1494df58">Image::Domain</a> d = image.domain(); for (Image::Domain::ConstIterator it = d.begin(), itEnd = d.end(); it != itEnd; ++it) { <a class="el" href="classDGtal_1_1Image.html#ad56b43a36c897e64398934c8f7a3b01c">Image::Value</a> v = image( *it ); v += 5; //adding 5 to all values image.setValue( v ); }</p>
<p>Note that this method of iterating over the values of an image is not always the fastest and that is why we also provide ranges.</p>
<h3><a class="anchor" id="dgtalImagesRanges"></a>
Ranges of values</h3>
<p>Constant images provide a constant range of values returned by the <code>constRange</code> method. As every model of <a class="el" href="structDGtal_1_1CConstBidirectionalRange.html">CConstBidirectionalRange</a>, it provides <code>begin</code>, <code>end</code>, <code>rbegin</code> and <code>rend</code> methods returning constant iterators to iterate over the values in the forward or backward direction.</p>
<p>iterate over the values <a class="el" href="classDGtal_1_1Image.html#a0f2c0b68fdedee9231353fc0900e94b6">Image::ConstRange</a> r = image.constRange(); for (Image::ConstRange::ConstIterator it = r.begin(), itEnd = r.end(); it != itEnd; ++it) {}</p>
<p>However, this range is also a model of <a class="el" href="structDGtal_1_1CConstBidirectionalRangeFromPoint.html" title="Aim: refined concept of const bidirectional range with a begin() method from a point.">CConstBidirectionalRangeFromPoint</a>, which is a refinement of <a class="el" href="structDGtal_1_1CConstBidirectionalRange.html">CConstBidirectionalRange</a>. That is why it also has overloaded versions of the <code>begin</code> and <code>rbegin</code> methods taking a point as input argument. This provides a way of iterating on sub-ranges defined from points.</p>
<p>iterator on the origin (0, ... , 0) Image::ConstRange::ConstIterator it = r.begin( Image::Point::diagonal(0) )</p>
<p>Note that if the point does not belong to the domain, the returned iterators (resp. reverse iterators) must be equal to the <code>end</code> (resp. <code>rend</code>) methods. </p>
<div class="fragment"><pre class="fragment">ASSERT( image.constRange().begin( image.domain().end() ) == image.constRange().end() )</pre></div><p> Images provide in addition to a constant range, a richer range returned by the <code>range</code> method. This range is not only a model of <a class="el" href="structDGtal_1_1CBidirectionalRangeFromPoint.html" title="Aim: refined concept of single pass range with a begin() method from a point.">CBidirectionalRangeFromPoint</a>, but also a model of <a class="el" href="structDGtal_1_1CBidirectionalOutputRangeFromPoint.html" title="Aim: refined concept of single pass range with an routputIterator() method from a point...">CBidirectionalOutputRangeFromPoint</a>. That is why, it must have two methods: <code>outputIterator</code> and <code>routputIterator</code> returning output iterators. Moreover, it must have overloaded versions of these methods taking a point as input argument. Thus, these output iterators are useful in order to incrementaly fill (a part of) an image. For instance, you can fill an image from the values of another one (assumed to have the same domain) as follows: </p>
<div class="fragment"><pre class="fragment">Image::Range r1 = image1.range(); 
Image::ConstRange r2 = image2.constRange(); 
std::copy( r2.begin(), r2.end(), r1.outputIterator() ); </pre></div> <h2><a class="anchor" id="dgtalImagesModels"></a>
Main models</h2>
<p>Different models of images are available: <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>, <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a>, and --- coming soon --- <a class="el" href="classDGtal_1_1ImageContainerByHashTree.html" title="Model of CImageContainer implementing the association key&lt;-&gt;Value using a hash tree. This class provides a built-in iterator.">ImageContainerByHashTree</a>, ImageContainerByITKImage, a wrapper for ITK images.</p>
<h3><a class="anchor" id="dgtalImagesModelsVector"></a>
ImageContainerBySTLVector</h3>
<p><a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a> is a model of <a class="el" href="structDGtal_1_1CImage.html">CImage</a> that inherits the STL vector class. The hyper-rectangular domain, which the only model of domain accepted, is linearized so that each point is mapped, from its coordinates, into an index and each index is mapped into a unique value, as in any one-dimensional array.</p>
<p>Let <img class="formulaInl" alt="$ n $" src="form_3.png"/> be the domain size (the number of points). At construction all the needed space is allocated and filled with a default value (0) in <img class="formulaInl" alt="$ O(n) $" src="form_86.png"/> space and time. After that, you can access to the value associated to any point at any time. Each access for reading (<code>operator()</code>) or writing ('setValue`) values is in <img class="formulaInl" alt="$ O(1) $" src="form_87.png"/>.</p>
<p>The (constant) range of this class only used the built-in iterators of the underlying STL vector. It is therefore a fast way of iterating over the values of the image.</p>
<h3><a class="anchor" id="dgtalImagesModelsMap"></a>
ImageContainerBySTLMap</h3>
<p><a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> is a model of <a class="el" href="structDGtal_1_1CImage.html">CImage</a> that inherits the STL map class. The domain can be any set of points. Values are stored and associated to points in pairs point-value. The set of points stored in this way may be any domain subset. A default value (user-defined) is automatically associated to each point of the domain that does not belong the subset for which values are known. Once constructed (in <img class="formulaInl" alt="$ O(1) $" src="form_87.png"/>), the image is valid and every point of the image domain has a value, which can be read and overwritten.</p>
<p>The pairs point-value are stored in a red-black tree, where the points are used as keys, so that each access for reading (<code>operator()</code>) or writing (<code>setValue</code>) values is in <img class="formulaInl" alt="$ O(log m) $" src="form_88.png"/>, where <img class="formulaInl" alt="$ m $" src="form_89.png"/> is the cardinal of the subset for which values are known (less or equal to the domain size <img class="formulaInl" alt="$ n $" src="form_3.png"/>).</p>
<p>The (constant) range of this class adapts the domain iterators in order to deal with values instead of points. The <code>operator*</code> of the iterators provided by the range calls the <code>operator()</code> and use the <code>setValue</code> method of the class.</p>
<h3><a class="anchor" id="dgtalImagesModelsHashTree"></a>
ImageContainerByHashTree</h3>
<h2><a class="anchor" id="dgtalImagesFunctions"></a>
Useful classes and functions</h2>
<p>In addition to the image containers described in the previous section, there are image adapters:</p>
<p>i. <a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a model of CConstImage that adapts an underlying image.">ConstImageAdapter</a> is a small class that adapts any (constant or not) image into a constant one, which provides a virtual view of the true values contained in the adapted image.</p>
<p>ii. <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> is a light proxy on image containers based on a COW pointer. It can be constructed, copied, assigned, deleted without any special care.</p>
<p>Moreover, in <a class="el" href="ImageHelper_8h_source.html">ImageHelper.h</a>, many useful functions are provided.</p>
<ol type="1">
<li>Conversely, others convert images into digital sets with value comparators: setFromPointsRangeAndPredicate, setFromPointsRangeAndFunctor, setFromImage.</li>
</ol>
<ol type="1">
<li>Some of them convert digital sets into images, imageFromRangeAndValue assigns a given value in an image to each point of a given range.</li>
</ol>
<ol type="1">
<li>Lastly, some functions are available to fastly fill images from point functors or other images: imageFromFunctor and imageFromImage. </li>
</ol>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu May 10 2012 16:09:55 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
