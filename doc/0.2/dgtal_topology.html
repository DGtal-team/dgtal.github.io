<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DGtal: Digital topology and digital objects</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Digital topology and digital objects </h1>  </div>
</div>
<div class="contents">
<p>This part of the manual describes how to define digital objects. Subset of a digital sets are not really objects as long as they do not have some adjacency relation which describes how points (pixels in 2D, voxels in 3D, <em>spels</em> in nD) are connected. Digital topology was introduced by Rosenfeld as a framework to describe consistently how objects are connected and how complements of objects are connected. It has lead him to define two different adjacencies relations, one for the foreground (object), one for the background (complement of object). For well chosen adjacency relations, we find again some classical results of topology in continuous domains. For instance, the Jordan property may hold for several couples of adjacencies.</p>
<p>The topology kernel of <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> allows to define adjacencies, topologies, objects, and operations with objects in a very generic framework. Some of these operations have been specialized for standard spaces and topologies, in order to keep operations as fast as possible.</p>
<p>Once a topology (class <a class="el" href="classDGtal_1_1DigitalTopology.html">DigitalTopology</a>) has been defined from two adjacencies (models of <a class="el" href="structDGtal_1_1CAdjacency.html">CAdjacency</a>), a digital object (class <a class="el" href="classDGtal_1_1Object.html">Object</a>) has a <em>border</em> which is the set of elements adjacent to its complement. The border is again a digital object. A digital object can also be seen as a graph, which can be traversed in many ways, although the breadth-first is often very useful (class <a class="el" href="classDGtal_1_1Expander.html">Expander</a>).</p>
<ol type="1">
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec1_ajdacency">Adjacency relations</a><ol type="a">
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec1s1">4- and 8- adjacencies in Z2</a></li>
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec1s2">6-, 18- and 26- adjacencies in Z3</a></li>
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec1s3">Metric adjacencies in Zn</a></li>
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec1s4">Concepts CAdjacency et CDomainAdjacency</a></li>
</ol>
</li>
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec2_digital_topology">Digital topology over a digital space</a></li>
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec3_digital_object">Digital objects</a><ol type="a">
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec3s1">Construction of digital objects</a></li>
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec3s2">Neighborhood of a point in an object</a></li>
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec3s3">Border of a digital object</a></li>
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec3s4">Connectedness and connected components</a></li>
<li><a class="el" href="dgtal_topology.html#dgtal_topology_sec3s5">Simple points</a></li>
</ol>
</li>
</ol>
<h2><a class="anchor" id="dgtal_topology_sec1_ajdacency"></a>
Adjacency relations</h2>
<p>An adjacency relation in a digital space <b>X</b> describes which points of the digital space are close to each other. Generally it is a reflexive and symmetric relation over the points of <b>X</b>. Interested readers can read the works of Azriel Rosenfeld and Gabor Herman to see a well-founded theory of digital spaces.</p>
<h3><a class="anchor" id="dgtal_topology_sec1s1"></a>
4- and 8- adjacencies in Z2</h3>
<p>In <img class="formulaInl" alt="$ Z^2 $" src="form_7.png"/>, two adjacencies are used. The so-called <b>4-adjacency</b> tells that a 2D point is adjacent to itself and to four other points (north, east, south, and west points). The so-called <b>8-adjacency</b> tells that a 2D point is adjacent to itself and to eight other points (the four points of the 4-adjacency relation added with four points in the diagonals). These two adjacencies relations are translation invariant, symmetric, reflexive. You can define them as follows with <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>:</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">typedef</span> <span class="keywordtype">int</span> Integer;                <span class="comment">// choose your digital line here.</span>
 <span class="keyword">typedef</span> SpaceND&lt;int,2&gt; Z2;          <span class="comment">// Z^2</span>
 <span class="keyword">typedef</span> MetricAdjacency&lt;Z2,1&gt; Adj4; <span class="comment">// 4-adjacency type</span>
 <span class="keyword">typedef</span> MetricAdjacency&lt;Z2,2&gt; Adj8; <span class="comment">// 8-adjacency type</span>
 Adj4 <a class="code" href="namespaceDGtal_1_1Z2i.html#ab85365bfaeb1bf55ff96eee60026a852">adj4</a>;                          <span class="comment">// instance of 4-adjacency</span>
 Adj8 <a class="code" href="namespaceDGtal_1_1Z2i.html#ac30a8868a1f783f0758b5d4977ef2ee5">adj8</a>;                          <span class="comment">// instance of 8-adjacency</span>
</pre></div><p>You can equivalently use the types <code>Z2Adj4</code> and <code>Z2Adj8</code>, defined on <code>SpaceND&lt;int,2&gt;</code>.</p>
<p>It is well known that if you choose the 4-adjacency for an object, one should choose the 8-adjacency for the background in order to get consistent topological properties. For instance a simple 4-connected digital close curve (of more than 4 points) splits the digital space into two 8-connected background components (digital Jordan theorem). The same is true if you choose the 8-adjacency relation for the object, the 4-adjacency should be choosed for the background. This is called the <b>digital Jordan theorem</b> (Rosenfeld).</p>
<table class="doxtable">
<tr>
<td><div align="center">
<img src="DiskWithAdj4.png" alt="DiskWithAdj4.png"/>
<p><strong>Illustration of a Digital Object with the 4-adjacency</strong></p></div>
  </td><td><div align="center">
<img src="DiskWithAdj8.png" alt="DiskWithAdj8.png"/>
<p><strong>Illustration of a Digital Object with the 8-adjacency</strong></p></div>
   </td></tr>
</table>
<h3><a class="anchor" id="dgtal_topology_sec1s2"></a>
6-, 18- and 26- adjacencies in Z3</h3>
<p>Similarly as the 4-,8- adjacencies in 3D, the name of the 6-, 18-, 26- adjacencies defined in Z3 comes from the number of proper adjacent points for each point. Seeing a digital 3D point as a cube, the 6-neighbors are the points sharing at least a face with the cube, the 18-neighbors are the ones sharing at least an edge, while the 26-neighbors are the ones sharing at least a vertex. These three adjacencies relations are translation invariant, symmetric, reflexive. You can define them as follows with <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>:</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">typedef</span> <span class="keywordtype">int</span> Integer;                 <span class="comment">// choose your digital line here.</span>
 <span class="keyword">typedef</span> SpaceND&lt;int,3&gt; Z3;           <span class="comment">// Z^3</span>
 <span class="keyword">typedef</span> MetricAdjacency&lt;Z3,1&gt; Adj6;  <span class="comment">// 6-adjacency type</span>
 <span class="keyword">typedef</span> MetricAdjacency&lt;Z3,2&gt; Adj18; <span class="comment">// 18-adjacency type</span>
 <span class="keyword">typedef</span> MetricAdjacency&lt;Z3,3&gt; Adj26; <span class="comment">// 26-adjacency type</span>
 Adj6 <a class="code" href="namespaceDGtal_1_1Z3i.html#acb3f81fd7822995f3a738dffa7c2c155">adj6</a>;                           <span class="comment">// instance of 6-adjacency</span>
 Adj18 <a class="code" href="namespaceDGtal_1_1Z3i.html#a9824aaed1cbac82a90bde24d7ecda794">adj18</a>;                         <span class="comment">// instance of 18-adjacency</span>
 Adj26 <a class="code" href="namespaceDGtal_1_1Z3i.html#ae657d08f0914786f08b0260cec2ee1bf">adj26</a>;                         <span class="comment">// instance of 26-adjacency</span>
</pre></div><p>You can equivalently use the types <code>Z3Adj6</code>, <code>Z3Adj18</code> and <code>Z3Adj26</code>, defined on <code>SpaceND&lt;int,3&gt;</code>.</p>
<h3><a class="anchor" id="dgtal_topology_sec1s3"></a>
Metric adjacencies in Zn</h3>
<p>Adjacencies based on metrics can be defined in arbitrary dimension. They all have the properties to be translation invariant, reflexive and symmetric. They include the standard 4-, 8-adjacencies in Z2 and 6-, 18-, and 26-adjacencies in Z3. Given a maximal 1-norm <code>n1</code>, two points <code>p1</code> and <code>p2</code> are adjacent if and only if <img class="formulaInl" alt="$ \| p2 - p1 \|_1 \le n1 $" src="form_8.png"/> and <img class="formulaInl" alt="$ \| p2 - p1 \|_\infty \le 1 $" src="form_9.png"/>.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">const</span> <span class="keywordtype">int</span> n = ...;                   <span class="comment">// choose your dimension.</span>
 <span class="keyword">typedef</span> <span class="keywordtype">int</span> Integer;                 <span class="comment">// choose your digital line here.</span>
 <span class="keyword">typedef</span> SpaceND&lt;int,n&gt; Zn;           <span class="comment">// Z^N</span>
 <span class="keyword">const</span> <span class="keywordtype">int</span> n1 = ...;                  <span class="comment">// choose your max 1-norm here.</span>
 <span class="keyword">typedef</span> MetricAdjacency&lt;Zn,n1&gt; MyAdj;<span class="comment">// your adjacency type.</span>
 Myadj myAdj;                         <span class="comment">// your instance.</span>
</pre></div><h3><a class="anchor" id="dgtal_topology_sec1s4"></a>
Concepts CAdjacency et CDomainAdjacency</h3>
<p>Adjacencies are used at many places as a basis for more complex operations. To keep genericity and efficiency, adjacencies should satisfy the concept <a class="el" href="structDGtal_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">CAdjacency</a>. They are specialized only at instanciation as argument to templates. A <a class="el" href="structDGtal_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">CAdjacency</a> concept should define the following inner types:</p>
<ul>
<li>Space: the space of the adjacency.</li>
<li>Point: the digital point type.</li>
<li>Adjacency: the type of the adjacency itself.</li>
</ul>
<p>It should also define the following methods:</p>
<ul>
<li>isAdjacentTo</li>
<li>isProperlyAdjacentTo</li>
<li>writeNeighborhood</li>
<li>writeProperNeighborhood</li>
</ul>
<p>Methods <code>writeNeighborhood</code> and <code>writeProperNeighborhood</code> are overloaded so as to substitute their own predicate with another user-given predicate. They are useful to restrict neighborhoods.</p>
<p>A <a class="el" href="structDGtal_1_1CDomainAdjacency.html" title="Aim: Refines the concept CAdjacency by telling that the adjacency is specific to a given domain of th...">CDomainAdjacency</a> refines a <a class="el" href="structDGtal_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">CAdjacency</a> by specifying a limiting domain for the adjacency. It adds the following inner types:</p>
<ul>
<li>Domain: the type of embedding domain.</li>
<li>Predicate: the type of the predicate "is in domain ?".</li>
</ul>
<p>It should also define the following methods:</p>
<ul>
<li>domain</li>
<li>predicate</li>
</ul>
<h2><a class="anchor" id="dgtal_topology_sec2_digital_topology"></a>
Digital topology over a digital space</h2>
<p>A digital topology is a couple of adjacencies, one for the foreground, one for the background. The template class <a class="el" href="classDGtal_1_1DigitalTopology.html" title="Aim: Represents a digital topology as a couple of adjacency relations.">DigitalTopology</a> can be used to create such a couple.</p>
<p>The following lines of code creates the classical (6,18) topology over <img class="formulaInl" alt="$ Z^3 $" src="form_10.png"/>.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">typedef</span> SpaceND&lt; int, 3 &gt; Z3;
 <span class="keyword">typedef</span> MetricAdjacency&lt; Z3, 1 &gt; Adj6;
 <span class="keyword">typedef</span> MetricAdjacency&lt; Z3, 2 &gt; Adj18;
 <span class="keyword">typedef</span> DigitalTopology&lt; Adj6, Adj18 &gt; DT6_18;

 Adj6 adj6;
 Adj18 adj18;
 DT6_18 <a class="code" href="namespaceDGtal_1_1Z3i.html#a0b37f6533ee49fb1b86d8300c4939a5e">dt6_18</a>( adj6, adj18, <a class="code" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083da731ee8276af4e05e2fe322cf2a4fd179">JORDAN_DT</a> );
</pre></div><p>The foreground adjacency is classically called <em>kappa</em> <img class="formulaInl" alt="$ \kappa $" src="form_11.png"/> while the background is called <em>lambda</em> <img class="formulaInl" alt="$ \lambda $" src="form_12.png"/> . Any topology has a reversed topology which is the topology <img class="formulaInl" alt="$ (\lambda,\kappa) $" src="form_13.png"/>.</p>
<p>A topology can be a <b>Jordan</b> couple. In this case, some objects of this space have nice properties. The reader is referred to the papers of Herman or to its book <b> Geometry of digital spaces </b>.</p>
<h2><a class="anchor" id="dgtal_topology_sec3_digital_object"></a>
Digital objects</h2>
<p>A digital object is a set of points together with a topology describing how points are close to each others. In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>, they are defined by the template class <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a>, parameterized by the topology (a <a class="el" href="classDGtal_1_1DigitalTopology.html" title="Aim: Represents a digital topology as a couple of adjacency relations.">DigitalTopology</a>) and a digital set of points (any model of <a class="el" href="structDGtal_1_1CDigitalSet.html">CDigitalSet</a> like <a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim:">DigitalSetBySTLSet</a> or <a class="el" href="classDGtal_1_1DigitalSetBySTLVector.html" title="Aim: Realizes the concept CDigitalSet by using the STL container std::vector.">DigitalSetBySTLVector</a>).</p>
<p>The digital object stores its own set of points with a copy-on-write smart pointer. This means that a digital object can be copied without overhead, and may for instance be passed by value or returned. The input digital set given at construction specifies the domain of the object, which remains the same for the lifetime of the object.</p>
<h3><a class="anchor" id="dgtal_topology_sec3s1"></a>
Construction of digital objects</h3>
<p>A digital object is generally initialized with some given set. The type of the set can be chosen so as to leave to the user the choice of the best set container for the object. You may use the <a class="el" href="structDGtal_1_1DigitalSetSelector.html" title="Aim: Automatically defines an adequate digital set type according to the hints given by the user...">DigitalSetSelector</a> to let the compiler choose your digital set container at compilation time according to some preferences. The choice <a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim:">DigitalSetBySTLSet</a> is the most versatile and generally the most efficient. The choice <a class="el" href="classDGtal_1_1DigitalSetBySTLVector.html" title="Aim: Realizes the concept CDigitalSet by using the STL container std::vector.">DigitalSetBySTLVector</a> is only good for very small objects.</p>
<div class="fragment"><pre class="fragment"> ...
 <span class="keyword">typedef</span> <a class="code" href="testFreemanChain_8cpp.html#a7f0531e1424ee81d83c134455ecd1a83">Z3::Point</a> Point;
 <span class="keyword">typedef</span> HyperRectDomain&lt; Z3 &gt; Domain; 
 <span class="keyword">typedef</span> Domain::ConstIterator DomainConstIterator; 
 <span class="keyword">typedef</span> DigitalSetSelector&lt; Domain, BIG_DS+HIGH_BEL_DS &gt;::Type DigitalSet;
 <span class="keyword">typedef</span> Object&lt;DT6_18, DigitalSet&gt; ObjectType;

 Point p1( -50, -50, -50 );
 Point p2( 50, 50, 50 );
 Domain domain( p1, p2 );
 Point c( 0, 0 );
 <span class="comment">// diamond of radius 30</span>
 DigitalSet diamond_set( domain );
 <span class="keywordflow">for</span> ( DomainConstIterator it = domain.begin(); it != domain.end(); ++it )
   {
     <span class="keywordflow">if</span> ( (*it - c ).norm1() &lt;= 30 ) diamond_set.insertNew( *it );
   }
 ObjectType diamond( <a class="code" href="namespaceDGtal_1_1Z3i.html#a0b37f6533ee49fb1b86d8300c4939a5e">dt6_18</a>, diamond_set );
 <span class="comment">// The following line takes almost no time.</span>
 ObjectType diamond_clone( diamond );
 <span class="comment">// Since one of the objects is modified, the set is duplicated at the following line</span>
 diamond_clone.pointSet().erase( c );
</pre></div><p>Objects may also be initialized empty, so that you can easily use a container to store them. Of course, they are not valid in this case.</p>
<div class="fragment"><pre class="fragment"> ObjectType object;          <span class="comment">// valid</span>
 <a class="code" href="classvector.html">vector&lt;ObjectType&gt;</a> objects; <span class="comment">// valid</span>
</pre></div><h3><a class="anchor" id="dgtal_topology_sec3s2"></a>
Neighborhood of a point in an object</h3>
<p>An object proposes several methods to return the neighborhood of a given point of the object.</p>
<ul>
<li><a class="el" href="classDGtal_1_1Object.html#a1665be8be01f864f9fbd0b2ee5db4e61">Object::neighborhood</a>, <a class="el" href="classDGtal_1_1Object.html#a97cde76bc7a924b9b589498dcfd32be0">Object::properNeighborhood</a>: the neighborhoods are returned as objects (with a digital set type considered small).</li>
</ul>
<ul>
<li><a class="el" href="classDGtal_1_1Object.html#a4ede5fb7e40a56173acfdf1b72523d76">Object::neighborhoodSize</a>, <a class="el" href="classDGtal_1_1Object.html#ab5933ef261d262e5d1197ab9e364648d">Object::properNeighborhoodSize</a>: prefer these methods if you only need the cardinal of the neighborhoods and not the neighborhoods itselves</li>
</ul>
<h3><a class="anchor" id="dgtal_topology_sec3s3"></a>
Border of a digital object</h3>
<p>Objects have a border, which are the points which touch the complement in the sense of background adjacency. A border of an object is itself an object, with the same topology as the object.</p>
<div class="fragment"><pre class="fragment"> ObjectType bdiamond = diamond.border(); <span class="comment">// one component</span>
 ObjectType bdiamond_clone = diamond_clone.border(); <span class="comment">// two components</span>
</pre></div><h3><a class="anchor" id="dgtal_topology_sec3s4"></a>
Connectedness and connected components</h3>
<p>The digital topology induces a connectedness relation on the object (transitive closure of the foreground adjacency) and a connectedness relation on the complement of the set (transitive closure of the background adjacency). Objects may be connected or not. The connectedness is stored with the object, if it is known. The method <a class="el" href="classDGtal_1_1Object.html#a6d5aa84db0e031d502878feccaabd6d8">Object::connectedness</a> returns CONNECTED, DISCONNECTED or UNKNOWN depending on the connectedness of this object and if it has been computed. The method <a class="el" href="classDGtal_1_1Object.html#aa0a251b3dffbc7484669c3fa51995af5">Object::computeConnectedness</a> forces the computation. After this process, the connectedness is either CONNECTED or DISCONNECTED.</p>
<p>Furthermore, you can use the method <a class="el" href="classDGtal_1_1Object.html#a9daf3ea2b1073c20bae52e320dad272c">Object::writeComponents</a> to compute all the connected components of this object. It also updates the connectedness of this object to either CONNECTED or DISCONNECTED depending on the number of connected components. Each connected component is of course CONNECTED.</p>
<p>You may use writeComponents as follows:</p>
<div class="fragment"><pre class="fragment"> std::vector&lt; ObjectType &gt; objects;
 std::back_insert_iterator&lt; std::vector&lt; ObjectType &gt; &gt; inserter( objects );
 <span class="comment">// nbc == 1 since the boundary of the diamond is connected.</span>
 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbc = bdiamond.writeComponents( inserter );
 <span class="comment">// nbd == 2 since the boundary of the diamond minus its center is disconnected.</span>
 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbd = bdiamond_clone.writeComponents( inserter );
 <span class="comment">// objects.size() == 3</span>
</pre></div><p>You must be careful when using an output iterator writing in the same container as 'this' object (see <a class="el" href="classDGtal_1_1Object.html#a9daf3ea2b1073c20bae52e320dad272c">Object::writeComponents</a>).</p>
<h3><a class="anchor" id="dgtal_topology_sec3s5"></a>
Simple points</h3>
<p><b>TODO</b> </p>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Dec 10 2010 13:16:34 for DGtal by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
