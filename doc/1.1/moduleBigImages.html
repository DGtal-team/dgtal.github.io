<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Handle large images in DGtal</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Handle large images in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#dgtalBigImagesAbstract">Overview</a></li>
<li class="level1"><a href="#dgtalBigImagesConcepts">Concepts</a><ul><li class="level2"><a href="#dgtalBigImagesFactoryConcepts">CImageFactory</a></li>
<li class="level2"><a href="#dgtalBigImagesCachePoliciesConcepts">Cache policies concepts</a><ul><li class="level3"><a href="#dgtalBigImagesCacheReadPolicyConcepts">CImageCacheReadPolicy</a></li>
<li class="level3"><a href="#dgtalBigImagesCacheWritePolicyConcepts">CImageCacheWritePolicy</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#dgtalBigImagesModels">Models</a><ul><li class="level2"><a href="#dgtalBigImagesImageFactoryModels">Image factory models</a></li>
<li class="level2"><a href="#dgtalBigImagesCachePoliciesModels">Cache policies models</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtalBigImagesSamples">The TiledImage class</a></li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Authors</dt><dd>Martial Tola, David Coeurjolly </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2013/03/12</dd></dl>
<p>Part of the <a class="el" href="packageImage.html">Image package</a></p>
<h1><a class="anchor" id="dgtalBigImagesAbstract"></a>
Overview</h1>
<p>Large images like tiled images, HDF5 images, ... can be handled in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>.</p>
<p>For this, we provide two important mechanisms: an image factory mechanism and an image cache mechanism with read and write policies.</p>
<p>The image factory is necessary to keep control on the created images. As its responsibility is to create images according to a given domain. The factory can update (flush) the image on disk and also can free the image from memory. <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> factory models can associated with specific image formats such as <a href="http://www.hdfgroup.org/HDF5/">HDF5</a> which can be activated using a <em>WITH_HDF5</em> flag during <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> build (please refer to <a class="el" href="moduleBuildDGtal.html">Building DGtal</a>). This mechanism is a <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> concept called CImageFactory which is detailed below.</p>
<p>As we want to take also into account large images effectively, we also need a cache mechanism to access to subsets, so called tiles, of such images.</p>
<p>The cache has the responsibility to store tiles and giving us read and write access to them. The reading, writing and updating mechanisms of the cache are controlled with two policies: the read and the write policies. These policies are <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> concepts called respectively CImageCacheReadPolicy and CImageCacheWritePolicy which are detailed just below.</p>
<p>The cache process is rather simple. It consists of three important methods that are detailed here:</p>
<ul>
<li>the <code>read</code> function returns true and get the value of an image from cache at a given position given by a point only if that point belongs to an image from cache, else returns false.</li>
<li>the <code>write</code> function returns true and set the value of an image from cache at a given position given by a point only if that point belongs to an image from cache, else returns false.</li>
<li>the <code>update</code> function update the cache according to the read policy.</li>
</ul>
<h1><a class="anchor" id="dgtalBigImagesConcepts"></a>
Concepts</h1>
<h2><a class="anchor" id="dgtalBigImagesFactoryConcepts"></a>
CImageFactory</h2>
<p>Any model of the concept CImageFactory must have this nested type:</p>
<ul>
<li>OutputImage, which specifies the type of the images created by the factory.</li>
</ul>
<p>Moreover, it must have the following methods:</p>
<ul>
<li><code>requestImage</code>, which takes a domain as input parameter and returns an OutputImage pointer on the created image.</li>
<li><code>flushImage</code>, which takes an OutputImage pointer as input parameter in order to flush/synchronize it on disk.</li>
<li><code>detachImage</code>, which takes an OutputImage pointer as input parameter in order to delete/release it.</li>
</ul>
<h2><a class="anchor" id="dgtalBigImagesCachePoliciesConcepts"></a>
Cache policies concepts</h2>
<p>Cache policies concepts are divided in two concepts: read and write policies.</p>
<h3><a class="anchor" id="dgtalBigImagesCacheReadPolicyConcepts"></a>
CImageCacheReadPolicy</h3>
<p>Any model of the concept CImageCacheReadPolicy must have this nested type:</p>
<ul>
<li>ImageContainer, which specifies the type of the images stored in the cache.</li>
</ul>
<p>Moreover, it must have the following methods:</p>
<ul>
<li><code>getPage</code>, which takes a point as input parameter and returns an ImageContainer pointer on the image that contains the point or NULL if no image in the cache contains that point.</li>
<li><code>getPage</code>, which takes a domain as input parameter and returns an ImageContainer pointer on the image that contains the domain or NULL if no image in the cache contains that domain.</li>
<li><code>getPageToDetach</code>, which returns an ImageContainer pointer on the image that we have to detach or NULL if no image have to be detached.</li>
<li><code>updateCache</code>, which takes a domain as input parameter in order to update the cache according to the defined cache policy.</li>
<li><code>clearCache</code>, which clears the cache.</li>
</ul>
<h3><a class="anchor" id="dgtalBigImagesCacheWritePolicyConcepts"></a>
CImageCacheWritePolicy</h3>
<p>Any model of the concept CImageCacheWritePolicy must have this nested type:</p>
<ul>
<li>ImageContainer, which specifies the type of the images stored in the cache.</li>
</ul>
<p>Moreover, it must have the following methods:</p>
<ul>
<li><code>writeInPage</code>, which takes an ImageContainer pointer, a point and a value for that point as input parameters in order to set the value on the image at the position given by the point.</li>
<li><code>flushPage</code>, which takes an ImageContainer pointer as input parameter in order to flush the image on disk according to the defined cache policy.</li>
</ul>
<h1><a class="anchor" id="dgtalBigImagesModels"></a>
Models</h1>
<h2><a class="anchor" id="dgtalBigImagesImageFactoryModels"></a>
Image factory models</h2>
<ul>
<li><a class="el" href="classDGtal_1_1ImageFactoryFromImage.html" title="Aim: implements a factory to produce images from a &quot;bigger/original&quot; one according to a given domain.">ImageFactoryFromImage</a> model is a rather simple one. It implements a factory which produces images from a bigger original one. The bigger one is still in memory. This model is for debugging purposes.</li>
<li><a class="el" href="classDGtal_1_1ImageFactoryFromHDF5.html" title="Aim: implements a factory from an HDF5 file.">ImageFactoryFromHDF5</a> (with <em>WITH_HDF5</em> build flag) model is similar to <a class="el" href="classDGtal_1_1ImageFactoryFromImage.html" title="Aim: implements a factory to produce images from a &quot;bigger/original&quot; one according to a given domain.">ImageFactoryFromImage</a>: it implements a factory which produces images from an HDF5 "dataset/file" according to a given domain. When requesting a "block" of an HDF5 image, the factory will perform disk I/O access to load the appropriate chunk.</li>
</ul>
<h2><a class="anchor" id="dgtalBigImagesCachePoliciesModels"></a>
Cache policies models</h2>
<p>Cache policies models are split into read and write policies.</p>
<ul>
<li><a class="el" href="classDGtal_1_1ImageCacheReadPolicyLAST.html" title="Aim: implements a &#39;LAST&#39; read policy cache.">ImageCacheReadPolicyLAST</a> model is a rather simple one. It implements a 'LAST' read policy cache. The cache keeps only one page in memory, the last one. When the page needs to be replaced, the new page replaces the old one.</li>
<li><a class="el" href="classDGtal_1_1ImageCacheReadPolicyFIFO.html" title="Aim: implements a &#39;FIFO&#39; read policy cache.">ImageCacheReadPolicyFIFO</a> model is a rather simple one. It implements a 'FIFO' read policy cache. The cache keeps track of all the pages in memory in a queue, with the most recent arrival at the back, and the earliest arrival in front. When a page needs to be replaced, the page at the front of the queue (the oldest page) is selected.</li>
<li><a class="el" href="classDGtal_1_1ImageCacheWritePolicyWT.html" title="Aim: implements a &#39;WT (Write-through)&#39; write policy cache.">ImageCacheWritePolicyWT</a> model is a rather simple one. It implements a 'WT (Write-through)' write policy cache. Write is done synchronously both to the cache and to the disk.</li>
<li><a class="el" href="classDGtal_1_1ImageCacheWritePolicyWB.html" title="Aim: implements a &#39;WB (Write-back or Write-behind)&#39; write policy cache.">ImageCacheWritePolicyWB</a> model is a rather simple one. It implements a 'WB (Write-back or Write-behind)' write policy cache. Initially, writing is done only to the cache. The write to the disk is postponed until the cache blocks containing the data are about to be modified/replaced by new content.</li>
</ul>
<h1><a class="anchor" id="dgtalBigImagesSamples"></a>
The TiledImage class</h1>
<p>The <a class="el" href="classDGtal_1_1TiledImage.html" title="Aim: implements a tiled image from a &quot;bigger/original&quot; one from an ImageFactory.">TiledImage</a> is a simple class that implements a tiled image from a "bigger/original" one from an ImageFactory.</p>
<p>The tiled image is created from an existing image and with four parameters:</p><ul>
<li>An alias to the image factory (see <a class="el" href="classDGtal_1_1ImageFactoryFromImage.html" title="Aim: implements a factory to produce images from a &quot;bigger/original&quot; one according to a given domain.">ImageFactoryFromImage</a> or <a class="el" href="classDGtal_1_1ImageFactoryFromHDF5.html" title="Aim: implements a factory from an HDF5 file.">ImageFactoryFromHDF5</a>).</li>
<li>An alias to a read policy.</li>
<li>An alias to a write policy.</li>
<li>and a parameter to describe the number of tiles we want for each dimension.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>It is important to take into account that read and write policies are passed as aliases in the <a class="el" href="classDGtal_1_1TiledImage.html" title="Aim: implements a tiled image from a &quot;bigger/original&quot; one from an ImageFactory.">TiledImage</a> constructor, so for example, if two <a class="el" href="classDGtal_1_1TiledImage.html" title="Aim: implements a tiled image from a &quot;bigger/original&quot; one from an ImageFactory.">TiledImage</a> instances are successively created with the same read policy instance, the state of the cache for a given time is therefore the same for the two <a class="el" href="classDGtal_1_1TiledImage.html" title="Aim: implements a tiled image from a &quot;bigger/original&quot; one from an ImageFactory.">TiledImage</a> instances.</dd></dl>
<p>Concerning the cache mechanism explained at the top of this document, the accessor <code>operator()</code> (i.e. the getter) and the setter <code>setValue</code> are therefore really simple to write for the <a class="el" href="classDGtal_1_1TiledImage.html" title="Aim: implements a tiled image from a &quot;bigger/original&quot; one from an ImageFactory.">TiledImage</a> class:</p>
<ul>
<li>the getter just returns the value of an image (from cache) at a given position given by a point if the image is in the cache. If not, the cache is first update with the image that contains that point.</li>
<li>in the same manner, the setter just write the value of an image (in cache) at a given position given by a point if the image is in the cache. If not, the cache is first update with the image that contains that point.</li>
</ul>
<p>In order to illustrate the next <a class="el" href="classDGtal_1_1TiledImage.html" title="Aim: implements a tiled image from a &quot;bigger/original&quot; one from an ImageFactory.">TiledImage</a> usage sample, we are going a) to use these includes:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/io/colormaps/HueShadeColorMap.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/images/ImageContainerBySTLVector.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/images/ImageFactoryFromImage.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/images/TiledImage.h&quot;</span></div>
</div><!-- fragment --><p> b) then define these type and variable:</p>
<div class="fragment"><div class="line">    <span class="keyword">typedef</span> HueShadeColorMap&lt;int&gt; HueShade;     <span class="comment">// a simple HueShadeColorMap varying on &#39;int&#39; values</span></div>
</div><!-- fragment --><p> c) then define a simple 16x16 (1,1) to (16,16) image (of 'int' type):</p>
<div class="fragment"><div class="line">    <span class="keyword">typedef</span> ImageContainerBySTLVector&lt;Z2i::Domain, int&gt; VImage;</div>
<div class="line">    VImage <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a614d1b1c043b31763c1eb50f64666737">image</a>(<a class="code" href="namespaceDGtal_1_1Z2i.html#aca523bebdae58eb19385aaefffff8bc5">Z2i::Domain</a>(<a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(1,1), <a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(16,16)));</div>
</div><!-- fragment --><p> filled with 1 to 256 values like that:</p>
<div class="fragment"><div class="line">    <span class="keywordtype">int</span> i = 1;</div>
<div class="line">    <span class="keywordflow">for</span> (VImage::Iterator it = image.begin(); it != image.end(); ++it)</div>
<div class="line">        *it = i++;</div>
</div><!-- fragment --><p> which looks like that with a simple <a class="el" href="classDGtal_1_1HueShadeColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">HueShadeColorMap</a> varying from 1 to 256 and with (1,1) the first bottom-left point:</p>
<div class="image">
<img src="tiledImageFromImage-image.png" alt=""/>
<div class="caption">
(1) simple 16x16 source image: (1,1) to (16,16) drawn with a simple HueShadeColorMap varying from 1 to 256.</div></div>
 <p>Here is now the construction of a simple 4x4 tiled image with therefore 16 subdomains of the initial image domain. The tiled image is created from an existing image and with four parameters. The first parameter is an alias on the image factory (see <a class="el" href="classDGtal_1_1ImageFactoryFromImage.html" title="Aim: implements a factory to produce images from a &quot;bigger/original&quot; one according to a given domain.">ImageFactoryFromImage</a>). The second parameter is an alias on a read policy. The third parameter is an alias on a write policy. The fourth parameter is to set how many tiles we want for each dimension:</p>
<div class="fragment"><div class="line">    <span class="comment">// here we create an image factory</span></div>
<div class="line">    <span class="keyword">typedef</span> ImageFactoryFromImage&lt;VImage&gt; MyImageFactoryFromImage;</div>
<div class="line">    <span class="keyword">typedef</span> MyImageFactoryFromImage::OutputImage OutputImage;</div>
<div class="line">    MyImageFactoryFromImage imageFactoryFromImage(image);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// here we create read and write policies</span></div>
<div class="line">    <span class="keyword">typedef</span> ImageCacheReadPolicyFIFO&lt;OutputImage, MyImageFactoryFromImage&gt; MyImageCacheReadPolicyFIFO;</div>
<div class="line">    <span class="keyword">typedef</span> ImageCacheWritePolicyWT&lt;OutputImage, MyImageFactoryFromImage&gt; MyImageCacheWritePolicyWT;</div>
<div class="line">    MyImageCacheReadPolicyFIFO imageCacheReadPolicyFIFO(imageFactoryFromImage, 2);</div>
<div class="line">    MyImageCacheWritePolicyWT imageCacheWritePolicyWT(imageFactoryFromImage);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// here we create the TiledImage</span></div>
<div class="line">    <span class="keyword">typedef</span> TiledImage&lt;VImage, MyImageFactoryFromImage, MyImageCacheReadPolicyFIFO, MyImageCacheWritePolicyWT&gt; MyTiledImage;</div>
<div class="line">    BOOST_CONCEPT_ASSERT(( concepts::CImage&lt; MyTiledImage &gt; ));</div>
<div class="line">    MyTiledImage tiledImage(imageFactoryFromImage, imageCacheReadPolicyFIFO, imageCacheWritePolicyWT, 4);</div>
</div><!-- fragment --><p> In this sample, we are going to work only with the 8 bottom subdomains of the original image.</p>
<p>At the beginning the cache is empty.</p>
<p>First we want to read the point 4,2 (which is in domain 1),</p>
<div class="fragment"><div class="line">    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;Read value for Point 4,2: &quot;</span> &lt;&lt; tiledImage(<a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(4,2)) &lt;&lt; endl;</div>
</div><!-- fragment --><p> so after that the cache is (domain1,empty). Here is the domain1:</p>
<div class="image">
<img src="TiledImageFromImage-01-read.png" alt=""/>
<div class="caption">
(3) read: not in cache, so, update. Cache: (domain1,empty). Read: domain1.</div></div>
 <p>Then we want to read the point 10,6 (which is in domain 7),</p>
<div class="fragment"><div class="line">    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;Read value for Point 10,6: &quot;</span> &lt;&lt; tiledImage(<a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(10,6)) &lt;&lt; endl;</div>
</div><!-- fragment --><p> so after that the cache is (domain1,domain7). Here is the domain7:</p>
<div class="image">
<img src="TiledImageFromImage-03-read.png" alt=""/>
<div class="caption">
(4) read: not in cache, so, update. Cache: (domain1,domain7). Read: domain7.</div></div>
 <p>Then we want to set the value of the point 11,7 to 1 (which is in domain 7),</p>
<div class="fragment"><div class="line">    aValue = 1; tiledImage.setValue(<a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(11,7), aValue);</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;Write value for Point 11,7: &quot;</span> &lt;&lt; aValue &lt;&lt; endl;</div>
</div><!-- fragment --><p> so after that the cache is always (domain1,domain7). Here is the new domain7 after writing:</p>
<div class="image">
<img src="TiledImageFromImage-05-write.png" alt=""/>
<div class="caption">
(5) write: in cache. Cache: (domain1,domain7). Write: domain7.</div></div>
 <p>Then we want to read the point 2,3 (which is in domain 1),</p>
<div class="fragment"><div class="line">    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;Read value for Point 2,3: &quot;</span> &lt;&lt; tiledImage(<a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(2,3)) &lt;&lt; endl;</div>
</div><!-- fragment --><p> so after that the cache is always (domain1,domain7). Here is the domain1:</p>
<div class="image">
<img src="TiledImageFromImage-07-read.png" alt=""/>
<div class="caption">
(6) read: in cache. Cache: (domain1,domain7). Read: domain1.</div></div>
 <p>Then we want to read the point 16,1 (which is in domain 4),</p>
<div class="fragment"><div class="line">    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;Read value for Point 16,1: &quot;</span> &lt;&lt; tiledImage(<a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(16,1)) &lt;&lt; endl;</div>
</div><!-- fragment --><p> so after that the cache is (domain7,domain4). Here is the domain4:</p>
<div class="image">
<img src="TiledImageFromImage-09-read.png" alt=""/>
<div class="caption">
(7) read: not in cache, so, update. Cache: (domain7,domain4). Read: domain4.</div></div>
 <p>Then we want to set the value of the point 16,1 to 128 (which is in domain 4),</p>
<div class="fragment"><div class="line">    aValue = 128; tiledImage.setValue(<a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(16,1), aValue);</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;Write value for Point 16,1: &quot;</span> &lt;&lt; aValue &lt;&lt; endl;</div>
</div><!-- fragment --><p> so after that the cache is always (domain7,domain4). Here is the new domain4 after writing:</p>
<div class="image">
<img src="TiledImageFromImage-11-write.png" alt=""/>
<div class="caption">
(8) write: in cache. Cache: (domain7,domain4). Write: domain4</div></div>
 <p>And finally, here is the modified original image after the two writings.</p>
<div class="image">
<img src="tiledImageFromImage-image2.png" alt=""/>
<div class="caption">
(9) result image.</div></div>
  </div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_a614d1b1c043b31763c1eb50f64666737"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a614d1b1c043b31763c1eb50f64666737">image</a></div><div class="ttdeci">Image image(domain)</div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z2i_html_ac0a04516c81db6f4a583eddda0f64875"><div class="ttname"><a href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">DGtal::Z2i::Point</a></div><div class="ttdeci">Space::Point Point</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00095">StdDefs.h:95</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a8fc7012708b0416880a5c8b12dfdf9dd"><div class="ttname"><a href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">DGtal::trace</a></div><div class="ttdeci">Trace trace</div><div class="ttdef"><b>Definition:</b> <a href="Common_8h_source.html#l00150">Common.h:150</a></div></div>
<div class="ttc" id="aclassDGtal_1_1Trace_html_ad054990834d2763627166540087a2980"><div class="ttname"><a href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">DGtal::Trace::info</a></div><div class="ttdeci">std::ostream &amp; info()</div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z2i_html_aca523bebdae58eb19385aaefffff8bc5"><div class="ttname"><a href="namespaceDGtal_1_1Z2i.html#aca523bebdae58eb19385aaefffff8bc5">DGtal::Z2i::Domain</a></div><div class="ttdeci">HyperRectDomain&lt; Space &gt; Domain</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00099">StdDefs.h:99</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 6 2020 14:17:05 for DGtal by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
