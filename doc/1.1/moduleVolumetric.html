<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: nD Volumetric Analysis using Separable Processes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">nD Volumetric Analysis using Separable Processes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#introVol">Introduction</a></li>
<li class="level1"><a href="#voronoiSect">Digital Voronoi Diagram Computation</a></li>
<li class="level1"><a href="#DTsec">Distance Transformation</a></li>
<li class="level1"><a href="#RDTSec">Digital Power Map and Reverse Distance Transformation</a></li>
<li class="level1"><a href="#toricVol">Volumetric Analysis on Toric domains</a></li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>David Coeurjolly, Roland Denis</dd></dl>
<p>This part of the manual describes the <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> volumetric module. We focus here on separable process based volumetric analysis such as distance transformation, reverse distance transformation and medial axis extraction.</p>
<h1><a class="anchor" id="introVol"></a>
Introduction</h1>
<p>For decades, distance transformation (DT) and geometrical skeleton extraction have been standard tools for shape analysis <a class="el" href="citelist.html#CITEREF_Rosenfeld1966">[82]</a> <a class="el" href="citelist.html#CITEREF_Rosenfeld1968">[83]</a> . The DT of a shape consists in labeling object grid points with the distance to the closest background pixel. From the DT values, we thus have information on the shape geometry. Besides its applications in shape description, DT has been used in many situations such as shape analysis, shape matching, shape-based interpolation, motion planning, image registration, or differential measurement estimation.</p>
<p>In the literature, many techniques have been proposed to compute the DT, given a metric with a trade-off between algorithmic performances and the <em>accuracy</em> of the metric compared to the Euclidean one. Hence, many papers have considered distances based on chamfer masks <a class="el" href="citelist.html#CITEREF_Rosenfeld1966">[82]</a> <a class="el" href="citelist.html#CITEREF_Rosenfeld1968">[83]</a> <a class="el" href="citelist.html#CITEREF_Borgefors1986CVGIP">[13]</a> , or sequences of chamfer distances; the vector displacement based Euclidean distance <a class="el" href="citelist.html#CITEREF_Danielsson1980">[36]</a> <a class="el" href="citelist.html#CITEREF_Ragnemalm1993">[79]</a> the Voronoi diagram based Euclidean distance <a class="el" href="citelist.html#CITEREF_Breu1995">[15]</a> <a class="el" href="citelist.html#CITEREF_Maurer2003PAMI">[66]</a> or the square of the Euclidean distance <a class="el" href="citelist.html#CITEREF_Saito1994-DT">[88]</a> <a class="el" href="citelist.html#CITEREF_Hirata1996">[51]</a> . From a computational point of view, several of these methods lead to time optimal algorithms to compute the error-free Euclidean Distance Transformation (EDT) for <em>n-</em> dimensional binary images: the extension of these algorithms is straightforward since they use separable techniques to compute the DT; <em>n</em> one-dimensional operations -one per direction of the coordinate axis- are performed.</p>
<p>In <a class="el" href="citelist.html#CITEREF_dcoeurjo_pami_RDMA">[23]</a>, it has been demonstrated that a similar decomposition can be used to compute both the reverse distance transformation and a discrete medial axis of the binary shape.</p>
<p>The separable decomposition and the associated algorithmic tools can be used on a wider class of metrics (see <a class="el" href="citelist.html#CITEREF_Hirata1996">[51]</a> or <a class="el" href="citelist.html#CITEREF_Maurer2003PAMI">[66]</a>). For instance, all weighted \(l_p\) metrics defined in \(\mathbb{R}^d\) by </p><p class="formulaDsp">
\[ d_{L_p} (u,v) = \left ( \sum_{i=0}^d w_i|u_i-v_i |^p \right )^{\frac{1}{p}}\]
</p>
<p> can be considered.</p>
<p>In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>, we have chosen to implement such volumetric tools such that the underlying metric could be specified independently. As an example, we illustrate the distance maps from a single source point for various metrics in 2D using the generic <a class="el" href="classDGtal_1_1DistanceTransformation.html" title="Aim: Implementation of the linear in time distance transformation for separable metrics.">DistanceTransformation</a> method:</p>
<div class="image">
<img src="DTmetrics-small.png" alt=""/>
<div class="caption">
Distance maps for metrics L_1, L_2, L_4, L_80 and Chamfer masks M_{3−4} and M_{5−7−11}.</div></div>
 <p>For a complete discussion of metric concepts in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>, please refer to <a class="el" href="moduleMetrics.html">Metric Spaces, Digital Metric Spaces and Related Concepts</a>.</p>
<h1><a class="anchor" id="voronoiSect"></a>
Digital Voronoi Diagram Computation</h1>
<p>The generic distance transformation is based on a prior Voronoi map construction. Indeed, if we compute the Voronoi diagram of background points, the distance transformation at an object point is exactly its distance to the site associated with the Voronoi cell it belongs to.</p>
<p>The core of the implementation is based on a separable approach: For example, in dimension 2, partial digital Voronoi maps of dimension one are first computed in each row independently. Then such partial Voronoi maps are updated using independent processes along the columns, leading to a valid Voronoi map of dimension 2. In an algorithmic point of view, the 1D processes used for both columns and rows are the same. In higher dimensions, the other dimensions are processed similarly.</p>
<dl class="section note"><dt>Note</dt><dd>We say digital Voronoi map instead of Voronoi diagram since the output of the result is the intersection between the Voronoi diagram of exterior points with \( \mathbb{Z}^d \). Furthermore, along Voronoi faces (<em>e.i</em>. when two sites are equidistant), only one sites is considered when intersection with \( \mathbb{Z}^d \).</dd></dl>
<p>In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>, the class <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a> implements such digital Vornoi map extraction. Such class is parametrized by the following types:</p><ul>
<li>a type representing the underlying digital space (model of CSpace);</li>
<li>a type representing the object \( X \) as a point predicate (model of <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">concepts::CPointPredicate</a>) ;</li>
<li>a type representing the underlying metric (model of CSeparableMetric, see below)</li>
<li>and an optional image container to store the resulting Voronoi map (by default, the type is <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>&lt;HyperRectDomain&lt;TSpace&gt;,typename TSpace::Vector&gt;).</li>
</ul>
<p>The <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a> constructor is parametrized by</p><ul>
<li>an instance of Domain (the Domain type associated with the image container);</li>
<li>an instance of the PointPredicate ;</li>
<li>and an instance of the separable metric.</li>
</ul>
<p>The <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a> will be computed on the specified and will use the point predicate to decide if a point of such domain is in the object or note.</p>
<dl class="section warning"><dt>Warning</dt><dd>The point predicate must be valid for each point in the specified domain. Basically, the domain can a sub-domain of the point predicate definition domain.</dd></dl>
<p>Once the <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a> object is created, the voronoi map is computed and the class itself is a model of CConstImage. In other words, you can access to the <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a> value at a point <em>p</em> and iterate of values using image ranges (see <a class="el" href="moduleImages.html">Images</a>). For example</p>
<div class="fragment"><div class="line">VoronoiMap&lt;....&gt; myVoronoiMap( .... ); <span class="comment">//object construction</span></div>
<div class="line">VoronoiMap&lt;....&gt;<a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">::Point</a> p(12,34);</div>
<div class="line"> </div>
<div class="line">VoronoiMap&lt;....&gt;<a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">::Value</a> vectorToClosestSiteAtP = myVoronoiMap( p );</div>
<div class="line"><span class="keywordflow">for</span>(<a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">VoronoiMap&lt;....&gt;::Domain::ConstIterator</a> it  = myVoronoiMap.domain().begin() , itend = myVoronoiMap.domain().end();</div>
<div class="line">it != itend ; ++it)</div>
<div class="line">     <span class="comment">//do something on myVoronoiMap(it)</span></div>
</div><!-- fragment --><p>Since we are constructing a <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a>, the value type of the map is a vector (pointing to the closest site) of type <a class="el" href="classDGtal_1_1SpaceND.html#ae194f4dfc28465ea14b437c066e69604" title="Vectors in DGtal::SpaceND.">Space::Vector</a> (if Space was the underlying digital space type used when specifying <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a> template parameters).</p>
<p>Let us illustrate the construction in dimension 2 (see <a class="el" href="voronoimap2D_8cpp.html">voronoimap2D.cpp</a>). Other examples can be found in <a class="el" href="distancetransform2D_8cpp.html">distancetransform2D.cpp</a> and <a class="el" href="distancetransform3D_8cpp.html">distancetransform3D.cpp</a>.</p>
<p>First of all, we need couple of includes:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/kernel/BasicPointPredicates.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/images/SimpleThresholdForegroundPredicate.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/volumes/distance/ExactPredicateLpSeparableMetric.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/volumes/distance/VoronoiMap.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/volumes/distance/DistanceTransformation.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/io/colormaps/HueShadeColorMap.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/io/boards/Board2D.h&quot;</span></div>
</div><!-- fragment --><p> We will discuss later about the metric definition but let us consider a classical Euclidean \( l_2 \) metric:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ExactPredicateLpSeparableMetric&lt;Z2i::Space, 2&gt; <a class="code" href="namespaceDGtal_1_1Z2i.html#a5334b5612687982f0154e4ee8f5dd93d">L2Metric</a>;</div>
<div class="line">  <a class="code" href="namespaceDGtal_1_1Z2i.html#a5334b5612687982f0154e4ee8f5dd93d">L2Metric</a> l2;</div>
</div><!-- fragment --><p> We now consider an object in a [0,0]x[16,16] domain with three background points. To construct such point predicate, we first define a set containing the three points, then we consider the point predicate defined on this set (which returns true at a point if the point is inside the set) and we consider the negation of such predicate in order to return true for object points. Here you have the construction:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a> <a class="code" href="viewDualSurface_8cpp.html#a4b98c5389a8b08039179fe01b21c9ce7">lower</a>(0,0);</div>
<div class="line">  <a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a> <a class="code" href="viewDualSurface_8cpp.html#a91ad5a18fccee11320ecff413bb13b16">upper</a>(16,16);</div>
<div class="line">  <a class="code" href="namespaceDGtal_1_1Z2i.html#aca523bebdae58eb19385aaefffff8bc5">Z2i::Domain</a> <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>(<a class="code" href="viewDualSurface_8cpp.html#a4b98c5389a8b08039179fe01b21c9ce7">lower</a>,<a class="code" href="viewDualSurface_8cpp.html#a91ad5a18fccee11320ecff413bb13b16">upper</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespaceDGtal_1_1Z2i.html#a371252c324e496cf8650757c1a2b4eb0">Z2i::DigitalSet</a> set(<a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>);</div>
<div class="line">  set.insertNew(<a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(2,3));</div>
<div class="line">  set.insertNew(<a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(7,15));</div>
<div class="line">  set.insertNew(<a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a>(12,5));</div>
<div class="line">  Board2D board;</div>
<div class="line"> </div>
<div class="line">  board&lt;&lt; <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a> &lt;&lt; set;</div>
<div class="line">  board.saveSVG(<span class="stringliteral">&quot;voronoimap-inputset.svg&quot;</span>);</div>
</div><!-- fragment --><p> and the resulting set:</p>
<div class="image">
<img src="voronoimap-inputset.png" alt=""/>
<div class="caption">
Input set.</div></div>
 <p>The voronoi map is simply given by:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> VoronoiMap&lt;Z2i::Space, NotPredicate, L2Metric &gt; Voronoi2D;</div>
<div class="line">  Voronoi2D voronoimap(<a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>,notSetPred,l2);</div>
</div><!-- fragment --><p> At each point of the object, we thus have a vector to the closest background point. We can display this information as follows:</p>
<div class="fragment"><div class="line">  board.clear();</div>
<div class="line">  board &lt;&lt; <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>;</div>
<div class="line">  <span class="keywordflow">for</span>(<a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">Voronoi2D::Domain::ConstIterator</a> it = voronoimap.domain().begin(),</div>
<div class="line">      itend = voronoimap.domain().end(); it != itend; ++it)</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Voronoi2D::Value</a> site = voronoimap( *it );   <span class="comment">//closest site to (*it)</span></div>
<div class="line">    <span class="keywordflow">if</span> (site != (*it))</div>
<div class="line">      <a class="code" href="structDGtal_1_1Display2DFactory.html#a22bc78a987ac67e708111902eae1c698">Display2DFactory::draw</a>( board,   site - (*it), (*it)); <span class="comment">//Draw an arrow</span></div>
<div class="line">  }</div>
<div class="line">  board.saveSVG(<span class="stringliteral">&quot;voronoimap-voro.svg&quot;</span>);</div>
</div><!-- fragment --><p> To obtain:</p>
<div class="image">
<img src="voronoimap-voro.png" alt=""/>
<div class="caption">
Voronoi map.</div></div>
 <p>Changing the board output, we can see the Voronoi cells accordingly:</p>
<div class="fragment"><div class="line">  board.clear();</div>
<div class="line">  <span class="keywordflow">for</span>(<a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">Voronoi2D::Domain::ConstIterator</a> it = voronoimap.domain().begin(),</div>
<div class="line">      itend = voronoimap.domain().end(); it != itend; ++it)</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Voronoi2D::Value</a> site = voronoimap( *it );   <span class="comment">//closest site to (*it)</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c = (site[1]*13 + site[0] * 7) % 256; <span class="comment">//basic hashfunction</span></div>
<div class="line">    board &lt;&lt; CustomStyle( (*it).className(), <span class="keyword">new</span> CustomColors(Color(c,c,c),Color(c,c,c)))</div>
<div class="line">      &lt;&lt; (*it);</div>
<div class="line">  }</div>
<div class="line">  board.saveSVG(<span class="stringliteral">&quot;voronoimap-cells.svg&quot;</span>);</div>
</div><!-- fragment --><p> To get:</p>
<div class="image">
<img src="voronoimap-cells.png" alt=""/>
<div class="caption">
Voronoi map cells.</div></div>
 <p>We could easily change the metric (here to the \( l_8 \)) and get a new Voronoi map: </p><div class="fragment"><div class="line">  <span class="keyword">typedef</span> ExactPredicateLpSeparableMetric&lt;Z2i::Space, 8&gt; L8Metric;</div>
<div class="line">  L8Metric l8;</div>
<div class="line">  <span class="keyword">typedef</span> VoronoiMap&lt;Z2i::Space, NotPredicate, L8Metric &gt; Voronoi2D_l8;</div>
<div class="line">  Voronoi2D_l8 voronoimap_l8(<a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>,notSetPred,l8);</div>
<div class="line">  board.clear();</div>
<div class="line">  board &lt;&lt; <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>;</div>
<div class="line">  <span class="keywordflow">for</span>(<a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">Voronoi2D_l8::Domain::ConstIterator</a> it = voronoimap_l8.domain().begin(),</div>
<div class="line">      itend = voronoimap_l8.domain().end(); it != itend; ++it)</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Voronoi2D::Value</a> site = voronoimap_l8( *it );   <span class="comment">//closest site to (*it)</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c = (site[1]*13 + site[0] * 7) % 256; <span class="comment">//basic hashfunction</span></div>
<div class="line">    board &lt;&lt; CustomStyle( (*it).className(), <span class="keyword">new</span> CustomColors(Color(c,c,c),Color(c,c,c)))</div>
<div class="line">          &lt;&lt; (*it);</div>
<div class="line">  }</div>
<div class="line">  board.saveSVG(<span class="stringliteral">&quot;voronoimap-vorol8.svg&quot;</span>);</div>
</div><!-- fragment --> <div class="image">
<img src="voronoimap-vorol8.png" alt=""/>
<div class="caption">
Voronoi map for the l_8 metric.</div></div>
 <h1><a class="anchor" id="DTsec"></a>
Distance Transformation</h1>
<p>As discussed earlier, the distance transformation is given by computing distances once the Voronoi map is obtained. In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>, the class <a class="el" href="classDGtal_1_1DistanceTransformation.html" title="Aim: Implementation of the linear in time distance transformation for separable metrics.">DistanceTransformation</a> simply adapts the <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a> class in order to override output image getters to return the distance for the given metric to the closest site instead of the vector.</p>
<p>As a consequence, the <a class="el" href="classDGtal_1_1DistanceTransformation.html" title="Aim: Implementation of the linear in time distance transformation for separable metrics.">DistanceTransformation</a> class simply inherits from the <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a> class and overrides methods required by the <a class="el" href="structDGtal_1_1concepts_1_1CConstImage.html" title="Aim: Defines the concept describing a read-only image, which is a refinement of CPointFunctor.">concepts::CConstImage</a> concept. Note that the <a class="el" href="classDGtal_1_1DistanceTransformation.html#ad5d8165d97bfb5e9dc3f0411949733d5" title="Definition of the image value type.">DistanceTransformation::Value</a> type is double. If you want to get the underlying vector instead of the distance to perform exact computations, you can use the <a class="el" href="classDGtal_1_1DistanceTransformation.html#a8ef8a9c5be72cba265ac6b6fad444400">DistanceTransformation::getVoronoiVector</a> method.</p>
<p>In the following example, we consider the previous small image and use a colormap to display distance values for the \( l_2 \) mertic:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> DistanceTransformation&lt;Z2i::Space, NotPredicate, L2Metric &gt; DT;</div>
<div class="line">  DT dt(<a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>,notSetPred,l2);</div>
<div class="line">  board.clear();</div>
<div class="line">  board &lt;&lt; <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Fast max computation on the range value</span></div>
<div class="line">  <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">DT::Value</a> maxDT=0.0;</div>
<div class="line">  <span class="keywordflow">for</span>(<a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">DT::ConstRange::ConstIterator</a> it = dt.constRange().begin(), itend = dt.constRange().end();</div>
<div class="line">      it != itend ; ++it)</div>
<div class="line">    <span class="keywordflow">if</span> ((*it)&gt;maxDT) maxDT = (*it);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Colormap</span></div>
<div class="line">  HueShadeColorMap&lt;DT::Value,1&gt; hueMap(0.0,maxDT);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Drawing</span></div>
<div class="line">  <span class="keywordflow">for</span>(<a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">DT::Domain::ConstIterator</a> it = dt.domain().begin(),</div>
<div class="line">      itend = dt.domain().end(); it != itend; ++it)</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">DT::Value</a> dist = dt( *it );   <span class="comment">//distance to closest site to (*it)</span></div>
<div class="line">    board &lt;&lt; CustomStyle( (*it).className(), <span class="keyword">new</span> CustomColors( hueMap(dist), hueMap(dist)))</div>
<div class="line">          &lt;&lt; (*it);</div>
<div class="line">  }</div>
<div class="line">  board.saveSVG(<span class="stringliteral">&quot;voronoimap-dt.svg&quot;</span>);</div>
</div><!-- fragment --> <div class="image">
<img src="voronoimap-dt.png" alt=""/>
<div class="caption">
Distance transformation for the l_2 metric.</div></div>
 <h1><a class="anchor" id="RDTSec"></a>
Digital Power Map and Reverse Distance Transformation</h1>
<p>Similarly to Voronoi diagram and digital Voronoi maps, digital Power maps are defined as the intersection between the integer grid and a power diagram. Given a set of weighed points, power diagram can be seen as Voronoi diagram where the metric is modified with additive weights. For example, considering the \( l_2\) metric, the power distance between a point \(p\) and a weighted point \((q,w)\) is defined by </p><p class="formulaDsp">
\[ pow(p,q) = \| p - q\|_2^2 - w \]
</p>
<p>Hence, similarly to Voronoi diagram, the power diagram is a decomposition of the space ino cells from weighed sites where each cell (maybe empty) is associated with a site and each point in the cell has got minimal power distance to the cell site (compared to its power distance to all other sites) <a class="el" href="citelist.html#CITEREF_Aurenhammer1987">[7]</a> .</p>
<p>Separable algorithms similar to VoronoiMap/DistanceTransformation can be designed to compute respectively <a class="el" href="classDGtal_1_1PowerMap.html" title="Aim: Implementation of the linear in time Power map construction.">PowerMap</a> and <a class="el" href="classDGtal_1_1ReverseDistanceTransformation.html" title="Aim: Implementation of the linear in time reverse distance transformation for separable metrics.">ReverseDistanceTransformation</a>. The only difference is that the input of <a class="el" href="classDGtal_1_1PowerMap.html" title="Aim: Implementation of the linear in time Power map construction.">PowerMap</a> is a weighted set of points instead of a point predicate.</p>
<dl class="section note"><dt>Note</dt><dd>for \(l_p\) metrics, the power distance is defined by \( pow(p,q) = \| p - q\|_p^p - w \). Hence, both the distance and the weight value type capacity must be able to represent d-sums of power p numbers (if d is the dimension of the space).</dd></dl>
<p>Hence such class is parametrized by the following types:</p><ul>
<li>a type representing the mapping between points and weights (WeightImage, model of <a class="el" href="structDGtal_1_1concepts_1_1CImage.html" title="Aim: Defines the concept describing a read/write image, having an output iterator.">concepts::CImage</a>);</li>
<li>a type representing the underlying power metric (model of <a class="el" href="structDGtal_1_1concepts_1_1CPowerSeparableMetric.html" title="Aim: defines the concept of separable metrics.">concepts::CPowerSeparableMetric</a>, see below)</li>
<li>and an optional image container to store the resulting Power map (by default, the type is <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>).</li>
</ul>
<p>The <a class="el" href="classDGtal_1_1PowerMap.html" title="Aim: Implementation of the linear in time Power map construction.">PowerMap</a> constructor is parametrized by</p><ul>
<li>an instance of Domain (the Domain type associated with the image container);</li>
<li>an instance of <a class="el" href="classDGtal_1_1PowerMap.html#a96d646a0a331d6d6c3c2075bf4fa1a44" title="Copy of the distance image types.">PowerMap::WeightImage</a>;</li>
<li>and an instance of the power separable metric.</li>
</ul>
<p>Similarly to <a class="el" href="classDGtal_1_1DistanceTransformation.html" title="Aim: Implementation of the linear in time distance transformation for separable metrics.">DistanceTransformation</a>, <a class="el" href="classDGtal_1_1ReverseDistanceTransformation.html" title="Aim: Implementation of the linear in time reverse distance transformation for separable metrics.">ReverseDistanceTransformation</a> remaps the <a class="el" href="classDGtal_1_1PowerMap.html" title="Aim: Implementation of the linear in time Power map construction.">PowerMap</a> vectors to map the power metric to the closest weighted site.</p>
<p>As a consequence, for the Euclidean \( l_2 \) metric, if we consider a set of balls \( B_i(p_i,r_i) \) and if we create an WeightImage whose domain contains points \(\{ p_i \}\) and with values \( r_i^2\), negative (strictly) values of the <a class="el" href="classDGtal_1_1ReverseDistanceTransformation.html" title="Aim: Implementation of the linear in time reverse distance transformation for separable metrics.">ReverseDistanceTransformation</a> will correspond to digital points belonging to the union \( \bigcup \{B_i\}\) (see <a class="el" href="citelist.html#CITEREF_dcoeurjo_pami_RDMA">[23]</a>).</p>
<p><a class="el" href="classDGtal_1_1ReverseDistanceTransformation.html" title="Aim: Implementation of the linear in time reverse distance transformation for separable metrics.">ReverseDistanceTransformation</a> can thus be used to reconstructed a binary shape from a given Medial Axis or any set of balls. Another consequence is that given a binary shape, the pipeline </p><p class="formulaDsp">
\[ Shape \rightarrow DT \rightarrow ReverseDT \rightarrow \text{ strictly negative values }\]
</p>
<p> for the same metric/power metric, returns the input binary shape.</p>
<dl class="section note"><dt>Note</dt><dd>Power separable metrics are formalized in <a class="el" href="structDGtal_1_1concepts_1_1CPowerMetric.html" title="Aim: defines the concept of special weighted metrics, so called power metrics.">concepts::CPowerMetric</a> and <a class="el" href="structDGtal_1_1concepts_1_1CPowerSeparableMetric.html" title="Aim: defines the concept of separable metrics.">concepts::CPowerSeparableMetric</a> concepts whose main model is <a class="el" href="classDGtal_1_1ExactPredicateLpPowerSeparableMetric.html" title="Aim: implements weighted separable l_p metrics with exact predicates.">ExactPredicateLpPowerSeparableMetric</a>, see <a class="el" href="moduleMetrics.html">Metric Spaces, Digital Metric Spaces and Related Concepts</a></dd></dl>
<h1><a class="anchor" id="toricVol"></a>
Volumetric Analysis on Toric domains</h1>
<p>In some specific applications, toric domains and volumetric analysis of shapes in toric domains are crucial. Thanks to the separability property of <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a>, <a class="el" href="classDGtal_1_1PowerMap.html" title="Aim: Implementation of the linear in time Power map construction.">PowerMap</a> (and their associated wrappers <a class="el" href="classDGtal_1_1DistanceTransformation.html" title="Aim: Implementation of the linear in time distance transformation for separable metrics.">DistanceTransformation</a> and <a class="el" href="classDGtal_1_1ReverseDistanceTransformation.html" title="Aim: Implementation of the linear in time reverse distance transformation for separable metrics.">ReverseDistanceTransformation</a>), one can easily consider volumetric transformation in arbitrary dimension on toric domains <a class="el" href="citelist.html#CITEREF_Coeurjo2008">[30]</a>. Note that changing the periodicity property of the domain has no impact on the computational cost.</p>
<p>More precisely, <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a> and <a class="el" href="classDGtal_1_1DistanceTransformation.html" title="Aim: Implementation of the linear in time distance transformation for separable metrics.">DistanceTransformation</a> classes have constructors allowing to specify periodicity information. In dimension <em>d</em>, such periodicity information is an array with <em>d</em> boolean flags where the i-th value is <code>true</code> if the i-th dimension of the space is periodic, <code>false</code> otherwise. Hence, computation can be performed either on a full toric domain, or on a domain with toricity property along only one axis. Similar extensions to toric domains have been implemented for the <a class="el" href="classDGtal_1_1PowerMap.html" title="Aim: Implementation of the linear in time Power map construction.">PowerMap</a> and <a class="el" href="classDGtal_1_1ReverseDistanceTransformation.html" title="Aim: Implementation of the linear in time reverse distance transformation for separable metrics.">ReverseDistanceTransformation</a> classes.</p>
<p>As illustrated in the example <a class="el" href="toricdomainvolumetric_8cpp.html">toricdomainvolumetric.cpp</a>, given an input:</p>
<div class="image">
<img src="toric-inputShape-red.png" alt=""/>
<div class="caption">
Input domain and sites.</div></div>
<p>We consider the following distance transformation objects:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span>  DistanceTransformation&lt;Space, PointPredicate, L2Metric&gt; DTL2;</div>
<div class="line">  <span class="keyword">typedef</span>  DistanceTransformation&lt;Space, PointPredicate, L2Metric&gt; DTL2Toric;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Regular 2D domain</span></div>
<div class="line">  DTL2 dtL2(image.domain(), predicate, l2Metric);</div>
<div class="line">  <span class="comment">//Full toric 2D domain</span></div>
<div class="line">  DTL2Toric dtL2Toric(image.domain(), predicate, l2Metric, {{true, true}} );</div>
</div><!-- fragment --><p> The following results illustrate both distance transformation and Voronoi maps. For the <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a> results, points may be attached to sites exterior to the initial domain. In fact such sites correspond to toric replicas of existing sites within the domain.</p>
<center> <table class="doxtable">
<tr>
<td align="center">Classical domain  </td><td align="center">Toric domain   </td></tr>
<tr>
<td><div class="image">
<img src="toric-example-DT-L2-red.png" alt=""/>
<div class="caption">
DT values.</div></div>
  </td><td><div class="image">
<img src="toric-example-DT-L2-toric-red.png" alt=""/>
<div class="caption">
Toric DT values.</div></div>
   </td></tr>
<tr>
<td><div class="image">
<img src="toric-example-Voro-L2-red.png" alt=""/>
<div class="caption">
Voronoi map as vectors.</div></div>
  </td><td><div class="image">
<img src="toric-example-Voro-L2-toric-red.png" alt=""/>
<div class="caption">
Voronoi map as vectors.</div></div>
   </td></tr>
</table>
</center><p>Using <a class="el" href="classDGtal_1_1VoronoiMap.html#ad78b1adc3579482496ed4a3bf7b33087">VoronoiMap::projectPoint(Point) const</a>, site's coordinates can be projected into the initial domain, even for <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a> calculated on toric domains:</p>
<div class="image">
<img src="toric-example-Voro-L2-toric-projected.png" alt=""/>
<div class="caption">
Voronoi map on toric domain with projected sites.</div></div>
<p>With partial periodicity specification (along the first or second dimension only):</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span>  DistanceTransformation&lt;Space, PointPredicate, L2Metric&gt; DTL2ToricX;</div>
<div class="line">  <span class="keyword">typedef</span>  DistanceTransformation&lt;Space, PointPredicate, L2Metric&gt; DTL2ToricY;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 2D domain that is periodic along the first dimension.</span></div>
<div class="line">  DTL2ToricX dtL2ToricX( image.domain(), predicate, l2Metric, {{true,  false}} );</div>
<div class="line">  <span class="comment">// 2D domain that is periodic along the second dimension.</span></div>
<div class="line">  DTL2ToricY dtL2ToricY( image.domain(), predicate, l2Metric, {{false, true}} );</div>
</div><!-- fragment --><p> we obtain the following <a class="el" href="classDGtal_1_1VoronoiMap.html" title="Aim: Implementation of the linear in time Voronoi map construction.">VoronoiMap</a>:</p>
<center> <table class="doxtable">
<tr>
<td align="center">Periodic domain along the 1th dimension.  </td><td align="center">Periodic domain along the 2th dimension.   </td></tr>
<tr>
<td><div class="image">
<img src="toric-example-DT-L2-toricX-red.png" alt=""/>
<div class="caption">
DT values.</div></div>
  </td><td><div class="image">
<img src="toric-example-DT-L2-toricY-red.png" alt=""/>
<div class="caption">
DT values.</div></div>
   </td></tr>
<tr>
<td><div class="image">
<img src="toric-example-Voro-L2-toricX-red.png" alt=""/>
<div class="caption">
Voronoi map as vectors.</div></div>
  </td><td><div class="image">
<img src="toric-example-Voro-L2-toricY-red.png" alt=""/>
<div class="caption">
Voronoi map as vectors.</div></div>
   </td></tr>
</table>
</center> </div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="agreedy-plane-segmentation-ex2_8cpp_html_a6d06fad433cff067dfcbbbf16d6e2dbf"><div class="ttname"><a href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a></div><div class="ttdeci">MyDigitalSurface::ConstIterator ConstIterator</div><div class="ttdef"><b>Definition:</b> <a href="greedy-plane-segmentation-ex2_8cpp_source.html#l00093">greedy-plane-segmentation-ex2.cpp:93</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z2i_html_ac0a04516c81db6f4a583eddda0f64875"><div class="ttname"><a href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">DGtal::Z2i::Point</a></div><div class="ttdeci">Space::Point Point</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00095">StdDefs.h:95</a></div></div>
<div class="ttc" id="aviewDualSurface_8cpp_html_a4b98c5389a8b08039179fe01b21c9ce7"><div class="ttname"><a href="viewDualSurface_8cpp.html#a4b98c5389a8b08039179fe01b21c9ce7">lower</a></div><div class="ttdeci">Vector lower(const Vector &amp;z, unsigned int k)</div><div class="ttdef"><b>Definition:</b> <a href="viewDualSurface_8cpp_source.html#l00190">viewDualSurface.cpp:190</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z2i_html_a371252c324e496cf8650757c1a2b4eb0"><div class="ttname"><a href="namespaceDGtal_1_1Z2i.html#a371252c324e496cf8650757c1a2b4eb0">DGtal::Z2i::DigitalSet</a></div><div class="ttdeci">DigitalSetSelector&lt; Domain, BIG_DS+HIGH_BEL_DS &gt;::Type DigitalSet</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00100">StdDefs.h:100</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z2i_html_aca523bebdae58eb19385aaefffff8bc5"><div class="ttname"><a href="namespaceDGtal_1_1Z2i.html#aca523bebdae58eb19385aaefffff8bc5">DGtal::Z2i::Domain</a></div><div class="ttdeci">HyperRectDomain&lt; Space &gt; Domain</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00099">StdDefs.h:99</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z2i_html_a5334b5612687982f0154e4ee8f5dd93d"><div class="ttname"><a href="namespaceDGtal_1_1Z2i.html#a5334b5612687982f0154e4ee8f5dd93d">DGtal::Z2i::L2Metric</a></div><div class="ttdeci">ExactPredicateLpSeparableMetric&lt; Space, 2 &gt; L2Metric</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00118">StdDefs.h:118</a></div></div>
<div class="ttc" id="aviewDualSurface_8cpp_html_a91ad5a18fccee11320ecff413bb13b16"><div class="ttname"><a href="viewDualSurface_8cpp.html#a91ad5a18fccee11320ecff413bb13b16">upper</a></div><div class="ttdeci">Vector upper(const Vector &amp;z, unsigned int k)</div><div class="ttdef"><b>Definition:</b> <a href="viewDualSurface_8cpp_source.html#l00197">viewDualSurface.cpp:197</a></div></div>
<div class="ttc" id="atestProjection_8cpp_html_a1f1a69f8d8b037b72c2160ed12b3ef51"><div class="ttname"><a href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a></div><div class="ttdeci">Domain domain</div><div class="ttdef"><b>Definition:</b> <a href="testProjection_8cpp_source.html#l00088">testProjection.cpp:88</a></div></div>
<div class="ttc" id="atestClone2_8cpp_html_a15e9592ccc512dc691b46185e6814758"><div class="ttname"><a href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a></div><div class="ttdeci">MyPointD Point</div><div class="ttdef"><b>Definition:</b> <a href="testClone2_8cpp_source.html#l00383">testClone2.cpp:383</a></div></div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_a566a00621638570a4186414035153a2e"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Value</a></div><div class="ttdeci">double Value</div><div class="ttdef"><b>Definition:</b> <a href="testSimpleRandomAccessRangeFromPoint_8cpp_source.html#l00041">testSimpleRandomAccessRangeFromPoint.cpp:38</a></div></div>
<div class="ttc" id="astructDGtal_1_1Display2DFactory_html_a22bc78a987ac67e708111902eae1c698"><div class="ttname"><a href="structDGtal_1_1Display2DFactory.html#a22bc78a987ac67e708111902eae1c698">DGtal::Display2DFactory::draw</a></div><div class="ttdeci">static void draw(DGtal::Board2D &amp;board, const DGtal::DiscreteExteriorCalculus&lt; dimEmbedded, dimAmbient, TLinearAlgebraBackend, TInteger &gt; &amp;calculus)</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 6 2020 14:17:02 for DGtal by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
