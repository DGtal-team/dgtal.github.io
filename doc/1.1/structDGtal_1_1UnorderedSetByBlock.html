<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: DGtal::UnorderedSetByBlock&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceDGtal.html">DGtal</a></li><li class="navelem"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">UnorderedSetByBlock</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">DGtal::UnorderedSetByBlock&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="UnorderedSetByBlock_8h_source.html">DGtal/kernel/UnorderedSetByBlock.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DGtal::UnorderedSetByBlock&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structDGtal_1_1UnorderedSetByBlock__inherit__graph.svg" width="664" height="106"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for DGtal::UnorderedSetByBlock&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="structDGtal_1_1UnorderedSetByBlock__coll__graph.svg" width="100%" height="445"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read iterator on set elements. Model of ForwardIterator.  <a href="structDGtal_1_1UnorderedSetByBlock_1_1const__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-write iterator on set elements. Model of ForwardIterator.  <a href="structDGtal_1_1UnorderedSetByBlock_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad69ca22ee7fd9bb7a6385e76b6c034fd"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a></td></tr>
<tr class="separator:ad69ca22ee7fd9bb7a6385e76b6c034fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eab7bcf309c1ea810e7df623b0320fc"><td class="memItemLeft" align="right" valign="top">typedef TSplitter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a8eab7bcf309c1ea810e7df623b0320fc">Splitter</a></td></tr>
<tr class="separator:a8eab7bcf309c1ea810e7df623b0320fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2077e466982b6f25254da3c6184f72"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structDGtal_1_1Splitter.html#aada48987ba3ea394ce8421b8fbb3f18d">Splitter::Word</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a></td></tr>
<tr class="separator:a3c2077e466982b6f25254da3c6184f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb762841d653042309d681277291eec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structDGtal_1_1Splitter.html#a587fa8c5c9f8f6a01e3062794886fdda">Splitter::Coordinate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a3cb762841d653042309d681277291eec">Coordinate</a></td></tr>
<tr class="separator:a3cb762841d653042309d681277291eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561198be4a7c19c479f0da673628c398"><td class="memItemLeft" align="right" valign="top">typedef std::unordered_map&lt; Key, <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a>, Hash, KeyEqual, UnorderedMapAllocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a561198be4a7c19c479f0da673628c398">Container</a></td></tr>
<tr class="memdesc:a561198be4a7c19c479f0da673628c398"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying container, an unordered_map.  <a href="structDGtal_1_1UnorderedSetByBlock.html#a561198be4a7c19c479f0da673628c398">More...</a><br /></td></tr>
<tr class="separator:a561198be4a7c19c479f0da673628c398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0bc17410f081981da167948f950b9d"><td class="memItemLeft" align="right" valign="top">typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a1d0bc17410f081981da167948f950b9d">key_type</a></td></tr>
<tr class="memdesc:a1d0bc17410f081981da167948f950b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key.  <a href="structDGtal_1_1UnorderedSetByBlock.html#a1d0bc17410f081981da167948f950b9d">More...</a><br /></td></tr>
<tr class="separator:a1d0bc17410f081981da167948f950b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefa12789190556f7acc466b82e7c58a"><td class="memItemLeft" align="right" valign="top">typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#adefa12789190556f7acc466b82e7c58a">value_type</a></td></tr>
<tr class="memdesc:adefa12789190556f7acc466b82e7c58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key.  <a href="structDGtal_1_1UnorderedSetByBlock.html#adefa12789190556f7acc466b82e7c58a">More...</a><br /></td></tr>
<tr class="separator:adefa12789190556f7acc466b82e7c58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad170ff228e1814348e1139bb9277eb0d"><td class="memItemLeft" align="right" valign="top">typedef Container::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a></td></tr>
<tr class="memdesc:ad170ff228e1814348e1139bb9277eb0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type (usually std::size_t)  <a href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">More...</a><br /></td></tr>
<tr class="separator:ad170ff228e1814348e1139bb9277eb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c10b467d0ff0a879bd043b54b68324d"><td class="memItemLeft" align="right" valign="top">typedef Container::difference_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a8c10b467d0ff0a879bd043b54b68324d">difference_type</a></td></tr>
<tr class="memdesc:a8c10b467d0ff0a879bd043b54b68324d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type (usually std::ptrdiff_t)  <a href="structDGtal_1_1UnorderedSetByBlock.html#a8c10b467d0ff0a879bd043b54b68324d">More...</a><br /></td></tr>
<tr class="separator:a8c10b467d0ff0a879bd043b54b68324d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00baafce323046c26f3f9632a0bba1f3"><td class="memItemLeft" align="right" valign="top">typedef Hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a00baafce323046c26f3f9632a0bba1f3">hasher</a></td></tr>
<tr class="memdesc:a00baafce323046c26f3f9632a0bba1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash.  <a href="structDGtal_1_1UnorderedSetByBlock.html#a00baafce323046c26f3f9632a0bba1f3">More...</a><br /></td></tr>
<tr class="separator:a00baafce323046c26f3f9632a0bba1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeefb663d6313fbd8ecf06d07b410fab"><td class="memItemLeft" align="right" valign="top">typedef KeyEqual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#adeefb663d6313fbd8ecf06d07b410fab">key_equal</a></td></tr>
<tr class="memdesc:adeefb663d6313fbd8ecf06d07b410fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">KeyEqual.  <a href="structDGtal_1_1UnorderedSetByBlock.html#adeefb663d6313fbd8ecf06d07b410fab">More...</a><br /></td></tr>
<tr class="separator:adeefb663d6313fbd8ecf06d07b410fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03d1dc9713238a70482826a90c27a87"><td class="memItemLeft" align="right" valign="top">typedef Container::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ac03d1dc9713238a70482826a90c27a87">allocator_type</a></td></tr>
<tr class="memdesc:ac03d1dc9713238a70482826a90c27a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator.  <a href="structDGtal_1_1UnorderedSetByBlock.html#ac03d1dc9713238a70482826a90c27a87">More...</a><br /></td></tr>
<tr class="separator:ac03d1dc9713238a70482826a90c27a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d4519a05eb99a4fd365c99a830a93b"><td class="memItemLeft" align="right" valign="top">typedef Key &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a59d4519a05eb99a4fd365c99a830a93b">reference</a></td></tr>
<tr class="memdesc:a59d4519a05eb99a4fd365c99a830a93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to value_type/Key.  <a href="structDGtal_1_1UnorderedSetByBlock.html#a59d4519a05eb99a4fd365c99a830a93b">More...</a><br /></td></tr>
<tr class="separator:a59d4519a05eb99a4fd365c99a830a93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2d06b4e3b6094bde2f5a1a01425888"><td class="memItemLeft" align="right" valign="top">typedef const Key &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#abf2d06b4e3b6094bde2f5a1a01425888">const_reference</a></td></tr>
<tr class="memdesc:abf2d06b4e3b6094bde2f5a1a01425888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const reference to value_type/Key.  <a href="structDGtal_1_1UnorderedSetByBlock.html#abf2d06b4e3b6094bde2f5a1a01425888">More...</a><br /></td></tr>
<tr class="separator:abf2d06b4e3b6094bde2f5a1a01425888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7554458e1f8bba6235486503dd8befc4"><td class="memItemLeft" align="right" valign="top">typedef Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a7554458e1f8bba6235486503dd8befc4">pointer</a></td></tr>
<tr class="memdesc:a7554458e1f8bba6235486503dd8befc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to value_type/Key.  <a href="structDGtal_1_1UnorderedSetByBlock.html#a7554458e1f8bba6235486503dd8befc4">More...</a><br /></td></tr>
<tr class="separator:a7554458e1f8bba6235486503dd8befc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2e25fb919ff9133032c63a7320b99f"><td class="memItemLeft" align="right" valign="top">typedef const Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#aad2e25fb919ff9133032c63a7320b99f">const_pointer</a></td></tr>
<tr class="memdesc:aad2e25fb919ff9133032c63a7320b99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const Pointer to value_type/Key.  <a href="structDGtal_1_1UnorderedSetByBlock.html#aad2e25fb919ff9133032c63a7320b99f">More...</a><br /></td></tr>
<tr class="separator:aad2e25fb919ff9133032c63a7320b99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Standard services (construction, initialization, assignment)</div></td></tr>
<tr class="memitem:acecd7108cebad4b50eeb491ffec4f7a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#acecd7108cebad4b50eeb491ffec4f7a0">UnorderedSetByBlock</a> (<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a> bucket_count=23, const <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a8eab7bcf309c1ea810e7df623b0320fc">Splitter</a> &amp;splitter=<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a8eab7bcf309c1ea810e7df623b0320fc">Splitter</a>(), const Hash &amp;hash=Hash(), const <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#adeefb663d6313fbd8ecf06d07b410fab">key_equal</a> &amp;equal=<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#adeefb663d6313fbd8ecf06d07b410fab">key_equal</a>(), const UnorderedMapAllocator &amp;alloc=UnorderedMapAllocator())</td></tr>
<tr class="separator:acecd7108cebad4b50eeb491ffec4f7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163d61323a33d57bad4a03015568a434"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a163d61323a33d57bad4a03015568a434">~UnorderedSetByBlock</a> ()=default</td></tr>
<tr class="memdesc:a163d61323a33d57bad4a03015568a434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="structDGtal_1_1UnorderedSetByBlock.html#a163d61323a33d57bad4a03015568a434">More...</a><br /></td></tr>
<tr class="separator:a163d61323a33d57bad4a03015568a434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e01ec5b64d14fafbca152476144ca59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a4e01ec5b64d14fafbca152476144ca59">UnorderedSetByBlock</a> (const <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a> &amp;other)</td></tr>
<tr class="separator:a4e01ec5b64d14fafbca152476144ca59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1df96b2511f06d73b419947c74b5c21"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#aa1df96b2511f06d73b419947c74b5c21">UnorderedSetByBlock</a> (<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a> &amp;&amp;other)</td></tr>
<tr class="separator:aa1df96b2511f06d73b419947c74b5c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d3747a2702ec4327f8ba5ac50ed2e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a22d3747a2702ec4327f8ba5ac50ed2e8">operator=</a> (const <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a> &amp;other)</td></tr>
<tr class="separator:a22d3747a2702ec4327f8ba5ac50ed2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e7cd8044ab48d50a68581d6cf207b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a27e7cd8044ab48d50a68581d6cf207b0">operator=</a> (<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a> &amp;&amp;other)</td></tr>
<tr class="separator:a27e7cd8044ab48d50a68581d6cf207b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterator services</div></td></tr>
<tr class="memitem:a9c65bd5f0595a3ed1e5205d053c6b544"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a9c65bd5f0595a3ed1e5205d053c6b544">begin</a> ()</td></tr>
<tr class="separator:a9c65bd5f0595a3ed1e5205d053c6b544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bf069d09b826a3c3ba67bcd3b1fd7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a07bf069d09b826a3c3ba67bcd3b1fd7c">end</a> ()</td></tr>
<tr class="separator:a07bf069d09b826a3c3ba67bcd3b1fd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4ecdacae78c2e86747bf45d5b5066d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a9e4ecdacae78c2e86747bf45d5b5066d">begin</a> () const</td></tr>
<tr class="separator:a9e4ecdacae78c2e86747bf45d5b5066d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86da96b6df3682579eb08c20d2d1757"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ab86da96b6df3682579eb08c20d2d1757">end</a> () const</td></tr>
<tr class="separator:ab86da96b6df3682579eb08c20d2d1757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e918c8339de01d9500ed25bcb5208bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a6e918c8339de01d9500ed25bcb5208bc">cbegin</a> () const</td></tr>
<tr class="separator:a6e918c8339de01d9500ed25bcb5208bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9829652d26187c567691b75d85737326"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a9829652d26187c567691b75d85737326">cend</a> () const</td></tr>
<tr class="separator:a9829652d26187c567691b75d85737326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Capacity services</div></td></tr>
<tr class="memitem:aa55f64e0a7662d1b7c364ac9565b0719"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#aa55f64e0a7662d1b7c364ac9565b0719">empty</a> () const noexcept</td></tr>
<tr class="separator:aa55f64e0a7662d1b7c364ac9565b0719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37e36b86f68b59cf4595326b02bd1f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#aa37e36b86f68b59cf4595326b02bd1f8">size</a> () const noexcept</td></tr>
<tr class="separator:aa37e36b86f68b59cf4595326b02bd1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669500656c06a49fd637be535962fd54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a669500656c06a49fd637be535962fd54">max_size</a> () const noexcept</td></tr>
<tr class="separator:a669500656c06a49fd637be535962fd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dca62cd20caa4550443e02e13fc70b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a5dca62cd20caa4550443e02e13fc70b8">blocks</a> () const noexcept</td></tr>
<tr class="separator:a5dca62cd20caa4550443e02e13fc70b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34d156b56e94d5290922045dc1b2ad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#af34d156b56e94d5290922045dc1b2ad8">memory_usage</a> () const noexcept</td></tr>
<tr class="separator:af34d156b56e94d5290922045dc1b2ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73e59eebdaaae5efe428d803250a15b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad73e59eebdaaae5efe428d803250a15b">memory_usage_unordered_set</a> () const noexcept</td></tr>
<tr class="separator:ad73e59eebdaaae5efe428d803250a15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modifier services</div></td></tr>
<tr class="memitem:ae8f8bbd20bc272643e8941a20b7e5181"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ae8f8bbd20bc272643e8941a20b7e5181">clear</a> () noexcept</td></tr>
<tr class="memdesc:ae8f8bbd20bc272643e8941a20b7e5181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the container.  <a href="structDGtal_1_1UnorderedSetByBlock.html#ae8f8bbd20bc272643e8941a20b7e5181">More...</a><br /></td></tr>
<tr class="separator:ae8f8bbd20bc272643e8941a20b7e5181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36172e48062d5a70acd083827ed5f225"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a36172e48062d5a70acd083827ed5f225">swap</a> (<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a> &amp;other) noexcept</td></tr>
<tr class="separator:a36172e48062d5a70acd083827ed5f225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963e811959625467ce37d42ccc8cf8cb"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a963e811959625467ce37d42ccc8cf8cb">insert</a> (const <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#adefa12789190556f7acc466b82e7c58a">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a963e811959625467ce37d42ccc8cf8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to insert an element into the set.  <a href="structDGtal_1_1UnorderedSetByBlock.html#a963e811959625467ce37d42ccc8cf8cb">More...</a><br /></td></tr>
<tr class="separator:a963e811959625467ce37d42ccc8cf8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7d92c0a3a9e03ec8c692acc83aebc2"><td class="memTemplParams" colspan="2">template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a5f7d92c0a3a9e03ec8c692acc83aebc2"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a5f7d92c0a3a9e03ec8c692acc83aebc2">emplace</a> (_Args &amp;&amp;... __args)</td></tr>
<tr class="memdesc:a5f7d92c0a3a9e03ec8c692acc83aebc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to build and insert an element into the set.  <a href="structDGtal_1_1UnorderedSetByBlock.html#a5f7d92c0a3a9e03ec8c692acc83aebc2">More...</a><br /></td></tr>
<tr class="separator:a5f7d92c0a3a9e03ec8c692acc83aebc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6568e365f0cda8a20b1ae484fd98bf13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a6568e365f0cda8a20b1ae484fd98bf13">erase</a> (<a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1const__iterator.html">const_iterator</a> pos) noexcept</td></tr>
<tr class="separator:a6568e365f0cda8a20b1ae484fd98bf13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae782f51d9f71d31b98800ff6cff7c5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#aae782f51d9f71d31b98800ff6cff7c5a">erase</a> (<a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1const__iterator.html">const_iterator</a> first, <a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1const__iterator.html">const_iterator</a> last) noexcept</td></tr>
<tr class="separator:aae782f51d9f71d31b98800ff6cff7c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633561b5c0278e769db369a35f893073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a633561b5c0278e769db369a35f893073">erase</a> (const <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a1d0bc17410f081981da167948f950b9d">key_type</a> &amp;key)</td></tr>
<tr class="separator:a633561b5c0278e769db369a35f893073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Lookup services</div></td></tr>
<tr class="memitem:a1684b8a819c502094e20557280f548e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a1684b8a819c502094e20557280f548e7">find</a> (const Key &amp;key)</td></tr>
<tr class="separator:a1684b8a819c502094e20557280f548e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fb43a8f0e0dd28064b460512434000"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ab6fb43a8f0e0dd28064b460512434000">find</a> (const Key &amp;key) const</td></tr>
<tr class="separator:ab6fb43a8f0e0dd28064b460512434000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebdb6f5102ec46006d26844746331e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#abebdb6f5102ec46006d26844746331e2">count</a> (const Key &amp;key) const</td></tr>
<tr class="separator:abebdb6f5102ec46006d26844746331e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6711e3d9bc77065f2a0c56d91a50d88e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1iterator.html">iterator</a>, <a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1iterator.html">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a6711e3d9bc77065f2a0c56d91a50d88e">equal_range</a> (const Key &amp;key)</td></tr>
<tr class="separator:a6711e3d9bc77065f2a0c56d91a50d88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e2efc2737750f10b558bf914a14140"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1const__iterator.html">const_iterator</a>, <a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1const__iterator.html">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a26e2efc2737750f10b558bf914a14140">equal_range</a> (const Key &amp;key) const</td></tr>
<tr class="separator:a26e2efc2737750f10b558bf914a14140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Hash policy services</div></td></tr>
<tr class="memitem:a898512266e6cfd3b1bfd8508db3df1d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a898512266e6cfd3b1bfd8508db3df1d4">reserve</a> (<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a> block_count)</td></tr>
<tr class="separator:a898512266e6cfd3b1bfd8508db3df1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa28026264edfe83b6866d13da3b0e568"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a8eab7bcf309c1ea810e7df623b0320fc">Splitter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#aa28026264edfe83b6866d13da3b0e568">my_splitter</a></td></tr>
<tr class="memdesc:aa28026264edfe83b6866d13da3b0e568"><td class="mdescLeft">&#160;</td><td class="mdescRight">The splitter object.  <a href="structDGtal_1_1UnorderedSetByBlock.html#aa28026264edfe83b6866d13da3b0e568">More...</a><br /></td></tr>
<tr class="separator:aa28026264edfe83b6866d13da3b0e568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7cee622b2e5576c418b0fecf303390f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a561198be4a7c19c479f0da673628c398">Container</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a></td></tr>
<tr class="memdesc:ac7cee622b2e5576c418b0fecf303390f"><td class="mdescLeft">&#160;</td><td class="mdescRight">the unordered_set containing the elements  <a href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">More...</a><br /></td></tr>
<tr class="separator:ac7cee622b2e5576c418b0fecf303390f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8363d4cddc821fc441df9f35a39d1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#aaa8363d4cddc821fc441df9f35a39d1c">my_size</a></td></tr>
<tr class="memdesc:aaa8363d4cddc821fc441df9f35a39d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">the number of elements  <a href="structDGtal_1_1UnorderedSetByBlock.html#aaa8363d4cddc821fc441df9f35a39d1c">More...</a><br /></td></tr>
<tr class="separator:aaa8363d4cddc821fc441df9f35a39d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Set services</h2></td></tr>
<tr class="memitem:aa9b3c6c8c24306f92b8f3923ad55464c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#aa9b3c6c8c24306f92b8f3923ad55464c">includes</a> (const <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a> &amp;other) const</td></tr>
<tr class="separator:aa9b3c6c8c24306f92b8f3923ad55464c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8939c6173ea02d994fa77890715f1c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#aa8939c6173ea02d994fa77890715f1c3">internal_includes_by_map_iterator</a> (const <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a> &amp;other) const</td></tr>
<tr class="separator:aa8939c6173ea02d994fa77890715f1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e46f84b351f70700090133252b7251"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#af4e46f84b351f70700090133252b7251">internal_trace_includes_by_map_iterator</a> (const <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a> &amp;other) const</td></tr>
<tr class="separator:af4e46f84b351f70700090133252b7251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba677310679e40deb7ef937a7cc8398"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a7ba677310679e40deb7ef937a7cc8398">internal_includes_by_iterator</a> (const <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a> &amp;other) const</td></tr>
<tr class="separator:a7ba677310679e40deb7ef937a7cc8398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d193d3cad0861f34c6f71064303b29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a30d193d3cad0861f34c6f71064303b29">internal_trace_includes_by_iterator</a> (const <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a> &amp;other) const</td></tr>
<tr class="separator:a30d193d3cad0861f34c6f71064303b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Key, typename TSplitter = Splitter&lt; Key &gt;, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt;<br />
struct DGtal::UnorderedSetByBlock&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;</h3>

<p>This data structure represents a set of elements that must be integral arrays (i.e. digital points). It is similar to an unordered_set, but much more compact in general. The container used is a unordered_map from point to a 32-bit word. The idea is to group consecutive elements/points along x axis by blocks of 32 bits. If any point in a block is present, the corresponding element is present in the unordered_map and bits set to 1 in the word correspond to points present in the set. On average, memory occupancy is divided by four, the structure is four times faster for traversal and approximately same speed for queries/insertion/erase.</p>
<p>Almost all standard operations of unordered_set in c++11 are implemented.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>the type of integral array. </td></tr>
    <tr><td class="paramname">TSplitter</td><td>the type for splitting a key into a block and a bit (see <a class="el" href="structDGtal_1_1Splitter.html">Splitter</a>). </td></tr>
    <tr><td class="paramname">Hash</td><td>the type that provides a hasher for Key. </td></tr>
    <tr><td class="paramname">KeyEqual</td><td>the type that provides an equality comparator for Key. </td></tr>
    <tr><td class="paramname">UnorderedMapAllocator</td><td>the type that provides an allocator for the underlying unordered_map container.</td></tr>
  </table>
  </dd>
</dl>
<p>Specialized versions of <a class="el" href="structDGtal_1_1Splitter.html">Splitter</a> are written for usual digital points of <a class="el" href="namespaceDGtal_1_1Z2i.html" title="Z2i this namespace gathers the standard of types for 2D imagery.">Z2i</a> or <a class="el" href="namespaceDGtal_1_1Z3i.html" title="Z3i this namespace gathers the standard of types for 3D imagery.">Z3i</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/kernel/UnorderedSetByBlock.h&quot;</span></div>
<div class="line">...</div>
<div class="line">typedef <a class="code" href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt; 3, int &gt;</a>  Point3i; <span class="comment">// digital point in Z3;</span></div>
<div class="line">std::unordered_set&lt; Point3i &gt;         aSet;    <span class="comment">// usual data structure</span></div>
<div class="line"><a class="code" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock&lt; Point3i &gt;</a> aSet2;   <span class="comment">// this data structure</span></div>
<div class="line"><span class="comment">// same code after for aSet or aSet2.</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00163">163</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac03d1dc9713238a70482826a90c27a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03d1dc9713238a70482826a90c27a87">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Container::allocator_type <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ac03d1dc9713238a70482826a90c27a87">allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocator. </p>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00186">186</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>

</div>
</div>
<a id="aad2e25fb919ff9133032c63a7320b99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2e25fb919ff9133032c63a7320b99f">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const Key* <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#aad2e25fb919ff9133032c63a7320b99f">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const Pointer to value_type/Key. </p>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00194">194</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>

</div>
</div>
<a id="abf2d06b4e3b6094bde2f5a1a01425888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2d06b4e3b6094bde2f5a1a01425888">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const Key&amp; <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#abf2d06b4e3b6094bde2f5a1a01425888">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const reference to value_type/Key. </p>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00190">190</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>

</div>
</div>
<a id="a561198be4a7c19c479f0da673628c398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561198be4a7c19c479f0da673628c398">&#9670;&nbsp;</a></span>Container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::unordered_map&lt; Key, <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a>, Hash, KeyEqual, UnorderedMapAllocator &gt; <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a561198be4a7c19c479f0da673628c398">Container</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The underlying container, an unordered_map. </p>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00170">170</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>

</div>
</div>
<a id="a3cb762841d653042309d681277291eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb762841d653042309d681277291eec">&#9670;&nbsp;</a></span>Coordinate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structDGtal_1_1Splitter.html#a587fa8c5c9f8f6a01e3062794886fdda">Splitter::Coordinate</a> <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a3cb762841d653042309d681277291eec">Coordinate</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00167">167</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>

</div>
</div>
<a id="a8c10b467d0ff0a879bd043b54b68324d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c10b467d0ff0a879bd043b54b68324d">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Container::difference_type <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a8c10b467d0ff0a879bd043b54b68324d">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type (usually std::ptrdiff_t) </p>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00180">180</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>

</div>
</div>
<a id="a00baafce323046c26f3f9632a0bba1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00baafce323046c26f3f9632a0bba1f3">&#9670;&nbsp;</a></span>hasher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Hash <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a00baafce323046c26f3f9632a0bba1f3">hasher</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hash. </p>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00182">182</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>

</div>
</div>
<a id="adeefb663d6313fbd8ecf06d07b410fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeefb663d6313fbd8ecf06d07b410fab">&#9670;&nbsp;</a></span>key_equal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KeyEqual <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#adeefb663d6313fbd8ecf06d07b410fab">key_equal</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>KeyEqual. </p>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00184">184</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>

</div>
</div>
<a id="a1d0bc17410f081981da167948f950b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0bc17410f081981da167948f950b9d">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Key <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a1d0bc17410f081981da167948f950b9d">key_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Key. </p>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00174">174</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>

</div>
</div>
<a id="a7554458e1f8bba6235486503dd8befc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7554458e1f8bba6235486503dd8befc4">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Key* <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a7554458e1f8bba6235486503dd8befc4">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to value_type/Key. </p>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00192">192</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>

</div>
</div>
<a id="a59d4519a05eb99a4fd365c99a830a93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d4519a05eb99a4fd365c99a830a93b">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Key&amp; <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a59d4519a05eb99a4fd365c99a830a93b">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference to value_type/Key. </p>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00188">188</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>

</div>
</div>
<a id="ad69ca22ee7fd9bb7a6385e76b6c034fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69ca22ee7fd9bb7a6385e76b6c034fd">&#9670;&nbsp;</a></span>Self</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual &gt; <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00164">164</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>

</div>
</div>
<a id="ad170ff228e1814348e1139bb9277eb0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad170ff228e1814348e1139bb9277eb0d">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Container::size_type <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type (usually std::size_t) </p>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00178">178</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>

</div>
</div>
<a id="a8eab7bcf309c1ea810e7df623b0320fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eab7bcf309c1ea810e7df623b0320fc">&#9670;&nbsp;</a></span>Splitter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TSplitter <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a8eab7bcf309c1ea810e7df623b0320fc">Splitter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00165">165</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>

</div>
</div>
<a id="adefa12789190556f7acc466b82e7c58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adefa12789190556f7acc466b82e7c58a">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Key <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#adefa12789190556f7acc466b82e7c58a">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Key. </p>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00176">176</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>

</div>
</div>
<a id="a3c2077e466982b6f25254da3c6184f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2077e466982b6f25254da3c6184f72">&#9670;&nbsp;</a></span>Word</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structDGtal_1_1Splitter.html#aada48987ba3ea394ce8421b8fbb3f18d">Splitter::Word</a> <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00166">166</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acecd7108cebad4b50eeb491ffec4f7a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acecd7108cebad4b50eeb491ffec4f7a0">&#9670;&nbsp;</a></span>UnorderedSetByBlock() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">UnorderedSetByBlock</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em> = <code>23</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a8eab7bcf309c1ea810e7df623b0320fc">Splitter</a> &amp;&#160;</td>
          <td class="paramname"><em>splitter</em> = <code><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a8eab7bcf309c1ea810e7df623b0320fc">Splitter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#adeefb663d6313fbd8ecf06d07b410fab">key_equal</a> &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#adeefb663d6313fbd8ecf06d07b410fab">key_equal</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnorderedMapAllocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>UnorderedMapAllocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Main constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bucket_count</td><td>the initial number of buckets for the underlying container. </td></tr>
    <tr><td class="paramname">splitter</td><td>the splitter object for keys. </td></tr>
    <tr><td class="paramname">hash</td><td>the hash object for keys. </td></tr>
    <tr><td class="paramname">equal</td><td>the key equality comparator object for keys. </td></tr>
    <tr><td class="paramname">alloc</td><td>the allocator for the underlying container. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00474">474</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;      : <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aa28026264edfe83b6866d13da3b0e568">my_splitter</a>( splitter ),</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;        <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>( bucket_count, hash, equal, alloc ),</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;        <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aaa8363d4cddc821fc441df9f35a39d1c">my_size</a>( 0 ) {}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a163d61323a33d57bad4a03015568a434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163d61323a33d57bad4a03015568a434">&#9670;&nbsp;</a></span>~UnorderedSetByBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::~<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">UnorderedSetByBlock</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>

</div>
</div>
<a id="a4e01ec5b64d14fafbca152476144ca59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e01ec5b64d14fafbca152476144ca59">&#9670;&nbsp;</a></span>UnorderedSetByBlock() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">UnorderedSetByBlock</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the object to clone </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00488">488</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;      : <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aa28026264edfe83b6866d13da3b0e568">my_splitter</a>( other.my_splitter ),</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;        <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>( other.my_elements ),</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;        <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aaa8363d4cddc821fc441df9f35a39d1c">my_size</a>( other.my_size )</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;    {}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa1df96b2511f06d73b419947c74b5c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1df96b2511f06d73b419947c74b5c21">&#9670;&nbsp;</a></span>UnorderedSetByBlock() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::<a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">UnorderedSetByBlock</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the object to clone </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00496">496</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;      : <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aa28026264edfe83b6866d13da3b0e568">my_splitter</a>( std::move( other.my_splitter ) ),</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;        <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>( std::move( other.my_elements ) ),</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;        <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aaa8363d4cddc821fc441df9f35a39d1c">my_size</a>( std::move( other.my_size ) )</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;    {}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9c65bd5f0595a3ed1e5205d053c6b544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c65bd5f0595a3ed1e5205d053c6b544">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1iterator.html">iterator</a> <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an iterator of the first stored element </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00534">534</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;    {</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;      <span class="keywordflow">return</span> iterator( *<span class="keyword">this</span>, <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.begin() );</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9e4ecdacae78c2e86747bf45d5b5066d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4ecdacae78c2e86747bf45d5b5066d">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1const__iterator.html">const_iterator</a> <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an iterator of the first stored element </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00545">545</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;    {</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;      <span class="keywordflow">return</span> const_iterator( *<span class="keyword">this</span>, <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.cbegin() );</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5dca62cd20caa4550443e02e13fc70b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dca62cd20caa4550443e02e13fc70b8">&#9670;&nbsp;</a></span>blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a> <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::blocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Specific to this data structure. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of blocks stored in the container. </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00582">582</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.size(); }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="UnorderedSetByBlock_8h_source.html#l00586">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::memory_usage()</a>.</p>

</div>
</div>
<a id="a6e918c8339de01d9500ed25bcb5208bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e918c8339de01d9500ed25bcb5208bc">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1const__iterator.html">const_iterator</a> <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an iterator of the first stored element </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00556">556</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;    {</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;      <span class="keywordflow">return</span> const_iterator( *<span class="keyword">this</span>, <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.cbegin() );</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="UnorderedSetByBlock_8h_source.html#l01000">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::internal_includes_by_iterator()</a>, and <a class="el" href="UnorderedSetByBlock_8h_source.html#l01024">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::internal_trace_includes_by_iterator()</a>.</p>

</div>
</div>
<a id="a9829652d26187c567691b75d85737326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9829652d26187c567691b75d85737326">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1const__iterator.html">const_iterator</a> <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an iterator past the last stored element </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00561">561</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;    {</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;      <span class="keywordflow">return</span> const_iterator( *<span class="keyword">this</span>, <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.cend() );</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="UnorderedSetByBlock_8h_source.html#l00730">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::erase()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00863">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::find()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l01000">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::internal_includes_by_iterator()</a>, and <a class="el" href="UnorderedSetByBlock_8h_source.html#l01024">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::internal_trace_includes_by_iterator()</a>.</p>

</div>
</div>
<a id="ae8f8bbd20bc272643e8941a20b7e5181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f8bbd20bc272643e8941a20b7e5181">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the container. </p>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00620">620</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;    {</div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;      <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.clear();</div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;      <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aaa8363d4cddc821fc441df9f35a39d1c">my_size</a> = 0;</div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abebdb6f5102ec46006d26844746331e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abebdb6f5102ec46006d26844746331e2">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a> <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the value to look-up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of elements with key that compares equal to the specified argument key, which is either 1 or 0 since this container does not allow duplicates. </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00877">877</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;    {</div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span> se = <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aa28026264edfe83b6866d13da3b0e568">my_splitter</a>.split( key );</div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span> it = <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.find( se.first );</div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;      <span class="keywordflow">if</span> ( it == <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.cend() ) <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;      <span class="keyword">const</span> <span class="keywordtype">bool</span> exist = it-&gt;second &amp; ( <span class="keyword">static_cast&lt;</span><a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a><span class="keyword">&gt;</span>(1) &lt;&lt; se.second );</div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;      <span class="keywordflow">return</span> exist ? 1 : 0;</div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5f7d92c0a3a9e03ec8c692acc83aebc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7d92c0a3a9e03ec8c692acc83aebc2">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1iterator.html">iterator</a>, bool&gt; <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">_Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to build and insert an element into the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__args</td><td>Arguments used to generate an element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair, of which the first element is an iterator that points to the possibly inserted element, and the second is a bool that is true if the element was actually inserted.</dd></dl>
<p>This function attempts to build and insert an element into the set. A set relies on unique keys and thus an element is only inserted if it is not already present in the set.</p>
<p>Insertion takes amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00695">695</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;    {</div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span> se = <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aa28026264edfe83b6866d13da3b0e568">my_splitter</a>.split( Key( std::forward&lt;_Args&gt;(__args)... ) );</div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;      <span class="keyword">auto</span> it = <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.find( se.first );</div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;      <span class="keywordflow">if</span> ( it == <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.end() )</div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;        {</div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;          <span class="keyword">auto</span>   p =</div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;            <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.insert( std::make_pair( se.first,</div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;                                                <span class="keyword">static_cast&lt;</span><a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a><span class="keyword">&gt;</span>(1) &lt;&lt; se.second ) );</div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;          <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aaa8363d4cddc821fc441df9f35a39d1c">my_size</a> += 1;</div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;          <span class="keywordflow">return</span> std::make_pair( iterator( *<span class="keyword">this</span>, p.first, se.second ), <span class="keyword">true</span> );</div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;        }</div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;        {</div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;          <span class="keywordtype">bool</span> exist = it-&gt;second &amp; ( <span class="keyword">static_cast&lt;</span><a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a><span class="keyword">&gt;</span>(1) &lt;&lt; se.second );</div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;          <span class="keywordflow">if</span> ( ! exist )</div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;            {</div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;              it-&gt;second |= <span class="keyword">static_cast&lt;</span><a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a><span class="keyword">&gt;</span>(1) &lt;&lt; se.second;</div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;              <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aaa8363d4cddc821fc441df9f35a39d1c">my_size</a>    += 1;</div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;            }</div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;          <span class="keywordflow">return</span> std::make_pair( iterator( *<span class="keyword">this</span>, it, se.second ), ! exist );</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;        }</div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa55f64e0a7662d1b7c364ac9565b0719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55f64e0a7662d1b7c364ac9565b0719">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>'true' iff the container is empty </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00574">574</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.empty(); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a07bf069d09b826a3c3ba67bcd3b1fd7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07bf069d09b826a3c3ba67bcd3b1fd7c">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1iterator.html">iterator</a> <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an iterator past the last stored element </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00539">539</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;    {</div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;      <span class="keywordflow">return</span> iterator( *<span class="keyword">this</span>, <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.end() );</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="UnorderedSetByBlock_8h_source.html#l00895">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::equal_range()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00760">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::erase()</a>, and <a class="el" href="UnorderedSetByBlock_8h_source.html#l00848">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::find()</a>.</p>

</div>
</div>
<a id="ab86da96b6df3682579eb08c20d2d1757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86da96b6df3682579eb08c20d2d1757">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1const__iterator.html">const_iterator</a> <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an iterator past the last stored element </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00550">550</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;    {</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;      <span class="keywordflow">return</span> const_iterator( *<span class="keyword">this</span>, <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.cend() );</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6711e3d9bc77065f2a0c56d91a50d88e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6711e3d9bc77065f2a0c56d91a50d88e">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1iterator.html">iterator</a>,<a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1iterator.html">iterator</a>&gt; <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the bounds of a range that includes all the elements that compare equal to k. In set containers, where keys are unique, the range will include one element at most.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the value to look-up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a range containing the sought element or an empty range if <em>key</em> is not in this set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00895">895</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;    {</div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;      iterator first = <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a1684b8a819c502094e20557280f548e7">find</a>( key );</div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;      <span class="keywordflow">if</span> ( first != <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a07bf069d09b826a3c3ba67bcd3b1fd7c">end</a>() )</div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;        {</div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;          iterator last = first;</div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;          <span class="keywordflow">return</span> std::make_pair( first, ++last );</div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;        }</div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">return</span> std::make_pair( first, first );</div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a26e2efc2737750f10b558bf914a14140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e2efc2737750f10b558bf914a14140">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1const__iterator.html">const_iterator</a>,<a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1const__iterator.html">const_iterator</a>&gt; <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the bounds of a range that includes all the elements that compare equal to k. In set containers, where keys are unique, the range will include one element at most.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the value to look-up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a range containing the sought element or an empty range if <em>key</em> is not in this set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00915">915</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;    {</div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;      const_iterator first = <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a1684b8a819c502094e20557280f548e7">find</a>( key );</div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;      <span class="keywordflow">if</span> ( first != <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a07bf069d09b826a3c3ba67bcd3b1fd7c">end</a>() )</div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;        {</div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;          const_iterator last = first;</div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;          <span class="keywordflow">return</span> std::make_pair( first, ++last );</div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;        }</div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">return</span> std::make_pair( first, first );</div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a633561b5c0278e769db369a35f893073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633561b5c0278e769db369a35f893073">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a> <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a1d0bc17410f081981da167948f950b9d">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes specified element from the container, if it exists. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the value to erase from the set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of value removed from the set (either 0 or 1 ).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>References and iterators to the erased elements are invalidated. Other iterators and references are not invalidated. </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00825">825</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;    {</div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;      <span class="keyword">auto</span> it = <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a1684b8a819c502094e20557280f548e7">find</a>( key );</div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;      <span class="keywordflow">if</span> ( it != <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a07bf069d09b826a3c3ba67bcd3b1fd7c">end</a>() )</div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;        {</div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;          <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a6568e365f0cda8a20b1ae484fd98bf13">erase</a>( it );</div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;          <span class="keywordflow">return</span> 1;</div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;        }</div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aae782f51d9f71d31b98800ff6cff7c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae782f51d9f71d31b98800ff6cff7c5a">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1iterator.html">iterator</a> <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes the elements in the range [first; last), which must be a valid range in *this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>an iterator such that [first; last) is a valid range in this data structure</td></tr>
    <tr><td class="paramname">last</td><td>an iterator such that [first; last) is a valid range in this data structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the iterator following the last removed element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>References and iterators to the erased elements are invalidated. Other iterators and references are not invalidated. </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00760">760</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;    {</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;      ASSERT( <span class="keyword">this</span> == first.collection );</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;      ASSERT( <span class="keyword">this</span> == last.collection );</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;      <span class="keywordflow">if</span> ( first == <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a9829652d26187c567691b75d85737326">cend</a>() ) <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a07bf069d09b826a3c3ba67bcd3b1fd7c">end</a>();</div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;      <span class="keyword">auto</span> itB = first.it;</div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;      <span class="keyword">auto</span> itE = last.it;</div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;      <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a> mask = <span class="keyword">static_cast&lt;</span><a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a><span class="keyword">&gt;</span>(0);</div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;      <span class="comment">// Take care of range over one block only</span></div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;      <span class="keywordflow">if</span> ( itB == itE )</div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;        {</div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;          <span class="keywordflow">while</span> ( first != last )</div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;            {</div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;              mask    |= <span class="keyword">static_cast&lt;</span><a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a><span class="keyword">&gt;</span>(1) &lt;&lt; first.bit;</div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;              <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aaa8363d4cddc821fc441df9f35a39d1c">my_size</a> -= 1;</div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;              ++first;</div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;            }</div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;          <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>[ itB-&gt;first ] &amp;= ~mask;</div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;          <span class="keywordflow">return</span> iterator( *<span class="keyword">this</span>,</div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;                           <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.find( itE-&gt;first ),</div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;                           last.bit ); <span class="comment">// must be valid</span></div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;        }</div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;      <span class="comment">// Take care of first element.</span></div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;      <span class="keywordflow">while</span> ( first.it == itB )</div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;        {</div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;          mask    |= <span class="keyword">static_cast&lt;</span><a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a><span class="keyword">&gt;</span>(1) &lt;&lt; first.bit;</div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;          <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aaa8363d4cddc821fc441df9f35a39d1c">my_size</a> -= 1;</div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;          ++first;</div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;        }</div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;      <span class="comment">// Erase first block if empty</span></div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;      <span class="keywordflow">if</span> ( ( <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>[ itB-&gt;first ] &amp;= ~mask )</div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;           == <span class="keyword">static_cast&lt;</span><a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a><span class="keyword">&gt;</span>(0) )</div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;        <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.erase( itB );</div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;      <span class="comment">// Count erased elements in main range.</span></div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;      <span class="keywordflow">for</span> ( itB = first.it; itB != itE; ++itB )</div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;        <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aaa8363d4cddc821fc441df9f35a39d1c">my_size</a> -= <a class="code" href="structDGtal_1_1Bits.html#a6c8ae97b5a23db19fe0a04429f6f61c9">Bits::nbSetBits</a>( itB-&gt;second );</div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;      <span class="comment">// Erase elements in main range</span></div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;      <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.erase( first.it, itE );</div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;      <span class="comment">// Take care of last element.</span></div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;      <span class="keywordflow">if</span> ( itE == <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.cend() ) <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a07bf069d09b826a3c3ba67bcd3b1fd7c">end</a>();</div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;      itB   = itE;</div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;      first = const_iterator( *<span class="keyword">this</span>, itB );</div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;      mask  = <span class="keyword">static_cast&lt;</span><a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a><span class="keyword">&gt;</span>(0);</div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;      <span class="keywordflow">while</span> ( first != last )</div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;        {</div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;          mask    |= <span class="keyword">static_cast&lt;</span><a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a><span class="keyword">&gt;</span>(1) &lt;&lt; first.bit;</div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;          <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aaa8363d4cddc821fc441df9f35a39d1c">my_size</a> -= 1;</div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;          ++first;</div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;        }</div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;      <span class="comment">// Erase last block if empty</span></div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;      <span class="keywordflow">if</span> ( ( <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>[ itB-&gt;first ] &amp;= ~mask )</div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;           == <span class="keyword">static_cast&lt;</span><a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a><span class="keyword">&gt;</span>(0) )</div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;        <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.erase( itB );</div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;      <span class="keywordflow">return</span> iterator( *<span class="keyword">this</span>,</div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;                       <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.find( itE-&gt;first ),</div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;                       last.bit ); <span class="comment">// must be valid or end.</span></div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6568e365f0cda8a20b1ae484fd98bf13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6568e365f0cda8a20b1ae484fd98bf13">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1iterator.html">iterator</a> <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes specified element from the container. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>a valid iterator in this data structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the iterator following the last removed element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>References and iterators to the erased elements are invalidated. Other iterators and references are not invalidated.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The iterator pos must be valid and dereferenceable. Thus the <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a07bf069d09b826a3c3ba67bcd3b1fd7c">end()</a> iterator (which is valid, but is not dereferenceable) cannot be used as a value for pos. </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00730">730</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;    {</div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;      ASSERT( <span class="keyword">this</span> == pos.collection );</div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;      ASSERT( pos  != <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a9829652d26187c567691b75d85737326">cend</a>() );</div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;      ASSERT( ( pos.it-&gt;second &amp; ( <span class="keyword">static_cast&lt;</span><a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a><span class="keyword">&gt;</span>(1) &lt;&lt; pos.bit ) )</div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;              != <span class="keyword">static_cast&lt;</span><a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a><span class="keyword">&gt;</span>(0) );</div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;      <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aaa8363d4cddc821fc441df9f35a39d1c">my_size</a> -= 1;</div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;      <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a> &amp; w = <span class="keyword">const_cast&lt;</span> <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a>&amp; <span class="keyword">&gt;</span>( pos.it-&gt;second );</div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;      <span class="keywordflow">if</span> ( ( w &amp;= ~( <span class="keyword">static_cast&lt;</span><a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a><span class="keyword">&gt;</span>(1) &lt;&lt; pos.bit ) )</div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;           == <span class="keyword">static_cast&lt;</span><a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a><span class="keyword">&gt;</span>(0) )</div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;        <span class="keywordflow">return</span> iterator( *<span class="keyword">this</span>, <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.erase( pos.it ) );</div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;        <span class="keywordflow">return</span> iterator( *<span class="keyword">this</span>, <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.erase( pos.it, pos.it ), pos.bit );</div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="UnorderedSetByBlock_8h_source.html#l00825">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::erase()</a>.</p>

</div>
</div>
<a id="a1684b8a819c502094e20557280f548e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1684b8a819c502094e20557280f548e7">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1iterator.html">iterator</a> <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds an element with key equivalent to key. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the value to look-up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator pointing to <em>key</em> or <code><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a07bf069d09b826a3c3ba67bcd3b1fd7c">end()</a></code> if the key is not the set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00848">848</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;    {</div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span> se = <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aa28026264edfe83b6866d13da3b0e568">my_splitter</a>.split( key );</div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span> it = <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.find( se.first );</div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;      <span class="keywordflow">if</span> ( it == <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.end() ) <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a07bf069d09b826a3c3ba67bcd3b1fd7c">end</a>();</div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;      <span class="keyword">const</span> <span class="keywordtype">bool</span> exist = it-&gt;second &amp; ( <span class="keyword">static_cast&lt;</span><a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a><span class="keyword">&gt;</span>(1) &lt;&lt; se.second );</div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;      <span class="keywordflow">if</span> ( exist ) <span class="keywordflow">return</span> iterator( *<span class="keyword">this</span>, it, se.second );</div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;      <span class="keywordflow">else</span>         <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a07bf069d09b826a3c3ba67bcd3b1fd7c">end</a>();</div>
<div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="UnorderedSetByBlock_8h_source.html#l00895">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::equal_range()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00825">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::erase()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l01000">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::internal_includes_by_iterator()</a>, and <a class="el" href="UnorderedSetByBlock_8h_source.html#l01024">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::internal_trace_includes_by_iterator()</a>.</p>

</div>
</div>
<a id="ab6fb43a8f0e0dd28064b460512434000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6fb43a8f0e0dd28064b460512434000">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1const__iterator.html">const_iterator</a> <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds an element with key equivalent to key. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the value to look-up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const iterator pointing to <em>key</em> or <code><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a07bf069d09b826a3c3ba67bcd3b1fd7c">end()</a></code> if the key is not the set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00863">863</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;    {</div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span> se = <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aa28026264edfe83b6866d13da3b0e568">my_splitter</a>.split( key );</div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span> it = <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.find( se.first );</div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;      <span class="keywordflow">if</span> ( it == <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.cend() ) <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a9829652d26187c567691b75d85737326">cend</a>();</div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;      <span class="keyword">const</span> <span class="keywordtype">bool</span> exist = it-&gt;second &amp; ( <span class="keyword">static_cast&lt;</span><a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a><span class="keyword">&gt;</span>(1) &lt;&lt; se.second );</div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;      <span class="keywordflow">if</span> ( exist ) <span class="keywordflow">return</span> const_iterator( *<span class="keyword">this</span>, it, se.second );</div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;      <span class="keywordflow">else</span>         <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a9829652d26187c567691b75d85737326">cend</a>();</div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa9b3c6c8c24306f92b8f3923ad55464c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b3c6c8c24306f92b8f3923ad55464c">&#9670;&nbsp;</a></span>includes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::includes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>any unordered set with same sort of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if and only if this set includes <em>other</em>, and 'false' otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Much faster that using <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#abebdb6f5102ec46006d26844746331e2">count</a> or <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a1684b8a819c502094e20557280f548e7">find</a> on each element, since it proceeds block by block. </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00939">939</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;    {</div>
<div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aa8939c6173ea02d994fa77890715f1c3">internal_includes_by_map_iterator</a>( other );</div>
<div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a963e811959625467ce37d42ccc8cf8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963e811959625467ce37d42ccc8cf8cb">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structDGtal_1_1UnorderedSetByBlock_1_1iterator.html">iterator</a>,bool&gt; <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#adefa12789190556f7acc466b82e7c58a">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert an element into the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Element to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair, of which the first element is an iterator that points to the possibly inserted element, and the second is a bool that is true if the element was actually inserted.</dd></dl>
<p>This function attempts to insert an element into the set. A set relies on unique keys and thus an element is only inserted if it is not already present in the set.</p>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00656">656</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;    {</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span> se = <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aa28026264edfe83b6866d13da3b0e568">my_splitter</a>.split( value );</div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;      <span class="keyword">auto</span> it = <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.find( se.first );</div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;      <span class="keywordflow">if</span> ( it == <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.end() )</div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;        {</div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;          <span class="keyword">auto</span>   p = <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.insert</div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;            ( std::make_pair( se.first,</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;                              <span class="keyword">static_cast&lt;</span><a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a><span class="keyword">&gt;</span>(1) &lt;&lt; se.second ) );</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;          <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aaa8363d4cddc821fc441df9f35a39d1c">my_size</a> += 1;</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;          <span class="keywordflow">return</span> std::make_pair( iterator( *<span class="keyword">this</span>, p.first, se.second ), <span class="keyword">true</span> );</div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;        }</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;        {</div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;          <span class="keywordtype">bool</span> exist = it-&gt;second &amp; ( <span class="keyword">static_cast&lt;</span><a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a><span class="keyword">&gt;</span>(1) &lt;&lt; se.second );</div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;          <span class="keywordflow">if</span> ( ! exist )</div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;            {</div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;              it-&gt;second |= <span class="keyword">static_cast&lt;</span><a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a><span class="keyword">&gt;</span>(1) &lt;&lt; se.second;</div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;              <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aaa8363d4cddc821fc441df9f35a39d1c">my_size</a>    += 1;</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;            }</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;          <span class="keywordflow">return</span> std::make_pair( iterator( *<span class="keyword">this</span>, it, se.second ), ! exist );</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;        }</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7ba677310679e40deb7ef937a7cc8398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba677310679e40deb7ef937a7cc8398">&#9670;&nbsp;</a></span>internal_includes_by_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::internal_includes_by_iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs includes operation using iterators and big steps, slightly slower than internal_includes_by_map_iterator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>any unordered set with same sort of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if and only if this set includes <em>other</em>, and 'false' otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l01000">1000</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;    {</div>
<div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;      <span class="keyword">auto</span> it_other  = other.cbegin();</div>
<div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;      <span class="keyword">auto</span> itEnd_other = other.cend();</div>
<div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;      <span class="keywordflow">while</span> ( it_other != itEnd_other )</div>
<div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;        {</div>
<div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> it_this = <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a1684b8a819c502094e20557280f548e7">find</a>( *it_other );</div>
<div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;          <span class="keywordflow">if</span> ( it_this == <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a9829652d26187c567691b75d85737326">cend</a>() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;          <span class="keyword">auto</span>   itMap_other = it_other.it;</div>
<div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;          <span class="keyword">const</span> <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a> w_this  = it_this.it-&gt;second;</div>
<div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;          <span class="keyword">const</span> <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a> w_other = itMap_other-&gt;second;</div>
<div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;          <span class="keywordflow">if</span> ( ( w_this &amp; w_other ) != w_other ) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;          it_other = const_iterator( other, ++itMap_other );</div>
<div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;        }</div>
<div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa8939c6173ea02d994fa77890715f1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8939c6173ea02d994fa77890715f1c3">&#9670;&nbsp;</a></span>internal_includes_by_map_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::internal_includes_by_map_iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs includes operation using underlying container iterator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>any unordered set with same sort of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if and only if this set includes <em>other</em>, and 'false' otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00949">949</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;    {</div>
<div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;      <span class="keyword">auto</span>       itMap_other    = other.my_elements.cbegin();</div>
<div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span> itEndMap_other = other.my_elements.cend();</div>
<div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span> itEndMap_this  = <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.cend();</div>
<div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;      <span class="keywordflow">for</span> ( ; itMap_other != itEndMap_other; ++itMap_other )</div>
<div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;        {</div>
<div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> itMap_this = <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.find( itMap_other-&gt;first );</div>
<div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;          <span class="keywordflow">if</span> ( itMap_this == itEndMap_this ) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;          <span class="keyword">const</span> <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a> w_this  = itMap_this-&gt;second;</div>
<div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;          <span class="keyword">const</span> <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a> w_other = itMap_other-&gt;second;</div>
<div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;          <span class="keywordflow">if</span> ( ( w_this &amp; w_other ) != w_other ) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;        }</div>
<div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="UnorderedSetByBlock_8h_source.html#l00939">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::includes()</a>.</p>

</div>
</div>
<a id="a30d193d3cad0861f34c6f71064303b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d193d3cad0861f34c6f71064303b29">&#9670;&nbsp;</a></span>internal_trace_includes_by_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::internal_trace_includes_by_iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs includes operation using iterators and big steps, slightly slower than internal_includes_by_map_iterator. Verbose version for debug.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>any unordered set with same sort of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if and only if this set includes <em>other</em>, and 'false' otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l01024">1024</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;    {</div>
<div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;      <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;[trace_includes_v2] #this=&quot;</span> &lt;&lt; <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aa37e36b86f68b59cf4595326b02bd1f8">size</a>()</div>
<div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;                   &lt;&lt; <span class="stringliteral">&quot; #other=&quot;</span> &lt;&lt; other.size() &lt;&lt; std::endl;</div>
<div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;      <span class="keyword">auto</span> it_other  = other.cbegin();</div>
<div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;      <span class="keyword">auto</span> itEnd_other = other.cend();</div>
<div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;      <span class="keywordflow">while</span> ( it_other != itEnd_other )</div>
<div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;        {</div>
<div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;          <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;other: cell=&quot;</span> &lt;&lt; it_other.it-&gt;first</div>
<div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;                &lt;&lt; <span class="stringliteral">&quot; value=&quot;</span> &lt;&lt; std::hex &lt;&lt; it_other.it-&gt;second &lt;&lt; std::endl;</div>
<div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> it_this = <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a1684b8a819c502094e20557280f548e7">find</a>( *it_other );</div>
<div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;          <span class="keywordflow">if</span> ( it_this != <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a9829652d26187c567691b75d85737326">cend</a>() )</div>
<div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;            <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;this : cell=&quot;</span> &lt;&lt; it_this.it-&gt;first</div>
<div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;                  &lt;&lt; <span class="stringliteral">&quot; value=&quot;</span> &lt;&lt; std::hex &lt;&lt; it_this.it-&gt;second &lt;&lt; std::endl;</div>
<div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;            <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;this : end cell&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;          <span class="keywordflow">if</span> ( it_this == <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a9829652d26187c567691b75d85737326">cend</a>() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;          <span class="keyword">auto</span>   itMap_other = it_other.it;</div>
<div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;          <span class="keyword">const</span> <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a> w_this  = it_this.it-&gt;second;</div>
<div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;          <span class="keyword">const</span> <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a> w_other = itMap_other-&gt;second;</div>
<div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;          <span class="keywordflow">if</span> ( ( w_this &amp; w_other ) != w_other ) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;          it_other = const_iterator( other, ++itMap_other );</div>
<div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;        }</div>
<div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af4e46f84b351f70700090133252b7251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e46f84b351f70700090133252b7251">&#9670;&nbsp;</a></span>internal_trace_includes_by_map_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::internal_trace_includes_by_map_iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs includes operation using underlying container iterator. Verbose version for debug. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>any unordered set with same sort of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if and only if this set includes <em>other</em>, and 'false' otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00970">970</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;    {</div>
<div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;      <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;[trace_includes_v1] #this=&quot;</span> &lt;&lt; <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aa37e36b86f68b59cf4595326b02bd1f8">size</a>()</div>
<div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;                   &lt;&lt; <span class="stringliteral">&quot; #other=&quot;</span> &lt;&lt; other.size() &lt;&lt; std::endl;</div>
<div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;      <span class="keyword">auto</span>       itMap_other    = other.my_elements.cbegin();</div>
<div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span> itEndMap_other = other.my_elements.cend();</div>
<div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span> itEndMap_this  = <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.cend();</div>
<div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;      <span class="keywordflow">for</span> ( ; itMap_other != itEndMap_other; ++itMap_other )</div>
<div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;        {</div>
<div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;          <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;other: cell=&quot;</span> &lt;&lt; itMap_other-&gt;first</div>
<div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;                &lt;&lt; <span class="stringliteral">&quot; value=&quot;</span> &lt;&lt; std::hex &lt;&lt; itMap_other-&gt;second &lt;&lt; std::endl;</div>
<div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span> itMap_this = <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.find( itMap_other-&gt;first );</div>
<div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;          <span class="keywordflow">if</span> ( itMap_this != itEndMap_this )</div>
<div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;            <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;this : cell=&quot;</span> &lt;&lt; itMap_this-&gt;first</div>
<div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;                  &lt;&lt; <span class="stringliteral">&quot; value=&quot;</span> &lt;&lt; std::hex &lt;&lt; itMap_this-&gt;second &lt;&lt; std::endl;</div>
<div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;            <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;this : end cell&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;          <span class="keywordflow">if</span> ( itMap_this == itEndMap_this ) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;          <span class="keyword">const</span> <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a> w_this  = itMap_this-&gt;second;</div>
<div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;          <span class="keyword">const</span> <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a> w_other = itMap_other-&gt;second;</div>
<div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;          <span class="keywordflow">if</span> ( ( w_this &amp; w_other ) != w_other ) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;        }</div>
<div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a669500656c06a49fd637be535962fd54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669500656c06a49fd637be535962fd54">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a> <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the maximum number of elements that can be stored in the container. </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00578">578</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.max_size(); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af34d156b56e94d5290922045dc1b2ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34d156b56e94d5290922045dc1b2ad8">&#9670;&nbsp;</a></span>memory_usage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a> <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::memory_usage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Specific to this data structure. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an evaluation of the memory usage of this data structure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00586">586</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;    {</div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;      <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a> mem = (<a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.bucket_count()+1) * <span class="keyword">sizeof</span>( <span class="keywordtype">void</span>* )</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;        + 2 * <span class="keyword">sizeof</span>( <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a> );</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;      mem += <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a5dca62cd20caa4550443e02e13fc70b8">blocks</a>() * ( <span class="keyword">sizeof</span>( <span class="keywordtype">void</span>* )       <span class="comment">/* next */</span></div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;                          + <span class="keyword">sizeof</span>( Key )       <span class="comment">/* key */</span></div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;                          + <span class="keyword">sizeof</span>( <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">Word</a> )      <span class="comment">/* value */</span></div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;                          + <span class="keyword">sizeof</span>( <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a> ) <span class="comment">/* hash  */</span></div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;                          + <span class="keyword">sizeof</span>( <span class="keywordtype">void</span>* )     <span class="comment">/* dyn. alloc. */</span> );</div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;      <span class="keywordflow">return</span> mem;</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad73e59eebdaaae5efe428d803250a15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73e59eebdaaae5efe428d803250a15b">&#9670;&nbsp;</a></span>memory_usage_unordered_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a> <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::memory_usage_unordered_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Specific to this data structure. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an evaluation of the memory usage of the same data stored in an unordered set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00601">601</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;    {</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;      <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a> mem = (<a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.bucket_count()+1) * <span class="keyword">sizeof</span>( <span class="keywordtype">void</span>* )</div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;        + 2 * <span class="keyword">sizeof</span>( <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a> );</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;      mem += <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aa37e36b86f68b59cf4595326b02bd1f8">size</a>() * ( <span class="keyword">sizeof</span>( <span class="keywordtype">void</span>* )       <span class="comment">/* next */</span></div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;                        + <span class="keyword">sizeof</span>( Key )       <span class="comment">/* key */</span></div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;                        + <span class="keyword">sizeof</span>( <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a> ) <span class="comment">/* hash  */</span></div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;                        + <span class="keyword">sizeof</span>( <span class="keywordtype">void</span>* )     <span class="comment">/* dyn. alloc. */</span> );</div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;      <span class="keywordflow">return</span> mem;</div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a22d3747a2702ec4327f8ba5ac50ed2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d3747a2702ec4327f8ba5ac50ed2e8">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a>&amp; <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the object to clone </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00505">505</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;    {</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;      <span class="keywordflow">if</span> ( <span class="keyword">this</span> != &amp;other )</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;        {</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;          <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aa28026264edfe83b6866d13da3b0e568">my_splitter</a> = other.my_splitter;</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;          <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a> = other.my_elements;</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;          <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aaa8363d4cddc821fc441df9f35a39d1c">my_size</a>     = other.my_size;</div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;        }</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;      <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a27e7cd8044ab48d50a68581d6cf207b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e7cd8044ab48d50a68581d6cf207b0">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a>&amp; <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default move assignment </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the object to clone </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00518">518</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;    {</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;      <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aa28026264edfe83b6866d13da3b0e568">my_splitter</a> = std::move( other.my_splitter );</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;      <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a> = std::move( other.my_elements );</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;      <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aaa8363d4cddc821fc441df9f35a39d1c">my_size</a>     = std::move( other.my_size );</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;      <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a898512266e6cfd3b1bfd8508db3df1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898512266e6cfd3b1bfd8508db3df1d4">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a>&#160;</td>
          <td class="paramname"><em>block_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the number of buckets to the number needed to accomodate at least count elements without exceeding maximum load factor and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. Effectively calls <code>rehash(std::ceil(count / max_load_factor()))</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_count</td><td>new capacity of the container (should be thought in terms of number of expected blocks). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l01068">1068</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;    {</div>
<div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;      <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>.reserve( block_count );</div>
<div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa37e36b86f68b59cf4595326b02bd1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa37e36b86f68b59cf4595326b02bd1f8">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a> <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of elements stored in the container. </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00576">576</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aaa8363d4cddc821fc441df9f35a39d1c">my_size</a>; }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="UnorderedSetByBlock_8h_source.html#l01024">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::internal_trace_includes_by_iterator()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00970">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::internal_trace_includes_by_map_iterator()</a>, and <a class="el" href="UnorderedSetByBlock_8h_source.html#l00601">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::memory_usage_unordered_set()</a>.</p>

</div>
</div>
<a id="a36172e48062d5a70acd083827ed5f225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36172e48062d5a70acd083827ed5f225">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad69ca22ee7fd9bb7a6385e76b6c034fd">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other set to exchange with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>All iterators and references remain valid. The past-the-end iterator is invalidated. The Hash and KeyEqual objects must be Swappable, and they are exchanged using unqualified calls to non-member swap. </dd></dl>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l00636">636</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;    {</div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;      std::swap( <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aa28026264edfe83b6866d13da3b0e568">my_splitter</a>, other.my_splitter );</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;      std::swap( <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">my_elements</a>, other.my_elements );</div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;      std::swap( <a class="code" href="structDGtal_1_1UnorderedSetByBlock.html#aaa8363d4cddc821fc441df9f35a39d1c">my_size</a>, other.my_size );</div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="ac7cee622b2e5576c418b0fecf303390f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7cee622b2e5576c418b0fecf303390f">&#9670;&nbsp;</a></span>my_elements</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a561198be4a7c19c479f0da673628c398">Container</a> <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::my_elements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the unordered_set containing the elements </p>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l01080">1080</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="UnorderedSetByBlock_8h_source.html#l00534">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::begin()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00582">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::blocks()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00556">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::cbegin()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00561">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::cend()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00620">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::clear()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00214">DGtal::UnorderedSetByBlock&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::const_iterator::const_iterator()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00877">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::count()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00695">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::emplace()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00574">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::empty()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00539">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::end()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00730">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::erase()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00848">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::find()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00269">DGtal::UnorderedSetByBlock&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::const_iterator::increment()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00409">DGtal::UnorderedSetByBlock&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::iterator::increment()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00656">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::insert()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00949">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::internal_includes_by_map_iterator()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00970">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::internal_trace_includes_by_map_iterator()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00329">DGtal::UnorderedSetByBlock&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::iterator::iterator()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00578">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::max_size()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00586">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::memory_usage()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00601">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::memory_usage_unordered_set()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00505">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::operator=()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l01068">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::reserve()</a>, and <a class="el" href="UnorderedSetByBlock_8h_source.html#l00636">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::swap()</a>.</p>

</div>
</div>
<a id="aaa8363d4cddc821fc441df9f35a39d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8363d4cddc821fc441df9f35a39d1c">&#9670;&nbsp;</a></span>my_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">size_type</a> <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::my_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the number of elements </p>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l01082">1082</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="UnorderedSetByBlock_8h_source.html#l00620">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::clear()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00695">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::emplace()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00730">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::erase()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00656">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::insert()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00505">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::operator=()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00576">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::size()</a>, and <a class="el" href="UnorderedSetByBlock_8h_source.html#l00636">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::swap()</a>.</p>

</div>
</div>
<a id="aa28026264edfe83b6866d13da3b0e568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa28026264edfe83b6866d13da3b0e568">&#9670;&nbsp;</a></span>my_splitter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename TSplitter  = Splitter&lt; Key &gt;, class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class UnorderedMapAllocator  = std::allocator&lt;               std::pair&lt;const Key, typename TSplitter::Word &gt;               &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDGtal_1_1UnorderedSetByBlock.html#a8eab7bcf309c1ea810e7df623b0320fc">Splitter</a> <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a>&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::my_splitter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The splitter object. </p>

<p class="definition">Definition at line <a class="el" href="UnorderedSetByBlock_8h_source.html#l01078">1078</a> of file <a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="UnorderedSetByBlock_8h_source.html#l00249">DGtal::UnorderedSetByBlock&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::const_iterator::const_iterator()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00877">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::count()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00298">DGtal::UnorderedSetByBlock&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::const_iterator::dereference()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00447">DGtal::UnorderedSetByBlock&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::iterator::dereference()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00695">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::emplace()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00848">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::find()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00656">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::insert()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00366">DGtal::UnorderedSetByBlock&lt; Key, TSplitter, Hash, KeyEqual, UnorderedMapAllocator &gt;::iterator::iterator()</a>, <a class="el" href="UnorderedSetByBlock_8h_source.html#l00505">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::operator=()</a>, and <a class="el" href="UnorderedSetByBlock_8h_source.html#l00636">DGtal::UnorderedSetByBlock&lt; PointVector&lt; dim, Integer &gt;, DGtal::Splitter&lt; PointVector&lt; dim, Integer &gt;, uint64_t &gt; &gt;::swap()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="UnorderedSetByBlock_8h_source.html">UnorderedSetByBlock.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="astructDGtal_1_1UnorderedSetByBlock_html_a1684b8a819c502094e20557280f548e7"><div class="ttname"><a href="structDGtal_1_1UnorderedSetByBlock.html#a1684b8a819c502094e20557280f548e7">DGtal::UnorderedSetByBlock::find</a></div><div class="ttdeci">iterator find(const Key &amp;key)</div><div class="ttdef"><b>Definition:</b> <a href="UnorderedSetByBlock_8h_source.html#l00848">UnorderedSetByBlock.h:848</a></div></div>
<div class="ttc" id="astructDGtal_1_1Bits_html_a6c8ae97b5a23db19fe0a04429f6f61c9"><div class="ttname"><a href="structDGtal_1_1Bits.html#a6c8ae97b5a23db19fe0a04429f6f61c9">DGtal::Bits::nbSetBits</a></div><div class="ttdeci">static unsigned int nbSetBits(T val)</div><div class="ttdef"><b>Definition:</b> <a href="Bits_8h_source.html#l00130">Bits.h:130</a></div></div>
<div class="ttc" id="anamespaceDGtal_html_a8fc7012708b0416880a5c8b12dfdf9dd"><div class="ttname"><a href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">DGtal::trace</a></div><div class="ttdeci">Trace trace</div><div class="ttdef"><b>Definition:</b> <a href="Common_8h_source.html#l00150">Common.h:150</a></div></div>
<div class="ttc" id="astructDGtal_1_1UnorderedSetByBlock_html_ac7cee622b2e5576c418b0fecf303390f"><div class="ttname"><a href="structDGtal_1_1UnorderedSetByBlock.html#ac7cee622b2e5576c418b0fecf303390f">DGtal::UnorderedSetByBlock::my_elements</a></div><div class="ttdeci">Container my_elements</div><div class="ttdoc">the unordered_set containing the elements</div><div class="ttdef"><b>Definition:</b> <a href="UnorderedSetByBlock_8h_source.html#l01080">UnorderedSetByBlock.h:1080</a></div></div>
<div class="ttc" id="astructDGtal_1_1UnorderedSetByBlock_html_a5dca62cd20caa4550443e02e13fc70b8"><div class="ttname"><a href="structDGtal_1_1UnorderedSetByBlock.html#a5dca62cd20caa4550443e02e13fc70b8">DGtal::UnorderedSetByBlock::blocks</a></div><div class="ttdeci">size_type blocks() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="UnorderedSetByBlock_8h_source.html#l00582">UnorderedSetByBlock.h:582</a></div></div>
<div class="ttc" id="aclassDGtal_1_1Trace_html_ad054990834d2763627166540087a2980"><div class="ttname"><a href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">DGtal::Trace::info</a></div><div class="ttdeci">std::ostream &amp; info()</div></div>
<div class="ttc" id="astructDGtal_1_1UnorderedSetByBlock_html_a9829652d26187c567691b75d85737326"><div class="ttname"><a href="structDGtal_1_1UnorderedSetByBlock.html#a9829652d26187c567691b75d85737326">DGtal::UnorderedSetByBlock::cend</a></div><div class="ttdeci">const_iterator cend() const</div><div class="ttdef"><b>Definition:</b> <a href="UnorderedSetByBlock_8h_source.html#l00561">UnorderedSetByBlock.h:561</a></div></div>
<div class="ttc" id="astructDGtal_1_1UnorderedSetByBlock_html_aa28026264edfe83b6866d13da3b0e568"><div class="ttname"><a href="structDGtal_1_1UnorderedSetByBlock.html#aa28026264edfe83b6866d13da3b0e568">DGtal::UnorderedSetByBlock::my_splitter</a></div><div class="ttdeci">Splitter my_splitter</div><div class="ttdoc">The splitter object.</div><div class="ttdef"><b>Definition:</b> <a href="UnorderedSetByBlock_8h_source.html#l01078">UnorderedSetByBlock.h:1078</a></div></div>
<div class="ttc" id="astructDGtal_1_1UnorderedSetByBlock_html_aa37e36b86f68b59cf4595326b02bd1f8"><div class="ttname"><a href="structDGtal_1_1UnorderedSetByBlock.html#aa37e36b86f68b59cf4595326b02bd1f8">DGtal::UnorderedSetByBlock::size</a></div><div class="ttdeci">size_type size() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="UnorderedSetByBlock_8h_source.html#l00576">UnorderedSetByBlock.h:576</a></div></div>
<div class="ttc" id="astructDGtal_1_1UnorderedSetByBlock_html_a07bf069d09b826a3c3ba67bcd3b1fd7c"><div class="ttname"><a href="structDGtal_1_1UnorderedSetByBlock.html#a07bf069d09b826a3c3ba67bcd3b1fd7c">DGtal::UnorderedSetByBlock::end</a></div><div class="ttdeci">iterator end()</div><div class="ttdef"><b>Definition:</b> <a href="UnorderedSetByBlock_8h_source.html#l00539">UnorderedSetByBlock.h:539</a></div></div>
<div class="ttc" id="astructDGtal_1_1UnorderedSetByBlock_html_a6568e365f0cda8a20b1ae484fd98bf13"><div class="ttname"><a href="structDGtal_1_1UnorderedSetByBlock.html#a6568e365f0cda8a20b1ae484fd98bf13">DGtal::UnorderedSetByBlock::erase</a></div><div class="ttdeci">iterator erase(const_iterator pos) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="UnorderedSetByBlock_8h_source.html#l00730">UnorderedSetByBlock.h:730</a></div></div>
<div class="ttc" id="astructDGtal_1_1UnorderedSetByBlock_html_aaa8363d4cddc821fc441df9f35a39d1c"><div class="ttname"><a href="structDGtal_1_1UnorderedSetByBlock.html#aaa8363d4cddc821fc441df9f35a39d1c">DGtal::UnorderedSetByBlock::my_size</a></div><div class="ttdeci">size_type my_size</div><div class="ttdoc">the number of elements</div><div class="ttdef"><b>Definition:</b> <a href="UnorderedSetByBlock_8h_source.html#l01082">UnorderedSetByBlock.h:1082</a></div></div>
<div class="ttc" id="astructDGtal_1_1UnorderedSetByBlock_html_ad170ff228e1814348e1139bb9277eb0d"><div class="ttname"><a href="structDGtal_1_1UnorderedSetByBlock.html#ad170ff228e1814348e1139bb9277eb0d">DGtal::UnorderedSetByBlock::size_type</a></div><div class="ttdeci">Container::size_type size_type</div><div class="ttdoc">Unsigned integer type (usually std::size_t)</div><div class="ttdef"><b>Definition:</b> <a href="UnorderedSetByBlock_8h_source.html#l00178">UnorderedSetByBlock.h:178</a></div></div>
<div class="ttc" id="aclassDGtal_1_1PointVector_html"><div class="ttname"><a href="classDGtal_1_1PointVector.html">DGtal::PointVector</a></div><div class="ttdoc">Aim: Implements basic operations that will be used in Point and Vector classes.</div><div class="ttdef"><b>Definition:</b> <a href="PointVector_8h_source.html#l00592">PointVector.h:593</a></div></div>
<div class="ttc" id="astructDGtal_1_1UnorderedSetByBlock_html"><div class="ttname"><a href="structDGtal_1_1UnorderedSetByBlock.html">DGtal::UnorderedSetByBlock</a></div><div class="ttdef"><b>Definition:</b> <a href="UnorderedSetByBlock_8h_source.html#l00163">UnorderedSetByBlock.h:163</a></div></div>
<div class="ttc" id="astructDGtal_1_1UnorderedSetByBlock_html_aa8939c6173ea02d994fa77890715f1c3"><div class="ttname"><a href="structDGtal_1_1UnorderedSetByBlock.html#aa8939c6173ea02d994fa77890715f1c3">DGtal::UnorderedSetByBlock::internal_includes_by_map_iterator</a></div><div class="ttdeci">bool internal_includes_by_map_iterator(const Self &amp;other) const</div><div class="ttdef"><b>Definition:</b> <a href="UnorderedSetByBlock_8h_source.html#l00949">UnorderedSetByBlock.h:949</a></div></div>
<div class="ttc" id="astructDGtal_1_1UnorderedSetByBlock_html_a3c2077e466982b6f25254da3c6184f72"><div class="ttname"><a href="structDGtal_1_1UnorderedSetByBlock.html#a3c2077e466982b6f25254da3c6184f72">DGtal::UnorderedSetByBlock::Word</a></div><div class="ttdeci">Splitter::Word Word</div><div class="ttdef"><b>Definition:</b> <a href="UnorderedSetByBlock_8h_source.html#l00166">UnorderedSetByBlock.h:166</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 6 2020 14:17:36 for DGtal by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
