<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: DGtal::functors Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceDGtal.html">DGtal</a></li><li class="navelem"><a class="el" href="namespaceDGtal_1_1functors.html">functors</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">DGtal::functors Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>functors</code> namespace gathers all <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> functors.  
<a href="namespaceDGtal_1_1functors.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceDGtal_1_1functors_1_1deprecated"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors_1_1deprecated.html">deprecated</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceDGtal_1_1functors_1_1ShapeGeometricFunctors"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors_1_1ShapeGeometricFunctors.html">ShapeGeometricFunctors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Abs.html">Abs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1AndBoolFct2.html">AndBoolFct2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1BackwardRigidTransformation2D.html">BackwardRigidTransformation2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements backward rigid transformation of point in the 2D integer space. Warring: This version uses closest neighbor interpolation.  <a href="classDGtal_1_1functors_1_1BackwardRigidTransformation2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1BackwardRigidTransformation3D.html">BackwardRigidTransformation3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements backward rigid transformation of point in 3D integer space around any arbitrary axis. This implementation uses the <a href="http://mathworld.wolfram.com/RodriguesRotationFormula.html">Rodrigues' rotation formula</a>. Warring: This version uses closest neighbor interpolation.  <a href="classDGtal_1_1functors_1_1BackwardRigidTransformation3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1BallConstantFunction.html">BallConstantFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1BallConstantPointFunction.html">BallConstantPointFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1BasicDomainSubSampler.html">BasicDomainSubSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Functor that subsamples an initial domain by given a grid size and a shift vector. By this way, for a given point considered in a new domain, it allows to recover the point coordinates in the source domain. Such functor can be usefull to apply basic image subsampling in any dimensions by using <a class="el" href="classDGtal_1_1ImageAdapter.html" title="Aim: implements an image adapter with a given domain (i.e. a subdomain) and 3 functors : g for domain...">ImageAdapter</a> class.  <a href="classDGtal_1_1functors_1_1BasicDomainSubSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1BinaryPointPredicate.html">BinaryPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the given binary functor returns true for the two PointPredicates given at construction.  <a href="structDGtal_1_1functors_1_1BinaryPointPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1BinaryPointPredicate_3_01TPointPredicate1_00_01TPointPredicate2_00_01AndBoolFct2_01_4.html">BinaryPointPredicate&lt; TPointPredicate1, TPointPredicate2, AndBoolFct2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1BinaryPointPredicate_3_01TPointPredicate1_00_01TPointPredicate2_00_01OrBoolFct2_01_4.html">BinaryPointPredicate&lt; TPointPredicate1, TPointPredicate2, OrBoolFct2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1BlueChannel.html">BlueChannel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1BoundaryPredicate.html">BoundaryPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate on surfels that represents the frontier between a region and its complementary in an image. It can be used with <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels....">ExplicitDigitalSurface</a> or <a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels....">LightExplicitDigitalSurface</a> so as to define a digital surface. Such surfaces may of course be open.  <a href="classDGtal_1_1functors_1_1BoundaryPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Cast.html">Cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a simple functor using the static cast operator.  <a href="structDGtal_1_1functors_1_1Cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Ceil.html">Ceil</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor that rounds up.  <a href="structDGtal_1_1functors_1_1Ceil.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Ceil_3_01void_01_4.html">Ceil&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor that rounds up.  <a href="structDGtal_1_1functors_1_1Ceil_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1ColorRGBEncoder.html">ColorRGBEncoder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1Composer.html">Composer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a new Functor from the composition of two other functors.  <a href="classDGtal_1_1functors_1_1Composer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1ConstantPointPredicate.html">ConstantPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate that returns always the same value boolCst.  <a href="structDGtal_1_1functors_1_1ConstantPointPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html">ConstImageFunctorHolder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a point-dependent (and possibly domain-dependent) functor into a constant image.  <a href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1ConstValue.html">ConstValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a simple functor that returns a constant value (0 by default).  <a href="classDGtal_1_1functors_1_1ConstValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1ConstValueCell.html">ConstValueCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a simple functor that returns a constant quantity (0 by default).  <a href="classDGtal_1_1functors_1_1ConstValueCell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1DomainPredicate.html">DomainPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returning true iff the point is in the domain given at construction. It is just a wrapper class around the methods Domain::isInside( const Point &amp; ), where <code>Domain</code> stands for any model of CDomain.  <a href="structDGtal_1_1functors_1_1DomainPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1DomainRigidTransformation2D.html">DomainRigidTransformation2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements bounds of transformed domain.  <a href="classDGtal_1_1functors_1_1DomainRigidTransformation2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1DomainRigidTransformation3D.html">DomainRigidTransformation3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements bounds of transformed domain.  <a href="classDGtal_1_1functors_1_1DomainRigidTransformation3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1DummyEstimatorFromSurfels.html">DummyEstimatorFromSurfels</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1ElementaryConvolutionNormalVectorEstimator.html">ElementaryConvolutionNormalVectorEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Estimates normal vector by convolution of elementary normal vector to adjacent surfel.  <a href="classDGtal_1_1functors_1_1ElementaryConvolutionNormalVectorEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1EqualPointPredicate.html">EqualPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the point given as argument equals the reference point given at construction.  <a href="structDGtal_1_1functors_1_1EqualPointPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1FalseBoolFct0.html">FalseBoolFct0</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1FalsePointPredicate.html">FalsePointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate that returns always false.  <a href="structDGtal_1_1functors_1_1FalsePointPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1FlipDomainAxis.html">FlipDomainAxis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Functor that flips the domain coordinate system from some selected axis. For instance, if a flip on the y axis is applied on a domain of bounds (0, 0, 0) (MaxX, MaxY, MaxZ), then the coordinate of P(x,y,z) will transformed in P(x, MaxY-y, z).  <a href="classDGtal_1_1functors_1_1FlipDomainAxis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Floor.html">Floor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor that rounds down.  <a href="structDGtal_1_1functors_1_1Floor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Floor_3_01void_01_4.html">Floor&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor that rounds down.  <a href="structDGtal_1_1functors_1_1Floor_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1ForwardRigidTransformation2D.html">ForwardRigidTransformation2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements forward rigid transformation of point in the 2D integer space. Warring: This version uses closest neighbor interpolation.  <a href="classDGtal_1_1functors_1_1ForwardRigidTransformation2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1ForwardRigidTransformation3D.html">ForwardRigidTransformation3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements forward rigid transformation of point in 3D integer space around any arbitrary axis. This implementation uses the <a href="http://mathworld.wolfram.com/RodriguesRotationFormula.html">Rodrigues' rotation formula</a>. Warring: This version uses closest neighbor interpolation.  <a href="classDGtal_1_1functors_1_1ForwardRigidTransformation3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1FrontierPredicate.html">FrontierPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate on surfels that represents the frontier between two regions in an image. It can be used with <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels....">ExplicitDigitalSurface</a> or <a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels....">LightExplicitDigitalSurface</a> so as to define a digital surface. Such surfaces may of course be open.  <a href="classDGtal_1_1functors_1_1FrontierPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model.  <a href="classDGtal_1_1functors_1_1FunctorHolder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1GaussianKernel.html">GaussianKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: defines a functor on double numbers which corresponds to a Gaussian convolution kernel. This functor acts from [0,1] to [0,1].  <a href="structDGtal_1_1functors_1_1GaussianKernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1GreenChannel.html">GreenChannel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1HatFunction.html">HatFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1HatPointFunction.html">HatPointFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Identity.html">Identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a simple default functor that just returns its argument.  <a href="structDGtal_1_1functors_1_1Identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1IdentityBoolFct1.html">IdentityBoolFct1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1IICurvatureFunctor.html">IICurvatureFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A functor Real -&gt; Real that returns the 2d curvature by transforming the given volume. This functor is valid only in 2D space.  <a href="structDGtal_1_1functors_1_1IICurvatureFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1IIFirstPrincipalCurvature3DFunctor.html">IIFirstPrincipalCurvature3DFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A functor Matrix -&gt; Real that returns the first principal curvature value by diagonalizing the given covariance matrix. This functor is valid starting from 3D space. Note that by first we mean the value with first greatest curvature in absolute value.  <a href="structDGtal_1_1functors_1_1IIFirstPrincipalCurvature3DFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1IIFirstPrincipalDirectionFunctor.html">IIFirstPrincipalDirectionFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A functor Matrix -&gt; RealVector that returns the first principal curvature direction by diagonalizing the given covariance matrix. This functor is valid starting from 2D space and is equivalent to <a class="el" href="classDGtal_1_1functors_1_1IITangentDirectionFunctor.html" title="Aim: A functor Matrix -&gt; RealVector that returns the tangent direction by diagonalizing the given cov...">IITangentDirectionFunctor</a> in 2D. Note that by first we mean the direction with greatest curvature in absolute value.  <a href="classDGtal_1_1functors_1_1IIFirstPrincipalDirectionFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1IIGaussianCurvature3DFunctor.html">IIGaussianCurvature3DFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A functor Matrix -&gt; Real that returns the Gaussian curvature by diagonalizing the given covariance matrix. This functor is valid starting from 3D space. Note that the Gaussian curvature is computed by multiplying the two gretest curvature values in absolute value.  <a href="structDGtal_1_1functors_1_1IIGaussianCurvature3DFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1IIMeanCurvature3DFunctor.html">IIMeanCurvature3DFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A functor Real -&gt; Real that returns the 3d mean curvature by transforming the given volume. This functor is valid only in 3D space.  <a href="structDGtal_1_1functors_1_1IIMeanCurvature3DFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1IINormalDirectionFunctor.html">IINormalDirectionFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A functor Matrix -&gt; RealVector that returns the normal direction by diagonalizing the given covariance matrix.  <a href="classDGtal_1_1functors_1_1IINormalDirectionFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1IIPrincipalCurvatures3DFunctor.html">IIPrincipalCurvatures3DFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A functor Matrix -&gt; std::pair&lt;Real,Real&gt; that returns the first and the second principal curvature value by diagonalizing the given covariance matrix. This functor is valid starting from 3D space. Note that by first we mean the value with first greatest curvature in absolute value.  <a href="structDGtal_1_1functors_1_1IIPrincipalCurvatures3DFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1IIPrincipalCurvaturesAndDirectionsFunctor.html">IIPrincipalCurvaturesAndDirectionsFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A functor Matrix -&gt; std::pair&lt;RealVector,RealVector&gt; that returns the first and the second principal curvature directions by diagonalizing the given covariance matrix. This functor is valid only for 3D space. Note that by second we mean the direction with second greatest curvature in absolute value.  <a href="classDGtal_1_1functors_1_1IIPrincipalCurvaturesAndDirectionsFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1IIPrincipalDirectionsFunctor.html">IIPrincipalDirectionsFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A functor Matrix -&gt; std::pair&lt;RealVector,RealVector&gt; that returns the first and the second principal curvature directions by diagonalizing the given covariance matrix. This functor is valid starting from 3D space. Note that by second we mean the direction with second greatest curvature in absolute value.  <a href="classDGtal_1_1functors_1_1IIPrincipalDirectionsFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1IISecondPrincipalCurvature3DFunctor.html">IISecondPrincipalCurvature3DFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A functor Matrix -&gt; Real that returns the second principal curvature value by diagonalizing the given covariance matrix. This functor is valid starting from 3D space. Note that by second we mean the value with second greatest curvature in absolute value.  <a href="structDGtal_1_1functors_1_1IISecondPrincipalCurvature3DFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1IISecondPrincipalDirectionFunctor.html">IISecondPrincipalDirectionFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A functor Matrix -&gt; RealVector that returns the second principal curvature direction by diagonalizing the given covariance matrix. This functor is valid starting from 3D space. Note that by second we mean the direction with second greatest curvature in absolute value.  <a href="classDGtal_1_1functors_1_1IISecondPrincipalDirectionFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1IITangentDirectionFunctor.html">IITangentDirectionFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A functor Matrix -&gt; RealVector that returns the tangent direction by diagonalizing the given covariance matrix. This functor is valid only in 2D space.  <a href="classDGtal_1_1functors_1_1IITangentDirectionFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1ImpliesBoolFct2.html">ImpliesBoolFct2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1IntervalForegroundPredicate.html">IntervalForegroundPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a simple Foreground predicate thresholding image values between two constant values (the first one being excluded).  <a href="classDGtal_1_1functors_1_1IntervalForegroundPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1IntervalThresholder.html">IntervalThresholder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small functor with an operator () that compares one value to an interval.  <a href="classDGtal_1_1functors_1_1IntervalThresholder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1IsLowerPointPredicate.html">IsLowerPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the point is below (or equal) the given upper bound.  <a href="structDGtal_1_1functors_1_1IsLowerPointPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1IsUpperPointPredicate.html">IsUpperPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the point is above (or equal) the given lower bound.  <a href="structDGtal_1_1functors_1_1IsUpperPointPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1IsWithinPointPredicate.html">IsWithinPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the point is within the given bounds.  <a href="structDGtal_1_1functors_1_1IsWithinPointPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Lambda64Function.html">Lambda64Function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1LambdaExponentialFunction.html">LambdaExponentialFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1LambdaSinFromPiFunction.html">LambdaSinFromPiFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1LargeTruncationFunctor.html">LargeTruncationFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary functor that returns the algebraic quotient i of a/b with any fractional part discarded (truncation toward zero). <br  />
 Note that \( |i| \leq |a/b| \).  <a href="structDGtal_1_1functors_1_1LargeTruncationFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1LinearLeastSquareFittingNormalVectorEstimator.html">LinearLeastSquareFittingNormalVectorEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Estimates normal vector using CGAL linear least squares plane fitting.  <a href="classDGtal_1_1functors_1_1LinearLeastSquareFittingNormalVectorEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1MagickCast.html">MagickCast</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1MagickCast_3_01Color_01_4.html">MagickCast&lt; Color &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Max.html">Max</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1MeanChannels.html">MeanChannels</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Min.html">Min</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicated STL functors.  <a href="structDGtal_1_1functors_1_1Min.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Minus.html">Minus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1MongeJetFittingGaussianCurvatureEstimator.html">MongeJetFittingGaussianCurvatureEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Estimates Gaussian curvature using CGAL Jet Fitting and Monge Form.  <a href="classDGtal_1_1functors_1_1MongeJetFittingGaussianCurvatureEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1MongeJetFittingMeanCurvatureEstimator.html">MongeJetFittingMeanCurvatureEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Estimates Mean curvature using CGAL Jet Fitting and Monge Form.  <a href="classDGtal_1_1functors_1_1MongeJetFittingMeanCurvatureEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1MongeJetFittingNormalVectorEstimator.html">MongeJetFittingNormalVectorEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Estimates normal vector using CGAL Jet Fitting and Monge Form.  <a href="classDGtal_1_1functors_1_1MongeJetFittingNormalVectorEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1MongeJetFittingPrincipalCurvaturesEstimator.html">MongeJetFittingPrincipalCurvaturesEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Estimates Gaussian curvature using CGAL Jet Fitting and Monge Form.  <a href="classDGtal_1_1functors_1_1MongeJetFittingPrincipalCurvaturesEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1MultiplicationByScalar.html">MultiplicationByScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1NotBoolFct1.html">NotBoolFct1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1NotPointPredicate.html">NotPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the point predicate given at construction return false. Thus inverse a predicate: NOT operator.  <a href="structDGtal_1_1functors_1_1NotPointPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1OrBoolFct2.html">OrBoolFct2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1Pair1st.html">Pair1st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a simple functor that returns the first member of a pair.  <a href="classDGtal_1_1functors_1_1Pair1st.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1Pair1stMutator.html">Pair1stMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a simple unary functor that returns a reference on the first member of a pair in order to update it.  <a href="classDGtal_1_1functors_1_1Pair1stMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1Pair2nd.html">Pair2nd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a simple functor that returns the second member of a pair.  <a href="classDGtal_1_1functors_1_1Pair2nd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1Pair2ndMutator.html">Pair2ndMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a simple unary functor that returns a reference on the first member of a pair in order to update it.  <a href="classDGtal_1_1functors_1_1Pair2ndMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1Point2DEmbedderIn3D.html">Point2DEmbedderIn3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Functor that embeds a 2D point into a 3D space from two axis vectors and an origin point given in the 3D space.  <a href="classDGtal_1_1functors_1_1Point2DEmbedderIn3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1Point2ShapePredicate.html">Point2ShapePredicate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Point2ShapePredicateComparator.html">Point2ShapePredicateComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small struct with an operator that compares two values according to two bool template parameters.  <a href="structDGtal_1_1functors_1_1Point2ShapePredicateComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Point2ShapePredicateComparator_3_01T_00_01false_00_01false_01_4.html">Point2ShapePredicateComparator&lt; T, false, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small struct with an operator that compares two values (&lt;).  <a href="structDGtal_1_1functors_1_1Point2ShapePredicateComparator_3_01T_00_01false_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Point2ShapePredicateComparator_3_01T_00_01false_00_01true_01_4.html">Point2ShapePredicateComparator&lt; T, false, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small struct with an operator that compares two values (&lt;=).  <a href="structDGtal_1_1functors_1_1Point2ShapePredicateComparator_3_01T_00_01false_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Point2ShapePredicateComparator_3_01T_00_01true_00_01false_01_4.html">Point2ShapePredicateComparator&lt; T, true, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small struct with an operator that compares two values (&gt;).  <a href="structDGtal_1_1functors_1_1Point2ShapePredicateComparator_3_01T_00_01true_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Point2ShapePredicateComparator_3_01T_00_01true_00_01true_01_4.html">Point2ShapePredicateComparator&lt; T, true, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small struct with an operator that compares two values (&gt;=).  <a href="structDGtal_1_1functors_1_1Point2ShapePredicateComparator_3_01T_00_01true_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1PointFunctorFromPointPredicateAndDomain.html">PointFunctorFromPointPredicateAndDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a point functor from a point predicate and a domain.  <a href="structDGtal_1_1functors_1_1PointFunctorFromPointPredicateAndDomain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html">PointFunctorHolder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: hold any object callable on points as a <a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html">DGtal::concepts::CPointFunctor</a> model.  <a href="classDGtal_1_1functors_1_1PointFunctorHolder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1PointFunctorPredicate.html">PointFunctorPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the predicate returns true for the value assigned to a given point in the point functor.  <a href="structDGtal_1_1functors_1_1PointFunctorPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1PolarPointComparatorBy2x2DetComputer.html">PolarPointComparatorBy2x2DetComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class that implements a binary point predicate, which is able to compare the position of two given points \( P, Q \) around a pole \( O \). More precisely, it compares the oriented angles lying between the horizontal line passing by \( O \) and the rays \( [OP) \) and \( [OQ) \) (in a counter-clockwise orientation).  <a href="classDGtal_1_1functors_1_1PolarPointComparatorBy2x2DetComputer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1PositionFunctorFrom2DPoint.html">PositionFunctorFrom2DPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor that returns the position of any point/vector with respect to a digital straight line of shift <em>myShift</em>. We recall that the shift vector is a vector translating a point of remainder \( r \) to a point of remainder \( r + \omega \). See <a class="el" href="moduleArithDSSReco.html">Digital straight lines and segments</a> for further details.  <a href="structDGtal_1_1functors_1_1PositionFunctorFrom2DPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1PredicateCombiner.html">PredicateCombiner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the given binary functor returns true for the two Predicates given at construction.  <a href="structDGtal_1_1functors_1_1PredicateCombiner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Projector.html">Projector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Functor that maps a point P of dimension i to a point Q of dimension j. The member <em>myDims</em> is an array containing the coordinates - (0, 1, ..., j-1) by default - that are copied from P to Q.  <a href="structDGtal_1_1functors_1_1Projector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1RedChannel.html">RedChannel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Rescaling.html">Rescaling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Functor allowing to rescale a value. Values of the initial scale [initMin,initMax] are rescaled to the new scale [newMin,newMax].  <a href="structDGtal_1_1functors_1_1Rescaling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Round.html">Round</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor that rounds to the nearest integer.  <a href="structDGtal_1_1functors_1_1Round.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Round_3_01void_01_4.html">Round&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor that rounds to the nearest integer.  <a href="structDGtal_1_1functors_1_1Round_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1SCellToArrow.html">SCellToArrow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a signed cell into an arrow, ie. a pair point-vector.  <a href="classDGtal_1_1functors_1_1SCellToArrow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1SCellToCode.html">SCellToCode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a 2d signed cell, basically a linel, into a code (0,1,2 or 3),.  <a href="classDGtal_1_1functors_1_1SCellToCode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1SCellToIncidentPoints.html">SCellToIncidentPoints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a signed cell c into a pair of points corresponding to the signed cells of greater dimension that are indirectly and directly incident to c.  <a href="classDGtal_1_1functors_1_1SCellToIncidentPoints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1SCellToInnerPoint.html">SCellToInnerPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a signed cell c into a point corresponding to the signed cell of greater dimension that is indirectly incident to c.  <a href="classDGtal_1_1functors_1_1SCellToInnerPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1SCellToOuterPoint.html">SCellToOuterPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a signed cell c into a point corresponding to the signed cell of greater dimension that is directly incident to c.  <a href="classDGtal_1_1functors_1_1SCellToOuterPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1SCellToPoint.html">SCellToPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a scell into a point.  <a href="classDGtal_1_1functors_1_1SCellToPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1SimpleThresholdForegroundPredicate.html">SimpleThresholdForegroundPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a simple Foreground predicate thresholding image values given a single thresold. More precisely, the functor operator() returns true if the value is greater than a given threshold.  <a href="classDGtal_1_1functors_1_1SimpleThresholdForegroundPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1SliceRotator2D.html">SliceRotator2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special Point Functor that adds one dimension to a 2D point and apply on it a rotation of angle alpha according to a given direction and the domain center. It also checks if the resulting point is inside the 3D domain, else it returns a particular point (by default the point at domain origin (from the domain method lowerBound()).  <a href="classDGtal_1_1functors_1_1SliceRotator2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1SphereFittingEstimator.html">SphereFittingEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Use Patate library to perform a local sphere fitting.  <a href="classDGtal_1_1functors_1_1SphereFittingEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1SphericalHoughNormalVectorEstimator.html">SphericalHoughNormalVectorEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This functor estimates normal vector for a collection of surfels using spherical accumulator based Hough voting.  <a href="classDGtal_1_1functors_1_1SphericalHoughNormalVectorEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1StrictTruncationFunctor.html">StrictTruncationFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">BinaryFunctor that computes the algebraic quotient i of a/b with any non zero fractional part discarded (truncation toward zero), and that returns i+1 (resp. i-1) if a is negative (resp. positive) if b divides a. Since we assume that a is not equal to 0, we have \( |i| &lt; |a/b| \). See also <a class="el" href="structDGtal_1_1functors_1_1LargeTruncationFunctor.html" title="Binary functor that returns the algebraic quotient i of a/b with any fractional part discarded (trunc...">LargeTruncationFunctor</a>.  <a href="structDGtal_1_1functors_1_1StrictTruncationFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1SurfelSetPredicate.html">SurfelSetPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returning true iff the point is in the domain given at construction.  <a href="structDGtal_1_1functors_1_1SurfelSetPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1TensorVotingFeatureExtraction.html">TensorVotingFeatureExtraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements a functor to detect feature points from normal tensor voting strategy.  <a href="classDGtal_1_1functors_1_1TensorVotingFeatureExtraction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1Thresholder.html">Thresholder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small functor with an operator () that compares one value to a threshold value according to two bool template parameters.  <a href="classDGtal_1_1functors_1_1Thresholder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Thresholder_3_01T_00_01false_00_01false_01_4.html">Thresholder&lt; T, false, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Thresholder_3_01T_00_01false_00_01true_01_4.html">Thresholder&lt; T, false, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Thresholder_3_01T_00_01true_00_01false_01_4.html">Thresholder&lt; T, true, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Thresholder_3_01T_00_01true_00_01true_01_4.html">Thresholder&lt; T, true, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1TrueBoolFct0.html">TrueBoolFct0</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1TruePointPredicate.html">TruePointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate that returns always true.  <a href="structDGtal_1_1functors_1_1TruePointPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Trunc.html">Trunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor that rounds towards zero.  <a href="structDGtal_1_1functors_1_1Trunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1Trunc_3_01void_01_4.html">Trunc&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor that rounds towards zero.  <a href="structDGtal_1_1functors_1_1Trunc_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1UnaryMinus.html">UnaryMinus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1VCMAbsoluteCurvatureFunctor.html">VCMAbsoluteCurvatureFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A functor Surfel -&gt; Quantity that returns the absolute curvature at given surfel. This class has meaning only in 2D.  <a href="structDGtal_1_1functors_1_1VCMAbsoluteCurvatureFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1VCMFirstPrincipalAbsoluteCurvatureFunctor.html">VCMFirstPrincipalAbsoluteCurvatureFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A functor Surfel -&gt; Quantity that returns the first principal absolute curvature (greatest curvature) at given surfel. This class has meaning only in 3D.  <a href="structDGtal_1_1functors_1_1VCMFirstPrincipalAbsoluteCurvatureFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1VCMMeanAbsoluteCurvatures3DFunctor.html">VCMMeanAbsoluteCurvatures3DFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A functor Surfel -&gt; Quantity that returns the mean of absolute curvatures at given surfel: (abs(k1)+abs(k2))/2. This class has meaning only in 3D.  <a href="structDGtal_1_1functors_1_1VCMMeanAbsoluteCurvatures3DFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1VCMNormalVectorFunctor.html">VCMNormalVectorFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A functor Surfel -&gt; Quantity that returns the outer normal vector at given surfel.  <a href="structDGtal_1_1functors_1_1VCMNormalVectorFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1VCMSecondPrincipalAbsoluteCurvatureFunctor.html">VCMSecondPrincipalAbsoluteCurvatureFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A functor Surfel -&gt; Quantity that returns the second principal absolute curvature (smallest curvature) at given surfel. This class has meaning only in 3D.  <a href="structDGtal_1_1functors_1_1VCMSecondPrincipalAbsoluteCurvatureFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1VectorRounding.html">VectorRounding</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1functors_1_1XorBoolFct2.html">XorBoolFct2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa643601588b4b3ce48aded757e8fd7c7"><td class="memItemLeft" align="right" valign="top">typedef boost::function0&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors.html#aa643601588b4b3ce48aded757e8fd7c7">BoolFunctor0</a></td></tr>
<tr class="separator:aa643601588b4b3ce48aded757e8fd7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c097791d2639aed3534e3547291d916"><td class="memItemLeft" align="right" valign="top">typedef boost::function1&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors.html#a9c097791d2639aed3534e3547291d916">BoolFunctor1</a></td></tr>
<tr class="separator:a9c097791d2639aed3534e3547291d916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeef356bd5d6e01987e9ad5f55353050"><td class="memItemLeft" align="right" valign="top">typedef boost::function2&lt; bool, bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors.html#adeef356bd5d6e01987e9ad5f55353050">BoolFunctor2</a></td></tr>
<tr class="separator:adeef356bd5d6e01987e9ad5f55353050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471f1996fbfd82c45524da01e25c231b"><td class="memItemLeft" align="right" valign="top">typedef boost::function3&lt; bool, bool, bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors.html#a471f1996fbfd82c45524da01e25c231b">BoolFunctor3</a></td></tr>
<tr class="separator:a471f1996fbfd82c45524da01e25c231b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2f8247315145a8ef4de50fbdffc5747a"><td class="memTemplParams" colspan="2">template&lt;typename FunctorStorage , bool NeedDereference&gt; </td></tr>
<tr class="memitem:a2f8247315145a8ef4de50fbdffc5747a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors.html#a2f8247315145a8ef4de50fbdffc5747a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>&lt; FunctorStorage, NeedDereference &gt; &amp;object)</td></tr>
<tr class="memdesc:a2f8247315145a8ef4de50fbdffc5747a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads 'operator&lt;&lt;' for displaying objects of class <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>.  <a href="namespaceDGtal_1_1functors.html#a2f8247315145a8ef4de50fbdffc5747a">More...</a><br /></td></tr>
<tr class="separator:a2f8247315145a8ef4de50fbdffc5747a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6d83ea035f33c3d3fa47730be1ce9d"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:a5f6d83ea035f33c3d3fa47730be1ce9d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a> (Function &amp;&amp;fn) -&gt; decltype(holdFunctorImpl(std::forward&lt; Function &gt;(fn), typename std::is_lvalue_reference&lt; Function &gt;</td></tr>
<tr class="memdesc:a5f6d83ea035f33c3d3fa47730be1ce9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model.  <a href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">More...</a><br /></td></tr>
<tr class="separator:a5f6d83ea035f33c3d3fa47730be1ce9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056e758e28112d33b29c07ef3dace04c"><td class="memTemplParams" colspan="2">template&lt;typename TPoint , typename TDetComputer &gt; </td></tr>
<tr class="memitem:a056e758e28112d33b29c07ef3dace04c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors.html#a056e758e28112d33b29c07ef3dace04c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1functors_1_1PolarPointComparatorBy2x2DetComputer.html">PolarPointComparatorBy2x2DetComputer</a>&lt; TPoint, TDetComputer &gt; &amp;object)</td></tr>
<tr class="separator:a056e758e28112d33b29c07ef3dace04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbfbc4bfa978b0b089bcb1fe98c2ac1"><td class="memTemplParams" colspan="2">template&lt;typename TDomain , typename TValue , typename TFunctor &gt; </td></tr>
<tr class="memitem:a4cbfbc4bfa978b0b089bcb1fe98c2ac1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors.html#a4cbfbc4bfa978b0b089bcb1fe98c2ac1">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html">ConstImageFunctorHolder</a>&lt; TDomain, TValue, TFunctor &gt; &amp;object)</td></tr>
<tr class="memdesc:a4cbfbc4bfa978b0b089bcb1fe98c2ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads 'operator&lt;&lt;' for displaying objects of class <a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html">ConstImageFunctorHolder</a>.  <a href="namespaceDGtal_1_1functors.html#a4cbfbc4bfa978b0b089bcb1fe98c2ac1">More...</a><br /></td></tr>
<tr class="separator:a4cbfbc4bfa978b0b089bcb1fe98c2ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae078b1e517d167341988d5a5d6366a91"><td class="memTemplParams" colspan="2">template&lt;typename TValue , typename TDomain , typename TFunctor &gt; </td></tr>
<tr class="memitem:ae078b1e517d167341988d5a5d6366a91"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors.html#ae078b1e517d167341988d5a5d6366a91">holdConstImageFunctor</a> (TDomain const &amp;aDomain, TFunctor &amp;&amp;aFunctor) -&gt; <a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html">ConstImageFunctorHolder</a>&lt; TDomain, TValue, decltype(<a class="el" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt; TFunctor &gt;(aFunctor)))&gt;</td></tr>
<tr class="memdesc:ae078b1e517d167341988d5a5d6366a91"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html" title="Transform a point-dependent (and possibly domain-dependent) functor into a constant image.">ConstImageFunctorHolder</a> construction helper with specification of the return type.  <a href="namespaceDGtal_1_1functors.html#ae078b1e517d167341988d5a5d6366a91">More...</a><br /></td></tr>
<tr class="separator:ae078b1e517d167341988d5a5d6366a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa8624a2e5d42e63849ae5d2b19ea8a"><td class="memTemplParams" colspan="2">template&lt;typename TDomain , typename TFunctor &gt; </td></tr>
<tr class="memitem:a2aa8624a2e5d42e63849ae5d2b19ea8a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors.html#a2aa8624a2e5d42e63849ae5d2b19ea8a">holdConstImageFunctor</a> (TDomain const &amp;aDomain, TFunctor &amp;&amp;aFunctor) -&gt; <a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html">ConstImageFunctorHolder</a>&lt; TDomain, typename std::decay&lt; decltype(aFunctor(std::declval&lt; typename <a class="el" href="testCubicalComplex_8cpp.html#a15e9592ccc512dc691b46185e6814758">TDomain::Point</a> &gt;()))&gt;::type, decltype(<a class="el" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt; TFunctor &gt;(aFunctor))) &gt;</td></tr>
<tr class="memdesc:a2aa8624a2e5d42e63849ae5d2b19ea8a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html" title="Transform a point-dependent (and possibly domain-dependent) functor into a constant image.">ConstImageFunctorHolder</a> construction helper with auto-deduction of the return type.  <a href="namespaceDGtal_1_1functors.html#a2aa8624a2e5d42e63849ae5d2b19ea8a">More...</a><br /></td></tr>
<tr class="separator:a2aa8624a2e5d42e63849ae5d2b19ea8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35eaf44cefc27e8d094c70e124cdf23e"><td class="memTemplParams" colspan="2">template&lt;typename TPoint , typename TValue , typename TFunctor &gt; </td></tr>
<tr class="memitem:a35eaf44cefc27e8d094c70e124cdf23e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors.html#a35eaf44cefc27e8d094c70e124cdf23e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html">PointFunctorHolder</a>&lt; TPoint, TValue, TFunctor &gt; &amp;object)</td></tr>
<tr class="memdesc:a35eaf44cefc27e8d094c70e124cdf23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads 'operator&lt;&lt;' for displaying objects of class <a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html">PointFunctorHolder</a>.  <a href="namespaceDGtal_1_1functors.html#a35eaf44cefc27e8d094c70e124cdf23e">More...</a><br /></td></tr>
<tr class="separator:a35eaf44cefc27e8d094c70e124cdf23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2edeed82668eb0dd5c4a11c199794237"><td class="memTemplParams" colspan="2">template&lt;typename TPoint , typename TValue , typename TFunctor &gt; </td></tr>
<tr class="memitem:a2edeed82668eb0dd5c4a11c199794237"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors.html#a2edeed82668eb0dd5c4a11c199794237">holdPointFunctor</a> (TFunctor &amp;&amp;aFunctor) -&gt; <a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html">PointFunctorHolder</a>&lt; TPoint, TValue, decltype(<a class="el" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt; TFunctor &gt;(aFunctor)))&gt;</td></tr>
<tr class="memdesc:a2edeed82668eb0dd5c4a11c199794237"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html" title="Aim: hold any object callable on points as a DGtal::concepts::CPointFunctor model.">PointFunctorHolder</a> construction helper with specification of the return type.  <a href="namespaceDGtal_1_1functors.html#a2edeed82668eb0dd5c4a11c199794237">More...</a><br /></td></tr>
<tr class="separator:a2edeed82668eb0dd5c4a11c199794237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcaec612a0b304ea9e866043a2b9480"><td class="memTemplParams" colspan="2">template&lt;typename TPoint , typename TFunctor &gt; </td></tr>
<tr class="memitem:addcaec612a0b304ea9e866043a2b9480"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors.html#addcaec612a0b304ea9e866043a2b9480">holdPointFunctor</a> (TFunctor &amp;&amp;aFunctor) -&gt; <a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html">PointFunctorHolder</a>&lt; TPoint, typename std::decay&lt; decltype(aFunctor(std::declval&lt; TPoint &gt;()))&gt;::type, decltype(<a class="el" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt; TFunctor &gt;(aFunctor))) &gt;</td></tr>
<tr class="memdesc:addcaec612a0b304ea9e866043a2b9480"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html" title="Aim: hold any object callable on points as a DGtal::concepts::CPointFunctor model.">PointFunctorHolder</a> construction helper with auto-deduction of the return type.  <a href="namespaceDGtal_1_1functors.html#addcaec612a0b304ea9e866043a2b9480">More...</a><br /></td></tr>
<tr class="separator:addcaec612a0b304ea9e866043a2b9480"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ace3475deed0ceb6c16332680ff31506f"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal_1_1functors.html#aa643601588b4b3ce48aded757e8fd7c7">BoolFunctor0</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors.html#ace3475deed0ceb6c16332680ff31506f">trueBF0</a> = <a class="el" href="structDGtal_1_1functors_1_1TrueBoolFct0.html">TrueBoolFct0</a>()</td></tr>
<tr class="separator:ace3475deed0ceb6c16332680ff31506f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21e836606fcc449ad58326a746ec06b"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal_1_1functors.html#aa643601588b4b3ce48aded757e8fd7c7">BoolFunctor0</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors.html#ab21e836606fcc449ad58326a746ec06b">falseBF0</a> = <a class="el" href="structDGtal_1_1functors_1_1FalseBoolFct0.html">FalseBoolFct0</a>()</td></tr>
<tr class="separator:ab21e836606fcc449ad58326a746ec06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0f74ad307b8d3608630e802f067c16"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal_1_1functors.html#a9c097791d2639aed3534e3547291d916">BoolFunctor1</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors.html#aab0f74ad307b8d3608630e802f067c16">identityBF1</a> = <a class="el" href="structDGtal_1_1functors_1_1IdentityBoolFct1.html">IdentityBoolFct1</a>()</td></tr>
<tr class="separator:aab0f74ad307b8d3608630e802f067c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d18c0074a75f014ee71c9446ba0340"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal_1_1functors.html#a9c097791d2639aed3534e3547291d916">BoolFunctor1</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors.html#a54d18c0074a75f014ee71c9446ba0340">notBF1</a> = <a class="el" href="structDGtal_1_1functors_1_1NotBoolFct1.html">NotBoolFct1</a>()</td></tr>
<tr class="separator:a54d18c0074a75f014ee71c9446ba0340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f64f8aec85ed2085df8d5c13947324"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal_1_1functors.html#adeef356bd5d6e01987e9ad5f55353050">BoolFunctor2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors.html#a75f64f8aec85ed2085df8d5c13947324">andBF2</a> = <a class="el" href="structDGtal_1_1functors_1_1AndBoolFct2.html">AndBoolFct2</a>()</td></tr>
<tr class="separator:a75f64f8aec85ed2085df8d5c13947324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af339a8f7ec4c1c6fce14623aeaef44bd"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal_1_1functors.html#adeef356bd5d6e01987e9ad5f55353050">BoolFunctor2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors.html#af339a8f7ec4c1c6fce14623aeaef44bd">orBF2</a> = <a class="el" href="structDGtal_1_1functors_1_1OrBoolFct2.html">OrBoolFct2</a>()</td></tr>
<tr class="separator:af339a8f7ec4c1c6fce14623aeaef44bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae084a31146e6491bffe7e72c9bd2104a"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal_1_1functors.html#adeef356bd5d6e01987e9ad5f55353050">BoolFunctor2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors.html#ae084a31146e6491bffe7e72c9bd2104a">xorBF2</a> = <a class="el" href="structDGtal_1_1functors_1_1XorBoolFct2.html">XorBoolFct2</a>()</td></tr>
<tr class="separator:ae084a31146e6491bffe7e72c9bd2104a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bfc4f96b0d7d0a3e60bfbf060ca803"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal_1_1functors.html#adeef356bd5d6e01987e9ad5f55353050">BoolFunctor2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1functors.html#ab8bfc4f96b0d7d0a3e60bfbf060ca803">impliesBF2</a> = <a class="el" href="structDGtal_1_1functors_1_1ImpliesBoolFct2.html">ImpliesBoolFct2</a>()</td></tr>
<tr class="separator:ab8bfc4f96b0d7d0a3e60bfbf060ca803"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><code>functors</code> namespace gathers all <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> functors. </p>
<p>Aim: Provide various lambda functions and others L-MST related functors.</p>
<p>Description: Extension of namespace functors by functors related to L-MST.</p>
<p>A lambda function \(\lambda()\) - maps from [0,1] \(\in \mathbb{R}_+\) with F(0) = F(1) = 0 and F() &gt; 0 elsewhere and need to satisfy convexity/concavity property. For more information see J.-O. Lachaud et el <a class="el" href="citelist.html#CITEREF_LachaudIVC2007">[59]</a>. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aa643601588b4b3ce48aded757e8fd7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa643601588b4b3ce48aded757e8fd7c7">&#9670;&nbsp;</a></span>BoolFunctor0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function0&lt; bool &gt; <a class="el" href="namespaceDGtal_1_1functors.html#aa643601588b4b3ce48aded757e8fd7c7">DGtal::functors::BoolFunctor0</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>May hold bool functors taking no arguments. </p>

<p class="definition">Definition at line <a class="el" href="BasicBoolFunctors_8h_source.html#l00054">54</a> of file <a class="el" href="BasicBoolFunctors_8h_source.html">BasicBoolFunctors.h</a>.</p>

</div>
</div>
<a id="a9c097791d2639aed3534e3547291d916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c097791d2639aed3534e3547291d916">&#9670;&nbsp;</a></span>BoolFunctor1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function1&lt; bool, bool &gt; <a class="el" href="namespaceDGtal_1_1functors.html#a9c097791d2639aed3534e3547291d916">DGtal::functors::BoolFunctor1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>May hold bool functors taking one bool argument. </p>

<p class="definition">Definition at line <a class="el" href="BasicBoolFunctors_8h_source.html#l00059">59</a> of file <a class="el" href="BasicBoolFunctors_8h_source.html">BasicBoolFunctors.h</a>.</p>

</div>
</div>
<a id="adeef356bd5d6e01987e9ad5f55353050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeef356bd5d6e01987e9ad5f55353050">&#9670;&nbsp;</a></span>BoolFunctor2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function2&lt; bool, bool, bool &gt; <a class="el" href="namespaceDGtal_1_1functors.html#adeef356bd5d6e01987e9ad5f55353050">DGtal::functors::BoolFunctor2</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>May hold bool functors taking two bool arguments. </p>

<p class="definition">Definition at line <a class="el" href="BasicBoolFunctors_8h_source.html#l00064">64</a> of file <a class="el" href="BasicBoolFunctors_8h_source.html">BasicBoolFunctors.h</a>.</p>

</div>
</div>
<a id="a471f1996fbfd82c45524da01e25c231b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471f1996fbfd82c45524da01e25c231b">&#9670;&nbsp;</a></span>BoolFunctor3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function3&lt; bool, bool, bool, bool &gt; <a class="el" href="namespaceDGtal_1_1functors.html#a471f1996fbfd82c45524da01e25c231b">DGtal::functors::BoolFunctor3</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>May hold bool functors taking three bool arguments (Useful ?). </p>

<p class="definition">Definition at line <a class="el" href="BasicBoolFunctors_8h_source.html#l00069">69</a> of file <a class="el" href="BasicBoolFunctors_8h_source.html">BasicBoolFunctors.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae078b1e517d167341988d5a5d6366a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae078b1e517d167341988d5a5d6366a91">&#9670;&nbsp;</a></span>holdConstImageFunctor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TValue , typename TDomain , typename TFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DGtal::functors::holdConstImageFunctor </td>
          <td>(</td>
          <td class="paramtype">TDomain const &amp;&#160;</td>
          <td class="paramname"><em>aDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunctor &amp;&amp;&#160;</td>
          <td class="paramname"><em>aFunctor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html">ConstImageFunctorHolder</a>&lt;TDomain, TValue, decltype(<a class="el" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)))&gt;
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html" title="Transform a point-dependent (and possibly domain-dependent) functor into a constant image.">ConstImageFunctorHolder</a> construction helper with specification of the return type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TValue</td><td>The image value type. </td></tr>
    <tr><td class="paramname">TDomain</td><td>The domain type (auto-deduced). </td></tr>
    <tr><td class="paramname">TFunctor</td><td>The functor type (auto-deduced). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDomain</td><td>The image domain. </td></tr>
    <tr><td class="paramname">aFunctor</td><td>The functor that generates the image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of the appropriate <a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html" title="Transform a point-dependent (and possibly domain-dependent) functor into a constant image.">ConstImageFunctorHolder</a> type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html" title="Transform a point-dependent (and possibly domain-dependent) functor into a constant image.">ConstImageFunctorHolder</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="ConstImageFunctorHolder_8h_source.html#l00277">277</a> of file <a class="el" href="ConstImageFunctorHolder_8h_source.html">ConstImageFunctorHolder.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;  {</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;    <span class="keywordflow">return</span> ConstImageFunctorHolder&lt;TDomain, TValue, decltype(holdFunctor(std::forward&lt;TFunctor&gt;(aFunctor)))&gt;{ aDomain, <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)) };</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="FunctorHolder_8h_source.html#l00279">holdFunctor()</a>.</p>

<p class="reference">Referenced by <a class="el" href="exampleConstImageFunctorHolder_8cpp_source.html#l00044">main()</a>.</p>

</div>
</div>
<a id="a2aa8624a2e5d42e63849ae5d2b19ea8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa8624a2e5d42e63849ae5d2b19ea8a">&#9670;&nbsp;</a></span>holdConstImageFunctor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDomain , typename TFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DGtal::functors::holdConstImageFunctor </td>
          <td>(</td>
          <td class="paramtype">TDomain const &amp;&#160;</td>
          <td class="paramname"><em>aDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunctor &amp;&amp;&#160;</td>
          <td class="paramname"><em>aFunctor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html">ConstImageFunctorHolder</a>&lt;
          TDomain,
          typename std::decay&lt;decltype(aFunctor(std::declval&lt;typename <a class="el" href="testCubicalComplex_8cpp.html#a15e9592ccc512dc691b46185e6814758">TDomain::Point</a>&gt;()))&gt;::type,
          decltype(<a class="el" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)))
        &gt;
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html" title="Transform a point-dependent (and possibly domain-dependent) functor into a constant image.">ConstImageFunctorHolder</a> construction helper with auto-deduction of the return type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDomain</td><td>The domain type (auto-deduced). </td></tr>
    <tr><td class="paramname">TFunctor</td><td>The functor type (auto-deduced). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDomain</td><td>The image domain. </td></tr>
    <tr><td class="paramname">aFunctor</td><td>The functor (unary or binary) that generates the image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of the appropriate <a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html" title="Transform a point-dependent (and possibly domain-dependent) functor into a constant image.">ConstImageFunctorHolder</a> type.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You don't have to choose between the version for unary or binary functor: this choice is automatically done using SFINAE technique.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html" title="Transform a point-dependent (and possibly domain-dependent) functor into a constant image.">ConstImageFunctorHolder</a> and <a class="el" href="moduleImages.html">Images</a> <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#ae6a44171826c1811fc2f08b86d2f64ed">for</a> more informations. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ConstImageFunctorHolder_8h_source.html#l00305">305</a> of file <a class="el" href="ConstImageFunctorHolder_8h_source.html">ConstImageFunctorHolder.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;  {</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    <span class="keywordflow">return</span> ConstImageFunctorHolder&lt;</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        TDomain,</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;        <span class="keyword">typename</span> std::decay&lt;decltype(aFunctor(std::declval&lt;typename TDomain::Point&gt;()))&gt;::type,</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;        decltype(<a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)))</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;      &gt;{ aDomain, <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)) };</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="FunctorHolder_8h_source.html#l00279">holdFunctor()</a>.</p>

</div>
</div>
<a id="a5f6d83ea035f33c3d3fa47730be1ce9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6d83ea035f33c3d3fa47730be1ce9d">&#9670;&nbsp;</a></span>holdFunctor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DGtal::functors::holdFunctor </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> -&gt; decltype(holdFunctorImpl(std::forward&lt;Function&gt;(fn), typename std::is_lvalue_reference&lt;Function&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>The callable object type (auto-deduced, do not specify it) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>The callable object to be holded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html" title="Aim: hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model.">FunctorHolder</a> instance with appropriate storage type depending on the given object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html" title="Aim: hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model.">FunctorHolder</a> and <a class="el" href="moduleFunctors.html">Using functions, functors and lambdas in DGtal</a> <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#ae6a44171826c1811fc2f08b86d2f64ed">for</a> more informations </dd></dl>

<p class="definition">Definition at line <a class="el" href="FunctorHolder_8h_source.html#l00279">279</a> of file <a class="el" href="FunctorHolder_8h_source.html">FunctorHolder.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;                                                                                                 {})) <span class="comment">// Can we please pass to C++14 ?</span></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="exampleFunctorHolder_8cpp_source.html#l00110">get_mean_binarizer_from_range()</a>, <a class="el" href="exampleFunctorHolder_8cpp_source.html#l00102">get_trivial_binarizer()</a>, <a class="el" href="ConstImageFunctorHolder_8h_source.html#l00277">holdConstImageFunctor()</a>, <a class="el" href="PointFunctorHolder_8h_source.html#l00196">holdPointFunctor()</a>, and <a class="el" href="exampleFunctorHolder_8cpp_source.html#l00204">main()</a>.</p>

</div>
</div>
<a id="a2edeed82668eb0dd5c4a11c199794237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2edeed82668eb0dd5c4a11c199794237">&#9670;&nbsp;</a></span>holdPointFunctor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint , typename TValue , typename TFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DGtal::functors::holdPointFunctor </td>
          <td>(</td>
          <td class="paramtype">TFunctor &amp;&amp;&#160;</td>
          <td class="paramname"><em>aFunctor</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html">PointFunctorHolder</a>&lt;TPoint, TValue, decltype(<a class="el" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)))&gt;
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html" title="Aim: hold any object callable on points as a DGtal::concepts::CPointFunctor model.">PointFunctorHolder</a> construction helper with specification of the return type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TPoint</td><td>The point type. </td></tr>
    <tr><td class="paramname">TValue</td><td>The functor value type. </td></tr>
    <tr><td class="paramname">TFunctor</td><td>The functor type (auto-deduced). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aFunctor</td><td>The functor to hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of the appropriate <a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html" title="Aim: hold any object callable on points as a DGtal::concepts::CPointFunctor model.">PointFunctorHolder</a> type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html" title="Aim: hold any object callable on points as a DGtal::concepts::CPointFunctor model.">PointFunctorHolder</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="PointFunctorHolder_8h_source.html#l00196">196</a> of file <a class="el" href="PointFunctorHolder_8h_source.html">PointFunctorHolder.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;  {</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    <span class="keywordflow">return</span> PointFunctorHolder&lt;TPoint, TValue, decltype(holdFunctor(std::forward&lt;TFunctor&gt;(aFunctor)))&gt;{</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;        <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor))</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    };</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="FunctorHolder_8h_source.html#l00279">holdFunctor()</a>.</p>

</div>
</div>
<a id="addcaec612a0b304ea9e866043a2b9480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addcaec612a0b304ea9e866043a2b9480">&#9670;&nbsp;</a></span>holdPointFunctor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint , typename TFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DGtal::functors::holdPointFunctor </td>
          <td>(</td>
          <td class="paramtype">TFunctor &amp;&amp;&#160;</td>
          <td class="paramname"><em>aFunctor</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html">PointFunctorHolder</a>&lt;
          TPoint,
          typename std::decay&lt;decltype(aFunctor(std::declval&lt;TPoint&gt;()))&gt;::type,
          decltype(<a class="el" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)))
        &gt;
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html" title="Aim: hold any object callable on points as a DGtal::concepts::CPointFunctor model.">PointFunctorHolder</a> construction helper with auto-deduction of the return type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TPoint</td><td>The point type. </td></tr>
    <tr><td class="paramname">TFunctor</td><td>The functor type (auto-deduced). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aFunctor</td><td>The functor to hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of the appropriate <a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html" title="Aim: hold any object callable on points as a DGtal::concepts::CPointFunctor model.">PointFunctorHolder</a> type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html" title="Aim: hold any object callable on points as a DGtal::concepts::CPointFunctor model.">PointFunctorHolder</a> and <a class="el" href="moduleFunctors.html">Using functions, functors and lambdas in DGtal</a> <a class="el" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#ae6a44171826c1811fc2f08b86d2f64ed">for</a> more informations. </dd></dl>

<p class="definition">Definition at line <a class="el" href="PointFunctorHolder_8h_source.html#l00218">218</a> of file <a class="el" href="PointFunctorHolder_8h_source.html">PointFunctorHolder.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;  {</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    <span class="keywordflow">return</span> PointFunctorHolder&lt;</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        TPoint,</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;        <span class="keyword">typename</span> std::decay&lt;decltype(aFunctor(std::declval&lt;TPoint&gt;()))&gt;::type,</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        decltype(<a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)))</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;      &gt;{ <a class="code" href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">holdFunctor</a>(std::forward&lt;TFunctor&gt;(aFunctor)) };</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="FunctorHolder_8h_source.html#l00279">holdFunctor()</a>.</p>

</div>
</div>
<a id="a4cbfbc4bfa978b0b089bcb1fe98c2ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbfbc4bfa978b0b089bcb1fe98c2ac1">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDomain , typename TValue , typename TFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::functors::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html">ConstImageFunctorHolder</a>&lt; TDomain, TValue, TFunctor &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads 'operator&lt;&lt;' for displaying objects of class <a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html">ConstImageFunctorHolder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class <a class="el" href="classDGtal_1_1functors_1_1ConstImageFunctorHolder.html">ConstImageFunctorHolder</a> to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ConstImageFunctorHolder_8h_source.html#l00253">253</a> of file <a class="el" href="ConstImageFunctorHolder_8h_source.html">ConstImageFunctorHolder.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;{</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;  <span class="keywordtype">object</span>.selfDisplay(out);</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;  <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2f8247315145a8ef4de50fbdffc5747a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8247315145a8ef4de50fbdffc5747a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctorStorage , bool NeedDereference&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::functors::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>&lt; FunctorStorage, NeedDereference &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads 'operator&lt;&lt;' for displaying objects of class <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="FunctorHolder_8h_source.html#l00238">238</a> of file <a class="el" href="FunctorHolder_8h_source.html">FunctorHolder.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;{</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;  <span class="keywordtype">object</span>.selfDisplay( out );</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;  <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a35eaf44cefc27e8d094c70e124cdf23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35eaf44cefc27e8d094c70e124cdf23e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint , typename TValue , typename TFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::functors::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html">PointFunctorHolder</a>&lt; TPoint, TValue, TFunctor &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads 'operator&lt;&lt;' for displaying objects of class <a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html">PointFunctorHolder</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class <a class="el" href="classDGtal_1_1functors_1_1PointFunctorHolder.html">PointFunctorHolder</a> to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="PointFunctorHolder_8h_source.html#l00172">172</a> of file <a class="el" href="PointFunctorHolder_8h_source.html">PointFunctorHolder.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;{</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;  <span class="keywordtype">object</span>.selfDisplay(out);</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a056e758e28112d33b29c07ef3dace04c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056e758e28112d33b29c07ef3dace04c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint , typename TDetComputer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::functors::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1functors_1_1PolarPointComparatorBy2x2DetComputer.html">PolarPointComparatorBy2x2DetComputer</a>&lt; TPoint, TDetComputer &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1functors_1_1PolarPointComparatorBy2x2DetComputer.html" title="Aim: Class that implements a binary point predicate, which is able to compare the position of two giv...">PolarPointComparatorBy2x2DetComputer</a>'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1functors_1_1PolarPointComparatorBy2x2DetComputer.html" title="Aim: Class that implements a binary point predicate, which is able to compare the position of two giv...">PolarPointComparatorBy2x2DetComputer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a75f64f8aec85ed2085df8d5c13947324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f64f8aec85ed2085df8d5c13947324">&#9670;&nbsp;</a></span>andBF2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal_1_1functors.html#adeef356bd5d6e01987e9ad5f55353050">BoolFunctor2</a> DGtal::functors::andBF2 = <a class="el" href="structDGtal_1_1functors_1_1AndBoolFct2.html">AndBoolFct2</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The object function and (2 bool args). </p>

<p class="definition">Definition at line <a class="el" href="BasicBoolFunctors_8h_source.html#l00150">150</a> of file <a class="el" href="BasicBoolFunctors_8h_source.html">BasicBoolFunctors.h</a>.</p>

</div>
</div>
<a id="ab21e836606fcc449ad58326a746ec06b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21e836606fcc449ad58326a746ec06b">&#9670;&nbsp;</a></span>falseBF0</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal_1_1functors.html#aa643601588b4b3ce48aded757e8fd7c7">BoolFunctor0</a> DGtal::functors::falseBF0 = <a class="el" href="structDGtal_1_1functors_1_1FalseBoolFct0.html">FalseBoolFct0</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The object function (0 bool args) returning false. </p>

<p class="definition">Definition at line <a class="el" href="BasicBoolFunctors_8h_source.html#l00093">93</a> of file <a class="el" href="BasicBoolFunctors_8h_source.html">BasicBoolFunctors.h</a>.</p>

</div>
</div>
<a id="aab0f74ad307b8d3608630e802f067c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0f74ad307b8d3608630e802f067c16">&#9670;&nbsp;</a></span>identityBF1</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal_1_1functors.html#a9c097791d2639aed3534e3547291d916">BoolFunctor1</a> DGtal::functors::identityBF1 = <a class="el" href="structDGtal_1_1functors_1_1IdentityBoolFct1.html">IdentityBoolFct1</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The object function identity (1 bool args). </p>

<p class="definition">Definition at line <a class="el" href="BasicBoolFunctors_8h_source.html#l00112">112</a> of file <a class="el" href="BasicBoolFunctors_8h_source.html">BasicBoolFunctors.h</a>.</p>

</div>
</div>
<a id="ab8bfc4f96b0d7d0a3e60bfbf060ca803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8bfc4f96b0d7d0a3e60bfbf060ca803">&#9670;&nbsp;</a></span>impliesBF2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal_1_1functors.html#adeef356bd5d6e01987e9ad5f55353050">BoolFunctor2</a> DGtal::functors::impliesBF2 = <a class="el" href="structDGtal_1_1functors_1_1ImpliesBoolFct2.html">ImpliesBoolFct2</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The object function implies (2 bool args). </p>

<p class="definition">Definition at line <a class="el" href="BasicBoolFunctors_8h_source.html#l00165">165</a> of file <a class="el" href="BasicBoolFunctors_8h_source.html">BasicBoolFunctors.h</a>.</p>

</div>
</div>
<a id="a54d18c0074a75f014ee71c9446ba0340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d18c0074a75f014ee71c9446ba0340">&#9670;&nbsp;</a></span>notBF1</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal_1_1functors.html#a9c097791d2639aed3534e3547291d916">BoolFunctor1</a> DGtal::functors::notBF1 = <a class="el" href="structDGtal_1_1functors_1_1NotBoolFct1.html">NotBoolFct1</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The object function NOT (1 bool args). </p>

<p class="definition">Definition at line <a class="el" href="BasicBoolFunctors_8h_source.html#l00117">117</a> of file <a class="el" href="BasicBoolFunctors_8h_source.html">BasicBoolFunctors.h</a>.</p>

</div>
</div>
<a id="af339a8f7ec4c1c6fce14623aeaef44bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af339a8f7ec4c1c6fce14623aeaef44bd">&#9670;&nbsp;</a></span>orBF2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal_1_1functors.html#adeef356bd5d6e01987e9ad5f55353050">BoolFunctor2</a> DGtal::functors::orBF2 = <a class="el" href="structDGtal_1_1functors_1_1OrBoolFct2.html">OrBoolFct2</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The object function or (2 bool args). </p>

<p class="definition">Definition at line <a class="el" href="BasicBoolFunctors_8h_source.html#l00155">155</a> of file <a class="el" href="BasicBoolFunctors_8h_source.html">BasicBoolFunctors.h</a>.</p>

</div>
</div>
<a id="ace3475deed0ceb6c16332680ff31506f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3475deed0ceb6c16332680ff31506f">&#9670;&nbsp;</a></span>trueBF0</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal_1_1functors.html#aa643601588b4b3ce48aded757e8fd7c7">BoolFunctor0</a> DGtal::functors::trueBF0 = <a class="el" href="structDGtal_1_1functors_1_1TrueBoolFct0.html">TrueBoolFct0</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The object function (0 bool args) returning true. </p>

<p class="definition">Definition at line <a class="el" href="BasicBoolFunctors_8h_source.html#l00088">88</a> of file <a class="el" href="BasicBoolFunctors_8h_source.html">BasicBoolFunctors.h</a>.</p>

</div>
</div>
<a id="ae084a31146e6491bffe7e72c9bd2104a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae084a31146e6491bffe7e72c9bd2104a">&#9670;&nbsp;</a></span>xorBF2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal_1_1functors.html#adeef356bd5d6e01987e9ad5f55353050">BoolFunctor2</a> DGtal::functors::xorBF2 = <a class="el" href="structDGtal_1_1functors_1_1XorBoolFct2.html">XorBoolFct2</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The object function xor (2 bool args). </p>

<p class="definition">Definition at line <a class="el" href="BasicBoolFunctors_8h_source.html#l00160">160</a> of file <a class="el" href="BasicBoolFunctors_8h_source.html">BasicBoolFunctors.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespaceDGtal_1_1functors_html_a5f6d83ea035f33c3d3fa47730be1ce9d"><div class="ttname"><a href="namespaceDGtal_1_1functors.html#a5f6d83ea035f33c3d3fa47730be1ce9d">DGtal::functors::holdFunctor</a></div><div class="ttdeci">auto holdFunctor(Function &amp;&amp;fn) -&gt; decltype(holdFunctorImpl(std::forward&lt; Function &gt;(fn), typename std::is_lvalue_reference&lt; Function &gt;</div><div class="ttdoc">Hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model.</div><div class="ttdef"><b>Definition:</b> <a href="FunctorHolder_8h_source.html#l00279">FunctorHolder.h:279</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 9 2020 08:59:32 for DGtal by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
