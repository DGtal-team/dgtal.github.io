<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Digital convexity</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Digital convexity </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#dgtal_dconvexity_sec1">Introduction to digital convexity</a></li>
<li class="level1"><a href="#dgtal_dconvexity_sec2">Checking digital convexity</a><ul><li class="level2"><a href="#dgtal_dconvexity_sec21">Lattice polytopes</a></li>
<li class="level2"><a href="#dgtal_dconvexity_sec22">Building a set of lattice cells from digital points</a></li>
<li class="level2"><a href="#dgtal_dconvexity_sec23">Checking digital (sub-)convexity</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtal_dconvexity_sec3">Rational polytopes</a></li>
<li class="level1"><a href="#dgtal_dconvexity_sec4">Further notes</a></li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Jacques-Olivier Lachaud</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.1</dd></dl>
<p>Part of the <a class="el" href="packageGeometry.html">Geometry package</a>.</p>
<p>This part of the manual describes how to define and check digital convexity, in such a way that digital convex set are digitally connected.</p>
<p>The following programs are related to this documentation: <a class="el" href="exampleDigitalConvexity_8cpp.html" title="An example file for DigitalConvexity in 2D.">geometry/curves/exampleDigitalConvexity.cpp</a>, <a class="el" href="exampleRationalConvexity_8cpp_source.html">geometry/curves/exampleRationalConvexity.cpp</a>, <a class="el" href="testBoundedLatticePolytope_8cpp.html">testBoundedLatticePolytope.cpp</a>, <a class="el" href="testCellGeometry_8cpp.html">testCellGeometry.cpp</a>, <a class="el" href="testDigitalConvexity_8cpp.html">testDigitalConvexity.cpp</a></p>
<h1><a class="anchor" id="dgtal_dconvexity_sec1"></a>
Introduction to digital convexity</h1>
<p>The usual definition for <b>digital</b> <b>convexity</b> is as follows. For some digital set \( S \subset \mathbb{Z}^d \), \( S \) is said to be <em>digitally</em> <em>convex</em> whenever \( \mathrm{Conv}(S) \cap \mathbb{Z}^d = S \). Otherwise said, the convex hull of all the digital points contains exactly these digital points and no other.</p>
<p>Although handy and easy to check, this definition lacks many properties related to (continuous) convexity in the Euclidean plane.</p>
<p>We extend this definition as follows. Let \( C^d \) be the usual regular cubical complex induced by the lattice \( \mathbb{Z}^d \), and let \( C^d_k \) be its <em>k-cells</em>, for \( 0 \le k \le d \). We have that the 0-cells of \( C^d_0 \) are exactly the lattice points, the 1-cells of \( C^d_1 \) are the open unit segment joining 2 neighboring lattice points, etc.</p>
<p>Finally, for an arbitrary subset \( Y \subset \mathbb{R}^d \), we denote by \( C^d_k \lbrack Y \rbrack \) the set of k-cells of \( C^d \) whose closure have a non-empty intersection with \( Y \), i.e. \( C^d_k \lbrack Y \rbrack := \{ c \in C^d_k,~\text{s.t.}~ \bar{c} \cap Y \neq \emptyset \} \).</p>
<p>A digital set \( S \subset \mathbb{Z}^d \) is said to be <b>digitally</b> <em>k-</em> <b>convex</b> whenever \( C^d_k \lbrack \mathrm{Conv}(S) \rbrack = C^d_k \lbrack S \rbrack \). \( S \) is said to be <b>fully</b> (digitally) <b>convex</b> whenever it is digitally <em>k-</em> convex for \( 0 \le k \le d \).</p>
<p>A fully convex set is always \( 3^d-1 \)-connected (i.e. 8-connected in 2D, 26-connected in 3D). Furthermore its axis-aligned slices are connected (with the same kind of connectedness). It is also clear that digitally 0-convexity is the usual digital convexity.</p>
<div class="image">
<img src="non-fully-convex-triangles.png" alt=""/>
<div class="caption">
Examples of non fully digitally convex triangles in Z2. Missing 1-cells for 1-digital convexity are in blue, Missing 2-cells for 2-digital convexity are in green.</div></div>
<p></p>
<p>A last useful notion is the <em>subconvexity</em>. Let \( X \subset \mathbb{Z}^d \) some arbitrary digital set. Then the digital set \( S \subset \mathbb{Z}^d \) is said to be <b>digitally</b> <em>k-</em> <b>subconvex</b> to \( X \) whenever \( C^d_k \lbrack \mathrm{Conv}(S) \rbrack \subset C^d_k \lbrack X \rbrack \). And \( S \) is said to be <b>fully</b> (digitally) <b>subconvex</b> to \( X \) whenever it is digitally <em>k-</em> subconvex to \( X \) for \( 0 \le k \le d \).</p>
<p>Subconvexity is a useful for notion for digital contour and surface analysis. It tells which subsets of these digital sets are <em>tangent</em> to them.</p>
<h1><a class="anchor" id="dgtal_dconvexity_sec2"></a>
Checking digital convexity</h1>
<p>Three classes help to check digital convexity.</p>
<ul>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html" title="Aim: Represents an nD lattice polytope, i.e. a convex polyhedron bounded with vertices with integer c...">BoundedLatticePolytope</a> is the class that is used to build polytopes, i.e. intersections of half-spaces, which are a way to represent convex polyhedra.</li>
<li><a class="el" href="classDGtal_1_1CellGeometry.html" title="Aim: Computes and stores sets of cells and provides methods to compute intersections of lattice and r...">CellGeometry</a> is used to store sets of cells and provides methods to build the set of cells that intersect a polytope or the set of cells that touch a set of digital points.</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html" title="Aim: A helper class to build polytopes from digital sets and to check digital k-convexity.">DigitalConvexity</a> provides many helper methods to build <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html" title="Aim: Represents an nD lattice polytope, i.e. a convex polyhedron bounded with vertices with integer c...">BoundedLatticePolytope</a> and <a class="el" href="classDGtal_1_1CellGeometry.html" title="Aim: Computes and stores sets of cells and provides methods to compute intersections of lattice and r...">CellGeometry</a> objects and to check digital convexity and subconvexity.</li>
</ul>
<h2><a class="anchor" id="dgtal_dconvexity_sec21"></a>
Lattice polytopes</h2>
<p>For now, the class is quite limited. You may build a polytope in dimension \( d \le 3 \) from a range of \( n \le d + 1 \) points in general position. The polytope is then a simplex. For dimensions higher than 3, you may only builds the polytope from a full dimensional simplex, i.e. \( n = d + 1 \) in general position. Alternatively, you may provide a domain and a range of half-spaces to create the polytope.</p>
<p>You may also cut a polytope by a new halfspace (<a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a35105f2693a342337167d58d996609ea">BoundedLatticePolytope::cut</a>), count the number of lattice points inside, interior or on the boundary (<a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a1ee74413874f29908e018af444c8948b">BoundedLatticePolytope::count</a>, <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#aeb097d12b56ee838d381a37e8d6e3bce">BoundedLatticePolytope::countInterior</a>, <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a0aee76a181914932c55ac6ea9c0f6b82">BoundedLatticePolytope::countBoundary</a>) or enumerate them.</p>
<dl class="section note"><dt>Note</dt><dd>Lattice point counting is done here in a naive way, by domain enumeration and constraint check. If <em>m</em> is the number of constraints and <em>n</em> the number of lattice points in the polytope domain, then complexity is in \( O(mn) \).</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/volumes/BoundedLatticePolytope.h&quot;</span></div>
<div class="line">...</div>
<div class="line">using <span class="keyword">namespace </span><a class="code" href="namespaceDGtal_1_1Z3i.html">DGtal::Z3i</a>;</div>
<div class="line"><span class="keyword">typedef</span> BoundedLatticePolytope&lt; Space &gt; Simplex;</div>
<div class="line">Simplex S( { <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(3,0,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1,5,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(-3,2,4) } );</div>
<div class="line">std::cout &lt;&lt; S.count() &lt;&lt; std::endl;</div>
<div class="line">simplex += Simplex::UnitSegment( 0 ); <span class="comment">// Extend it along x</span></div>
<div class="line">std::cout &lt;&lt; S.count() &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Last, you may compute Minkowski sums of a polytope with axis-aligned segments, squares or (hyper)-cubes (<a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a75702f637e48b780b089f4c70b48da42">BoundedLatticePolytope::operator+=</a>).</p>
<dl class="section note"><dt>Note</dt><dd>You can check if the result of a Minkowski sum will be valid by calling <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a84c9f2b23e3e4e2257719c1b09e87813">BoundedLatticePolytope::canBeSummed</a> before. The support is for now limited to polytopes built as simplices in 2D and 3D.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1DigitalConvexity.html#a1f7509afa782b4513656ac5600cba55d">DigitalConvexity::makeSimplex</a></dd></dl>
<p>Point check services:</p><ul>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a15d2ac4e2ad4b272b49eeb844fc00627">BoundedLatticePolytope::isInside</a> checks if some point belongs to the polytope.</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#ad68a34c51b920aebcef0a18828f4fa80">BoundedLatticePolytope::isDomainPointInside</a> checks if some point within the polyyope bounding box belongs to the polytope.</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#aedf183d8561e8644fdd044be8e90c9f1">BoundedLatticePolytope::isInterior</a> checks if some point is strictly inside the polytope.</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a8c2eddafed81451d810ecfcf9eb413ec">BoundedLatticePolytope::isBoundary</a> checks if some point is lying on the polytope boundary.</li>
</ul>
<p>Standard polytope services:</p><ul>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a694126b98affa76503626080c0ce4eea">BoundedLatticePolytope::interiorPolytope</a> returns the corresponding interior polytope by making strict every constraint</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a35105f2693a342337167d58d996609ea">BoundedLatticePolytope::cut</a> cuts the polytope by the given half-space constraint</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a3ce419df24109a16a1fb9e8b9bd1afb0">BoundedLatticePolytope::swap</a> swaps this polytope with another one in constant time</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#ac483387ad8f76aeef244136f7ccfc90f">BoundedLatticePolytope::operator*=</a> dilates this polytope by a given factor</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a75702f637e48b780b089f4c70b48da42">BoundedLatticePolytope::operator+=</a> performs Minkowski sum with some axis aligned unit segment/cell</li>
</ul>
<p>Enumeration services:</p><ul>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a1ee74413874f29908e018af444c8948b">BoundedLatticePolytope::count</a> counts the number of lattice points in the polytope</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#aeb097d12b56ee838d381a37e8d6e3bce">BoundedLatticePolytope::countInterior</a> counts the number of lattice points strictly inside the polytope</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a0aee76a181914932c55ac6ea9c0f6b82">BoundedLatticePolytope::countBoundary</a> counts the number of lattice points on the boundary of the polytope</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a0559c255374e60656cd069aa094bddb0">BoundedLatticePolytope::countWithin</a> counts the number of lattice points in some subdomain of the polytope</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#ac7a0781979b2887dec85f65d66ff782a">BoundedLatticePolytope::countUpTo</a> counts the number of lattice points in the polytope up to some maximal number</li>
</ul>
<p>Lattice point retrieval services:</p><ul>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#af641cdb97623643b2da06ed9439e5253">BoundedLatticePolytope::getPoints</a> outputs the lattice points in the polytope</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a08497899fc57e891f7e31d4c602cd20b">BoundedLatticePolytope::getInteriorPoints</a> outputs the lattice points in the interior of the polytope</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#a7c45dd504a734a902bcb9341ab2c767e">BoundedLatticePolytope::getBoundaryPoints</a> outputs the lattice points on the boundary of the polytope</li>
<li><a class="el" href="classDGtal_1_1BoundedLatticePolytope.html#af3f7e63f778429a299d056e4fd5e31f3">BoundedLatticePolytope::insertPoints</a> inserts the lattice points in the polytope into some point set</li>
</ul>
<h2><a class="anchor" id="dgtal_dconvexity_sec22"></a>
Building a set of lattice cells from digital points</h2>
<p>The class <a class="el" href="classDGtal_1_1CellGeometry.html" title="Aim: Computes and stores sets of cells and provides methods to compute intersections of lattice and r...">CellGeometry</a> can compute and store set of lattice cells of different dimensions. You specify at construction a Khalimsky space (any model of <a class="el" href="structDGtal_1_1concepts_1_1CCellularGridSpaceND.html" title="Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian produc...">concepts::CCellularGridSpaceND</a>), as well as the dimensions of the cells you are interested in. Internally it uses a variant of unordered set of points (see <a class="el" href="structDGtal_1_1UnorderedSetByBlock.html">UnorderedSetByBlock</a>) to store the lattice cells in a compact manner.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/volumes/CellGeometry.h&quot;</span></div>
<div class="line">...</div>
<div class="line">using <span class="keyword">namespace </span><a class="code" href="namespaceDGtal_1_1Z3i.html">DGtal::Z3i</a>;</div>
<div class="line"><a class="code" href="classDGtal_1_1KhalimskySpaceND.html">KSpace</a> <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>;</div>
<div class="line"><a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a15dcbcaae831dd1c36090e6336c177d4">init</a>( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(-5,-5,-5), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(15,15,15) );</div>
<div class="line">CellGeometry&lt; KSpace &gt; cell_geometry( <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, 1, 2 ); <span class="comment">// only 1-cells and 2-cells</span></div>
</div><!-- fragment --><p>Then you may add cells that touch a range of points, or cells intersected by a polytope, or cells belonging to another <a class="el" href="classDGtal_1_1CellGeometry.html" title="Aim: Computes and stores sets of cells and provides methods to compute intersections of lattice and r...">CellGeometry</a> object.</p>
<ul>
<li><a class="el" href="classDGtal_1_1CellGeometry.html#a5d8ab2da8ebbeac571dc49989a962bb5">CellGeometry::addCellsTouchingPoints</a>: Updates the cell cover with the cells touching a range of digital points [itB, itE).</li>
<li><a class="el" href="classDGtal_1_1CellGeometry.html#a47bcd59803e91e07d03df003ed0694c4">CellGeometry::addCellsTouchingPointels</a>: Updates the cell cover with the cells touching a range of digital pointels [itB, itE).</li>
<li><a class="el" href="classDGtal_1_1CellGeometry.html#aecfe3cefcabb945d131302cfe32bb6a9">CellGeometry::addCellsTouchingPolytopePoints</a>: Updates the cell cover with the cells touching the points of a polytope.</li>
<li><a class="el" href="classDGtal_1_1CellGeometry.html#a985ac5e2fa4673feac1dd8fa02f8b1fb">CellGeometry::addCellsTouchingPolytope</a>: Updates the cell cover with all the cells touching the polytope (all cells whose closure have a non empty intersection with the polytope).</li>
<li><a class="el" href="classDGtal_1_1CellGeometry.html#a7f13187fbc88321ca2b1ece23a5ca74f">CellGeometry::operator+=( const CellGeometry&amp; other )</a>: Adds the cells of dimension k of object <em>other</em>, for <code>minCellDim() &lt;= k &lt;= maxCellDim()</code>, to this cell geometry.</li>
</ul>
<p>With respect to full digital convexity, <a class="el" href="classDGtal_1_1CellGeometry.html#a985ac5e2fa4673feac1dd8fa02f8b1fb">CellGeometry::addCellsTouchingPolytope</a> is very important since it allows to compute \( C^d_k \lbrack P \rbrack \) for an arbitrary polytope \( P \) and for any \( k \).</p>
<h2><a class="anchor" id="dgtal_dconvexity_sec23"></a>
Checking digital (sub-)convexity</h2>
<p>Class <a class="el" href="classDGtal_1_1DigitalConvexity.html" title="Aim: A helper class to build polytopes from digital sets and to check digital k-convexity.">DigitalConvexity</a> is a helper class to build polytopes from digital sets and to check digital k-convexity. It provides methods for checking if a simplex is full dimensional, building the corresponding polytope, methods for getting the lattice points in a polytope, computing the cells touching lattice points or touching a polytope, and a set of methods to check k-convexity or k-subconvexity.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/volumes/DigitalConvexity.h&quot;</span></div>
<div class="line">...</div>
<div class="line">using <span class="keyword">namespace </span><a class="code" href="namespaceDGtal.html">DGtal</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceDGtal_1_1Z3i.html">DGtal::Z3i</a>;</div>
<div class="line"><span class="keyword">typedef</span> DigitalConvexity&lt; KSpace &gt;       DConvexity;</div>
<div class="line"><span class="comment">// Create DigitalConvexity object with a domain.</span></div>
<div class="line">DConvexity dconv( <a class="code" href="namespaceDGtal_1_1Z3i.html#a8d69892de6b10119a8070bd5d0871bf5">Point</a>( -5, -5 ), <a class="code" href="namespaceDGtal_1_1Z3i.html#a8d69892de6b10119a8070bd5d0871bf5">Point</a>( 10, 10 ) );</div>
<div class="line"><span class="comment">// Create a (fat) simplex within the domain</span></div>
<div class="line">std::vector&lt;Point&gt; V = { <a class="code" href="namespaceDGtal_1_1Z3i.html#a8d69892de6b10119a8070bd5d0871bf5">Point</a>(0,0), <a class="code" href="namespaceDGtal_1_1Z3i.html#a8d69892de6b10119a8070bd5d0871bf5">Point</a>(4,-1), <a class="code" href="namespaceDGtal_1_1Z3i.html#a8d69892de6b10119a8070bd5d0871bf5">Point</a>(2,5) };</div>
<div class="line"><span class="keyword">auto</span> fat_simplex   = dconv.makeSimplex  ( V.begin(), V.end() );</div>
<div class="line"><span class="comment">// Get all the points in the simplex</span></div>
<div class="line"><span class="keyword">auto</span> inside_pts    = dconv.insidePoints ( fat_simplex );</div>
<div class="line"><span class="comment">// Get the lattice cells intersected by the simplex</span></div>
<div class="line"><span class="keyword">auto</span> simplex_cover = dconv.makeCellCover( fat_simplex );</div>
<div class="line"><span class="comment">// Get the lattice cells intersected by the lattice points in the simplex</span></div>
<div class="line"><span class="keyword">auto</span> point_cover   = dconv.makeCellCover( inside_pts.begin(), inside_pts.end() );</div>
<div class="line"><span class="comment">// They are the same here since this simplex is fully convex.</span></div>
<div class="line"><span class="keywordtype">bool</span> ok  = simplex_cover.subset( point_cover ); <span class="comment">// one way to do it</span></div>
<div class="line"><span class="keywordtype">bool</span> ok2 = dconv.isFullyConvex ( fat_simplex ); <span class="comment">// the other way to do it</span></div>
</div><!-- fragment --><p>Simplex services:</p><ul>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a1f7509afa782b4513656ac5600cba55d">DigitalConvexity::makeSimplex</a> builds a simplex from lattice point iterators or initializer list</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a1d6b24ed0bb76b2290b5fcf899a01ce0">DigitalConvexity::isSimplexFullDimensional</a> checks that the given points form a full dimensional simplex</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#af64332b6960ab4b06ee86afd022a71f8">DigitalConvexity::simplexType</a> returns the simplex type in SimplexType::INVALID (when the number of points is less than d+1), SimplexType::DEGENERATED when it is not full dimensional, SimplexType::UNITARY when it is full dimensional and of determinant 1, SimplexType::COMMON otherwise.</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a3af7c3766f87499faeb68d43b1bc439c">DigitalConvexity::displaySimplex</a> outputs simplex information for debugging</li>
</ul>
<p>Polytope services:</p><ul>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a02884b4960ea77330822c7b3d5b10444">DigitalConvexity::insidePoints</a> returns the range of lattice points in the given polytope</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#afe2a661668dc2d1837d93a86d685437f">DigitalConvexity::interiorPoints</a> returns the range of lattice points in the interior of the given polytope</li>
</ul>
<p>Lattice cell geometry services:</p><ul>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#af588213a1371bc38f45973ef3fc331f4">DigitalConvexity::makeCellCover</a> either returns the lattice cells touching the given range of points or the lattice cells touching the given polytope</li>
</ul>
<p>Convexity services:</p><ul>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a1c68ee37d58620cf8e70f901f86cea5c">DigitalConvexity::isKConvex</a> tells if a given polytope is k-convex</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a7d2a2137cf7d22c982b7c73c68ec6094">DigitalConvexity::isFullyConvex</a> tells if a given polytope is fully convex</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#a8ad8e913928fa3ea5629512a8c93a38c">DigitalConvexity::isKSubconvex</a> tells if a given polytope is k-subconvex to some cell cover</li>
<li><a class="el" href="classDGtal_1_1DigitalConvexity.html#ab85164421d1ec12169837162aaee0529">DigitalConvexity::isFullySubconvex</a> tells if a given polytope is fully subconvex to some cell cover</li>
</ul>
<h1><a class="anchor" id="dgtal_dconvexity_sec3"></a>
Rational polytopes</h1>
<p>You can also create bounded rational polytopes, i.e. polytopes with vertices with rational coordinates, with class <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html" title="Aim: Represents an nD rational polytope, i.e. a convex polyhedron bounded by vertices with rational c...">BoundedRationalPolytope</a>. You must give a common denominator for all rational coordinates.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/volumes/BoundedRationalPolytope.h&quot;</span></div>
<div class="line">...</div>
<div class="line">typedef SpaceND&lt;2,int&gt;                    <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a38dfaf1641eab4d3fb805df4b52ab10d">Space</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classDGtal_1_1PointVector.html">Space::Point</a>                      <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>;</div>
<div class="line"><span class="keyword">typedef</span> BoundedRationalPolytope&lt; Space &gt;  Polytope;</div>
<div class="line"><span class="comment">// A thin triangle P at (4/4,2/4), (2/4,4/4), (9/4,9/4)</span></div>
<div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> a( 4, 2 );</div>
<div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> b( 2, 4 );</div>
<div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> c( 9, 9 );</div>
<div class="line">Polytope P { <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(4,4), a, b, c };</div>
</div><!-- fragment --><p>Then the interface of <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html" title="Aim: Represents an nD rational polytope, i.e. a convex polyhedron bounded by vertices with rational c...">BoundedRationalPolytope</a> is almost the same as the one of <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html" title="Aim: Represents an nD lattice polytope, i.e. a convex polyhedron bounded with vertices with integer c...">BoundedLatticePolytope</a> (see <a class="el" href="moduleDigitalConvexity.html#dgtal_dconvexity_sec21">Lattice polytopes</a> ).</p>
<p>The classs <a class="el" href="classDGtal_1_1BoundedRationalPolytope.html" title="Aim: Represents an nD rational polytope, i.e. a convex polyhedron bounded by vertices with rational c...">BoundedRationalPolytope</a> offers dilatation by an arbitrary rational, e.g. as follows</p>
<div class="fragment"><div class="line">Polytope Q = Polytope::Rational( 10, 3 ) * P; <span class="comment">// 10/3 * P</span></div>
</div><!-- fragment --><p>You may also check digital convexity and compute cell covers with bounded rational polytopes, exactly in the same way as with <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html" title="Aim: Represents an nD lattice polytope, i.e. a convex polyhedron bounded with vertices with integer c...">BoundedLatticePolytope</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Big denominators increase with the same factor coefficients of half space constraints, hence the integer type should be chosen accordingly.</dd></dl>
<h1><a class="anchor" id="dgtal_dconvexity_sec4"></a>
Further notes</h1>
<p>The class <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html" title="Aim: Represents an nD lattice polytope, i.e. a convex polyhedron bounded with vertices with integer c...">BoundedLatticePolytope</a> is different from the class <a class="el" href="classDGtal_1_1LatticePolytope2D.html" title="Aim: Represents a 2D polytope, i.e. a convex polygon, in the two-dimensional digital plane....">LatticePolytope2D</a> for the following two reasons:</p><ul>
<li>the class <a class="el" href="classDGtal_1_1LatticePolytope2D.html" title="Aim: Represents a 2D polytope, i.e. a convex polygon, in the two-dimensional digital plane....">LatticePolytope2D</a> is limited to 2D</li>
<li>the class <a class="el" href="classDGtal_1_1LatticePolytope2D.html" title="Aim: Represents a 2D polytope, i.e. a convex polygon, in the two-dimensional digital plane....">LatticePolytope2D</a> is a vertex representation (or V-representation) of a polytope while the class <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html" title="Aim: Represents an nD lattice polytope, i.e. a convex polyhedron bounded with vertices with integer c...">BoundedLatticePolytope</a> is a half-space representation (or H-representation) of a polytope.</li>
</ul>
<p>There are no simple conversion from one to the other. Class <a class="el" href="classDGtal_1_1LatticePolytope2D.html" title="Aim: Represents a 2D polytope, i.e. a convex polygon, in the two-dimensional digital plane....">LatticePolytope2D</a> is optimized for cuts and lattice points enumeration, and is very specific to 2D. Class <a class="el" href="classDGtal_1_1BoundedLatticePolytope.html" title="Aim: Represents an nD lattice polytope, i.e. a convex polyhedron bounded with vertices with integer c...">BoundedLatticePolytope</a> is less optimized than the previous one but works in nD and provides Minkowski sum and dilation services. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="aclassDGtal_1_1KhalimskySpaceND_html_a15dcbcaae831dd1c36090e6336c177d4"><div class="ttname"><a href="classDGtal_1_1KhalimskySpaceND.html#a15dcbcaae831dd1c36090e6336c177d4">DGtal::KhalimskySpaceND::init</a></div><div class="ttdeci">bool init(const Point &amp;lower, const Point &amp;upper, bool isClosed)</div><div class="ttdoc">Specifies the upper and lower bounds for the maximal cells in this space.</div></div>
<div class="ttc" id="atestCubicalComplex_8cpp_html_a2b87ed989d2519d025bd5d4fbcbac062"><div class="ttname"><a href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a></div><div class="ttdeci">KSpace K</div><div class="ttdef"><b>Definition:</b> <a href="testCubicalComplex_8cpp_source.html#l00062">testCubicalComplex.cpp:62</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z3i_html_a8d69892de6b10119a8070bd5d0871bf5"><div class="ttname"><a href="namespaceDGtal_1_1Z3i.html#a8d69892de6b10119a8070bd5d0871bf5">DGtal::Z3i::Point</a></div><div class="ttdeci">Space::Point Point</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00168">StdDefs.h:168</a></div></div>
<div class="ttc" id="anamespaceDGtal_html"><div class="ttname"><a href="namespaceDGtal.html">DGtal</a></div><div class="ttdoc">DGtal is the top-level namespace which contains all DGtal functions and types.</div><div class="ttdef"><b>Definition:</b> <a href="ClosedIntegerHalfPlane_8h_source.html#l00048">ClosedIntegerHalfPlane.h:49</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z3i_html"><div class="ttname"><a href="namespaceDGtal_1_1Z3i.html">DGtal::Z3i</a></div><div class="ttdoc">Z3i this namespace gathers the standard of types for 3D imagery.</div></div>
<div class="ttc" id="aclassDGtal_1_1PointVector_html"><div class="ttname"><a href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt; dim, Integer &gt;</a></div></div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_a38dfaf1641eab4d3fb805df4b52ab10d"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a38dfaf1641eab4d3fb805df4b52ab10d">Space</a></div><div class="ttdeci">SpaceND&lt; 2 &gt; Space</div><div class="ttdef"><b>Definition:</b> <a href="testSimpleRandomAccessRangeFromPoint_8cpp_source.html#l00042">testSimpleRandomAccessRangeFromPoint.cpp:42</a></div></div>
<div class="ttc" id="atestClone2_8cpp_html_a15e9592ccc512dc691b46185e6814758"><div class="ttname"><a href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a></div><div class="ttdeci">MyPointD Point</div><div class="ttdef"><b>Definition:</b> <a href="testClone2_8cpp_source.html#l00383">testClone2.cpp:383</a></div></div>
<div class="ttc" id="aclassDGtal_1_1KhalimskySpaceND_html"><div class="ttname"><a href="classDGtal_1_1KhalimskySpaceND.html">DGtal::KhalimskySpaceND</a></div><div class="ttdoc">Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex,...</div><div class="ttdef"><b>Definition:</b> <a href="KhalimskySpaceND_8h_source.html#l00392">KhalimskySpaceND.h:394</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 6 2020 14:16:59 for DGtal by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
