<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Iterators and ranges</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DGtal<span id="projectnumber">&#160;1.4.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('moduleIteratorsRanges.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Iterators and ranges</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul>
  <li class="level1">
    <a href="#secIteratorRangesIterators">Introduction to iterators</a>
  </li>
  <li class="level1">
    <a href="#secIteratorRangesRanges">Introduction to ranges</a>
    <ul>
      <li class="level2">
        <a href="#subsecIteratorRangesRangesMainConcepts">Main concepts</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#secIteratorRangesAdatpers">Adapters to iterators</a>
    <ul>
      <li class="level2">
        <a href="#subsecIteratorRangesAdaptersReverse">Reverse iterator</a>
      </li>
      <li class="level2">
        <a href="#subsecIteratorRangesAdaptersAdapters">On-line transformations</a>
      </li>
    </ul>
  </li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Tristan Roussillon</dd></dl>
<p>This part of the manual describes basic concepts of iterators and ranges. It also presents several tools available in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> to ease their use: traits class, useful functions, adapters, etc.</p>
<p><a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> users usually have to play with ranges to iterate over finite sets of elements. <br  />
</p>
<h1><a class="anchor" id="secIteratorRangesIterators"></a>
Introduction to iterators</h1>
<p>The concept of <em>iterator</em> is one of the main concept introduced in the <a href="www.cplusplus.com/reference/std/iterator/" title="STL iterators">STL</a> in order to make data structures and algorithms independent: a programmer would be able to apply one algorithm on different data structures. Algorithms typically take iterators as arguments, so a data structure is only required to provide a way to access its elements using iterators. An iterator is any object that, pointing to some element stored in a data structure, can be incremented so that it points to the next element. An iterator has at least, the dereference (<code>*</code>) and increment (<code>++</code>) operators, but can have more operators to implement extra functionalities. Depending on the functionality they implement, <br  />
 they belong to one of the several categories of iterators. <br  />
 Following [The Boost.Iterator Library] (<a href="http://www.boost.org/doc/libs/1_49_0/libs/iterator/doc/index.html">http://www.boost.org/doc/libs/1_49_0/libs/iterator/doc/index.html</a> "Boost iterators"), which extends the hierarchy of concepts proposed in the STL and separates access and traversal functionalities, we consider in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> the following access and traversal categories:</p>
<ul>
<li>Readable iterator: <code>*i</code> returns an instance of V (value type) and <code>i-&gt;m</code> is equivalent to <code>(*i).m</code></li>
<li>Writable iterator: <code>*i = o</code></li>
<li>LValue iterator: <code>*i</code> returns an instance of <code>V&amp;</code></li>
</ul>
<ol type="1">
<li>Incrementable iterator: dereference (<code>*</code>), indirection (<code>-&gt;</code>) and increment (<code>++</code>) operators.</li>
<li>Single-pass iterator: equality operators (<code>==</code> and <code>!=</code>).</li>
<li>Forward iterator: default constructor.</li>
<li>Bidirectional iterator: decrement (<code>--</code>) operator. <br  />
</li>
<li>Random access iterator: arithmetic and comparison operators (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>). <br  />
</li>
</ol>
<p>Each traversal category of level <em>l</em> obviously implements the functionalities of all the categories <em>k &lt; l</em> and one or more extra functionalities. For each category, the main difference with the previous categories is provided in the above list, but [The Boost.Iterator Library] (<a href="http://www.boost.org/doc/libs/1_49_0/libs/iterator/doc/index.html">http://www.boost.org/doc/libs/1_49_0/libs/iterator/doc/index.html</a> "Boost iterators") gives more details.</p>
<p>The following diagram sums up the main iterator concepts:</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_2.svg" width="899" height="572"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<h1><a class="anchor" id="secIteratorRangesRanges"></a>
Introduction to ranges</h1>
<p>A <em>range</em> of elements stored in a data structure (container) may be implicitly described by a well-chosen pair of iterators. Any pair does not define a valid range, even with iterators having nonsingular values. An iterator <code>j</code> is reachable from an iterator <code>i</code> if and only if <code>i</code> can be made equal to <code>j</code> with finitely many applications of the increment operator. If <code>j</code> is reachable from <code>i</code>, one can iterate over the range bounded by <code>i</code> and <code>j</code>, from the one pointed to by <code>i</code> and up to, but not including, the one pointed to by <code>j</code>. Such a range is valid and is denoted by [<code>i,j</code>).</p>
<p>In linear data structures, any iterator pointing to the last element is incremented so that it points to the <em>past-the-end</em> element, ie. it points past the last element (just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element of the array). <br  />
</p>
<p>If an iterator <code>begin</code> points to the first element of a data structure and an iterator <code>end</code> points to the past-the-end element, iterating over the range [<code>begin,end</code>) is a way of iterating over all the elements of the underlying data structure. Note that if the underlying data structure is empty, it only has a past-the-end element. As a consequence, a range [<code>i,i</code>) denotes an empty range. <br  />
 A range of a linear data structure is illustrated below (normal values are depicted with a small straight segment, whereas the past-the-end value is depicted with a cross). In this example, [<code>i,j</code>) is not a valid range because <code>j</code> cannot be reached from <code>i</code> and the whole range may be denoted by [<code>begin,end</code>).</p>
<div class="image">
<img src="linearRange.png" alt=""/>
<div class="caption">
Linear range</div></div>
 <h2><a class="anchor" id="subsecIteratorRangesRangesMainConcepts"></a>
Main concepts</h2>
<p>Some objects have the capability to provide a pair of iterators describing a (valid) range. For instance, methods <code>begin()</code> and <code>end()</code> of STL containers return two iterators bounding the range of elements contained in the data structure. Similarly, in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>, there are several concepts of range having at least these <code>begin()</code> and <code>end()</code> methods.</p>
<p>The concept <a class="el" href="structDGtal_1_1concepts_1_1CConstSinglePassRange.html">CConstSinglePassRange</a> describes any object for which, one can iterate at least one time over a range of elements. <br  />
 Models of <a class="el" href="structDGtal_1_1concepts_1_1CConstSinglePassRange.html" title="Aim: Defines the concept describing a const single pass range.">concepts::CConstSinglePassRange</a> have a nested type ConstIterator, which is a readable and (at least) single-pass iterator. <br  />
 Instances of ConstIterator are returned by <code>begin()</code> and <code>end()</code> methods. <br  />
</p>
<p>The concept <a class="el" href="structDGtal_1_1concepts_1_1CConstBidirectionalRange.html">CConstBidirectionalRange</a>, which is a refinement of <a class="el" href="structDGtal_1_1concepts_1_1CConstSinglePassRange.html" title="Aim: Defines the concept describing a const single pass range.">concepts::CConstSinglePassRange</a>, describes any collection of elements that can be scanned several times, either forward or backward. <br  />
 Models of this concept have obviously a nested type ConstIterator, but it is a readable and (at least) bidirectional iterator. They have in addition a nested type ConstReverseIterator, which is a readable and bidirectional iterator too. Finally, <code>begin()</code> and <code>end()</code> methods return instances of ConstIterator, whereas <code>rbegin()</code> and <code>rend()</code> methods return instances of ConstReverseIterator.</p>
<p>The concept <a class="el" href="structDGtal_1_1concepts_1_1CSinglePassRange.html">CSinglePassRange</a> (resp. <a class="el" href="structDGtal_1_1concepts_1_1CBidirectionalRange.html">CBidirectionalRange</a>) is a refinement of <a class="el" href="structDGtal_1_1concepts_1_1CConstSinglePassRange.html" title="Aim: Defines the concept describing a const single pass range.">concepts::CConstSinglePassRange</a> (resp. <a class="el" href="structDGtal_1_1concepts_1_1CConstBidirectionalRange.html" title="Aim: Defines the concept describing a bidirectional const range.">concepts::CConstBidirectionalRange</a>) for not constant, mutable elements. All their models have a nested type Iterator (resp. <a class="el" href="classDGtal_1_1ReverseIterator.html" title="This class adapts any bidirectional iterator so that operator++ calls operator-- and vice versa.">ReverseIterator</a>), which are the readable and writable counterparts of ConstIterator (resp. ConstReverseIterator). <br  />
</p>
<p>These four concepts and their links are depicted in the following figure:</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_3.svg" width="587" height="327"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<h1><a class="anchor" id="secIteratorRangesAdatpers"></a>
Adapters to iterators</h1>
<p>In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>, several adapters to iterators are provided.</p>
<h2><a class="anchor" id="subsecIteratorRangesAdaptersReverse"></a>
Reverse iterator</h2>
<p>Any bidirectional iterator may have a reverse counterpart, ie. an adapter that enables a backward scanning by calling the decrement operator instead of the increment operator and conversely. Bidirectional ranges provide reverse iterators that can be used as follows: </p><pre class="fragment">template&lt;typename Range&gt;
void anyProcedure(const Range&amp; aRange)
  {
    BOOST_CONCEPT_ASSERT(( concepts::CBidirectionalRange&lt;Range&gt; )); 
    ...
    for (typename Range::ReverseIterator ri = r.rbegin(), 
         typename Range::ReverseIterator riEnd = r.rend(); 
         ri != riEnd; ++ri)
      {
         ...
      }
   }
</pre><p>In order to take profit of the whole <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> framework, you should use <a class="el" href="classDGtal_1_1ReverseIterator.html" title="This class adapts any bidirectional iterator so that operator++ calls operator-- and vice versa.">DGtal::ReverseIterator</a> instead of std::reverse_iterator or even boost::reverse_iterator. </p><pre class="fragment">#include "DGtal/base/ReverseIterator.h"
...
template&lt;typename Iterator&gt;
void anyProcedure(const Iterator&amp; anIterator)
  {
    ...
    DGtal::ReverseIterator&lt;Iterator&gt; ri(anIterator); 
    ASSERT( ri.base() == anIterator ); //ie. anIterator is the underlying iterator of ri
    ...
  }
</pre><dl class="section note"><dt>Note</dt><dd>Reverse iterators are a little tricky because <code>*ri == *--ri.base()</code> (or equivalently <code>*++ri == *ri.base()</code>), so that when an iterator is reversed, the reversed version does not point to the same element in the range, but to the one preceding it. <br  />
</dd>
<dd>
<b>Developer trick</b>: there is no erase or insert method taking a reverse iterator as input argument in STL containers. Static methods are provided to do that in a small struct called <a class="el" href="structDGtal_1_1OpInSTLContainers.html">OpInSTLContainers</a>. <br  />
</dd></dl>
<h2><a class="anchor" id="subsecIteratorRangesAdaptersAdapters"></a>
On-line transformations</h2>
<p><a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> also provides adapters to iterators that transforms the data returned by the dereference (and indirection) operator into other data, possibly of different type. The transformation is delegated to a <em>functor</em>. Dereferencing any adapted iterator consists in applying the functor on the data to which points the underlying iterator: <br  />
 </p><pre class="fragment">#include "DGtal/base/ConstIteratorAdapter.h"
...
template&lt;typename Iterator, typename Functor, typename ReturnType&gt;
void anyProcedure(const Iterator&amp; anIterator, const Functor&amp; aFunctor)
  {
    ...
    DGtal::ConstAdapterIterator&lt;Iterator, Functor, ReturnType&gt; a(i, f);
    ASSERT( *a == f(*i) ); //ie. *a and f(*i) return equivalent instances of ReturnType  
    ...
  } 
</pre><p>The class <a class="el" href="classDGtal_1_1ConstIteratorAdapter.html" title="This class adapts any iterator so that operator* returns another element than the one pointed to by t...">ConstIteratorAdapter</a> adapts any (at least) readable and (at least) incremental iterator with any functor, whereas the class <a class="el" href="classDGtal_1_1IteratorAdapter.html" title="This class adapts any lvalue iterator so that operator* returns a member on the element pointed to by...">IteratorAdapter</a> adapts any readable, writable, Lvalue and (at least) incremental iterator.</p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">DGtal - Digital Geometry Tools and Algorithms Library.</a></li><li class="navelem"><a class="el" href="packageBase.html">Base package</a></li>
    <li class="footer">Generated on Mon Dec 23 2024 11:13:45 for DGtal by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
