<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Half-edge data structure, triangulated surfaces and polygonal surfaces</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.0.beta</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Half-edge data structure, triangulated surfaces and polygonal surfaces </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#HEM_sec1">The half-edge data structure</a><ul><li class="level2"><a href="#HEM_sec1_1">Creating a half-edge data structure</a></li>
<li class="level2"><a href="#HEM_sec1_2">Elementary operations</a></li>
<li class="level2"><a href="#HEM_sec1_3">Details about internal representation</a></li>
</ul>
</li>
<li class="level1"><a href="#HEM_sec2">A triangulated surface data structure</a><ul><li class="level2"><a href="#HEM_sec2_1">Building a triangulated surface</a></li>
<li class="level2"><a href="#HEM_sec2_2">Main topological operations</a></li>
<li class="level2"><a href="#HEM_sec2_3">Boundary of triangulated surface</a></li>
<li class="level2"><a href="#HEM_sec2_4">Helpers to convert triangulated surfaces from/to mesh</a></li>
<li class="level2"><a href="#HEM_sec2_5">Geometrical operations</a></li>
<li class="level2"><a href="#HEM_sec2_6">Associating data to vertices, edges, faces</a></li>
<li class="level2"><a href="#HEM_sec2_7">Triangulated surface I/O and visualization</a></li>
</ul>
</li>
<li class="level1"><a href="#HEM_sec3">A polygonal surface data structure</a><ul><li class="level2"><a href="#HEM_sec3_1">Building a polygonal surface</a></li>
<li class="level2"><a href="#HEM_sec3_2">Main topological operations</a></li>
<li class="level2"><a href="#HEM_sec3_3">Boundary of polygonal surface</a></li>
<li class="level2"><a href="#HEM_sec3_4">Helpers to convert polygonal surfaces from/to mesh</a></li>
<li class="level2"><a href="#HEM_sec3_5">Geometrical operations</a></li>
<li class="level2"><a href="#HEM_sec3_6">Associating data to vertices, edges, faces</a></li>
<li class="level2"><a href="#HEM_sec3_7">Polygonal surface I/O and visualization</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Jacques-Olivier Lachaud</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.9.4</dd></dl>
<p>Part of <a class="el" href="packageTopology.html">Topology package</a> and <a class="el" href="packageShapes.html">Shapes package</a></p>
<p>This part of the manual describes how to represent combinatorial surfaces, generally embedded in \(\mathbb{R}^3\). The underlying combinatorial topological structure is the classical half-edge data structure (or doubly connected cell list). We also provide a triangulated surface representation that is based on an half-edge data structure. A more general polygonal surface is provided and is also based on the same half-edge data sructure. In the latter case, faces of the surface can be arbitrary simple polygons.</p>
<p>The following programs are related to this documentation: </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="testHalfEdgeDataStructure_8cpp.html">testHalfEdgeDataStructure.cpp</a>, <a class="el" href="testTriangulatedSurface_8cpp.html">testTriangulatedSurface.cpp</a>, <a class="el" href="viewMarchingCubes_8cpp.html">viewMarchingCubes.cpp</a>, <a class="el" href="viewPolygonalMarchingCubes_8cpp.html">viewPolygonalMarchingCubes.cpp</a></dd></dl>
<h1><a class="anchor" id="HEM_sec1"></a>
The half-edge data structure</h1>
<p>A half-edge data structure is a way to represent the topology of a combinatorial surface. A combinatoirial surface is a union of vertices, edges (a curve bordered by two vertices), faces (a piece of surface bordered by a sequence of edges). They are often called 0-cells, 1-cells and 2-cells respectively. The half-edge data structure describes which cells are connected to each other. Its principle is to associate two <em>half-edges</em> to each edge. Once this is done, it is easy to tie cells together by simply indicating for each half-edge:</p>
<ul>
<li>its next half-edge (along its face)</li>
<li>its opposite half-edge (along the edge, that the half-edge associated to the neighboring face)</li>
<li>its associated face</li>
<li>its associated vertex (here, we choose the "to" vertex if the half-edge is seen as an arc)</li>
<li>its associated edge</li>
</ul>
<p>The classical half-edge data structure is implemented in the class <a class="el" href="classDGtal_1_1HalfEdgeDataStructure.html" title="Aim: This class represents an half-edge data structure, which is a structure for representing the top...">HalfEdgeDataStructure</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Large parts of this class are taken from <a href="https://github.com/yig/halfedge,">https://github.com/yig/halfedge,</a> written by Yotam Gingold.</dd></dl>
<h2><a class="anchor" id="HEM_sec1_1"></a>
Creating a half-edge data structure</h2>
<p>For now, you only have methods to create a half-edge data structure from a set of triangles and edges. For instance, the following code builds a half-edge data structure representing two triangles tied along one edge:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/topology/HalfEdgeDataStructure.h&quot;</span></div><div class="line">...</div><div class="line">std::vector&lt; <a class="code" href="structDGtal_1_1HalfEdgeDataStructure_1_1Triangle.html">Triangle</a> &gt; triangles( 2 );</div><div class="line">triangles[0].v = { 0, 1, 2 };</div><div class="line">triangles[1].v = { 2, 1, 3 };</div><div class="line"></div><div class="line">HalfEdgeDataStructure mesh;</div><div class="line">mesh.build( triangles );</div></div><!-- fragment --><p>All elements within the half-edge data structure are numbered, starting from 0. Furthermore, the indices of vertices and triangles are the same as the one given at initialization.</p>
<p>So, for instance, in the code above, triangle 0 is incident to vertices 0, 1, 2 and triangle 1 is incident to vertices 2, 1, 3.</p>
<dl class="section note"><dt>Note</dt><dd>Unordered edges may also be numbered according to your preference, but you need to call the other <a class="el" href="classDGtal_1_1HalfEdgeDataStructure.html#afea3fa97feae93287face6c2d6a7a092">HalfEdgeDataStructure::build</a> method, which takes as input triangles <b>and</b> edges, not only triangles. In this case, this other method builds a half-edge structure that keeps both the numbering of triangles and edges.</dd></dl>
<h2><a class="anchor" id="HEM_sec1_2"></a>
Elementary operations</h2>
<p>Since half-edges are the basis of the structure, you have operations to get a half-edge from an arc (i.e. a couple of vertices), or from neighboring vertices or faces:</p>
<ul>
<li><a class="el" href="classDGtal_1_1HalfEdgeDataStructure.html#ae8d63fc15e56a3e2475eeaf94a6bd1e9">HalfEdgeDataStructure::halfEdgeIndexFromArc</a> : given an arc or two vertices, returns the corresponding half-edge index (logarithmic cost in the number of half-edges)</li>
<li><a class="el" href="classDGtal_1_1HalfEdgeDataStructure.html#afbd9c8260f6201857a4b8ef5cf3dcc59">HalfEdgeDataStructure::halfEdgeIndexFromVertexIndex</a>, <a class="el" href="classDGtal_1_1HalfEdgeDataStructure.html#a0e8782e0455b44b564c8533ef203900d">HalfEdgeDataStructure::halfEdgeIndexFromFaceIndex</a>, <a class="el" href="classDGtal_1_1HalfEdgeDataStructure.html#a135ad4f55f3442ed03402aac9124db67">HalfEdgeDataStructure::halfEdgeIndexFromEdgeIndex</a>: returns the index of a half-edge that borders the given vertex, face or edge (constant time operation)</li>
<li><a class="el" href="classDGtal_1_1HalfEdgeDataStructure.html#a18e745d09f934904f0d90f911b481ad3">HalfEdgeDataStructure::halfEdge</a> : given a half-edge index, returns the half-edge itself.</li>
</ul>
<p>Then, each half-edge can give you its associated vertex, face, edge, opposite and next half-edge:</p>
<ul>
<li><a class="el" href="structDGtal_1_1HalfEdgeDataStructure_1_1HalfEdge.html#acadcc2ba0d7687dfdc97362dc92d5f1f" title="The end vertex of this half-edge as an index into the vertex array. ">HalfEdgeDataStructure::HalfEdge::toVertex</a> : the end vertex of this half-edge as an index into the vertex array.</li>
<li><a class="el" href="structDGtal_1_1HalfEdgeDataStructure_1_1HalfEdge.html#adf24ad847f8298ffe2d473b75655b419" title="Index into the face array. ">HalfEdgeDataStructure::HalfEdge::face</a> : index of the associated face into the face array.</li>
<li><a class="el" href="structDGtal_1_1HalfEdgeDataStructure_1_1HalfEdge.html#a8d3099ac0e6fa851c192b47e31179618" title="Index into the edges array. ">HalfEdgeDataStructure::HalfEdge::edge</a> : index of the associated edge into the edge array.</li>
<li><a class="el" href="structDGtal_1_1HalfEdgeDataStructure_1_1HalfEdge.html#adac10f1d7e7f06a9dd15884052057fbd" title="Index into the halfedges array. ">HalfEdgeDataStructure::HalfEdge::opposite</a> : index of the opposite half-edge into the half-edge array.</li>
<li><a class="el" href="structDGtal_1_1HalfEdgeDataStructure_1_1HalfEdge.html#a49bc8cde2d8fc2a41917a085dff051d7" title="Index into the halfedges array. ">HalfEdgeDataStructure::HalfEdge::next</a> index of the next half-edge along the face into the half-edge array.</li>
</ul>
<div class="image">
<img src="half-edge-data-structure.png" alt="half-edge-data-structure.png"/>
<div class="caption">
Illustration of half-edge data structure: each edge corresponds to two half-edges with opposite direction. You have access to the next half-edge along the face or to your opposite half-edge. You can also retrieve your associated face or vertex.</div></div>
<p> Finally a half-edge data structure can give you all the necessary neighboring information, and can also list the vertices and arcs that lie on the boundary of the data structure:</p>
<ul>
<li><a class="el" href="classDGtal_1_1HalfEdgeDataStructure.html#aa78ed5e6435580f8adb27211cb06660c">HalfEdgeDataStructure::neighboringVertices</a>, <a class="el" href="classDGtal_1_1HalfEdgeDataStructure.html#a46283a094290db5b3d852ffa410a4551">HalfEdgeDataStructure::getNeighboringVertices</a> : returns the sequence of vertices that are neighbors to the given vertex. The order of neighbors has meaning and corresponds to the order given at the initialization per triangle.</li>
<li><a class="el" href="classDGtal_1_1HalfEdgeDataStructure.html#a1f90fb7c5b427721d070105cde90e003">HalfEdgeDataStructure::neighboringFaces</a>, <a class="el" href="classDGtal_1_1HalfEdgeDataStructure.html#a47f361a0e7c0634b0b7cec3400421986">HalfEdgeDataStructure::getNeighboringFaces</a> : returns the sequence of faces that are incident to the given vertex. The order of neighbors has meaning and corresponds to the order given at the initialization per triangle.</li>
<li><a class="el" href="classDGtal_1_1HalfEdgeDataStructure.html#aa040f87bad3b24787dd69cf79d8d0e49">HalfEdgeDataStructure::boundaryVertices</a>, <a class="el" href="classDGtal_1_1HalfEdgeDataStructure.html#aaf1759b13ee8b196fd07f29326b3c602">HalfEdgeDataStructure::boundaryHalfEdgeIndices</a>, <a class="el" href="classDGtal_1_1HalfEdgeDataStructure.html#a48a8eece8d77b24d80f9f1e13c6e6875">HalfEdgeDataStructure::boundaryArcs</a> : returns the vertices and/or arcs lying on the boundary of the combinatorial surface (in no particular order).</li>
</ul>
<h2><a class="anchor" id="HEM_sec1_3"></a>
Details about internal representation</h2>
<p>It is worthy to note the following elements in this representation:</p>
<ul>
<li>half-edges, vertices, edges and faces are numbered consecutively from 0.</li>
<li>vertices and faces (here triangles) keep their numbering given at initialization.</li>
<li>given a vertex index, an edge index, or a face index, you can get an half-edge incident to it in constant time (stored as a vector).</li>
<li>given an arc (i.e. a couple of vertices), you can get the corresponding half-edge in logarithmic time (stored as a map).</li>
</ul>
<h1><a class="anchor" id="HEM_sec2"></a>
A triangulated surface data structure</h1>
<p>A <b>triangulated</b> <b>surface</b> is a two-dimensional simplicial complex, with a piecewise linear geometry. We use the half-edge data structure to represent its topology and its geometry is simply given by precising coordinates for each vertex. The class <a class="el" href="classDGtal_1_1TriangulatedSurface.html" title="Aim: Represents a triangulated surface. The topology is stored with a half-edge data structure...">TriangulatedSurface</a> represents this geometric object. You may also associate other information to each vertex of the surface, through TriangulatedSurface::VertexPropertyMap objects.</p>
<p>A triangulated surface is a model of graph (<a class="el" href="structDGtal_1_1concepts_1_1CUndirectedSimpleGraph.html" title="Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not neces...">concepts::CUndirectedSimpleGraph</a>) so you may use graph algorithms to traverse it (see <a class="el" href="moduleGraphDefinitions.html">Basic graph definitions and concepts</a>).</p>
<h2><a class="anchor" id="HEM_sec2_1"></a>
Building a triangulated surface</h2>
<p>A triangulated surface is parameterized by the type that represents the coordinates of each vertex. Then you simply add vertices by specifying their coordinates, and triangles by giving the indices of the three vertices counterclockwise. Once this is done, you must call <a class="el" href="classDGtal_1_1TriangulatedSurface.html#af4334ce3ecb5f6cdeb4f609732ed4e77">TriangulatedSurface::build</a> to finish the construction. The following code creates a tetrahedron.</p>
<div class="fragment"><div class="line"><span class="comment">// The following includes and type definitions will be used everywhere afterwards.</span></div><div class="line"><span class="preprocessor">#include &quot;DGtal/shapes/TriangulatedSurface.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> PointVector&lt;3,double&gt;             <a class="code" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a>;</div><div class="line"><span class="keyword">typedef</span> TriangulatedSurface&lt; RealPoint &gt;  <a class="code" href="testTriangulatedSurface_8cpp.html#aaf4ecd10947ad3153979882617dda21f">TriMesh</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classDGtal_1_1TriangulatedSurface.html#a1c42f23af141f67c2192274825a10130">TriMesh::VertexRange</a>              <a class="code" href="testTriangulatedSurface_8cpp.html#a36c0bda5e047365ae72e11a1d75d082b">VertexRange</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classDGtal_1_1TriangulatedSurface.html#af4276e10c169bd7ebf80eea3c4a2d0be">TriMesh::ArcRange</a>                 <a class="code" href="testTriangulatedSurface_8cpp.html#ad03c498d78a6dd75a1c7991201fe8606">ArcRange</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classDGtal_1_1TriangulatedSurface.html#a131324d45f00ec530d3ebc6a8b366df7">TriMesh::Arc</a>                      <a class="code" href="testTriangulatedSurface_8cpp.html#ac00eb5fb04426d42c44b0ae764d95fa1">Arc</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classDGtal_1_1TriangulatedSurface.html#a1e0f97f92d302d345fad25941adee94e">TriMesh::Face</a>                     <a class="code" href="testTriangulatedSurface_8cpp.html#aa7e89e659ae870a9963bb6109a53da62">Face</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classDGtal_1_1TriangulatedSurface.html#af61ebc616e280c5e26666d816cc2449b">TriMesh::Vertex</a>                   <a class="code" href="testTriangulatedSurface_8cpp.html#ae931baebcf0de56dd5f3b9342207e4fd">Vertex</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structDGtal_1_1TriangulatedSurface_1_1IndexedPropertyMap.html">TriMesh::PositionsMap</a>             <a class="code" href="testTriangulatedSurface_8cpp.html#a5506b620cc0c62a63c9a987601779ff4">PositionsMap</a>;</div><div class="line"></div><div class="line"><a class="code" href="classDGtal_1_1TriangulatedSurface.html">TriMesh</a> mesh;</div><div class="line">mesh.<a class="code" href="classDGtal_1_1TriangulatedSurface.html#a8a0442ba63377ac3c073ceba4bdab2cf">addVertex</a>( <a class="code" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a>( 0, 0, 0 ) ); <span class="comment">// vertex 0</span></div><div class="line">mesh.<a class="code" href="classDGtal_1_1TriangulatedSurface.html#a8a0442ba63377ac3c073ceba4bdab2cf">addVertex</a>( <a class="code" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a>( 1, 0, 0 ) ); <span class="comment">// vertex 1</span></div><div class="line">mesh.<a class="code" href="classDGtal_1_1TriangulatedSurface.html#a8a0442ba63377ac3c073ceba4bdab2cf">addVertex</a>( <a class="code" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a>( 0, 1, 0 ) ); <span class="comment">// vertex 2</span></div><div class="line">mesh.<a class="code" href="classDGtal_1_1TriangulatedSurface.html#a8a0442ba63377ac3c073ceba4bdab2cf">addVertex</a>( <a class="code" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a>( 1, 1, 1 ) ); <span class="comment">// vertex 3</span></div><div class="line">mesh.<a class="code" href="classDGtal_1_1TriangulatedSurface.html#aa02915bb0ae1b81931806f2c9df2d5dd">addTriangle</a>( 0, 1, 2 );            <span class="comment">// triangle 0</span></div><div class="line">mesh.<a class="code" href="classDGtal_1_1TriangulatedSurface.html#aa02915bb0ae1b81931806f2c9df2d5dd">addTriangle</a>( 3, 1, 0 );            <span class="comment">// triangle 1</span></div><div class="line">mesh.<a class="code" href="classDGtal_1_1TriangulatedSurface.html#aa02915bb0ae1b81931806f2c9df2d5dd">addTriangle</a>( 3, 2, 1 );            <span class="comment">// triangle 2</span></div><div class="line">mesh.<a class="code" href="classDGtal_1_1TriangulatedSurface.html#aa02915bb0ae1b81931806f2c9df2d5dd">addTriangle</a>( 3, 0, 2 );            <span class="comment">// triangle 3</span></div><div class="line"><span class="keywordtype">bool</span> ok = mesh.<a class="code" href="classDGtal_1_1TriangulatedSurface.html#af4334ce3ecb5f6cdeb4f609732ed4e77">build</a>(); <span class="comment">// should be true</span></div></div><!-- fragment --><p>Note that the topology that ties triangles together is built when calling <a class="el" href="classDGtal_1_1TriangulatedSurface.html#af4334ce3ecb5f6cdeb4f609732ed4e77">TriangulatedSurface::build</a>. If the topology is valid, it returns true. This method may return false for instance in the following cases:</p><ul>
<li>three triangles sharing an edge,</li>
<li>number of vertices given by triangles does not match the number of vertex coordinates,</li>
<li>butterfly neighborhoods in the triangulation.</li>
</ul>
<h2><a class="anchor" id="HEM_sec2_2"></a>
Main topological operations</h2>
<p>As a model of graph (more precisely <a class="el" href="structDGtal_1_1concepts_1_1CUndirectedSimpleGraph.html" title="Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not neces...">concepts::CUndirectedSimpleGraph</a>), you can get neighbors of vertices, degree and some other operations, as well as iterators for visiting vertices. As a combinatorial surfaces you have a lot of other operations to navigate onto the triangulated surface:</p>
<ul>
<li>vertex to vertices: you can get the neighboring vertices with <a class="el" href="classDGtal_1_1TriangulatedSurface.html#a1a00efc4f9aab84179bf3532aff56116">TriangulatedSurface::writeNeighbors</a>.</li>
<li>vertex to arcs: you can get ingoing and outgoing arcs with <a class="el" href="classDGtal_1_1TriangulatedSurface.html#ab84d156aca3050544a213559649fb74e">TriangulatedSurface::inArcs</a> and <a class="el" href="classDGtal_1_1TriangulatedSurface.html#a9b213a215ba96f99987cdcca1723e47e">TriangulatedSurface::outArcs</a>. The order is significant.</li>
<li>vertex to faces: you can get the faces incident to the given vertex with <a class="el" href="classDGtal_1_1TriangulatedSurface.html#a4555ff756a6188c32b8af56114427e0a">TriangulatedSurface::facesAroundVertex</a>.</li>
<li>arc to vertices: you can get the head and the tail of an arc with <a class="el" href="classDGtal_1_1TriangulatedSurface.html#a20be18a37d0761f4bd1d14b5ad657cd8">TriangulatedSurface::head</a> and <a class="el" href="classDGtal_1_1TriangulatedSurface.html#a8e16d646ef8de89594b0864dd8fe5156">TriangulatedSurface::tail</a>.</li>
<li>arc to opposite arc: with <a class="el" href="classDGtal_1_1TriangulatedSurface.html#a71ec4d0b0c33e0923846d0fb89e6ce85">TriangulatedSurface::opposite</a>.</li>
<li>arc to face: you can get the only face incident to the given arc with <a class="el" href="classDGtal_1_1TriangulatedSurface.html#ae5b100e101085f03d714f6f56beaac3f">TriangulatedSurface::faceAroundArc</a> (may be invalid) or as a sequence of zero or one face with <a class="el" href="classDGtal_1_1TriangulatedSurface.html#ac8950ed0af77574a8173ad1a0cddae0f">TriangulatedSurface::facesAroundArc</a>.</li>
<li>face to vertices: you can get the sequence of vertices incident to a given face with <a class="el" href="classDGtal_1_1TriangulatedSurface.html#ab69c1aee69a39fb12d9465cef732c2b7">TriangulatedSurface::verticesAroundFace</a>, in the same order as the sequence of incident arcs along the face. Here, it returns three vertices.</li>
<li>face to arcs: you can get the sequence of 3 arcs incident to a given face with <a class="el" href="classDGtal_1_1TriangulatedSurface.html#a2f937acd477cc690b87382d6d93ab09b">TriangulatedSurface::arcsAroundFace</a>, in the same order as the sequence of incident arcs along the face.</li>
</ul>
<p>Furthermore you can enumerate all the vertices, arcs and faces with <a class="el" href="classDGtal_1_1TriangulatedSurface.html#a7c84edf28732adf63e5ccc2804d7cd26">TriangulatedSurface::allVertices</a>, <a class="el" href="classDGtal_1_1TriangulatedSurface.html#a55c7ffd76eb7483df3d5902f0a39438f">TriangulatedSurface::allArcs</a>, <a class="el" href="classDGtal_1_1TriangulatedSurface.html#a578cfac7befc20b1cb8265fdd17f45de">TriangulatedSurface::allFaces</a>.</p>
<h2><a class="anchor" id="HEM_sec2_3"></a>
Boundary of triangulated surface</h2>
<p>Some of the edges of the triangulation may not be shared by two triangles, but only one. This set of edges, which may be organized in sequences, forms the boundary of the surface, which may be connected or disconnected. You have some operations to access to the boundary of the surface:</p>
<ul>
<li><a class="el" href="classDGtal_1_1TriangulatedSurface.html#ab9058173eaef8f8a6cf4e7c593089061">TriangulatedSurface::isVertexBoundary</a> tells if some vertex lies on the boundary.</li>
<li><a class="el" href="classDGtal_1_1TriangulatedSurface.html#aa758a220f6eb9e6153cb90105c975788">TriangulatedSurface::isArcBoundary</a> tells if an arc is a boundary arc (its opposite is then not in the boundary)</li>
<li><a class="el" href="classDGtal_1_1TriangulatedSurface.html#a318325185a4ade47657101197d41eaca">TriangulatedSurface::allBoundaryArcs</a> returns the set of all arcs (oriented edges) lying on the boundary of the surface (in no particular order).</li>
<li><a class="el" href="classDGtal_1_1TriangulatedSurface.html#a0dbba7d092aea1979680013ac9ee5cac">TriangulatedSurface::allBoundaryVertices</a> returns the set of vertices lying on the boundary of the surface (in no particular order).</li>
</ul>
<h2><a class="anchor" id="HEM_sec2_4"></a>
Helpers to convert triangulated surfaces from/to mesh</h2>
<p>File <a class="el" href="MeshHelpers_8h_source.html">MeshHelpers.h</a> provides two methods to convert a <a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces...">Mesh</a> into a <a class="el" href="classDGtal_1_1TriangulatedSurface.html" title="Aim: Represents a triangulated surface. The topology is stored with a half-edge data structure...">TriangulatedSurface</a> and conversely.</p>
<ul>
<li><a class="el" href="classDGtal_1_1MeshHelpers.html#a134812dbf9957a26ad4021da2511f2b3">MeshHelpers::mesh2TriangulatedSurface</a> builds a triangulated surface (class <a class="el" href="classDGtal_1_1TriangulatedSurface.html" title="Aim: Represents a triangulated surface. The topology is stored with a half-edge data structure...">TriangulatedSurface</a>) from an arbitrary mesh (class <a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces...">Mesh</a>). Since a mesh may have non triangular faces, they are then triangulated naively (triangles (0,1,2), (0,2,3), (0,3,4), etc).</li>
<li><a class="el" href="classDGtal_1_1MeshHelpers.html#addda5f3d0d685e76d545eb7fa42cc487">MeshHelpers::triangulatedSurface2Mesh</a> Builds a mesh (class <a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces...">Mesh</a>) from a triangulated surface (class <a class="el" href="classDGtal_1_1TriangulatedSurface.html" title="Aim: Represents a triangulated surface. The topology is stored with a half-edge data structure...">TriangulatedSurface</a>). Note that the mesh looses the topology of the triangulated surface, since it is essentially a soup of triangles. It is useful for display or for export to OBJ format for instance.</li>
<li><a class="el" href="classDGtal_1_1MeshHelpers.html#a78451e3bfa2e13976c7803a67d715bca">MeshHelpers::digitalSurface2DualTriangulatedSurface</a> builds a triangulated surface (class <a class="el" href="classDGtal_1_1TriangulatedSurface.html" title="Aim: Represents a triangulated surface. The topology is stored with a half-edge data structure...">TriangulatedSurface</a>) from the dual graph of a digital surface (class <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>). It is for instance useful for building an isosurface.</li>
</ul>
<p>You may have a look at example <a class="el" href="viewMarchingCubes_8cpp.html">shapes/viewMarchingCubes.cpp</a> to see an example of using <a class="el" href="classDGtal_1_1MeshHelpers.html#a78451e3bfa2e13976c7803a67d715bca">MeshHelpers::digitalSurface2DualTriangulatedSurface</a> and <a class="el" href="classDGtal_1_1MeshHelpers.html#addda5f3d0d685e76d545eb7fa42cc487">MeshHelpers::triangulatedSurface2Mesh</a>.</p>
<div class="image">
<img src="chinese-dragon-aa-512.png" alt="chinese-dragon-aa-512.png"/>
<div class="caption">
Marching cubes surface of anti-aliased vol file chinese-dragon-512 (see https://github.com/JacquesOlivierLachaud/AAVolGallery)</div></div>
<div class="image">
<img src="chinese-dragon-aa-512-wired.png" alt="chinese-dragon-aa-512-wired.png"/>
<div class="caption">
Close-up on Marching cubes surface of anti-aliased vol file chinese-dragon-512 (see https://github.com/JacquesOlivierLachaud/AAVolGallery)</div></div>
 <h2><a class="anchor" id="HEM_sec2_5"></a>
Geometrical operations</h2>
<p>The class <a class="el" href="classDGtal_1_1TriangulatedSurface.html" title="Aim: Represents a triangulated surface. The topology is stored with a half-edge data structure...">TriangulatedSurface</a> just come with a way to get/set the position of each vertex:</p>
<ul>
<li><a class="el" href="classDGtal_1_1TriangulatedSurface.html#a5ceeb2d2f1e10a04d656b77965dd30de">TriangulatedSurface::position</a> : setter/getter of position given a vertex index.</li>
</ul>
<h2><a class="anchor" id="HEM_sec2_6"></a>
Associating data to vertices, edges, faces</h2>
<p>The easiest way to associate data to vertices, edges or faces is to create a relevant <a class="el" href="structDGtal_1_1TriangulatedSurface_1_1IndexedPropertyMap.html">TriangulatedSurface::IndexedPropertyMap</a>. In fact, this is the mechanism used by the class <a class="el" href="classDGtal_1_1TriangulatedSurface.html" title="Aim: Represents a triangulated surface. The topology is stored with a half-edge data structure...">TriangulatedSurface</a> to store positions. The lines below show how to build a map associated an integer to each face:</p>
<div class="fragment"><div class="line">TriangulatedSurface&lt;RealPoint&gt; mesh;</div><div class="line">...</div><div class="line">auto face_normal_map = mesh.<a class="code" href="classDGtal_1_1TriangulatedSurface.html#a3e8a0baa26c9e6dab45728a110aecc9a">makeFaceMap</a>&lt;<span class="keywordtype">int</span>&gt;( 0 ); <span class="comment">// 0 is default value</span></div><div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; mesh.nbFaces(); ++i )</div><div class="line">{</div><div class="line">  face_normal_map[ i ] = i; <span class="comment">// each face is labelled with its own index.</span></div><div class="line">}</div></div><!-- fragment --><p>Any <a class="el" href="structDGtal_1_1TriangulatedSurface_1_1IndexedPropertyMap.html">TriangulatedSurface::IndexedPropertyMap</a> is in fact a vector of value, the size of which depends on the number of vertices / edges / face. We exploit the fact that vertices, edges and faces are all numbered consecutively starting from 0. The following methods returns property maps:</p>
<ul>
<li><a class="el" href="classDGtal_1_1TriangulatedSurface.html#ab35510ce21e2e7885a49b947c0bdb112">TriangulatedSurface::makeVertexMap&lt;T&gt;</a> : creates a map associating a value of type T to each vertex.</li>
<li><a class="el" href="classDGtal_1_1TriangulatedSurface.html#a581cba6d5c6c5f98e4bcd88198add2ec">TriangulatedSurface::makeEdgeMap&lt;T&gt;</a> : creates a map associating a value of type T to each edge.</li>
<li><a class="el" href="classDGtal_1_1TriangulatedSurface.html#a3e8a0baa26c9e6dab45728a110aecc9a">TriangulatedSurface::makeFaceMap&lt;T&gt;</a> : creates a map associating a value of type T to each face.</li>
<li><a class="el" href="classDGtal_1_1TriangulatedSurface.html#a65dacd74aaae7dfcdf12917d87750605">TriangulatedSurface::positions</a> : returns an alias to the map giving the position of each vertex.</li>
</ul>
<h2><a class="anchor" id="HEM_sec2_7"></a>
Triangulated surface I/O and visualization</h2>
<p>You have methods to export a triangulated surface as an OBJ file: <a class="el" href="classDGtal_1_1MeshHelpers.html#a039386aa1c2b460e0a33ff6d15a6f53e">MeshHelpers::exportOBJ</a> or the more complete <a class="el" href="classDGtal_1_1MeshHelpers.html#aa687e35fc678eeed1d39c816c8d43880">MeshHelpers::exportOBJwithFaceNormalAndColor</a>.</p>
<p>In its present form, class <a class="el" href="classDGtal_1_1TriangulatedSurface.html" title="Aim: Represents a triangulated surface. The topology is stored with a half-edge data structure...">TriangulatedSurface</a> does not provide any visualization methods. However it is simpler to convert a <a class="el" href="classDGtal_1_1TriangulatedSurface.html" title="Aim: Represents a triangulated surface. The topology is stored with a half-edge data structure...">TriangulatedSurface</a> to/from a <a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces...">Mesh</a> for I/O or for visualization (see <a class="el" href="moduleHalfEdgeMesh.html#HEM_sec2_4">Helpers to convert triangulated surfaces from/to mesh</a>).</p>
<p>You may input or output a <a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces...">Mesh</a> as an OFF/OFS/OBJ file, see <a class="el" href="moduleMesh.html#subsect2moduleMeshIO">Mesh IO</a>. More precisely, class <a class="el" href="structDGtal_1_1MeshWriter.html" title="Aim: Export a Mesh (Mesh object) in different format as OFF and OBJ). ">MeshWriter</a> allows you to output a <a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces...">Mesh</a> as an OFF/OFS/OBJ file while class <a class="el" href="structDGtal_1_1MeshReader.html" title="Aim: Defined to import OFF and OFS surface mesh. It allows to import a Mesh object and takes into acc...">MeshReader</a> can input an OFF/OFS file into a <a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces...">Mesh</a>.</p>
<p>For visualization, you may also directly stream a <a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces...">Mesh</a> into a <a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/shapes/TriangulatedSurface.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;DGtal/shapes/Mesh.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;DGtal/shapes/MeshHelpers.h&quot;</span></div><div class="line">...</div><div class="line">  <span class="keyword">typedef</span> TriangulatedSurface&lt; RealPoint &gt;                <a class="code" href="testTriangulatedSurface_8cpp.html#aaf4ecd10947ad3153979882617dda21f">TriMesh</a>;</div><div class="line">  <span class="keyword">typedef</span> Mesh&lt; RealPoint &gt;                               ViewMesh;</div><div class="line"></div><div class="line">  <span class="comment">// Creates two triangles glued together.</span></div><div class="line">  <a class="code" href="classDGtal_1_1TriangulatedSurface.html">TriMesh</a> tmesh;</div><div class="line">  tmesh.<a class="code" href="classDGtal_1_1TriangulatedSurface.html#a8a0442ba63377ac3c073ceba4bdab2cf">addVertex</a>( <a class="code" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a>( 0, 0, 0 ) );</div><div class="line">  tmesh.<a class="code" href="classDGtal_1_1TriangulatedSurface.html#a8a0442ba63377ac3c073ceba4bdab2cf">addVertex</a>( <a class="code" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a>( 1, 0, 0 ) );</div><div class="line">  tmesh.<a class="code" href="classDGtal_1_1TriangulatedSurface.html#a8a0442ba63377ac3c073ceba4bdab2cf">addVertex</a>( <a class="code" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a>( 0, 1, 0 ) );</div><div class="line">  tmesh.<a class="code" href="classDGtal_1_1TriangulatedSurface.html#a8a0442ba63377ac3c073ceba4bdab2cf">addVertex</a>( <a class="code" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a>( 1, 1, 1 ) );</div><div class="line">  tmesh.<a class="code" href="classDGtal_1_1TriangulatedSurface.html#aa02915bb0ae1b81931806f2c9df2d5dd">addTriangle</a>( 0, 1, 2 );</div><div class="line">  tmesh.<a class="code" href="classDGtal_1_1TriangulatedSurface.html#aa02915bb0ae1b81931806f2c9df2d5dd">addTriangle</a>( 2, 1, 3 );</div><div class="line">  tmesh.<a class="code" href="classDGtal_1_1TriangulatedSurface.html#af4334ce3ecb5f6cdeb4f609732ed4e77">build</a>();</div><div class="line"></div><div class="line">  <span class="comment">// Convert it to a mesh</span></div><div class="line">  ViewMesh mesh;</div><div class="line">  <a class="code" href="classDGtal_1_1MeshHelpers.html#addda5f3d0d685e76d545eb7fa42cc487">MeshHelpers::triangulatedSurface2Mesh</a>( tmesh, mesh );</div><div class="line"></div><div class="line">  <span class="comment">// View it</span></div><div class="line">  Viewer3D&lt;&gt; viewer;</div><div class="line">  viewer.<a class="code" href="classDGtal_1_1Viewer3D.html#a1ea1c9cf781ce6940db02c352cf24e6f">show</a>();</div><div class="line">  viewer.setLineColor(Color(150,0,0,254));</div><div class="line">  viewer &lt;&lt; mesh;</div><div class="line">  viewer &lt;&lt; Viewer3D&lt;&gt;::updateDisplay;</div><div class="line">  application.exec();</div></div><!-- fragment --><h1><a class="anchor" id="HEM_sec3"></a>
A polygonal surface data structure</h1>
<p>A <b>polygonal</b> <b>surface</b> is a two-dimensional simplicial complex, with a piecewise linear geometry per face. Contrary to class <a class="el" href="classDGtal_1_1TriangulatedSurface.html" title="Aim: Represents a triangulated surface. The topology is stored with a half-edge data structure...">TriangulatedSurface</a>, faces are not restricted to triangles but may be arbitrary simple polygons. We use the half-edge data structure to represent its topology and its geometry is simply given by precising coordinates for each vertex. The class <a class="el" href="classDGtal_1_1PolygonalSurface.html" title="Aim: Represents a polygon mesh, i.e. a 2-dimensional combinatorial surface whose faces are (topologic...">PolygonalSurface</a> represents this geometric object. You may also associate other information to each vertex of the surface, through PolygonalSurface::VertexPropertyMap objects.</p>
<p>A polygonal surface is a model of graph (<a class="el" href="structDGtal_1_1concepts_1_1CUndirectedSimpleGraph.html" title="Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not neces...">concepts::CUndirectedSimpleGraph</a>) so you may use graph algorithms to traverse it (see <a class="el" href="moduleGraphDefinitions.html">Basic graph definitions and concepts</a>).</p>
<h2><a class="anchor" id="HEM_sec3_1"></a>
Building a polygonal surface</h2>
<p>A polygonal surface is parameterized by the type that represents the coordinates of each vertex. Then you simply add vertices by specifying their coordinates, and triangles by giving the indices of the three vertices counterclockwise. Once this is done, you must call <a class="el" href="classDGtal_1_1PolygonalSurface.html#a791af6dbf32880c9e147a3145b20574c">PolygonalSurface::build</a> to finish the construction. The following code creates a pyramid.</p>
<div class="fragment"><div class="line"><span class="comment">// The following includes and type definitions will be used everywhere afterwards.</span></div><div class="line"><span class="preprocessor">#include &quot;DGtal/shapes/PolygonalSurface.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> PointVector&lt;3,double&gt;              <a class="code" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a>;</div><div class="line"><span class="keyword">typedef</span> PolygonalSurface&lt; RealPoint &gt;      PolyMesh;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="testTriangulatedSurface_8cpp.html#a36c0bda5e047365ae72e11a1d75d082b">PolyMesh::VertexRange</a>              <a class="code" href="testTriangulatedSurface_8cpp.html#a36c0bda5e047365ae72e11a1d75d082b">VertexRange</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="testTriangulatedSurface_8cpp.html#ad03c498d78a6dd75a1c7991201fe8606">PolyMesh::ArcRange</a>                 <a class="code" href="testTriangulatedSurface_8cpp.html#ad03c498d78a6dd75a1c7991201fe8606">ArcRange</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="testTriangulatedSurface_8cpp.html#ac00eb5fb04426d42c44b0ae764d95fa1">PolyMesh::Arc</a>                      <a class="code" href="testTriangulatedSurface_8cpp.html#ac00eb5fb04426d42c44b0ae764d95fa1">Arc</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="testTriangulatedSurface_8cpp.html#aa7e89e659ae870a9963bb6109a53da62">PolyMesh::Face</a>                     <a class="code" href="testTriangulatedSurface_8cpp.html#aa7e89e659ae870a9963bb6109a53da62">Face</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="testTriangulatedSurface_8cpp.html#ae931baebcf0de56dd5f3b9342207e4fd">PolyMesh::Vertex</a>                   <a class="code" href="testTriangulatedSurface_8cpp.html#ae931baebcf0de56dd5f3b9342207e4fd">Vertex</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="testTriangulatedSurface_8cpp.html#a5506b620cc0c62a63c9a987601779ff4">PolyMesh::PositionsMap</a>             <a class="code" href="testTriangulatedSurface_8cpp.html#a5506b620cc0c62a63c9a987601779ff4">PositionsMap</a>;</div><div class="line"></div><div class="line">PolyMesh mesh;</div><div class="line">mesh.addVertex( <a class="code" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a>( 0, 0, 0 ) ); <span class="comment">// vertex 0</span></div><div class="line">mesh.addVertex( <a class="code" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a>( 1, 0, 0 ) ); <span class="comment">// vertex 1</span></div><div class="line">mesh.addVertex( <a class="code" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a>( 0, 1, 0 ) ); <span class="comment">// vertex 2</span></div><div class="line">mesh.addVertex( <a class="code" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a>( 1, 1, 0 ) ); <span class="comment">// vertex 3</span></div><div class="line">mesh.addVertex( <a class="code" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a>( 0.5, 0.5, 1 ) ); <span class="comment">// vertex 4</span></div><div class="line">mesh.addTriangle( 0, 1, 4 );            <span class="comment">// triangle 0</span></div><div class="line">mesh.addTriangle( 1, 3, 4 );            <span class="comment">// triangle 1</span></div><div class="line">mesh.addTriangle( 3, 2, 4 );            <span class="comment">// triangle 2</span></div><div class="line">mesh.addTriangle( 2, 0, 4 );            <span class="comment">// triangle 3</span></div><div class="line">mesh.addQuadrangle( 1, 0, 2, 3 );       <span class="comment">// quadrangle 4</span></div><div class="line"><span class="keywordtype">bool</span> ok = mesh.build(); <span class="comment">// should be true</span></div></div><!-- fragment --><p>Note that the topology that ties faces together is built when calling <a class="el" href="classDGtal_1_1PolygonalSurface.html#a791af6dbf32880c9e147a3145b20574c">PolygonalSurface::build</a>. If the topology is valid, it returns true. This method may return false for instance in the following cases:</p><ul>
<li>three faces sharing an edge,</li>
<li>number of vertices given by faces does not match the number of vertex coordinates,</li>
<li>butterfly neighborhoods in the triangulation.</li>
</ul>
<h2><a class="anchor" id="HEM_sec3_2"></a>
Main topological operations</h2>
<p>As a model of graph (more precisely <a class="el" href="structDGtal_1_1concepts_1_1CUndirectedSimpleGraph.html" title="Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not neces...">concepts::CUndirectedSimpleGraph</a>), you can get neighbors of vertices, degree and some other operations, as well as iterators for visiting vertices. As a combinatorial surfaces you have a lot of other operations to navigate onto the polygonal surface:</p>
<ul>
<li>vertex to vertices: you can get the neighboring vertices with <a class="el" href="classDGtal_1_1PolygonalSurface.html#a29c99ca3f755ff4afa749dc0a0de7014">PolygonalSurface::writeNeighbors</a>.</li>
<li>vertex to arcs: you can get ingoing and outgoing arcs with <a class="el" href="classDGtal_1_1PolygonalSurface.html#af79b603fe8bf7cc86b6e3bd6283247de">PolygonalSurface::inArcs</a> and <a class="el" href="classDGtal_1_1PolygonalSurface.html#ad2c22ba188a09f89a827e9c458e8464f">PolygonalSurface::outArcs</a>. The order is significant.</li>
<li>vertex to faces: you can get the faces incident to the given vertex with <a class="el" href="classDGtal_1_1PolygonalSurface.html#a60c7fdabb66e47fa754c46e249a904f7">PolygonalSurface::facesAroundVertex</a>.</li>
<li>arc to vertices: you can get the head and the tail of an arc with <a class="el" href="classDGtal_1_1PolygonalSurface.html#ac7e137db95b3c988ebdfef0856dcd190">PolygonalSurface::head</a> and <a class="el" href="classDGtal_1_1PolygonalSurface.html#a8ea83d13b1cfea3488ccd4f768f0ebf5">PolygonalSurface::tail</a>.</li>
<li>arc to opposite arc: with <a class="el" href="classDGtal_1_1PolygonalSurface.html#a584e184f0aaf16d5f3ff5dee808ad732">PolygonalSurface::opposite</a>.</li>
<li>arc to face: you can get the only face incident to the given arc with <a class="el" href="classDGtal_1_1PolygonalSurface.html#aba455836b971e22b0981ff86ddcb20cb">PolygonalSurface::faceAroundArc</a> (may be invalid) or as a sequence of zero or one face with <a class="el" href="classDGtal_1_1PolygonalSurface.html#a0cef66151476041e2c9c2caa42284cf7">PolygonalSurface::facesAroundArc</a>.</li>
<li>face to vertices: you can get the sequence of vertices incident to a given face with <a class="el" href="classDGtal_1_1PolygonalSurface.html#a761b87a9d9052dbcd724b417c1ac17c2">PolygonalSurface::verticesAroundFace</a>, in the same order as the sequence of incident arcs along the face. It is thus the sequence of vertices representing the polygonal face.</li>
<li>face to arcs: you can get the sequence of arcs incident to a given face with <a class="el" href="classDGtal_1_1PolygonalSurface.html#a4cbd2790bd68f7d18b9038753e474bbf">PolygonalSurface::arcsAroundFace</a>, in the same order as the sequence of incident arcs along the face.</li>
</ul>
<p>Furthermore you can enumerate all the vertices, arcs and faces with <a class="el" href="classDGtal_1_1PolygonalSurface.html#acbbc3f7d6a31380bc57c0e148b4ee5e8">PolygonalSurface::allVertices</a>, <a class="el" href="classDGtal_1_1PolygonalSurface.html#af5941c80a972f38fa2c5844383617d4a">PolygonalSurface::allArcs</a>, <a class="el" href="classDGtal_1_1PolygonalSurface.html#a8ca8e29100036e975bfedf0636816baa">PolygonalSurface::allFaces</a>.</p>
<h2><a class="anchor" id="HEM_sec3_3"></a>
Boundary of polygonal surface</h2>
<p>Some of the edges of the combinatorial surface may not be shared by two triangles, but only one. This set of edges, which may be organized in sequences, forms the boundary of the surface, which may be connected or disconnected. You have some operations to access to the boundary of the surface:</p>
<ul>
<li><a class="el" href="classDGtal_1_1PolygonalSurface.html#a6c539ed2e91576b2e3f60c67364fa700">PolygonalSurface::isVertexBoundary</a> tells if some vertex lies on the boundary.</li>
<li><a class="el" href="classDGtal_1_1PolygonalSurface.html#ae62bfd1398d321d3912487587c3cafab">PolygonalSurface::isArcBoundary</a> tells if an arc is a boundary arc (its opposite is then not in the boundary)</li>
<li><a class="el" href="classDGtal_1_1PolygonalSurface.html#a336340ac2010eee7e7bdc5fa63e56046">PolygonalSurface::allBoundaryArcs</a> returns the set of all arcs (oriented edges) lying on the boundary of the surface (in no particular order).</li>
<li><a class="el" href="classDGtal_1_1PolygonalSurface.html#a4acaa5c200c6d8ce65cbe94d38cb93f0">PolygonalSurface::allBoundaryVertices</a> returns the set of vertices lying on the boundary of the surface (in no particular order).</li>
</ul>
<h2><a class="anchor" id="HEM_sec3_4"></a>
Helpers to convert polygonal surfaces from/to mesh</h2>
<p>File <a class="el" href="MeshHelpers_8h_source.html">MeshHelpers.h</a> provides two methods to convert a <a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces...">Mesh</a> into a <a class="el" href="classDGtal_1_1PolygonalSurface.html" title="Aim: Represents a polygon mesh, i.e. a 2-dimensional combinatorial surface whose faces are (topologic...">PolygonalSurface</a> and conversely.</p>
<ul>
<li><a class="el" href="classDGtal_1_1MeshHelpers.html#ae75be28e0deaa72b405cc7ccbb6618a7">MeshHelpers::mesh2PolygonalSurface</a> builds a polygonal surface (class <a class="el" href="classDGtal_1_1PolygonalSurface.html" title="Aim: Represents a polygon mesh, i.e. a 2-dimensional combinatorial surface whose faces are (topologic...">PolygonalSurface</a>) from an arbitrary mesh (class <a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces...">Mesh</a>).</li>
<li><a class="el" href="classDGtal_1_1MeshHelpers.html#a3c3aa1ae1402b9a9aef3c7e65022ed2d">MeshHelpers::polygonalSurface2TriangulatedSurface</a> builds a polygonal surface from a triangulated surface (faces are triangulated according to parameters).</li>
<li><a class="el" href="classDGtal_1_1MeshHelpers.html#a4f6a5df120fabbbb1302b35feb820492">MeshHelpers::polygonalSurface2Mesh</a> builds a mesh (class <a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces...">Mesh</a>) from a polygonal surface (class <a class="el" href="classDGtal_1_1PolygonalSurface.html" title="Aim: Represents a polygon mesh, i.e. a 2-dimensional combinatorial surface whose faces are (topologic...">PolygonalSurface</a>). Note that the mesh looses the topology of the polygonal surface, since it is essentially a soup of triangles. It is useful for display or for export to OBJ format for instance.</li>
<li><a class="el" href="classDGtal_1_1MeshHelpers.html#a0da78928e2d3aebb9c4fd9b98a153a24">MeshHelpers::digitalSurface2PrimalPolygonalSurface</a> builds a polygonal surface (class <a class="el" href="classDGtal_1_1PolygonalSurface.html" title="Aim: Represents a polygon mesh, i.e. a 2-dimensional combinatorial surface whose faces are (topologic...">PolygonalSurface</a>) from the primal graph of a 2-dimensional digital surface in K^3 (class <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>).</li>
<li><a class="el" href="classDGtal_1_1MeshHelpers.html#ad04dc560df67748c1547c9216b23d1aa">MeshHelpers::digitalSurface2DualPolygonalSurface</a> builds a polygonal surface (class <a class="el" href="classDGtal_1_1PolygonalSurface.html" title="Aim: Represents a polygon mesh, i.e. a 2-dimensional combinatorial surface whose faces are (topologic...">PolygonalSurface</a>) from the dual graph of a digital surface (class <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>). It is for instance useful for building an isosurface.</li>
</ul>
<p>You may have a look at example <a class="el" href="viewPolygonalMarchingCubes_8cpp.html">shapes/viewPolygonalMarchingCubes.cpp</a> to see an example of using <a class="el" href="classDGtal_1_1MeshHelpers.html#ad04dc560df67748c1547c9216b23d1aa">MeshHelpers::digitalSurface2DualPolygonalSurface</a> and <a class="el" href="classDGtal_1_1MeshHelpers.html#a4f6a5df120fabbbb1302b35feb820492">MeshHelpers::polygonalSurface2Mesh</a>.</p>
<h2><a class="anchor" id="HEM_sec3_5"></a>
Geometrical operations</h2>
<p>The class <a class="el" href="classDGtal_1_1PolygonalSurface.html" title="Aim: Represents a polygon mesh, i.e. a 2-dimensional combinatorial surface whose faces are (topologic...">PolygonalSurface</a> juste come with a way to get/set the position of each vertex:</p>
<ul>
<li><a class="el" href="classDGtal_1_1PolygonalSurface.html#a890f54e01915a9dd294763c696ecf10b">PolygonalSurface::position</a> : setter/getter of position given a vertex index.</li>
</ul>
<h2><a class="anchor" id="HEM_sec3_6"></a>
Associating data to vertices, edges, faces</h2>
<p>The easiest way to associate data to vertices, edges or faces is to create a relevant <a class="el" href="structDGtal_1_1PolygonalSurface_1_1IndexedPropertyMap.html">PolygonalSurface::IndexedPropertyMap</a>. In fact, this is the mechanism used by the class <a class="el" href="classDGtal_1_1PolygonalSurface.html" title="Aim: Represents a polygon mesh, i.e. a 2-dimensional combinatorial surface whose faces are (topologic...">PolygonalSurface</a> to store positions. The lines below show how to build a map associating an integer to each face:</p>
<div class="fragment"><div class="line">PolygonalSurface&lt;RealPoint&gt; mesh;</div><div class="line">...</div><div class="line">auto face_normal_map = mesh.makeFaceMap&lt;<span class="keywordtype">int</span>&gt;( 0 ); <span class="comment">// 0 is default value</span></div><div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; mesh.nbFaces(); ++i )</div><div class="line">{</div><div class="line">  face_normal_map[ i ] = i; <span class="comment">// each face is labelled with its own index.</span></div><div class="line">}</div></div><!-- fragment --><p>Any <a class="el" href="structDGtal_1_1PolygonalSurface_1_1IndexedPropertyMap.html">PolygonalSurface::IndexedPropertyMap</a> is in fact a vector of value, the size of which depends on the number of vertices / edges / face. We exploit the fact that vertices, edges and faces are all numbered consecutively starting from 0. The following methods returns property maps:</p>
<ul>
<li><a class="el" href="classDGtal_1_1PolygonalSurface.html#a2f4a7d1871b0a4b487b01c2b12ddc671">PolygonalSurface::makeVertexMap&lt;T&gt;</a> : creates a map associating a value of type T to each vertex.</li>
<li><a class="el" href="classDGtal_1_1PolygonalSurface.html#a77a72a0062c73f5bfc57a9dbded83058">PolygonalSurface::makeEdgeMap&lt;T&gt;</a> : creates a map associating a value of type T to each edge.</li>
<li><a class="el" href="classDGtal_1_1PolygonalSurface.html#aeb85400ed2a7b2cea4a1a7ecf09c277c">PolygonalSurface::makeFaceMap&lt;T&gt;</a> : creates a map associating a value of type T to each face.</li>
<li><a class="el" href="classDGtal_1_1PolygonalSurface.html#ae86b2753566087b882846a42f231a972">PolygonalSurface::positions</a> : returns an alias to the map giving the position of each vertex.</li>
</ul>
<h2><a class="anchor" id="HEM_sec3_7"></a>
Polygonal surface I/O and visualization</h2>
<p>You have methods to export a polygonal surface as an OBJ file: <a class="el" href="classDGtal_1_1MeshHelpers.html#a039386aa1c2b460e0a33ff6d15a6f53e">MeshHelpers::exportOBJ</a> or the more complete <a class="el" href="classDGtal_1_1MeshHelpers.html#aa687e35fc678eeed1d39c816c8d43880">MeshHelpers::exportOBJwithFaceNormalAndColor</a>.</p>
<p>In its present form, class <a class="el" href="classDGtal_1_1PolygonalSurface.html" title="Aim: Represents a polygon mesh, i.e. a 2-dimensional combinatorial surface whose faces are (topologic...">PolygonalSurface</a> does not provide any visualization methods. However it is simpler to convert a <a class="el" href="classDGtal_1_1PolygonalSurface.html" title="Aim: Represents a polygon mesh, i.e. a 2-dimensional combinatorial surface whose faces are (topologic...">PolygonalSurface</a> to/from a <a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces...">Mesh</a> for I/O or for visualization (see <a class="el" href="moduleHalfEdgeMesh.html#HEM_sec3_4">Helpers to convert polygonal surfaces from/to mesh</a>).</p>
<p>You may input or output a <a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces...">Mesh</a> as an OFF/OFS/OBJ file, see <a class="el" href="moduleMesh.html#subsect2moduleMeshIO">Mesh IO</a>. More precisely, class <a class="el" href="structDGtal_1_1MeshWriter.html" title="Aim: Export a Mesh (Mesh object) in different format as OFF and OBJ). ">MeshWriter</a> allows you to output a <a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces...">Mesh</a> as an OFF/OFS/OBJ file while class <a class="el" href="structDGtal_1_1MeshReader.html" title="Aim: Defined to import OFF and OFS surface mesh. It allows to import a Mesh object and takes into acc...">MeshReader</a> can input an OFF/OFS file into a <a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces...">Mesh</a>.</p>
<p>For visualization, you may also directly stream a <a class="el" href="classDGtal_1_1Mesh.html" title="Aim: This class is defined to represent a surface mesh through a set of vertices and faces...">Mesh</a> into a <a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/shapes/PolygonalSurface.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;DGtal/shapes/Mesh.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;DGtal/shapes/MeshHelpers.h&quot;</span></div><div class="line">...</div><div class="line">  <span class="keyword">typedef</span> PolygonalSurface&lt; RealPoint &gt;                PolyMesh;</div><div class="line">  <span class="keyword">typedef</span> Mesh&lt; RealPoint &gt;                            ViewMesh;</div><div class="line"></div><div class="line">  <span class="comment">// Creates two triangles glued together.</span></div><div class="line">  PolyMesh tmesh;</div><div class="line">  tmesh.<a class="code" href="classDGtal_1_1TriangulatedSurface.html#a8a0442ba63377ac3c073ceba4bdab2cf">addVertex</a>( <a class="code" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a>( 0, 0, 0 ) );</div><div class="line">  tmesh.addVertex( <a class="code" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a>( 1, 0, 0 ) );</div><div class="line">  tmesh.addVertex( <a class="code" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a>( 0, 1, 0 ) );</div><div class="line">  tmesh.addVertex( <a class="code" href="testTriangulatedSurface_8cpp.html#abb3595c097987c9d2c4f0cc1902df316">RealPoint</a>( 1, 1, 1 ) );</div><div class="line">  tmesh.addTriangle( 0, 1, 2 );</div><div class="line">  tmesh.addTriangle( 2, 1, 3 );</div><div class="line">  tmesh.build();</div><div class="line"></div><div class="line">  <span class="comment">// Convert it to a mesh</span></div><div class="line">  ViewMesh mesh;</div><div class="line">  <a class="code" href="classDGtal_1_1MeshHelpers.html#a4f6a5df120fabbbb1302b35feb820492">MeshHelpers::polygonalSurface2Mesh</a>( tmesh, mesh );</div><div class="line"></div><div class="line">  <span class="comment">// View it</span></div><div class="line">  Viewer3D&lt;&gt; viewer;</div><div class="line">  viewer.show();</div><div class="line">  viewer.setLineColor(Color(150,0,0,254));</div><div class="line">  viewer &lt;&lt; mesh;</div><div class="line">  viewer &lt;&lt; Viewer3D&lt;&gt;::updateDisplay;</div><div class="line">  application.exec();</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Nov 30 2018 08:59:20 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
