<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Cellular grid space and topology, unoriented and oriented cells, incidence</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.0.beta</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Cellular grid space and topology, unoriented and oriented cells, incidence </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#dgtal_ctopo_sec1">Images and digital spaces</a><ul><li class="level2"><a href="#dgtal_ctopo_sec2">Cells in the cubical grid and Khalimsky coordinates</a></li>
<li class="level2"><a href="#dgtal_ctopo_sec3">Models for cellular grid spaces</a></li>
<li class="level2"><a href="#dgtal_ctopo_sec4">Creating a cellular grid space</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtal_ctopo_sec5">Creating (unsigned) cells in a cellular grid space</a></li>
<li class="level1"><a href="#dgtal_ctopo_sec6">Cells may be unsigned or signed</a></li>
<li class="level1"><a href="#dgtal_ctopo_sec7">Accessing and modifying cell coordinates.</a></li>
<li class="level1"><a href="#dgtal_ctopo_sec8">Moving within the cellular grid space</a></li>
<li class="level1"><a href="#dgtal_ctopo_sec9">Cell topology and directions</a></li>
<li class="level1"><a href="#dgtal_ctopo_sec10">Cell adjacency and neighborhood</a></li>
<li class="level1"><a href="#dgtal_ctopo_sec11">Cell incidence</a></li>
<li class="level1"><a href="#dgtal_ctopo_periodicKSpace">Periodic Khalimsky space and per-dimension closure specification.</a></li>
<li class="level1"><a href="#dgtal_ctopo_precellulargridspace">Unbounded cellular grid space</a></li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: by Jacques-Olivier Lachaud, Bertrand Kerautret and Roland Denis</dt><dd></dd></dl>
<p>Part of the <a class="el" href="packageTopology.html">Topology package</a>.</p>
<p>This part of the manual describes how to define cellular grid space or cartesian cubic spaces, as well as the main objects living in these spaces. A lot of the ideas, concepts, algorithms, documentation and code is a backport from <a href="https://gforge.liris.cnrs.fr/projects/imagene">ImaGene</a>.</p>
<h1><a class="anchor" id="dgtal_ctopo_sec1"></a>
Images and digital spaces</h1>
<p>2D images are often seen as two dimensional arrays, where each cell is a pixel with some value (a gray level, a color). If \(\mathbf{Z}\) is the set of integer numbers, then an image is a map from a rectangular subset of \(\mathbf{Z} \times \mathbf{Z}\) to some space (gray levels, colors).</p>
<p>More generally, a nD image is a map from a parallelepipedic subset of \(\mathbf{Z}^n\) to some space (gray levels, colors).</p>
<p>Many algorithms need to represent positions in images (ie pixels and voxels), in order to represent regions in images. Often, we need also to measure the shape of a region, for instance its perimeter, or we may be interested in the interface between two regions. In these cases, it is often convenient (and generally it is also the theoretic way) to represent other elements in digital spaces, such as paths in-between regions, the thin boundary or surface of a region, etc. We need in this case to represent not only the "squares" (pixels) or "cubes" (voxels) of images, but also their faces, edges, vertices.</p>
<p>We therefore model not only n-dimensional cells (the hypercubes in nD), but also all the lower dimensional cells of the space. For instance, in 2D, we have:</p>
<ul>
<li>2-dimensional cells (closed unit square) = pixels</li>
<li>1-dimensional cells (closed unit segment) = linels</li>
<li>0-dimensional cells (closed point) = pointels</li>
</ul>
<p>The set of all cells \(\mathbf{F}^n\) is called the n-dimensional space of cubical complexes, or n-dimensional cellular grid space. The couple \((\mathbf{F}^n,\subseteq)\) is a partially ordered set or poset. Let \(X\) be any subset of \(\mathbf{F}^n\). The set \(\mathcal{U}=\{U \subseteq X / \forall x \in U, x^{\uparrow} \subseteq U \}\), where \(x^{\uparrow}=\{y \in X, x \le y\}\) or the up incident cells of x, is a topology on \(X\), called the Aleksandrov topology. Therefore we can use standard combinatorial topology results for any subset of the cellular grid space.</p>
<p>Cells of the cellular grid space are illustrated below. The paving mode of digital space gives a nice illustration of what is this space. The 2-cell is in red, the 1-cell in green, the 0-cell in blue.</p>
<div class="image">
<img src="cellular-grid-space-1.png" alt="cellular-grid-space-1.png"/>
<div class="caption">
Illustration of a cellular grid space with cells of different dimensions.</div></div>
<h2><a class="anchor" id="dgtal_ctopo_sec2"></a>
Cells in the cubical grid and Khalimsky coordinates</h2>
<p>We use now the regularity of the cubical grid to represent it efficiently. In 1D, the cubical grid is a simple line alternating closed points {k} and open unit segments (k,k+1). Khalimsky noticed that this (topological) space is homeomorphic to the integer set \(\mathbf{Z}\), if we declare every even integer as closed and every odd integer as open.</p>
<p>A digital cell in 1D is thus just an integer. Its topology is defined by its parity. The cell 2k is the closed point {k}; the cell 2k+1 is the segment (k,k+1) (considered open).</p>
<p>In 2D, we use the fact that \(\mathbf{Z}^2\) is a cartesian product. A digital cell in 2D is thus a couple of integer</p>
<ul>
<li>(2i, 2j): a pointel which is the point set {(i,j)} in the plane</li>
<li>(2i+1, 2j): an horizontal linel which is the open segment {(i,i+1) x j} in the plane.</li>
<li>(2i, 2j+1): a vertical linel which is the open segment {i x (j,j+1)} in the plane.</li>
<li>(2i+1, 2j+1): a pixel which is the open square {(i,i+1) x (j,j+1)} in the plane.</li>
</ul>
<p>In nD, the principle is the same. A cell is thus uniquely identifed by an n-tuple of integers whose parities define the topology of the cell. These integers are called the <b>Khalimsky</b> <b>coordinates</b> of the cell.</p>
<p>For instance, the pixel (x,y) of the digital space \(\mathbf{Z}^2\) corresponds to the 2-cell (2x+1,2y+1) of the cellular grid space \(\mathbf{F}^2\).</p>
<h2><a class="anchor" id="dgtal_ctopo_sec3"></a>
Models for cellular grid spaces</h2>
<p>Instead of chosing a specific implementation of a cellular grid space, we keep the genericity and efficiency objective of <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a> by defining a cellular grid space as the concept <a class="el" href="structDGtal_1_1concepts_1_1CCellularGridSpaceND.html" title="Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian produc...">concepts::CCellularGridSpaceND</a>. It provides a set of types (Cell, SCell, etc) and methods to manipulate cells of arbitrary dimension. Models of CCellularGridSpaceND are:</p>
<ol type="1">
<li>the <a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex...">KhalimskySpaceND</a> template class, that allows per-dimension closure specification (open, closed or periodic).</li>
<li>the &mdash; yet to come &mdash; CodedKhalimskySpaceND class, a backport from class KnSpace of <a href="http://gforge.liris.cnrs.fr/projects/imagene">ImaGene</a>.</li>
</ol>
<p>The inner types are:</p><ul>
<li>Integer: the type for representing a coordinate or component in this space.</li>
<li>Size: the type for representing a size (unsigned)</li>
<li>Cell: the type of unsigned cells</li>
<li>SCell: the type of signed cells</li>
<li>Sign: the sign type for cells</li>
<li>DirIterator: the type for iterating over directions of a cell</li>
<li>Point: the type for representing a digital point in this space</li>
<li>Vector: the type for representing a digital vector in this space</li>
<li>Space: the associated digital space type</li>
<li>KhalimskySpace: this cellular grid space</li>
<li>Cells: a sequence of unsigned cells</li>
<li>SCells: a sequence of signed cells</li>
<li><em>CellSet:</em> a set container that stores unsigned cells (efficient for queries like <code>find</code>, model of <a class="el" href="structboost_1_1UniqueAssociativeContainer.html" title="Go to http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html. ">boost::UniqueAssociativeContainer</a> and <a class="el" href="structboost_1_1SimpleAssociativeContainer.html" title="Go to http://www.sgi.com/tech/stl/SimpleAssociativeContainer.html. ">boost::SimpleAssociativeContainer</a>).</li>
<li><em>SCellSet:</em> a set container that stores signed cells (efficient for queries like <code>find</code>, model of <a class="el" href="structboost_1_1UniqueAssociativeContainer.html" title="Go to http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html. ">boost::UniqueAssociativeContainer</a> and <a class="el" href="structboost_1_1SimpleAssociativeContainer.html" title="Go to http://www.sgi.com/tech/stl/SimpleAssociativeContainer.html. ">boost::SimpleAssociativeContainer</a>).</li>
<li><em>SurfelSet:</em> a set container that stores surfels, i.e. signed n-1-cells (efficient for queries like <code>find</code>, model of <a class="el" href="structboost_1_1UniqueAssociativeContainer.html" title="Go to http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html. ">boost::UniqueAssociativeContainer</a> and <a class="el" href="structboost_1_1SimpleAssociativeContainer.html" title="Go to http://www.sgi.com/tech/stl/SimpleAssociativeContainer.html. ">boost::SimpleAssociativeContainer</a>).</li>
<li><em>CellMap&lt;Value&gt;</em>: an associative container Cell-&gt;Value rebinder type (efficient for key queries). Use as <code>typename</code> X::template CellMap&lt;Value&gt;::Type, which is a model of <a class="el" href="structboost_1_1UniqueAssociativeContainer.html" title="Go to http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html. ">boost::UniqueAssociativeContainer</a> and <a class="el" href="structboost_1_1PairAssociativeContainer.html" title="Go to http://www.sgi.com/tech/stl/PairAssociativeContainer.html. ">boost::PairAssociativeContainer</a>.</li>
<li><em>SCellMap&lt;Value&gt;</em>: an associative container SCell-&gt;Value rebinder type (efficient for key queries). Use as <code>typename</code> X::template SCellMap&lt;Value&gt;::Type, which is a model of <a class="el" href="structboost_1_1UniqueAssociativeContainer.html" title="Go to http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html. ">boost::UniqueAssociativeContainer</a> and <a class="el" href="structboost_1_1PairAssociativeContainer.html" title="Go to http://www.sgi.com/tech/stl/PairAssociativeContainer.html. ">boost::PairAssociativeContainer</a>.</li>
<li><em>SurfelMap&lt;Value&gt;</em>: an associative container Surfel-&gt;Value rebinder type (efficient for key queries). Use as <code>typename</code> X::template SurfelMap&lt;Value&gt;::Type, which is a model of <a class="el" href="structboost_1_1UniqueAssociativeContainer.html" title="Go to http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html. ">boost::UniqueAssociativeContainer</a> and <a class="el" href="structboost_1_1PairAssociativeContainer.html" title="Go to http://www.sgi.com/tech/stl/PairAssociativeContainer.html. ">boost::PairAssociativeContainer</a>.</li>
</ul>
<p>Methods include:</p><ul>
<li>Cell creation services</li>
<li>Read accessors to cells</li>
<li>Write accessors to cells</li>
<li>Conversion signed/unsigned cells</li>
<li>Cell topology services</li>
<li>Direction iterator services for cells</li>
<li>Unsigned cell geometry services</li>
<li>Signed cell geometry services</li>
<li>Neighborhood services</li>
<li>Incidence services</li>
<li>Interface</li>
</ul>
<p>An comprehensive description is given in <a class="el" href="structDGtal_1_1concepts_1_1CCellularGridSpaceND.html" title="Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian produc...">concepts::CCellularGridSpaceND</a>.</p>
<h2><a class="anchor" id="dgtal_ctopo_sec4"></a>
Creating a cellular grid space</h2>
<p>We use hereafter the model <a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex...">KhalimskySpaceND</a>. To create a 2D cellular grid space where cells have coordinates coded with standard <code>int</code> (32 bits generally), we can write:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/topology/KhalimskySpaceND.h&quot;</span></div><div class="line">...</div><div class="line">typedef KhalimskySpaceND&lt; 2, int &gt; <a class="code" href="sphereCotangentLaplaceOperator_8cpp.html#a55d0319fc69f55ae6fba7a8dd4d6f3e8">KSpace</a>;</div><div class="line"><a class="code" href="classDGtal_1_1KhalimskySpaceND.html">KSpace</a> <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>;</div><div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> low( -3, -4 );</div><div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> high( 5, 3 );</div><div class="line"><span class="comment">// true for closed space, false for open space.</span></div><div class="line"><span class="keywordtype">bool</span> space_ok = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a15dcbcaae831dd1c36090e6336c177d4">init</a>( low, high, <span class="keyword">true</span> );</div></div><!-- fragment --><p>Note that the cellular grid space is limited by the given bounds. Since the user has chosen a closed space, the Khalimsky coordinates of cells are bounded by:</p>
<ul>
<li>lower bound: (-3*2, -4*2)</li>
<li>upper bound: (5*2+2, 3*2+2)</li>
</ul>
<p>Another frequent way of constructing a cellular grid space is to start from a preexisting digital space and <a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;. ">HyperRectDomain</a>. You can define the associated cellular grid space as follows:</p>
<div class="fragment"><div class="line">...</div><div class="line">typedef SpaceND&lt;3, int&gt; Z;</div><div class="line"><span class="keyword">typedef</span> HyperRectDomain&lt;Z&gt; <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a>;</div><div class="line">...</div><div class="line"><a class="code" href="classDGtal_1_1HyperRectDomain.html#a23de221b9f2716649340754dd9bd4453">Domain</a> <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>( a, b );</div><div class="line">...</div><div class="line">typedef KhalimskySpaceND&lt; Z::dimension, Z::Integer &gt; <a class="code" href="sphereCotangentLaplaceOperator_8cpp.html#a55d0319fc69f55ae6fba7a8dd4d6f3e8">KSpace</a>;</div><div class="line"><a class="code" href="classDGtal_1_1KhalimskySpaceND.html">KSpace</a> <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>;</div><div class="line"><span class="keywordtype">bool</span> space_ok = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a15dcbcaae831dd1c36090e6336c177d4">init</a>( <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.lowerBound(), <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.upperBound(), true );</div></div><!-- fragment --><p>If you wish to build a digital space and a <a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;. ">HyperRectDomain</a> from a cellular grid space K, you may write:</p>
<div class="fragment"><div class="line">...</div><div class="line">typedef SpaceND&lt;KSpace::dimension, KSpace::Integer&gt; Z;</div><div class="line"><span class="keyword">typedef</span> HyperRectDomain&lt;Z&gt; <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a>;</div><div class="line"><a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>( <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#abdaa80d0d0b08137a355602d087fee46">lowerBound</a>(), <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#ae445ac351d3c7ddeecc2bac7e58f8e72">upperBound</a>() );</div></div><!-- fragment --><p>Last but not least, for standard users it is generally enough to use the default types provided in "DGtal/helpers/StdDefs.h". </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/helpers/StdDefs.h&quot;</span></div><div class="line">...</div><div class="line">using <span class="keyword">namespace </span><a class="code" href="namespaceZ2i.html">Z2i</a>;</div><div class="line"><a class="code" href="classDGtal_1_1KhalimskySpaceND.html">KSpace</a> <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>; <span class="comment">// or K2 K;</span></div><div class="line">...</div></div><!-- fragment --><h1><a class="anchor" id="dgtal_ctopo_sec5"></a>
Creating (unsigned) cells in a cellular grid space</h1>
<p>There are many ways of creating cells within a cellular grid space. The simplest way is certainly to give the Khalimsky coordinates of the cell you wish to create. Its topology is then induced by its coordinates. We use generally <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a8af9290623791e758d68c2ed5e227d9e">KhalimskySpaceND::uCell</a> for arbitrary cells, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a0a767cfea8d95d93aa45a819612b567b">KhalimskySpaceND::uSpel</a> for n-dimensional cells, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a53bdd59871913e6ab68bb05fa04cfbd3">KhalimskySpaceND::uPointel</a> for 0-dimensional cells.</p>
<p>The full code of this example is in file <a class="el" href="ctopo-1_8cpp.html">ctopo-1.cpp</a>. Pointels or 0-cells are displayed in blue, linels or 1-cells in green, pixels or 2-cells in red. Note that <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a8af9290623791e758d68c2ed5e227d9e">KhalimskySpaceND::uCell</a> requires Khalimsky coordinates while the two others require digital coordinates (the topology is known in the two latter cases).</p>
<div class="fragment"><div class="line"><a class="code" href="classDGtal_1_1KhalimskySpaceND.html">KSpace</a> <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>;</div><div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> plow(-3,-2);</div><div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> pup(5,3);</div><div class="line"><a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a15dcbcaae831dd1c36090e6336c177d4">init</a>( plow, pup, <span class="keyword">true</span> );</div><div class="line"><a class="code" href="structDGtal_1_1KhalimskyCell.html">Cell</a> pixlow = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a0a767cfea8d95d93aa45a819612b567b">uSpel</a>( plow ); <span class="comment">// pixel (-3*2+1,-2*2+1)</span></div><div class="line"><a class="code" href="structDGtal_1_1KhalimskyCell.html">Cell</a> ptlow = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a53bdd59871913e6ab68bb05fa04cfbd3">uPointel</a>( plow ); <span class="comment">// pointel (-3*2,-2*2)</span></div><div class="line"><a class="code" href="structDGtal_1_1KhalimskyCell.html">Cell</a> pixup = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a0a767cfea8d95d93aa45a819612b567b">uSpel</a>( pup ); <span class="comment">// pixel (5*2+1,3*2+1)</span></div><div class="line"><a class="code" href="structDGtal_1_1KhalimskyCell.html">Cell</a> ptup1 = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a53bdd59871913e6ab68bb05fa04cfbd3">uPointel</a>( pup );<span class="comment">// pointel (5*2,3*2)</span></div><div class="line"><a class="code" href="structDGtal_1_1KhalimskyCell.html">Cell</a> ptup2 = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a1823ad364c79bce5aa7d28c2996c4939">uTranslation</a>( ptup1, Point::diagonal() ); <span class="comment">// pointel (6*2,4*2)</span></div><div class="line"><a class="code" href="structDGtal_1_1KhalimskyCell.html">Cell</a> linelb = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a8af9290623791e758d68c2ed5e227d9e">uCell</a>( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>( 1, 0 ) ); <span class="comment">// linel (1,0) bottom</span></div><div class="line"><a class="code" href="structDGtal_1_1KhalimskyCell.html">Cell</a> linelt = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a8af9290623791e758d68c2ed5e227d9e">uCell</a>( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>( 1, 2 ) ); <span class="comment">// linel (1,2) top</span></div><div class="line"><a class="code" href="structDGtal_1_1KhalimskyCell.html">Cell</a> linell = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a8af9290623791e758d68c2ed5e227d9e">uCell</a>( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>( 0, 1 ) ); <span class="comment">// linel (0,1) left</span></div><div class="line"><a class="code" href="structDGtal_1_1KhalimskyCell.html">Cell</a> linelr = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a8af9290623791e758d68c2ed5e227d9e">uCell</a>( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>( 2, 1 ) ); <span class="comment">// linel (2,1) right</span></div></div><!-- fragment --><div class="image">
<img src="ctopo-1.png" alt="ctopo-1.png"/>
<div class="caption">
Displaying some cells in different colors.</div></div>
<p>The file <a class="el" href="ctopo-1-3d_8cpp.html">ctopo-1-3d.cpp</a> shows another example in 3D:</p>
<div class="fragment"><div class="line"><a class="code" href="classDGtal_1_1KhalimskySpaceND.html">KSpace</a> <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>;</div><div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> plow(0,0,0);</div><div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> pup(3,3,2);</div><div class="line">...</div><div class="line">Cell ptlow = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a53bdd59871913e6ab68bb05fa04cfbd3">uPointel</a>( plow ); <span class="comment">// pointel (0*2,0*2, 0*2)</span></div><div class="line"><a class="code" href="structDGtal_1_1KhalimskyCell.html">Cell</a> ptup1 = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a53bdd59871913e6ab68bb05fa04cfbd3">uPointel</a>( pup ); <span class="comment">// pointel (3*2,3*2, 2*2)</span></div><div class="line"><a class="code" href="structDGtal_1_1KhalimskyCell.html">Cell</a> ptup2 = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a1823ad364c79bce5aa7d28c2996c4939">uTranslation</a>( ptup1, Point::diagonal() ); <span class="comment">// pointel (4*2, 4*2, 3*2)</span></div><div class="line"></div><div class="line">viewer &lt;&lt; ptlow &lt;&lt; ptup1 &lt;&lt; ptup2;</div><div class="line"><a class="code" href="structDGtal_1_1KhalimskyCell.html">Cell</a> linel0 = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a8af9290623791e758d68c2ed5e227d9e">uCell</a>( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>( 1, 0, 2 ) ); <span class="comment">// linel (2, 0, 2)</span></div><div class="line">viewer &lt;&lt; linel0; <span class="comment">// ...</span></div><div class="line"><a class="code" href="structDGtal_1_1KhalimskyCell.html">Cell</a> surfelA = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a8af9290623791e758d68c2ed5e227d9e">uCell</a>( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>( 2, 1, 3 ) ); <span class="comment">// surfel (2,1,3)</span></div><div class="line">viewer &lt;&lt; surfelA; <span class="comment">//...</span></div><div class="line"><a class="code" href="structDGtal_1_1KhalimskyCell.html">Cell</a> vox1 = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a8af9290623791e758d68c2ed5e227d9e">uCell</a>( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>( 3, 3, 3 ) ); <span class="comment">// voxel (3,3,3)</span></div><div class="line">viewer &lt;&lt; vox1;</div></div><!-- fragment --><div class="image">
<img src="ctopo-1-3d.png" alt="ctopo-1-3d.png"/>
<div class="caption">
Displaying some cells in different colors.</div></div>
 <h1><a class="anchor" id="dgtal_ctopo_sec6"></a>
Cells may be unsigned or signed</h1>
<p>Up to now, we have only consider unsigned cells (type Cell). However it is often convenient to assign a sign (POS or NEG) to a cell, a kind of orientation. The sign is especially useful to define boundary operators and digital surfaces. It is also used in algebraic topological models of cubical complexes, for instance to define chains (formal sums of cells).</p>
<p>Signed cells have type SCell. They are created using methods <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a6db7625796651e3cc3b9d6c4cacbca79">KhalimskySpaceND::sCell</a> for arbitrary cells, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a7d5231f241513f15be0a1ee092db2590">KhalimskySpaceND::sSpel</a> for n-dimensional cells, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#acef44a43175249a103f6d43a1dd955aa">KhalimskySpaceND::sPointel</a> for 0-dimensional cells. The user gives the sign at creation, either K.POS or K.NEG if K is the space.</p>
<p>You may use methods <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ac356729023872a5db249886442caf6f1">KhalimskySpaceND::sSign</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a0463f6a2dd286316b62d5e78f8bca7e2">KhalimskySpaceND::sSetSign</a> <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a54d6ff6601342438c5380efcb34ecf82">KhalimskySpaceND::signs</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a22d8a0b3bf9ab0c07596ff57af908f92">KhalimskySpaceND::unsigns</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a4b574f0ed04bdc2476d32004226a6d85">KhalimskySpaceND::sOpp</a>, respectively to get the sign of a signed cell, to change the sign of a signed cell, to sign an unsigned cell, to unsign a signed cell, and to compute the cell with opposite sign.</p>
<p>All methods concerning unsigned cells are prefixed by <code>u</code>, all methods concerning signed cells are prefixed by <code>s</code>.</p>
<p>Note that the sign of the signed and unsigned are well taked into account in the display with <a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a> .</p>
<center> <div class="image">
<img src="ctopo-1b-3d.png" alt="ctopo-1b-3d.png"/>
<div class="caption">
Visualisation of unsigned Cell</div></div>
 <div class="image">
<img src="ctopo-1s-3d.png" alt="ctopo-1s-3d.png"/>
<div class="caption">
Visualisation of signed Cell</div></div>
 </center><h1><a class="anchor" id="dgtal_ctopo_sec7"></a>
Accessing and modifying cell coordinates.</h1>
<p>Since one does not necessarily know which model of CCellularGridSpaceND you may be using, you cannot access the cell coordinates directly. Therefore a model of CCellularGridSpaceND provides a set of methods to access and modify cell coordinates and topology. Here a few of them (with the model example <a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex...">KhalimskySpaceND</a>)</p>
<ul>
<li>Read accessors to coordinate(s)<ul>
<li><a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a1cff0fccc2bdcc73f94c0bc9b920cc9f">KhalimskySpaceND::uKCoord</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a362f63c4975d8cc1b96a6d46c51b1bd4">KhalimskySpaceND::sKCoord</a> (read Khalimsky coordinate)</li>
<li><a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a37a8aa8eed4f210253ecbbd31a476af0">KhalimskySpaceND::uCoord</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ab9a766fa0737f595472c6974dfbc1663">KhalimskySpaceND::sCoord</a> (read digital coordinate)</li>
<li><a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae87c396bb81e47ae5bc739626e44cb4d">KhalimskySpaceND::uKCoords</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a52197498d5f2961b2ced5b7cb821ec40">KhalimskySpaceND::sKCoords</a> (read Khalimsky coordinates)</li>
<li><a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ac9da0709a076181ecbbd647947d81d2b">KhalimskySpaceND::uCoords</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a36d05bc463af9b7521723edfee606315">KhalimskySpaceND::sCoords</a> (read digital coordinates)</li>
</ul>
</li>
<li>Write accessors to coordinate(s)<ul>
<li><a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a309fc4eea8cc7f15dc7910f96be2d033">KhalimskySpaceND::uSetKCoord</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#aeb88d710aa1221ed5ab4c282b163002f">KhalimskySpaceND::sSetKCoord</a> (write Khalimsky coordinate)</li>
<li><a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ab0137daa32424e6dde2f1717f6379363">KhalimskySpaceND::uSetCoord</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a9a14e8bd0892cf1328f69f5c66580a31">KhalimskySpaceND::sSetCoord</a> (write digital coordinate)</li>
<li><a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a10fa089f4b77e9566e9cdf25c3a5b22a">KhalimskySpaceND::uSetKCoords</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a2b0f036db47bb9bf004ab01b283a8e1c">KhalimskySpaceND::sSetKCoords</a> (write Khalimsky coordinates)</li>
<li><a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a4e841692083468f030f35cca55cc8d33">KhalimskySpaceND::uSetCoords</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a5dcde5392eb072efafc4a3afffbadfd8">KhalimskySpaceND::sSetCoords</a> (write digital coordinates)</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="dgtal_ctopo_sec8"></a>
Moving within the cellular grid space</h1>
<p>Note that you dispose also of a whole set of methods to determine cells according to different geometric queries. The following methods do not change the topology of the input cell only the coordiantes. Again the prefix <code>u</code> is related to method taking as input unsigned cells while the prefix <code>s</code> is related to signed cells:</p>
<ul>
<li>Getting the first or last cell of the space: <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#aa249d0b757804d2fb3ed0f7f5890a145">KhalimskySpaceND::uFirst</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a4cdfc7fbdf3740ac6745e84fee1d2d25">KhalimskySpaceND::uLast</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a9e8263ffd2787b05b398d1e112adfdeb">KhalimskySpaceND::sFirst</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a57758c697b0f737083fa44340a964136">KhalimskySpaceND::sLast</a></li>
<li>Moving to the adjacent cell with one coordinate greater or one coordinate lower: <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a78ed248844b4108089e9b95371f82edc">KhalimskySpaceND::uGetIncr</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a155d08e50ad34a77fdac8355a1f4ebff">KhalimskySpaceND::uGetDecr</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#af91c9fbc8b4e1f6be9f19dc547bf3725">KhalimskySpaceND::sGetIncr</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a55a0560183f07602ba3962dc0a5aa388">KhalimskySpaceND::sGetDecr</a>, or moving to an arbitrary cell along some axis with <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a9c83aff0f5d0756bfaa126255cb2c230">KhalimskySpaceND::uGetAdd</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ac72d20446a4aecc7ede89d279db5aa8e">KhalimskySpaceND::uGetSub</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a708123c7103490ed78cf460e41f54436">KhalimskySpaceND::sGetAdd</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a4a2c4162d85c7d15613e35afb14074d3">KhalimskySpaceND::sGetSub</a>.</li>
<li>Testing whether you are the cell with maximal or minimal coordinate along some axis with <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a89bb2428b36295e06f5fdae7b97240ad">KhalimskySpaceND::uIsMax</a> or <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#abfe7406b6591c3d10a8e79bb5de137f8">KhalimskySpaceND::uIsMin</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a1a2c412f9e754ebf5fa8770b2a4a40ea">KhalimskySpaceND::sIsMax</a> or <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a62f5aa469673ca76f656f53247e0ea60">KhalimskySpaceND::sIsMin</a></li>
<li>Getting the cell along some axis that has same coordinates as the input cell but for one which belongs the minimal or maximal accepted in this space: <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a4930cbe2a54b8d780d4a12b95222968d">KhalimskySpaceND::uGetMax</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#accc4b048428cdc38869d8668c3432ce6">KhalimskySpaceND::uGetMin</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a9fa945aaec2d8eca401b50c9291e0a6d">KhalimskySpaceND::sGetMax</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a53703eb64b1d91e9baaf2b87b4a1a2e2">KhalimskySpaceND::sGetMin</a></li>
<li>Projet a cell along some coordinate onto the axis-aligned hyperplanes spanned by a cell with <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a407a2dfa4bbc7ea53f6a9f647a7fcd4c">KhalimskySpaceND::uProject</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a135cb805740b724cc32f500034869dbb">KhalimskySpaceND::uProjection</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a503462426e5053cf11c20a686f6cab07">KhalimskySpaceND::sProject</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a35563322fa061d6e6e9b4332cc316f86">KhalimskySpaceND::sProjection</a></li>
<li>Computes the distance of the cell to the bounds of the space along some axis with <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ad428ca8d9d9623a0f0684c149f562086">KhalimskySpaceND::uDistanceToMax</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a1fce177c92db37d39b490132187473d6">KhalimskySpaceND::uDistanceToMin</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ad6416fecd794b4ec4f90d00145422cda">KhalimskySpaceND::sDistanceToMax</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a8c1c2bcf53c8cd8dfd5b7fa9ba4ec63a">KhalimskySpaceND::sDistanceToMin</a></li>
<li>Getting the next cell in this space such that if one starts from the first cell (with same topology) of the space and iterates this process, then all cells of the space with same topology were visited. This may be done with <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a4e3016f0ff5ead152d03f43f39c5a1de">KhalimskySpaceND::uNext</a>, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a09e5c593723d7c87c43d408377d445c0">KhalimskySpaceND::sNext</a>. Below is a code snippet that does a scanning of all cells of same topology between first and last cell.</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="classDGtal_1_1KhalimskySpaceND.html">KSpace</a> <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>;</div><div class="line"><a class="code" href="structDGtal_1_1KhalimskyCell.html">Cell</a> first, last; <span class="comment">// lower and upper bounds</span></div><div class="line"><a class="code" href="structDGtal_1_1KhalimskyCell.html">Cell</a> p = first;</div><div class="line"><span class="keywordflow">do</span></div><div class="line">{ <span class="comment">// ... whatever [p] is the current cell</span></div><div class="line">}</div><div class="line"><span class="keywordflow">while</span> ( <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a4e3016f0ff5ead152d03f43f39c5a1de">uNext</a>( p, first, last ) );</div></div><!-- fragment --><p>For instance (see. <a class="el" href="khalimskySpaceScanner_8cpp.html">khalimskySpaceScanner.cpp</a>) you will obtain the default following scan:</p>
<div class="image">
<img src="khalimskySpaceScanner1.png" alt="khalimskySpaceScanner1.png"/>
<div class="caption">
Sequence of visited pixels in a scan of Khalimsky Space (standard scan order).</div></div>
<ul>
<li><p class="startli">The scan can also be done by explicitly controlling the order: </p><div class="fragment"><div class="line"><a class="code" href="structDGtal_1_1KhalimskyCell.html">KSpace::Cell</a> q;</div><div class="line"></div><div class="line">...</div><div class="line">for (q = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.uGetMaxT(q, 0); <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a0b0f3feceffe5dbbd10fc806dd047428">uIsInside</a>(q,0); q = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a155d08e50ad34a77fdac8355a1f4ebff">uGetDecr</a>(q, 0))</div><div class="line">  <span class="keywordflow">for</span> ( q = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.uGetMinT(q, 1); <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a0b0f3feceffe5dbbd10fc806dd047428">uIsInside</a>(q,1); q = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a78ed248844b4108089e9b95371f82edc">uGetIncr</a>(q, 1))</div><div class="line">    {</div><div class="line">      <span class="comment">// ... whatever [q] is the current cell</span></div><div class="line">    }</div></div><!-- fragment --><p> You will obtain the following scan:</p>
<div class="image">
<img src="khalimskySpaceScanner2.png" alt="khalimskySpaceScanner2.png"/>
<div class="caption">
Sequence of visited pixels in a scan of Khalimsky Space (other scan order).</div></div>
 </li>
<li>Translating arbitrarily a cell in the space with <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a1823ad364c79bce5aa7d28c2996c4939">KhalimskySpaceND::uTranslation</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#aa939cede9599ba206331c1cc6dd44547">KhalimskySpaceND::sTranslation</a>.</li>
</ul>
<h1><a class="anchor" id="dgtal_ctopo_sec9"></a>
Cell topology and directions</h1>
<p>As said above, the cell topology is defined by the parity of its Khalimsky coordinates. The number of coordinates where the cell is open define the dimension of the cell. A cell of maximal dimension (n) is called a <em>pixel</em> in 2D, a <em>voxel</em> in 3D, and sometimes called a <em>spel</em> or <em>xel</em> in nD. A cell of minimial dimension (0) is often called a <em>pointel</em>. n-1 cells are called <em>surfels</em> (or sometimes <em>linels</em> in 2D). Here are the methods related to the cell topology.</p>
<ul>
<li>the dimension of a cell is given by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ac451b3a94546cf18d06898b47c6025db">KhalimskySpaceND::uDim</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ae6e30a00585bdce3145a0ad4bd36862e">KhalimskySpaceND::sDim</a>.</li>
<li>whether a cell is open or not along some axis is returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#aab9342cfa6a6ae3894f39c920f4bca63">KhalimskySpaceND::uIsOpen</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ad749c51cfb7b8921c8c5bfb7019cba5c">KhalimskySpaceND::sIsOpen</a>.</li>
<li>whether a cell is a surfel or not is returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a9fbd844a145efd2502be7d02f2739e69">KhalimskySpaceND::uIsSurfel</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ab055bd8ea0cc912085e38a5a5a31969b">KhalimskySpaceND::sIsSurfel</a>. NB: you should use it instead of comparing the dimension of the cell with n-1, depending on the model of cellular grid space chosen.</li>
<li>the integer coding the topology of the cell such that the k-th bit is 1 whenever the cell is open along the k-th axis is returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a737dc0a044f9bde1cc6b3fb95974f69c">KhalimskySpaceND::uTopology</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a614764504368a72f1ac88d989e0ceb7e">KhalimskySpaceND::sTopology</a>.</li>
<li>you may iterate over all open coordinates (or all closed coordinates) of a cell with the iterator returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a2395674cf702e0e5fb33b60ae78d1ab4">KhalimskySpaceND::uDirs</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a31c056cb3dd8a1aec31dd2c7594c232b">KhalimskySpaceND::sDirs</a> (<a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a33199dd3a300dcc593a02ae8449650fb">KhalimskySpaceND::uOrthDirs</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ac149aa19589579b6ce52a5f8d90e5873">KhalimskySpaceND::sOrthDirs</a> for closed coordinates), such as in this snippet:</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="structDGtal_1_1KhalimskyCell.html">KSpace::Cell</a> p;</div><div class="line">...</div><div class="line">for ( KnSpace::DirIterator q = ks.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a2395674cf702e0e5fb33b60ae78d1ab4">uDirs</a>( p ); q != 0; ++q )</div><div class="line">{</div><div class="line">KSpace::Dimension dir = *q;</div><div class="line">      ...</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="dgtal_ctopo_sec10"></a>
Cell adjacency and neighborhood</h1>
<p>You may obtain the cells of same topology which are (face-)adjacent to a given cell with the following methods:</p>
<ul>
<li>the neighborhood of a given cell within the space are given by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a390464a3800193097225afecf4dc324b">KhalimskySpaceND::uNeighborhood</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ab3dc1266942376e5ebc51381905efec1">KhalimskySpaceND::sNeighborhood</a>, while the proper neighborhood is returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a77d1435822d69f2de51c5c6c06d5e7e9">KhalimskySpaceND::uProperNeighborhood</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a726b1f00db67b49df781acc547594a84">KhalimskySpaceND::sProperNeighborhood</a>.</li>
<li>the cell that is adjacent forward or backward along some given axis is returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#ac77fe53bde52efbf052d0f3b718762fc">KhalimskySpaceND::uAdjacent</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a8d23d496bd5a6080aab047d145388e02">KhalimskySpaceND::sAdjacent</a>.</li>
</ul>
<h1><a class="anchor" id="dgtal_ctopo_sec11"></a>
Cell incidence</h1>
<p>Cells incident to some cell touch the cell but do not have the same dimension. Cells lower incident to a cell have lower dimensions, cells upper incident to a cell have higher dimensions. Specific rules determine the sign of incident cells to a signed cell:</p>
<ol type="1">
<li>A first rule is that along some axis, the forward and the backward incident cell have opposite sign.</li>
<li>A second rule is that the rules are invariant by translation of cells.</li>
<li>A third rule is that changing the sign of the cell changes the sign of all incident cells.</li>
<li>A last rule is that taking an incident cell along some axis k then taking an incident cell along some other axis l will give a cell that has the opposite sign as if the incidence was taken before along l and after along k.</li>
</ol>
<p>These rules together allow the definition of (co)boundary operators, which are homomorphisms between chains of cells. They have the property that applied twice they give the null chain. Otherwise said, the boundary of a set of cells has an empty boundary.</p>
<ul>
<li>The cell incident to some given cell along some axis and in forward or backward direction is returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a0ff55f673b6b22f4c39c1325a8f42747">KhalimskySpaceND::uIncident</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#adcda490970c3962a731a5ad604ef5ce6">KhalimskySpaceND::sIncident</a>.</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="structDGtal_1_1SignedKhalimskyCell.html">SCell</a> pix = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a7d5231f241513f15be0a1ee092db2590">sSpel</a>( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>( 0,0 ), <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a90ae1527195edd79cf9c4d1915f938fe">POS</a> ); <span class="comment">// pixel (0+1,0+1)</span></div><div class="line"><a class="code" href="structDGtal_1_1SignedKhalimskyCell.html">SCell</a> leftl = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#adcda490970c3962a731a5ad604ef5ce6">sIncident</a>( pix, 0, <span class="keyword">false</span> ); <span class="comment">// linel (0,0+1)</span></div><div class="line"><a class="code" href="structDGtal_1_1SignedKhalimskyCell.html">SCell</a> rightl = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#adcda490970c3962a731a5ad604ef5ce6">sIncident</a>( pix, 0, <span class="keyword">true</span> ); <span class="comment">// linel (2,0+1)</span></div><div class="line"><a class="code" href="structDGtal_1_1SignedKhalimskyCell.html">SCell</a> downl = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#adcda490970c3962a731a5ad604ef5ce6">sIncident</a>( pix, 1, <span class="keyword">false</span> ); <span class="comment">// linel (0+1,0)</span></div><div class="line"><a class="code" href="structDGtal_1_1SignedKhalimskyCell.html">SCell</a> upl = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#adcda490970c3962a731a5ad604ef5ce6">sIncident</a>( pix, 1, <span class="keyword">true</span> ); <span class="comment">// linel (0+1,2)</span></div><div class="line"><a class="code" href="structDGtal_1_1SignedKhalimskyCell.html">SCell</a> ptld = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#adcda490970c3962a731a5ad604ef5ce6">sIncident</a>( leftl, 1, <span class="keyword">false</span> );<span class="comment">// pointel (0,0)</span></div><div class="line"><a class="code" href="structDGtal_1_1SignedKhalimskyCell.html">SCell</a> ptdl = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#adcda490970c3962a731a5ad604ef5ce6">sIncident</a>( downl, 0, <span class="keyword">false</span> );<span class="comment">// pointel (0,0)</span></div><div class="line"><span class="comment">// ptld and ptdl have opposite signs.</span></div></div><!-- fragment --><ul>
<li>The set of cells low incident to a given cell (i.e. just 1 dimension less) is returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a757c7c05c4bc4d373282cb2fde74dbc1">KhalimskySpaceND::uLowerIncident</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a61396e76298c2d1df0c25b8f00bd7ed0">KhalimskySpaceND::sLowerIncident</a>.</li>
<li>The set of cells up incident to a given cell (i.e. just 1 dimension more) is returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a17009d510cac32c20e0540ee704dcd27">KhalimskySpaceND::uUpperIncident</a> and <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a813e9bb9d848aab21abd50c762d91421">KhalimskySpaceND::sUpperIncident</a>.</li>
<li>The proper faces of an unsigned cell are returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a34114a4f6c7175681dc29c3293c3a0f5">KhalimskySpaceND::uFaces</a>.</li>
<li>The proper cofaces of an unsigned cell are returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a1021e39d2da165515dae58d5f6590e7e">KhalimskySpaceND::uCoFaces</a>.</li>
<li>One of the two cells that are incident to some signed cells along some axis has a positive sign. The orientation (forward or backward) is called the <em>direct</em> orientation. It is returned by <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a5b0f526da6d98c2988670b69470efd26">KhalimskySpaceND::sDirect</a>. It is worth to note that the following assertion is always true:</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// c is a signed cell, k a direction</span></div><div class="line">ASSERT( <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#ac356729023872a5db249886442caf6f1">sSign</a>( <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#adcda490970c3962a731a5ad604ef5ce6">sIncident</a>( c, k, <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a5b0f526da6d98c2988670b69470efd26">sDirect</a>( c, k ) ) ) == <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a90ae1527195edd79cf9c4d1915f938fe">POS</a> );</div></div><!-- fragment --><ul>
<li>You may obtain straightforwardly the positive incident cell along some axis with <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#aaa60ad137a7aa68627cd86b0d76c3693">KhalimskySpaceND::sDirectIncident</a> and the negative incident cell along some axis with <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#a172d3f227c8b7ef02baebf182ccdb785">KhalimskySpaceND::sIndirectIncident</a>.</li>
</ul>
<h1><a class="anchor" id="dgtal_ctopo_periodicKSpace"></a>
Periodic Khalimsky space and per-dimension closure specification.</h1>
<p>In addition to the <a class="el" href="structDGtal_1_1concepts_1_1CCellularGridSpaceND.html" title="Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian produc...">concepts::CCellularGridSpaceND</a> requirements, <a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex...">KhalimskySpaceND</a> allows the use of different closures for each dimension and the use of periodic dimension.</p>
<p>The closure is specified at the space initialization: </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="classDGtal_1_1KhalimskySpaceND.html">KSpace</a> = <a class="code" href="classDGtal_1_1KhalimskySpaceND.html">DGtal::KhalimskySpaceND&lt; int, 2 &gt;</a>;</div><div class="line"><a class="code" href="classDGtal_1_1KhalimskySpaceND.html">KSpace</a> <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>;</div><div class="line"><a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a15dcbcaae831dd1c36090e6336c177d4">init</a>( {-3, -2}, {2, 4}, { <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#ab1e57d8bd06fd2d995555de82b39d959a6517952369441939afd034a920e523f0">CLOSED</a>, <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#ab1e57d8bd06fd2d995555de82b39d959ae5819c27512f541df22534e93f0ea146">PERIODIC</a> } ); <span class="comment">// K is closed along the first dimension, but periodic along the second.</span></div></div><!-- fragment --><p>Therefore, any coordinates are valid along a periodic dimension but the coordinates accessors of <a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex...">KhalimskySpaceND</a> will always return a coordinate between the two bounds given at the initialization: </p><div class="fragment"><div class="line"><a class="code" href="structDGtal_1_1KhalimskyCell.html">KSpace::Cell</a> cell = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a0a767cfea8d95d93aa45a819612b567b">uSpel</a>( {0, 6} ); <span class="comment">// Valid, thanks to the periodicity.</span></div><div class="line"><span class="keywordtype">int</span> y = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a37a8aa8eed4f210253ecbbd31a476af0">uCoord</a>( cell, 1 ); <span class="comment">// y = -1</span></div><div class="line"><span class="keyword">auto</span> cell2 = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#ac72d20446a4aecc7ede89d279db5aa8e">uGetSub</a>( cell, 1, 2 ); <span class="comment">// Decrementing second digital coordinate by 2.</span></div><div class="line"><span class="keywordtype">int</span> y2 = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a37a8aa8eed4f210253ecbbd31a476af0">uCoord</a>( cell2, 1 ); <span class="comment">// y2 = 4</span></div></div><!-- fragment --><p>It is also possible to span a sub-space that crosses the bounds along a periodic dimension: </p><div class="fragment"><div class="line"><a class="code" href="structDGtal_1_1KhalimskyCell.html">KSpace::Cell</a> first = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a0a767cfea8d95d93aa45a819612b567b">uSpel</a>( {-2, 1} );</div><div class="line"><a class="code" href="structDGtal_1_1KhalimskyCell.html">KSpace::Cell</a> last  = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a0a767cfea8d95d93aa45a819612b567b">uSpel</a>( { 2, 7} );</div><div class="line"><span class="keyword">auto</span> p = first;</div><div class="line"><span class="keywordflow">do</span></div><div class="line">  {</div><div class="line">    <span class="comment">// do something with the current cell [p]</span></div><div class="line">  }</div><div class="line"><span class="keywordflow">while</span> ( <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a4e3016f0ff5ead152d03f43f39c5a1de">uNext</a>( p, first, last ) );</div></div><!-- fragment --><h1><a class="anchor" id="dgtal_ctopo_precellulargridspace"></a>
Unbounded cellular grid space</h1>
<p>If you need to arbitrarily manipulate the cells coordinates without bounds checking, or if you simply doesn't need a bounded space, you may consider <a class="el" href="classDGtal_1_1KhalimskyPreSpaceND.html" title="Aim: This class is a model of CPreCellularGridSpaceND. It represents the cubical grid as a cell compl...">KhalimskyPreSpaceND</a>.</p>
<p>It is a model of <a class="el" href="structDGtal_1_1concepts_1_1CPreCellularGridSpaceND.html" title="Aim: This concept describes an unbounded cellular grid space in nD. In these spaces obtained by carte...">concepts::CPreCellularGridSpaceND</a>, that is a base concept of <a class="el" href="structDGtal_1_1concepts_1_1CCellularGridSpaceND.html" title="Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian produc...">concepts::CCellularGridSpaceND</a>. The main difference is that <a class="el" href="structDGtal_1_1concepts_1_1CPreCellularGridSpaceND.html" title="Aim: This concept describes an unbounded cellular grid space in nD. In these spaces obtained by carte...">concepts::CPreCellularGridSpaceND</a> doesn't require to initialize the space with bounds and some bounds related methods (like <a class="el" href="classDGtal_1_1KhalimskySpaceND.html#accc4b048428cdc38869d8668c3432ce6">KhalimskySpaceND::uGetMin</a>) are not available.</p>
<p>Therefore, <a class="el" href="classDGtal_1_1KhalimskyPreSpaceND.html" title="Aim: This class is a model of CPreCellularGridSpaceND. It represents the cubical grid as a cell compl...">KhalimskyPreSpaceND</a> is a purely static class that provides almost all the methods of <a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex...">KhalimskySpaceND</a> but without bounds influence (coordinates validity, restricted neighborhood, ...) and is also fully compatible with <a class="el" href="classDGtal_1_1KhalimskySpaceND.html">KhalimskySpaceND</a>-based algorithms when bounds are not necessary.</p>
<p>The main features are:</p><ul>
<li>direct manipulation of the Khalimsky coordinates through the <code>coordinates</code> public member of <a class="el" href="structDGtal_1_1KhalimskyPreCell.html">KhalimskyPreCell</a> and <a class="el" href="structDGtal_1_1SignedKhalimskyPreCell.html">SignedKhalimskyPreCell</a>: <div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="namespaceDGtal_1_1Z2i.html#a5b69aa7cfda029c5be3acb0f648bb72b">KPreSpace</a> = <a class="code" href="classDGtal_1_1KhalimskyPreSpaceND.html">DGtal::KhalimskyPreSpaceND&lt;2, int&gt;</a>;</div><div class="line"><a class="code" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">KPreSpace::Cell</a>  a = KPreSpace::uSpel( {1, 1} );</div><div class="line">KPreSpace::SCell b = KPreSpace::sPointel( {12, 5}, true );</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> pt_diff = b.coordinates - a.coordinates;</div><div class="line">a.coordinates[0] += 2;</div></div><!-- fragment --></li>
<li>direct construction of a pre-cell from its Khalimsky coordinates: <div class="fragment"><div class="line"><a class="code" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">KPreSpace::Cell</a> precell( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>( 4, 5 ) ); <span class="comment">// OK</span></div><div class="line"></div><div class="line"><span class="comment">// KSpace::Cell    cell( Point( 4, 5 ) ); // Compilation error.</span></div><div class="line"><span class="comment">// Cell creation is only possible through a valid KhalimskySpaceND.</span></div></div><!-- fragment --></li>
<li>easy conversion from a cell to a pre-cell using the <a class="el" href="structDGtal_1_1KhalimskyCell.html#a952594a747cd132ddca90495b5b54380" title="Returns the underlying constant pre-cell. ">KhalimskyCell::preCell</a> and <a class="el" href="structDGtal_1_1SignedKhalimskyCell.html#a671fb3a5899408ce7234d3f0902a4038" title="Returns the underlying constant signed pre-cell. ">SignedKhalimskyCell::preCell</a> methods, or using the implicit conversion: <div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="classDGtal_1_1KhalimskySpaceND.html">KSpace</a> = DGtal::KhalimksySpaceND&lt;2, int&gt;;</div><div class="line"><a class="code" href="classDGtal_1_1KhalimskySpaceND.html">KSpace</a> <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>;</div><div class="line"><a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a15dcbcaae831dd1c36090e6336c177d4">init</a>( {-3, -3}, {3, 2}, true );</div><div class="line"><a class="code" href="structDGtal_1_1KhalimskyCell.html">KSpace::Cell</a> cell = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a0a767cfea8d95d93aa45a819612b567b">uSpel</a>( {1, 1} );</div><div class="line"></div><div class="line"><span class="comment">// KSpace::PreCell is an alias to DGtal::KhalimskyPreCell&lt;2, int&gt;</span></div><div class="line"><a class="code" href="structDGtal_1_1KhalimskyPreCell.html">KSpace::PreCell</a> preA = cell; <span class="comment">// implicit conversion to a pre-cell.</span></div><div class="line"><a class="code" href="structDGtal_1_1KhalimskyPreCell.html">KSpace::PreCell</a> preB = cell.<a class="code" href="structDGtal_1_1KhalimskyCell.html#a952594a747cd132ddca90495b5b54380">preCell</a>(); <span class="comment">// explicit conversion to a pre-cell using KhalimskyCell::preCell.</span></div><div class="line"><a class="code" href="structDGtal_1_1KhalimskyPreCell.html">KSpace::PreCell</a> preC = <span class="keyword">static_cast&lt;</span><a class="code" href="structDGtal_1_1KhalimskyPreCell.html">KSpace::PreCell</a><span class="keyword">&gt;</span>( cell ); <span class="comment">// conversion using static_cast.</span></div><div class="line"></div><div class="line"><span class="comment">/* Implicit conversion when calling function accepting</span></div><div class="line"><span class="comment"> * a pre-cell as parameter is possible as long as template deduction</span></div><div class="line"><span class="comment"> * is not needed on the pre-cell template parameters.</span></div><div class="line"><span class="comment"> */</span></div><div class="line">myAlgorithmThatWorksOnPreCell( cell );</div></div><!-- fragment --></li>
<li>most <a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex...">KhalimskySpaceND</a> methods exist in <a class="el" href="classDGtal_1_1KhalimskyPreSpaceND.html" title="Aim: This class is a model of CPreCellularGridSpaceND. It represents the cubical grid as a cell compl...">KhalimskyPreSpaceND</a> (take a look to the <a class="el" href="classDGtal_1_1KhalimskyPreSpaceND.html" title="Aim: This class is a model of CPreCellularGridSpaceND. It represents the cubical grid as a cell compl...">KhalimskyPreSpaceND</a> documentation or just to the difference between <a class="el" href="structDGtal_1_1concepts_1_1CCellularGridSpaceND.html" title="Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian produc...">concepts::CCellularGridSpaceND</a> and <a class="el" href="structDGtal_1_1concepts_1_1CPreCellularGridSpaceND.html" title="Aim: This concept describes an unbounded cellular grid space in nD. In these spaces obtained by carte...">concepts::CPreCellularGridSpaceND</a>).</li>
<li>Conversion from a pre-cell to a cell needs the associate Khalimsky space in order to ensure that the coordinates are valid: <div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="namespaceDGtal_1_1Z2i.html#a5b69aa7cfda029c5be3acb0f648bb72b">KPreSpace</a> = <a class="code" href="classDGtal_1_1KhalimskyPreSpaceND.html">DGtal::KhalimskyPreSpaceND&lt;2, int&gt;</a>;</div><div class="line"><a class="code" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">KPreSpace::Cell</a>  preA = KPreSpace::uSpel( {1, 1} );</div><div class="line">KPreSpace::SCell preB = KPreSpace::sPointel( {12, 5}, true );</div><div class="line"></div><div class="line"><span class="keyword">using</span> <a class="code" href="classDGtal_1_1KhalimskySpaceND.html">KSpace</a> = DGtal::KhalimksySpaceND&lt;2, int&gt;;</div><div class="line"><a class="code" href="classDGtal_1_1KhalimskySpaceND.html">KSpace</a> <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>;</div><div class="line"><a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a15dcbcaae831dd1c36090e6336c177d4">init</a>( {-3, -3}, {3, 2}, true );</div><div class="line"></div><div class="line"><span class="comment">// KSpace::Cell cell = preA; // &lt;- doesn&#39;t compile.</span></div><div class="line"></div><div class="line"><a class="code" href="structDGtal_1_1KhalimskyCell.html">KSpace::Cell</a>  cell1 = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a8af9290623791e758d68c2ed5e227d9e">uCell</a>( preA ); <span class="comment">// OK since preA lies inside K.</span></div><div class="line"><a class="code" href="structDGtal_1_1SignedKhalimskyCell.html">KSpace::SCell</a> cell2 = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a6db7625796651e3cc3b9d6c4cacbca79">sCell</a>( preB ); <span class="comment">// Will failed at runtime (in DEBUG mode) because preB is outside K.</span></div></div><!-- fragment --> </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Nov 17 2018 13:26:45 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
